您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。并发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 并发是指在同一时间段内，能够处理多个任务的能力。为了提升应用的响应速度与帧率，以及防止耗时任务对主线程的干扰，HarmonyOS系统提供了异步并发和多线程并发两种处理策略。 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。 多线程并发允许在同一时间段内同时执行多段代码。在主线程继续响应用户操作和更新UI的同时，后台也能执行耗时操作，从而避免应用出现卡顿。  并发能力在多种场景中都有应用，其中包括单次I/O任务、CPU密集型任务、I/O密集型任务和同步任务等。开发者可以根据不同的场景，选择相应的并发策略进行优化和开发。 ArkTS支持异步并发和多线程并发。 Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见异步并发概述。 TaskPool和Worker提供多线程并发能力，适用于CPU密集型任务、I/O密集型任务和同步任务等并发场景。详细请参见多线程并发概述。   上一篇 并发 下一篇 使用异步并发能力进行开发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。DevEco Studio配置参数列表 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio基于IntelliJ平台开发，在原生的IntelliJ参数的基础上新增了部分参数，这些参数可在idea.properties中进行配置，参数列表如下： 参数  参数说明    grs_url  设置DevEco Studio连接的云端环境。   npm_config_strict_ssl  设置是否开启npm的https证书校验。默认为true，表示开启证书校验。   ohpm_config_strict_ssl  设置是否开启ohpm的https证书校验。默认为true，表示开启证书校验。     
说明
关闭证书校验，可能会带来安全风险，请谨慎使用。 
  上一篇 通过DevEco Studio编译和上传软件包 下一篇 DevEco Service使用指南 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。配置ohpm包依赖引用ohpm包资源配置应用的依赖 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 应用/服务支持通过ohpm来安装、共享、分发代码，管理项目的依赖关系。本文将介绍如何配置ohpm包依赖。 配置ohpm包依赖ohpm包的依赖一般包括以下三种：ohpm原生三方包、ohpm三方共享包和ohpm本地共享模块。开发者可在工程或模块下的oh-package.json5中进行配置，配置依赖的示例如下所示： ohpm原生三方包依赖示例如下：已复制"dependencies": {  "eslint": "^7.32.0",  ... } 三方包依赖示例如下：已复制"dependencies": { "@ohos/lottie": "^2.0.0", ...} ohpm本地共享模块依赖示例如下已复制"dependencies": { "library": "file:../library",  ...}  依赖配置完成后，请在Terminal窗口执行ohpm install命令下载依赖包，或者单击编辑器窗口上方的Sync Now进行同步，依赖包会存储在工程或各模块的oh_modules目录下。 已复制ohpm install  引用ohpm包资源依赖设置完成后，您可以在工程中引用ohpm三方共享包资源，引用方法请参考引用HAR文件和资源。   上一篇 开启AOT编译模式 下一篇 HAP唯一性校验逻辑 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。连接ServiceAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 如果ServiceAbility需要与PageAbility或其他应用的ServiceAbility进行交互，则须创建用于连接的Connection。ServiceAbility支持其他Ability通过connectAbility()方法与其进行连接。PageAbility的connectAbility方法定义在featureAbility中，ServiceAbility的connectAbility方法定义在particleAbility中。在使用connectAbility()处理回调时，需要传入目标Service的Want与IAbilityConnection的实例。IAbilityConnection提供了以下方法供开发者实现。 表1 IAbilityConnection接口说明 接口名  描述    onConnect()  用于处理连接Service成功的回调。   onDisconnect()  用来处理Service异常死亡的回调。   onFailed()  用来处理连接Service失败的回调。     PageAbility创建连接本地ServiceAbility回调实例的代码以及连接本地ServiceAbility的示例代码如下： 已复制import rpc from "@ohos.rpc"import prompt from '@system.prompt'import featureAbility from '@ohos.ability.featureAbility'
let option = {  onConnect: function onConnectCallback(element, proxy) {    console.info(`onConnectLocalService onConnectDone`)    if (proxy === null) {      prompt.showToast({        message: "Connect service failed"      })      return    }    let data = rpc.MessageParcel.create()    let reply = rpc.MessageParcel.create()    let option = new rpc.MessageOption()    data.writeInterfaceToken("connect.test.token")    proxy.sendRequest(0, data, reply, option)    prompt.showToast({      message: "Connect service success"    })  },  onDisconnect: function onDisconnectCallback(element) {    console.info(`onConnectLocalService onDisconnectDone element:${element}`)    prompt.showToast({      message: "Disconnect service success"    })  },  onFailed: function onFailedCallback(code) {    console.info(`onConnectLocalService onFailed errCode:${code}`)    prompt.showToast({      message: "Connect local service onFailed"    })  }}
let request = {  bundleName: "com.example.myapplication",  abilityName: "com.example.myapplication.ServiceAbility",}let connId = featureAbility.connectAbility(request, option) 同时，Service侧也需要在onConnect()时返回IRemoteObject，从而定义与Service进行通信的接口。onConnect()需要返回一个IRemoteObject对象。HarmonyOS提供了IRemoteObject的默认实现，开发者可以通过继承rpc.RemoteObject来创建自定义的实现类。 Service侧把自身的实例返回给调用侧的示例代码如下： 已复制import rpc from "@ohos.rpc"
class FirstServiceAbilityStub extends rpc.RemoteObject {  constructor(des: any) {    if (typeof des === 'string') {      super(des)    } else {      return    }  }
  onRemoteRequest(code: number, data: any, reply: any, option: any) {    console.info(`onRemoteRequest called`)    if (code === 1) {      let string = data.readString()      console.info(`string=${string}`)      let result = Array.from(string).sort().join('')      console.info(`result=${result}`)      reply.writeString(result)    } else {      console.info(`unknown request code`)    }    return true  }}  上一篇 启动ServiceAbility 下一篇 DataAbility组件开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。容器类库概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 容器类库，用于存储各种数据类型的元素，并具备一系列处理数据元素的方法，作为纯数据结构容器来使用具有一定的优势。 容器类采用了类似静态语言的方式来实现，并通过对存储位置以及属性的限制，让每种类型的数据都能在完成自身功能的基础上去除冗余逻辑，保证了数据的高效访问，提升了应用的性能。 当前提供了线性和非线性两类容器，共14种。每种容器都有自身的特性及使用场景，详情请参见线性容器和非线性容器。  上一篇 容器类库 下一篇 线性容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述功能介绍使用场景约束与限制接口说明开发步骤Stage模型FA模型长时任务 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述   功能介绍 应用退至后台后，在后台需要长时间运行用户可感知的任务，如播放音乐、导航等。为防止应用进程被挂起，导致对应功能异常，可以申请长时任务，使应用在后台长时间运行。 申请长时任务后，系统会做相应的校验，确保应用在执行相应的长时任务。同时，系统有与长时任务相关联的通知栏消息，用户删除通知栏消息时，系统会自动停止长时任务。   使用场景 下表给出了当前长时任务支持的类型，包含数据传输、音频播放、录音、定位导航、蓝牙相关、多设备互联、WLAN相关、音视频通话和计算任务。可以参考下表中的场景举例，选择合适的长时任务类型。 表1 长时任务类型     参数名 描述 配置项 场景举例    DATA_TRANSFER 数据传输 dataTransfer 后台下载大文件，如浏览器后台下载等。   AUDIO_PLAYBACK 音频播放 audioPlayback 音乐类应用在后台播放音乐。   AUDIO_RECORDING 录音 audioRecording 录音机在后台录音。   LOCATION 定位导航 location 导航类应用后台导航。   BLUETOOTH_INTERACTION 蓝牙相关 bluetoothInteraction 通过蓝牙传输分享的文件。   MULTI_DEVICE_CONNECTION 多设备互联 multiDeviceConnection 分布式业务连接。   WIFI_INTERACTION WLAN相关（仅对系统应用开放） wifiInteraction 通过WLAN传输分享的文件。   VOIP 音视频通话（仅对系统应用开放） voip 系统聊天类应用后台音频电话。   TASK_KEEPING 计算任务（仅对特定设备开放） taskKeeping 杀毒软件。     申请了DATA_TRANSFER（数据传输）的长时任务，系统仅会提升应用进程的优先级，降低系统终止应用进程的概率，但仍然会挂起对应的应用进程。对于上传下载对应的功能，需要调用系统上传下载代理接口托管给系统执行。    约束与限制  申请限制：Stage模型中，长时任务仅支持UIAbility申请；FA模型中，长时任务仅支持ServiceAbility申请。 数量限制：一个UIAbility（FA模型则为ServiceAbility）同一时刻仅支持申请一个长时任务，即在一个长时任务结束后才可能继续申请。如果一个应用同时需要申请多个长时任务，需要创建多个UIAbility；一个应用的一个UIAbility申请长时任务后，整个应用下的所有进程均不会被挂起。 运行限制：在手机产品上，系统会进行长时任务校验。 场景1：若应用申请了长时任务，但未真正执行申请类型的长时任务或申请类型的任务已结束，系统会对应用进行管控。例如系统检测到应用申请了AUDIO_PLAYBACK（音频播放），但实际未播放音乐，系统则会终止对应的进程。 场景2：若应用没有申请对应的长时任务类型，但执行了相关类型的长时任务，系统会对应用进行管控。例如系统检测到应用只申请了AUDIO_PLAYBACK（音频播放），但实际上除了播放音乐（对应AUDIO_PLAYBACK类型），还在进行录音（对应AUDIO_RECORDING类型），系统会对应用进行管控。 场景3：若运行长时任务的进程后台负载持续高于所申请类型的典型负载，系统会对应用进行管控。  
说明
 应用按需求申请长时任务，当应用无需在后台运行（任务结束）时，要及时主动取消长时任务，否则系统会强行取消。例如用户点击音乐暂停播放时，应用需及时取消对应的长时任务；用户再次点击音乐播放时，需重新申请长时任务。 
   接口说明 表2 主要接口 以下是长时任务开发使用的相关接口，下表均以Promise形式为例，更多接口及使用方式请见后台任务管理。     接口名 描述    startBackgroundRunning(context: Context, bgMode: BackgroundMode, wantAgent: WantAgent): Promise<void> 申请长时任务   stopBackgroundRunning(context: Context): Promise<void> 取消长时任务      开发步骤 本文以申请录音长时任务为例，示例中包含“申请长时任务”和“取消长时任务”两个按钮，显示效果为：  点击“申请长时任务”按钮，应用申请录音长时任务成功，通知栏显示“正在运行录音任务”通知。 点击“取消长时任务”按钮，取消长时任务，通知栏撤销相关通知。    Stage模型  需要申请ohos.permission.KEEP_BACKGROUND_RUNNING权限，配置方式请参见配置文件权限声明。 声明后台模式类型。 在module.json5配置文件中为需要使用长时任务的UIAbility声明相应的长时任务类型（配置文件中填写长时任务类型的配置项）。 已复制 "module": {     "abilities": [         {             "backgroundModes": [             // 长时任务类型的配置项             "audioRecording"             ],          }     ],     ... } 导入模块。         长时任务相关的模块为backgroundTaskManager和wantAgent，其余模块按实际需要导入。        已复制 import backgroundTaskManager from '@ohos.resourceschedule.backgroundTaskManager'; import UIAbility from '@ohos.app.ability.UIAbility'; import window from '@ohos.window'; import AbilityConstant from '@ohos.app.ability.AbilityConstant'; import Want from '@ohos.app.ability.Want'; import rpc from '@ohos.rpc'; import { BusinessError } from '@ohos.base'; import wantAgent, { WantAgent } from '@ohos.app.ability.wantAgent';  申请和取消长时任务。  在Stage模型中，长时任务支持设备本应用申请，也支持跨设备或跨应用申请。 跨设备或者跨应用在后台执行长时任务时，可以通过Call的方式在后台创建并运行UIAbility，具体使用请参考Call调用开发指南（同设备）。  设备本应用申请长时任务示例代码如下： 已复制 @Entry @Component struct Index {   @State message: string = 'ContinuousTask';  // 通过getContext方法，来获取page所在的UIAbility上下文。   private context: Context = getContext(this);
   startContinuousTask() {     let wantAgentInfo: wantAgent.WantAgentInfo = {       // 点击通知后，将要执行的动作列表       // 添加需要被拉起应用的bundleName和abilityName       wants: [         {           bundleName: "com.example.myapplication",           abilityName: "com.example.myapplication.MainAbility"         }       ],       // 指定点击通知栏消息后的动作是拉起ability       operationType: wantAgent.OperationType.START_ABILITY,       // 使用者自定义的一个私有值       requestCode: 0,       // 点击通知后，动作执行属性       wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]     };
     // 通过wantAgent模块下getWantAgent方法获取WantAgent对象     wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj: WantAgent) => {        backgroundTaskManager.startBackgroundRunning(this.context,          backgroundTaskManager.BackgroundMode.AUDIO_RECORDING, wantAgentObj).then(() => {          console.info(`Succeeded in operationing startBackgroundRunning.`);        }).catch((err: BusinessError) => {          console.error(`Failed to operation startBackgroundRunning. Code is ${err.code}, message is ${err.message}`);        });     });   }
   stopContinuousTask() {      backgroundTaskManager.stopBackgroundRunning(this.context).then(() => {        console.info(`Succeeded in operationing stopBackgroundRunning.`);      }).catch((err: BusinessError) => {        console.error(`Failed to operation stopBackgroundRunning. Code is ${err.code}, message is ${err.message}`);      });   }
   build() {     Row() {       Column() {         Text("Index")           .fontSize(50)           .fontWeight(FontWeight.Bold)
        Button() {           Text('申请长时任务').fontSize(25).fontWeight(FontWeight.Bold)         }         .type(ButtonType.Capsule)         .margin({ top: 10 })         .backgroundColor('#0D9FFB')         .width(250)         .height(40)         .onClick(() => {           // 通过按钮申请长时任务           this.startContinuousTask();
           // 此处执行具体的长时任务逻辑，如放音等。         })
         Button() {           Text('取消长时任务').fontSize(25).fontWeight(FontWeight.Bold)         }         .type(ButtonType.Capsule)         .margin({ top: 10 })         .backgroundColor('#0D9FFB')         .width(250)         .height(40)         .onClick(() => {           // 此处结束具体的长时任务的执行
           // 通过按钮取消长时任务           this.stopContinuousTask();         })       }       .width('100%')     }     .height('100%')   } } 跨设备或跨应用申请长时任务示例代码如下： 已复制 const MSG_SEND_METHOD: string = 'CallSendMsg'
 let mContext: Context;
 function startContinuousTask() {   let wantAgentInfo : wantAgent.WantAgentInfo = {     // 点击通知后，将要执行的动作列表     wants: [       {         bundleName: "com.example.myapplication",         abilityName: "com.example.myapplication.MainAbility",       }     ],     // 点击通知后，动作类型     operationType: wantAgent.OperationType.START_ABILITY,     // 使用者自定义的一个私有值     requestCode: 0,     // 点击通知后，动作执行属性     wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]   };
   // 通过wantAgent模块的getWantAgent方法获取WantAgent对象   wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj : WantAgent) => {     backgroundTaskManager.startBackgroundRunning(mContext,       backgroundTaskManager.BackgroundMode.AUDIO_RECORDING, wantAgentObj).then(() => {       console.info(`Succeeded in operationing startBackgroundRunning.`);     }).catch((err: BusinessError) => {       console.error(`Failed to operation startBackgroundRunning. Code is ${err.code}, message is ${err.message}`);     });   }); }
 function stopContinuousTask() {   backgroundTaskManager.stopBackgroundRunning(mContext).then(() => {     console.info(`Succeeded in operationing stopBackgroundRunning.`);   }).catch((err: BusinessError) => {     console.error(`Failed to operation stopBackgroundRunning. Code is ${err.code}, message is ${err.message}`);   }); }
 class MyParcelable implements rpc.Parcelable {   num: number = 0;   str: string = '';
   constructor(num: number, string: string) {     this.num = num;     this.str = string;   }
   marshalling(messageSequence: rpc.MessageSequence) {     messageSequence.writeInt(this.num);     messageSequence.writeString(this.str);     return true;   }
   unmarshalling(messageSequence: rpc.MessageSequence) {     this.num = messageSequence.readInt();     this.str = messageSequence.readString();     return true;   } }
 function sendMsgCallback(data: rpc.MessageSequence) {   console.info('BgTaskAbility funcCallBack is called ' + data);   let receivedData: MyParcelable = new MyParcelable(0, '');   data.readParcelable(receivedData);   console.info(`receiveData[${receivedData.num}, ${receivedData.str}]`);   // 可以根据Caller端发送的序列化数据的str值，执行不同的方法。   if (receivedData.str === 'start_bgtask') {     // 申请长时     startContinuousTask();   } else if (receivedData.str === 'stop_bgtask') {     // 取消长时     stopContinuousTask();   }   return new MyParcelable(10, 'Callee test'); }
 export default class BgTaskAbility extends UIAbility {   // Ability创建   onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {     console.info("[Demo] BgTaskAbility onCreate");     try {       this.callee.on(MSG_SEND_METHOD, sendMsgCallback)     } catch (error) {       console.error(`${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`);     }     mContext = this.context;   }     // Ability销毁   onDestroy() {     console.info('[Demo] BgTaskAbility onDestroy');   }
   onWindowStageCreate(windowStage: window.WindowStage) {     console.info('[Demo] BgTaskAbility onWindowStageCreate');
     windowStage.loadContent('pages/Index', (error, data) => {       if (error.code) {         console.error(`load content failed with error ${JSON.stringify(error)}`);         return;       }       console.info(`load content succeed with data ${JSON.stringify(data)}`);     });   }
   onWindowStageDestroy() {     console.info('[Demo] BgTaskAbility onWindowStageDestroy');   }      onForeground() {     console.info('[Demo] BgTaskAbility onForeground');   }
   onBackground() {     console.info('[Demo] BgTaskAbility onBackground');   } };    FA模型  启动并连接ServiceAbility。  不需要与用户进行交互时，采用startAbility()方法启动ServiceAbility（具体使用请参考ServiceAbility组件，并在ServiceAbility的onStart回调方法中，调用长时任务的申请和取消接口。 需要与用户进行交互时（如播放音乐），采用connectAbility()方法启动并连接ServiceAbility（具体使用请参考ServiceAbility组件，在获取到服务的代理对象后，与服务进行通信，控制长时任务的申请和取消。  配置权限和声明后台模式类型。 在config.json文件中配置长时任务权限ohos.permission.KEEP_BACKGROUND_RUNNING，配置方式请参见配置文件权限声明。同时，为需要使用长时任务的ServiceAbility声明相应的长时任务类型。 已复制"module": {    "package": "com.example.myapplication",    "abilities": [        {            "backgroundModes": [            "audioRecording",            ], // 后台模式类型            "type": "service"  // ability类型为service        }    ],    "reqPermissions": [        {            "name": "ohos.permission.KEEP_BACKGROUND_RUNNING"  // 长时任务权限        }    ]} 导入模块。 已复制 import backgroundTaskManager from '@ohos.resourceschedule.backgroundTaskManager'; import featureAbility from '@ohos.ability.featureAbility'; import wantAgent, { WantAgent } from '@ohos.app.ability.wantAgent'; import rpc from "@ohos.rpc"; import { BusinessError } from '@ohos.base'; import Want from '@ohos.app.ability.Want'; 申请和取消长时任务。在 ServiceAbility 中，调用 startBackgroundRunning() 接口和 stopBackgroundRunning() 接口实现长时任务的申请和取消，通过js代码实现。 已复制 function startContinuousTask() {   let wantAgentInfo: wantAgent.WantAgentInfo = {     // 点击通知后，将要执行的动作列表     wants: [       {         bundleName: "com.example.myapplication",         abilityName: "com.example.myapplication.MainAbility"       }     ],     // 点击通知后，动作类型     operationType: wantAgent.OperationType.START_ABILITY,     // 使用者自定义的一个私有值     requestCode: 0,     // 点击通知后，动作执行属性     wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]   };
   // 通过wantAgent模块的getWantAgent方法获取WantAgent对象   wantAgent.getWantAgent(wantAgentInfo).then((wantAgentObj: WantAgent) => {     backgroundTaskManager.startBackgroundRunning(featureAbility.getContext(),       backgroundTaskManager.BackgroundMode.AUDIO_RECORDING, wantAgentObj).then(() => {       console.info(`Succeeded in operationing startBackgroundRunning.`);     }).catch((err: BusinessError) => {       console.error(`Failed to operation startBackgroundRunning. Code is ${err.code}, message is ${err.message}`);     });   }); }
 function stopContinuousTask() {   backgroundTaskManager.stopBackgroundRunning(featureAbility.getContext()).then(() => {     console.info(`Succeeded in operationing stopBackgroundRunning.`);   }).catch((err: BusinessError) => {     console.error(`Failed to operation stopBackgroundRunning. Code is ${err.code}, message is ${err.message}`);   }); }
 async function processAsyncJobs() {   // 此处执行具体的长时任务。
   // 长时任务执行完，调用取消接口，释放资源。   stopContinuousTask(); }
 let mMyStub: MyStub;
 // 采用connectAbility的方式启动服务 class MyStub extends rpc.RemoteObject {   constructor(des: string) {     super(des);   }
   onRemoteRequest(code: number, data: rpc.MessageParcel, reply: rpc.MessageParcel, option: rpc.MessageOption) {     console.log('ServiceAbility onRemoteRequest called');     // code 的具体含义用户自定义     if (code === 1) {       // 接收到申请长时任务的请求码       startContinuousTask();       // 此处执行具体长时任务     } else if (code === 2) {       // 接收到取消长时任务的请求码       stopContinuousTask();     } else {       console.log('ServiceAbility unknown request code');     }     return true;   } }
 // 采用startAbility的方式启动服务 class ServiceAbility {   onStart(want: Want) {     console.info('ServiceAbility onStart');     mMyStub = new MyStub("ServiceAbility-test");     // 在执行长时任务前，调用申请接口。     startContinuousTask();     processAsyncJobs();   }
   onStop() {     console.info('ServiceAbility onStop');   }
   onConnect(want: Want) {     console.info('ServiceAbility onConnect');     return mMyStub;   }
   onReconnect(want: Want) {     console.info('ServiceAbility onReconnect');   }
   onDisconnect() {     console.info('ServiceAbility onDisconnect');   }
   onCommand(want: Want, startId: number) {     console.info('ServiceAbility onCommand');   } }
 export default new ServiceAbility();    上一篇 短时任务 下一篇 延迟任务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。分布式应用/服务调试流程前提条件操作步骤跨设备应用/服务调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持一个工程（单模块或多模块）连接多个设备，在设备之间能彼此通信的条件下（如分布式流转场景），支持对跨设备、跨模块、跨进程的HarmonyOS应用/服务进行调试。分布式应用/服务调试支持Java应用/服务调用Java应用/服务、JS应用/服务调用Java应用/服务，以及使用HarmonyOS IDL实现的跨设备场景，开发者在如下表中的方法处设置断点，当中断到该断点处，执行Step Into即可进入到被调用方法的实现处。 发起调用端（设备A）  实现调用端（设备B）    Java FA/PA：startAbility(Intent intent)  Java FA/PA：onStart(Intent intent)   Java FA/PA：connectAbility(Intent intent，IAbilityConnection conn)  Java PA：onConnect(Intent intent)   JS FA：FeatureAbility.startAbility(OBJECT)  Java PA/FA：onStart(Intent intent)   Java：IRemoteObject.sendRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option)  Java：IRemoteObject.onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option)   Java：HarmonyOS IDL方法调用处  Java：HarmonyOS IDL方法实现处     分布式应用/服务调试流程下面以一个设备A（FA）调用设备B（PA）的分布式调用场景来介绍分布式应用/服务调试流程，如下图所示：  开发者启动分布式调试任务。IDE调试器会分别在设备A和设备B上安装应用/服务，并启动调试。开发者在设备A（FA）调用设备B（PA）的调用处设置断点，IDE调试器在该断点处中断。执行Step Into操作，则会在设备B（PA）被调用的方法实现处中断。开发者对设备B（PA）进行调试。如果在设备B（PA）被调用的方法实现处执行Step Out，则退出设备B（PA）的调试，并在设备A调用处中断。开发者停止调试任务。IDE调试器停止设备A和设备B的应用/服务运行，调试结束。  前提条件调测的多个设备成功组网，包括连接到同一个WLAN网络和登录同一个华为帐号。  操作步骤在涉及跨设备调用的代码行设置断点。选择跨设备调试配置（Super App）选项，单击按钮启动调试。 在弹出的设备选择窗口，指定调试设备对应的模块名称。 启动调试后，DevEco Studio将按照勾选的多个设备，分别启动多个调试会话窗口，命名为：“Super App-模块名”，如Super App-entry。 在代码执行到断点处（跨设备调用的代码处）中断，单击Step Into，快捷键为F7（macOS为F7），则会自动跳转到被调用代码接口方法处。例如，以上图中的调试界面为例，在Phone中调用TV的音乐播放能力，单击Step Into，调试窗口将从“Super App-entry”跳转到“Super App-entrytv”窗口，同时，代码也会跳转到调用实现的接口方法处，无需开发者手动设置断点。    上一篇 Hot Reload 下一篇 打印日志 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用TaskPool进行图像直方图处理使用Worker进行长时间数据分析CPU密集型任务开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  CPU密集型任务是指需要占用系统资源处理大量计算能力的任务，需要长时间运行，这段时间会阻塞线程其它事件的处理，不适宜放在主线程进行。例如图像处理、视频编码、数据分析等。 基于多线程并发机制处理CPU密集型任务可以提高CPU利用率，提升应用程序响应速度。 当进行一系列同步任务时，推荐使用Worker；而进行大量或调度点较为分散的独立任务时，不方便使用8个Worker去做负载管理，推荐采用TaskPool。接下来将以图像直方图处理以及后台长时间的模型预测任务分别进行举例。  使用TaskPool进行图像直方图处理  实现图像处理的业务逻辑。 数据分段，将各段数据通过不同任务的执行完成图像处理。 创建Task，通过execute()执行任务，在当前任务结束后，会将直方图处理结果同时返回。 结果数组汇总处理。  已复制import taskpool from '@ohos.taskpool';
@Concurrentfunction imageProcessing(dataSlice: ArrayBuffer) {  // 步骤1: 具体的图像处理操作及其他耗时操作  return dataSlice;}
function histogramStatistic(pixelBuffer: ArrayBuffer) {  // 步骤2: 分成三段并发调度  let number = pixelBuffer.byteLength / 3;  let buffer1 = pixelBuffer.slice(0, number);  let buffer2 = pixelBuffer.slice(number, number * 2);  let buffer3 = pixelBuffer.slice(number * 2);
  let task1 = new taskpool.Task(imageProcessing, buffer1);  let task2 = new taskpool.Task(imageProcessing, buffer2);  let task3 = new taskpool.Task(imageProcessing, buffer3);
  taskpool.execute(task1).then((ret: ArrayBuffer[]) => {    // 步骤3: 结果处理  });  taskpool.execute(task2).then((ret: ArrayBuffer[]) => {    // 步骤3: 结果处理  });  taskpool.execute(task3).then((ret: ArrayBuffer[]) => {    // 步骤3: 结果处理  });}
@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            let data: ArrayBuffer;            histogramStatistic(data);          })      }      .width('100%')    }    .height('100%')  }}   使用Worker进行长时间数据分析 本文通过某地区提供的房价数据训练一个简易的房价预测模型，该模型支持通过输入房屋面积和房间数量去预测该区域的房价，模型需要长时间运行，房价预测需要使用前面的模型运行结果，因此需要使用Worker。  DevEco Studio提供了Worker创建的模板，新建一个Worker线程，例如命名为“MyWorker”。  在主线程中通过调用ThreadWorker的constructor()方法创建Worker对象，当前线程为宿主线程。 已复制import worker from '@ohos.worker';
const workerInstance = new worker.ThreadWorker('entry/ets/workers/MyWorker.ts'); 在宿主线程中通过调用onmessage()方法接收Worker线程发送过来的消息，并通过调用postMessage()方法向Worker线程发送消息。 例如向Worker线程发送训练和预测的消息，同时接收Worker线程发送回来的消息。 已复制// 接收Worker子线程的结果workerInstance.onmessage = function(e) {  // data：Worker线程发送的信息  let data = e.data;  console.info('MyWorker.ts onmessage');}
workerInstance.onerror = function (d) {  // 接收Worker子线程的错误信息}
// 向Worker子线程发送训练消息workerInstance.postMessage({ 'type': 0 });// 向Worker子线程发送预测消息workerInstance.postMessage({ 'type': 1, 'value': [90, 5] }); 在MyWorker.ts文件中绑定Worker对象，当前线程为Worker线程。 已复制import worker, { ThreadWorkerGlobalScope, MessageEvents, ErrorEvent } from '@ohos.worker';
let workerPort: ThreadWorkerGlobalScope = worker.workerPort; 在Worker线程中通过调用onmessage()方法接收宿主线程发送的消息内容，并通过调用postMessage()方法向宿主线程发送消息。 例如在Worker线程中定义预测模型及其训练过程，同时与主线程进行信息交互。 已复制import worker, { ThreadWorkerGlobalScope, MessageEvents, ErrorEvent } from '@ohos.worker';
let workerPort: ThreadWorkerGlobalScope = worker.workerPort;
// 定义训练模型及结果 let result;
// 定义预测函数function predict(x) {  return result[x];}
// 定义优化器训练过程function optimize() {  result = {};}
// Worker线程的onmessage逻辑workerPort.onmessage = function (e: MessageEvents) {  let data = e.data  // 根据传输的数据的type选择进行操作  switch (data.type) {    case 0:    // 进行训练      optimize();    // 训练之后发送主线程训练成功的消息      workerPort.postMessage({ type: 'message', value: 'train success.' });      break;    case 1:    // 执行预测      const output = predict(data.value);    // 发送主线程预测的结果      workerPort.postMessage({ type: 'predict', value: output });      break;    default:      workerPort.postMessage({ type: 'message', value: 'send message is invalid' });      break;  }} 在Worker线程中完成任务之后，执行Worker线程销毁操作。销毁线程的方式主要有两种：根据需要可以在宿主线程中对Worker线程进行销毁；也可以在Worker线程中主动销毁Worker线程。 在宿主线程中通过调用onexit()方法定义Worker线程销毁后的处理逻辑。 已复制// Worker线程销毁后，执行onexit回调方法workerInstance.onexit = function() {  console.info("main thread terminate");} 方式一：在宿主线程中通过调用terminate()方法销毁Worker线程，并终止Worker接收消息。 已复制// 销毁Worker线程workerInstance.terminate(); 方式二：在Worker线程中通过调用close()方法主动销毁Worker线程，并终止Worker接收消息。 已复制// 销毁线程workerPort.close();    上一篇 @Concurrent装饰器：校验并发函数 下一篇 I/O密集型任务开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建DataAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 实现DataAbility中Insert、Query、Update、Delete接口的业务内容。保证能够满足数据库存储业务的基本需求。BatchInsert与ExecuteBatch接口已经在系统中实现遍历逻辑，依赖Insert、Query、Update、Delete接口逻辑，来实现数据的批量处理。 创建DataAbility的代码示例如下： 已复制import featureAbility from '@ohos.ability.featureAbility'import dataAbility from '@ohos.data.dataAbility'import dataRdb from '@ohos.data.rdb'
const TABLE_NAME = 'book'const STORE_CONFIG = { name: 'book.db' }const SQL_CREATE_TABLE = 'CREATE TABLE IF NOT EXISTS book(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, introduction TEXT NOT NULL)'let rdbStore: dataRdb.RdbStore = undefined
export default {  onInitialized(abilityInfo) {    console.info('DataAbility onInitialized, abilityInfo:' + abilityInfo.bundleName)    let context = featureAbility.getContext()    dataRdb.getRdbStore(context, STORE_CONFIG, 1, (err, store) => {      console.info('DataAbility getRdbStore callback')      store.executeSql(SQL_CREATE_TABLE, [])      rdbStore = store    });  },  insert(uri, valueBucket, callback) {    console.info('DataAbility insert start')    rdbStore.insert(TABLE_NAME, valueBucket, callback)  },  batchInsert(uri, valueBuckets, callback) {    console.info('DataAbility batch insert start')    for (let i = 0;i < valueBuckets.length; i++) {      console.info('DataAbility batch insert i=' + i)      if (i < valueBuckets.length - 1) {        rdbStore.insert(TABLE_NAME, valueBuckets[i], (err: any, num: number) => {          console.info('DataAbility batch insert ret=' + num)        })      } else {        rdbStore.insert(TABLE_NAME, valueBuckets[i], callback)      }    }  },  query(uri, columns, predicates, callback) {    console.info('DataAbility query start')    let rdbPredicates = dataAbility.createRdbPredicates(TABLE_NAME, predicates)    rdbStore.query(rdbPredicates, columns, callback)  },  update(uri, valueBucket, predicates, callback) {    console.info('DataAbilityupdate start')    let rdbPredicates = dataAbility.createRdbPredicates(TABLE_NAME, predicates)    rdbStore.update(valueBucket, rdbPredicates, callback)  },  delete(uri, predicates, callback) {    console.info('DataAbilitydelete start')    let rdbPredicates = dataAbility.createRdbPredicates(TABLE_NAME, predicates)    rdbStore.delete(rdbPredicates, callback)  }};  上一篇 DataAbility的生命周期 下一篇 启动DataAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建PageAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 开发者需要重写app.js/app.ets中的生命周期回调函数，开发者通过DevEco Studio开发平台创建PageAbility时，DevEco Studio会在app.js/app.ets中默认生成onCreate()和onDestroy()方法，其他方法需要开发者自行实现。接口说明参见前述章节，创建PageAbility示例如下： 已复制export default {  onCreate() {    console.info('Application onCreate')  },  onDestroy() {    console.info('Application onDestroy')  },  onShow() {    console.info('Application onShow')  },  onHide() {    console.info('Application onHide')  },  onActive() {    console.info('Application onActive')  },  onInactive() {    console.info('Application onInactive')  },  onNewWant() {    console.info('Application onNewWant')  },} PageAbility创建成功后，其abilities相关的配置项在config.json中体现，一个名字为MainAbility的config.json配置文件示例如下： 已复制{  "abilities": [    {      "skills": [        {          "entities": [            "entity.system.home"          ],          "actions": [            "action.system.home"          ]        }      ],      "orientation": "unspecified",      "visible": true,      "srcPath": "MainAbility",      "name": ".MainAbility",      "srcLanguage": "ets",      "icon": "$media:icon",      "description": "$string:MainAbility_desc",      "formsEnabled": false,      "label": "$string:MainAbility_label",      "type": "page",      "launchType": "singleton"    }  ]} FA模型中，可以通过featureAbility的getContext接口获取应用上下文，进而使用上下文提供的能力。  表1 featureAbility接口说明 接口名 接口描述   getContext() 获取应用上下文。    通过getContext获取应用上下文并获取分布式目录的示例如下： 已复制import featureAbility from '@ohos.ability.featureAbility'import fileIo from '@ohos.fileio'
(async () => {  let dir: string  try {    console.info('Begin to getOrCreateDistributedDir')    dir = await featureAbility.getContext().getOrCreateDistributedDir()    console.info('distribute dir is ' + dir)  } catch (error) {    console.error('getOrCreateDistributedDir failed with ' + error)  }
  let fd: number;  let path = dir + "/a.txt";  fd = fileIo.openSync(path, 0o2 | 0o100, 0o666);  fileIo.close(fd);})()  上一篇 PageAbility的启动模式 下一篇 启动本地PageAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建ServiceAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 创建ServiceAbility。 重写ServiceAbility的生命周期方法，添加其他Ability请求与ServiceAbility交互时的处理方法。 已复制  import rpc from "@ohos.rpc"    class FirstServiceAbilityStub extends rpc.RemoteObject {    constructor(des: any) {      if (typeof des === 'string') {        super(des)      } else {        return      }    }  }    export default {    onStart() {      console.info('ServiceAbility onStart')    },    onStop() {      console.info('ServiceAbility onStop')    },    onCommand(want, startId) {      console.info('ServiceAbility onCommand')    },    onConnect(want) {      console.info('ServiceAbility onConnect' + want)      return new FirstServiceAbilityStub('test')    },    onDisconnect(want) {      console.info('ServiceAbility onDisconnect' + want)    }  } 注册ServiceAbility。 ServiceAbility需要在应用配置文件config.json中进行注册，注册类型type需要设置为service。"visible"属性表示ServiceAbility是否可以被其他应用调用，true表示可以被其他应用调用，false表示不能被其他应用调用（仅应用内可以调用）。若ServiceAbility需要被其他应用调用，注册ServiceAbility时需要设置"visible"为true，同时需要设置支持关联启动。 已复制     {       "module": {         "abilities": [           {             "name": ".ServiceAbility",             "srcLanguage": "ets",             "srcPath": "ServiceAbility",             "icon": "$media:icon",             "description": "hap sample empty service",             "type": "service",             "visible": true           }         ]       }     }   上一篇 ServiceAbility的生命周期 下一篇 启动ServiceAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建和配置新工程创建HarmonyOS工程创建OpenHarmony工程创建一个新的工程 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 当您开始开发一个应用/服务时，首先需要根据工程创建向导，创建一个新的工程，工具会自动生成对应的代码和资源模板。 
说明
在运行DevEco Studio工程时，建议每一个运行窗口有2GB以上的可用内存空间。 
 创建和配置新工程DevEco Studio提供了基础的工程模板资源，不同模板支持的设备类型、API Version可能不同，在创建新工程前，请提前了解各模板的相关信息，具体请参考工程模板和开发语言介绍。  创建HarmonyOS工程通过如下两种方式，打开工程创建向导界面。如果当前未打开任何工程，可以在DevEco Studio的欢迎页，选择Create Project开始创建一个新工程。如果已经打开了工程，可以在菜单栏选择File > New > Create Project来创建一个新工程。 根据工程创建向导，选择创建Application应用服务或Atomic Service元服务。再选择需要的Ability工程模板，然后单击Next。  在工程配置页面，需要根据向导配置工程的基本信息。Project name：工程的名称，可以自定义，由大小写字母、数字和下划线组成。
说明
如果是创建的元服务，则： 调试、运行时，在设备桌面上没有应用图标，请使用DevEco Studio的调试和运行功能，来启动元服务。编译构建APP时，每个HAP大小不能超过10MB。 
 Bundle name：标识应用的包名，用于标识应用的唯一性。Save location：工程文件本地存储路径，由大小写字母、数字和下划线等组成，不能包含中文字符。Compile SDK：应用/服务的目标API Version，在编译构建时，DevEco Studio会根据指定的Compile API版本进行编译打包。Model：应用支持的模式，API Version 4~8只支持FA模式。Enable Super Visual：支持低代码开发模式，部分模板支持低代码开发，可选择打开该开关。Language：开发语言。Compatible SDK：兼容的最低API Version。Device type：该工程模板支持的设备类型。  单击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。  创建OpenHarmony工程在完成上述操作后，将模块级的build-profile.json5文件中runtimeOS字段修改为“OpenHarmony”，并点击“Sync Now”重新同步工程。已复制"targets": [  {    "name": "default",    "runtimeOS": "OpenHarmony"  },  {    "name": "ohosTest",  }]   若本地未安装OpenHarmony，可能会导致同步失败。可点击报错提示中“Open SDK Manager”，或在菜单栏Tool > SDK Manager > SDK页签，在下拉菜单中选择OpenHarmony，选择安装路径后，勾选需要下载的API Version并点击Apply，下载OpenHarmony SDK。    上一篇 工程模板和开发语言介绍 下一篇 Gradle工程适配为Hvigor工程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建库模块将库模块编译为HAR发布Har包到Maven仓为应用/服务模块添加依赖开发及引用静态共享包（API 4-7） 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 HAR包只能被Phone、Tablet、Car、TV和Wearable工程所引用。 
说明
不支持跨语言的HAR包依赖，例如不支持在JS工程中依赖Java开发的HAR包。 
 创建库模块在DevEco Studio中，可以通过如下方式创建新的库模块。 鼠标移到工程目录顶部，单击右键，选择New > Module，在工程中添加新的HarmonyOS Library模块。在New Module界面中，选择HarmonyOS Library，并单击Next。 在Configure the New Module界面中，设置新添加的模块信息，设置完成后，单击Finish完成创建。Library name：新增Module所属的类名称。Package name：软件包名称。Compatible SDK：兼容的SDK版本。Device type：选择设备类型。  等待工程自动同步完成后，会在工程目录中生成对应的库模块。   将库模块编译为HAR利用Gradle可以将HarmonyOS Library库模块构建为HAR包，以便在工程中引用HAR或者将HAR包提供给其它开发者进行调用。构建HAR包的方法如下： 在Gradle构建任务中，双击PackageDebugHar或PackageReleaseHar任务，构建Debug类型或Release类型的HAR。 图1 编译debug类型HAR包 图2 编译Release类型HAR包 待构建任务完成后，可以在工程目录中的moduleName > build > outputs > har目录中，获取生成的HAR包。   发布Har包到Maven仓借助Gradle提供的Maven-publish插件，可以将Har包发布到本地或远程Maven仓。 在工程根目录下，单击鼠标右键New > File，创建一个后缀为“.gradle”的文件，如upload.gradle。在创建的upload.gradle文件中，添加如下示例代码。如下示例代码为发布HAR包到Maven仓的最小集，请根据实际发布信息进行修改。已复制apply plugin: 'maven-publish'
def DEFAULT_POM_NAME='myLibrary'def DEFAULT_POM_VERSION='1.0.1'  //har包版本信息def DEFAULT_POM_ARTIFACT_ID="harTest"  //har包IDdef DEFAULT_POM_GROUP_ID='com.huawei.har'  //项目组IDdef DEFAULT_POM_PACKAGING='har'  //包类型，固定为hardef DEFAULT_POM_DESCRIPTION='myLib for harmonyos'def MAVEN_USERNAME='admin'   //远程Maven仓的用户名def MAVEN_PASSWORD='******'  //远程Maven仓的密码def LOCAL_MAVEN_REPOSITORY_URL='D:/01.localMaven/'  //本地Maven仓地址def REMOTE_MAVEN_REPOSITORY_URL='https:// '  //远程Maven仓地址
afterEvaluate { project ->    DEFAULT_POM_ARTIFACT_ID = project.name    publishing {        publications {            maven(MavenPublication) {                from components.debug  //指定发布的har包类型为debug或release                group = DEFAULT_POM_GROUP_ID                artifactId = DEFAULT_POM_ARTIFACT_ID                version = DEFAULT_POM_VERSION                pom {                    name = DEFAULT_POM_NAME                    description = DEFAULT_POM_DESCRIPTION                    packaging = DEFAULT_POM_PACKAGING                }            }        }        repositories {            maven {                url = LOCAL_MAVEN_REPOSITORY_URL  //发布到本地Maven仓                //发布到远程Maven仓的地址以及Maven仓的帐号和密码                /*url = REMOTE_MAVEN_REPOSITORY_URL                 credentials {                    username MAVEN_USERNAME                    password MAVEN_PASSWORD                 }                */            }        }    }}
 在Har模块的build.gradle中，添加HAR发布脚本。添加完成后，单击Sync Now进行同步。已复制apply from:'../upload.gradle'  同步完成后，会在Gradle任务中增加publishing的任务列表。 双击执行publishMavenPublicationToMavenRepository任务，将HAR包发布到指定的Maven地址。 本示例是以发布到本地Maven地址为例，发布结果如下图所示：   为应用/服务模块添加依赖在应用/服务模块（entry或feature模块）中调用HAR，常用的添加依赖的方式包括如下三种。 调用同一个工程中的HAR：HAR包和应用/服务模块在同一个工程，打开应用/服务模块的build.gradle文件，在dependencies闭包中，添加如下代码。添加完成后，请单击Sync Now同步工程。已复制dependencies {    implementation project(":mylibrary")} 调用Maven仓中的HAR：无论Har包是本地Maven仓还是远程Maven仓，均可以采用如下方式添加依赖。在工程的build.gradle的allprojects闭包中，添加HAR所在的Maven仓地址。已复制repositories {        maven {            url 'file://D:/01.localMaven/'  //添加Maven仓地址，可以是本地Maven地址，也可以是远程Maven地址        }} 在应用/服务模块的build.gradle的dependencies闭包中，添加如下代码。已复制dependencies {    implementation 'com.huawei.har:mylibrary:1.0.1'} 添加完成后，单击Sync Now同步工程。 调用本地HAR：将Har包放到模块下的libs目录，然后检查build.gradle中是否添加了*.har的依赖。已复制dependencies {    ...    implementation fileTree(dir: 'libs', include: ['*.jar', '*.har'])}    上一篇 开发及引用静态共享包（API 8） 下一篇 开发及引用动态共享包 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发及引用共享包 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    开发及引用静态共享包（API 9）  开发及引用静态共享包（API 8）  开发及引用静态共享包（API 4-7）  开发及引用动态共享包   上一篇 添加JS Component和Page 下一篇 开发及引用静态共享包（API 9） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建HarmonyOS npm模块编译HarmonyOS npm模块发布HarmonyOS npm包引用HarmonyOS npm包文件和资源配置HarmonyOS npm包依赖引用HarmonyOS npm包hml页面引用HarmonyOS npm包ArkTS页面引用HarmonyOS npm包内ts/js方法引用HarmonyOS npm包内资源开发及引用静态共享包（API 8） 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 API 8工程的npm共享包的实现依赖于npm，因此您需要了解和掌握npm的基础功能和机制，可通过npm官方文档进行了解。 接下来，将简单介绍HarmonyOS npm模块的工程结构，如下图所示：  相关字段的描述如下，其余字段与Entry或Feature模块相关字段相同，可参考工程介绍。 libs：用于存放.so文件。src > main > cpp > types：用于存放C++ API描述文件，子目录按照so维度进行划分。src > main > cpp > types > liblibrary > index.d.ts：描述C++接口的方法名、入参、返回参数等信息。src > main > cpp > types > liblibrary > package.json：描述so三方包声明文件入口和so包名信息。src > main > cpp > CMakeLists.txt：CMake配置文件，提供CMake构建脚本src > main > cpp > hello.cpp：HarmonyOS npm包C++代码源文件。index.ets：HarmonyOS npm包导出声明的入口。 本文将介绍如何创建HarmonyOS npm模块、如何编译HarmonyOS npm共享包、如何引用HarmonyOS npm包资源，以及如何将HarmonyOS npm共享包发布到npm仓。 创建HarmonyOS npm模块鼠标移到工程目录顶部，单击右键，选择New > Module，在HarmonyOS工程中添加HarmonyOS npm块。在Choose Your Ability Template界面中，选择Static Library，并单击Next。 在Configure the New Module界面中，设置新添加的模块信息，设置完成后，单击Finish完成创建。Module name：新增模块的名称。Language：选择开发HarmonyOS npm包的语言。Device type：选择HarmonyOS npm包支持的设备类型。Enable Native：是否创建一个用于调用C++代码的HarmonyOS npm共享模块。  创建完成后，会在工程目录中生成HarmonyOS npm共享模块及相关文件。   在开发HarmonyOS npm模块时，请注意以下事项： HarmonyOS npm模块的package.json中，必须包含ohos闭包。HarmonyOS npm模块暂不支持配置Ability。  编译HarmonyOS npm模块开发完HarmonyOS npm模块后，选中模块名，然后通过DevEco Studio菜单栏的Build > Make Module ${libraryName}进行编译构建，生成HarmonyOS npm包。HarmonyOS npm包可用于工程其它模块的引用，或将HarmonyOS npm包上传至npm仓库，供其他开发者下载使用。  编译构建的HarmonyOS npm包可在模块下的build目录下获取，包格式为*.tgz。  在编译构建HarmonyOS npm模块时，请注意以下事项： 在编译构建HarmonyOS npm包的过程中，DevEco Studio不会将模块中的C++代码打包进.tgz文件中，而是将C++代码编译成动态依赖库.so文件，并放置在libs目录下。原因是C++的编译构建任务只会在工程的模块下被执行。在编译构建HarmonyOS npm包的过程中，会生成资源文件ResourceTable.txt，以便编辑器可以对HarmonyOS npm包中的资源文件进行联想。因此，如果不使用DevEco Studio对HarmonyOS npm进行构建，则DevEco Studio的编辑器会无法联想HarmonyOS npm包中的资源。  发布HarmonyOS npm包将打包的HarmonyOS npm包发布至npm仓，可供其他开发者安装和引用。npm包的发布，既可以发布到npm官方中心仓，也可以将其发布到DevEco Marketplace提供的HarmonyOS npm专用仓，接下来将重点介绍如何发布到HarmonyOS npm专用仓。关于发布到npm官方中心仓请参考npm官方文档。 在HarmonyOS npm模块中（与src文件夹同一级目录下），添加如下文件：新建README.md文件：在README.md文件中必须包含包的介绍和引用方式，还可以根据包的内容添加更详细介绍。新建CHANGELOG.md文件：填写HarmonyOS npm包的版本更新记录。添加LICENSE文件：LICENSE许可文件。 重新编译HarmonyOS npm模块，生成*.tgz文件。登录DevEco Marketplace，单击主页右上角的个人中心 > 安全 > AccessToken，在AccessToken页签下，单击“生成新令牌”。
说明
发布HarmonyOS npm包需注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。 
  生成的令牌将会在发布HarmonyOS npm包时使用，请单击令牌末尾的复制按钮复制并保存令牌信息。 打开命令行工具执行如下命令设置新的scope：ohos。已复制npm config set @ohos:registry=https://repo.harmonyos.com/npm/ 执行如下命令，设置令牌信息，<authToken>请修改为步骤3中获取的Access Token。已复制npm config set //repo.harmonyos.com/npm/:_authToken <authToken> 执行如下命令发布HarmonyOS npm包，<HarmonyOS npm包名称>请根据实际进行修改。已复制npm publish <HarmonyOS npm包名称>   引用HarmonyOS npm包文件和资源 配置HarmonyOS npm包依赖引用HarmonyOS npm三方包，包括从HarmonyOS npm仓库进行安装和从本地HarmonyOS npm模块中进行安装两种方式。 引用npm仓中的HarmonyOS npm包，首先需要设置HarmonyOS npm三方包的仓库信息，请在DevEco Studio的Terminal窗口执行如下命令进行设置：已复制npm config set @ohos:registry=https://repo.harmonyos.com/npm/ 然后通过如下两种方式设置HarmonyOS npm三方包依赖信息：方式一：在Terminal窗口中，执行如下命令安装HarmonyOS npm三方包，DevEco Studio会自动在工程的package.json中自动添加三方包依赖。已复制npm install @ohos/vcard --save 方式二：在工程的package.json中设置HarmonyOS npm三方包依赖，配置示例如下：已复制"dependencies": {  "@ohos/vcard": "^2.1.0"} 依赖设置完成后，需要执行npm install命令安装依赖包，依赖包会存储在工程的node_modules目录下。 已复制npm install   引用本地HarmonyOS npm模块的文件和资源，有如下两种方式：方式一：在Terminal窗口中，执行如下命令进行安装，并会在package.json中自动添加依赖。已复制npm install ../library --save 方式二：在工程的package.json中设置HarmonyOS npm三方包依赖，配置示例如下：已复制"dependencies": {  "library": "file:../library"} 依赖设置完成后，需要执行npm install命令安装依赖包，依赖包会存储在工程的node_modules目录下。 已复制npm install    在引用HarmonyOS npm包时，请注意以下事项： 当前只支持在模块和工程下的package.json文件中声明dependencies依赖，才会被当做HarmonyOS依赖使用，并在编译构建过程中进行相应的处理。引用的模块的compileSdkVersion不能低于其依赖的HarmonyOS npm三方包（可在node_modules目录下，找到引用的npm包的src > main > module.json5 中查看）。 引用HarmonyOS npm包hml页面在JS工程范式中，组件功能由hml承载，开发者可以在JS工程的hml页面通过<element>标签来引入HarmonyOS npm包中的共享hml页面，示例如下： 已复制<element name="comp" src="library/src/main/js/components/index/index.hml"></element> 其中，library为HarmonyOS npm包的包名，hml页面的路径为HarmonyOS npm包中的相对路径。 随后便可以通过设置的name来使用该element元素，以引用HarmonyOS npm包中的hml页面，示例如下： 已复制<element name="comp" src="library/src/main/js/components/index/index.hml"></element>
<div class="container">    <comp></comp>    <text class="title">        {{ $t('strings.hello') }} {{ title }}    </text></div>  引用HarmonyOS npm包ArkTS页面ArkTS是TypeScript的扩展，因此导出和引入的语法与TypeScript一致。在HarmonyOS npm模块中，可以通过export导出ArkTS页面，示例如下：已复制// library/src/main/ets/components/MainPage/MainPage.ets@Entry@Componentexport struct MainPage {  @State message: string = 'Hello World'  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }}  然后在其它模块中通过import引入导出的ArkTS页面，示例如下所示：已复制// entry/MainAbility/pages/index.ets
import { MainPage } from "library"@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Column() {      MainPage()      Row() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('10%')  }}   引用HarmonyOS npm包内ts/js方法ts/js方法的导出和引用，与ArkTS页面的引用相同，即在HarmonyOS npm模块中，可以通过export导出ts/js方法，示例如下所示： 已复制// library/index.jsexport function func() {  return "[npm] func1";} 然后在其它的ts/js页面中，通过import引入导出的ts/js方法，示例如下所示： 已复制// entry/src/main/js/MainAbility/pages/index/index.jsimport {func} from "library"export default {    data: {        title: ""    },    onInit() {        this.title = func();    }}  引用HarmonyOS npm包内资源支持在HarmonyOS npm模块和依赖HarmonyOS npm的模块中引用HarmonyOS npm模块内的资源。例如在HarmonyOS npm模块的scr/main/resources里添加字符串资源（在string.json中定义，name：hello_npm）和图片资源（icon_npm.png）。然后在Entry模块中引用该字符串资源和图片资源的示例如下： 
说明
当前暂不支持类Web范式引用i18n文件中的国际化资源。 
 已复制// entry/src/main/ets/MainAbility/pages/index.ets@Entry@Componentstruct Index {  @State message: string = 'Hello World'  build() {    Column() {      Row() {        Text($r("app.string.hello_npm")) // 字符串资源          .fontSize(40)          .fontWeight(FontWeight.Bold)      }      .width('50%')      Image($r("app.media.icon_npm")) // 图片资源    }    .height('100%')  }} 在编译构建HAP中，DevEco Studio会从HAP模块及依赖的模块中收集资源文件，如果不同模块的相同限定词目录下的资源文件出现重名冲突时，DevEco Studio会按照以下优先级进行覆盖（优先级由高到低）： AppScope（仅API 9的Stage模型支持）HAP自身模块依赖的HarmonyOS npm模块    上一篇 开发及引用静态共享包（API 9） 下一篇 开发及引用静态共享包（API 4-7） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建库模块编译库模块发布HAR引用HAR文件和资源开发及引用静态共享包（API 9） 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 HAR(Harmony Archive）是静态共享包，可以包含代码、C++库、资源和配置文件。通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。HAR不同于HAP，不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。 接下来，将简单介绍库模块的工程结构，如下图所示：  相关字段的描述如下，其余字段与Entry或Feature模块相关字段相同，可参考工程介绍。 libs：用于存放.so文件。src > main > cpp > types：用于存放C++ API描述文件，子目录按照so维度进行划分。src > main > cpp > types > liblibrary > index.d.ts：描述C++接口的方法名、入参、返回参数等信息。src > main > cpp > types > liblibrary > oh-package.json5：描述so三方包声明文件入口和so包名信息。src > main > cpp > CMakeLists.txt：CMake配置文件，提供CMake构建脚本。src > main > cpp > hello.cpp：共享包C++代码源文件。index.ets：共享包导出声明的入口。 本文将介绍如何创建库模块、如何编译共享包、如何引用共享包资源，以及如何发布共享包。 创建库模块鼠标移到工程目录顶部，单击右键，选择New > Module，在工程中添加模块。在Choose Your Ability Template界面中，选择Static Library，并单击Next。 在Configure New Module界面中，设置新添加的模块信息，设置完成后，单击Finish完成创建。Module name：新增模块的名称。Language：开发语言。Device type：支持的设备类型。Enable native：是否创建一个用于调用C++代码的模块。  创建完成后，会在工程目录中生成库模块及相关文件。    编译库模块开发完库模块后，选中模块名，然后通过DevEco Studio菜单栏的Build > Make Module ${libraryName}进行编译构建，生成HAR。HAR可用于工程其它模块的引用，或将HAR上传至ohpm仓库，供其他开发者下载使用。若部分源码文件不需要打包至HAR中，可通过创建.ohpmignore文件，配置打包时要忽略的文件/文件夹。  编译构建的HAR可在模块下的build目录下获取，包格式为*.har。  在编译构建HAR时，请注意以下事项： 在编译构建HAR的过程中，不会将模块中的C++代码直接打包进.har文件中，而是将C++代码编译成动态依赖库.so文件放置在.har文件中的libs目录下。在编译构建HAR的过程中，会生成资源文件ResourceTable.txt，以便编辑器可以对HAR中的资源文件进行联想。因此，如果不使用DevEco Studio对HAR进行构建，则DevEco Studio的编辑器会无法联想HAR中的资源。  发布HAR发布打包的HAR，可供其他开发者安装和引用。接下来将介绍如何发布共享包。 在库模块中（与src文件夹同一级目录下），添加如下文件：新建README.md文件：在README.md文件中必须包含包的介绍和引用方式，还可以根据包的内容添加更详细介绍。新建CHANGELOG.md文件：填写HAR的版本更新记录。添加LICENSE文件：LICENSE许可文件。 重新编译库模块，生成*.har文件。利用工具ssh-keygen生成公、私钥，可执行以下命令：已复制ssh-keygen -m PEM -t RSA -b 4096 -f your_key_path 
说明
OHPM包管理器只支持加密密钥认证，请在生成公私钥时输入密码。 
 登录OpenHarmony三方库中心仓官网，单击主页右上角的个人中心，新增OHPM公钥，将公钥文件（your_publicKey.pub）的内容粘贴到公钥输入框中。打开命令行工具，执行如下命令设置私钥路径。已复制ohpm config set key_path your_key_path 登录OpenHarmony三方库中心仓，单击主页右上角的个人中心，复制发布码，获取发布码并配置到 .ohpmrc 文件中，可执行如下命令：已复制ohpm config set publish_id your_publish_id 执行如下命令发布HAR，<HAR路径>需指定为.har文件的具体路径。已复制ohpm publish <HAR路径>   引用HAR文件和资源引用三方HAR，包括从仓库进行安装、从本地文件夹和本地压缩包中进行安装三种方式。 引用ohpm仓中的HAR，首先需要设置三方HAR的仓库信息。DevEco Studio默认仓库地址为OpenHarmony三方库中心仓，如果您需要设置自定义仓库，请在DevEco Studio的Terminal窗口执行如下命令（执行命令前，请确保将DevEco Studio中ohpm安装bin目录配置在“环境变量-系统变量-PATH”中，第一次配置环境变量后，需重启DevEco Studio）：已复制ohpm config set registry your_registry1,your_registry2 说明：ohpm支持多个仓库地址，采用英文逗号分隔。 然后通过如下两种方式设置三方包依赖信息：方式一：在Terminal窗口中，执行如下命令安装三方包，DevEco Studio会自动在工程的oh-package.json5中自动添加三方包依赖。已复制ohpm install @ohos/lottie 方式二：在工程的oh-package.json5中设置三方包依赖，配置示例如下：已复制"dependencies": {  "@ohos/lottie": "^2.0.0"} 依赖设置完成后，需要执行ohpm install命令安装依赖包，依赖包会存储在工程的oh_modules目录下。 已复制ohpm install   引用本地文件夹，有如下两种方式：方式一：在Terminal窗口中，执行如下命令进行安装，并会在oh-package.json5中自动添加依赖。已复制ohpm install ../folder 方式二：在工程的oh-package.json5中设置三方包依赖，配置示例如下：已复制"dependencies": {  "folder": "file:../folder"} 依赖设置完成后，需要执行ohpm install命令安装依赖包，依赖包会存储在工程的oh_modules目录下。 已复制ohpm install   引用本地HAR包，有如下两种方式：方式一：在Terminal窗口中，执行如下命令进行安装，并会在oh-package.json5中自动添加依赖。已复制ohpm install ./package.har 方式二：在工程的oh-package.json5中设置三方包依赖，配置示例如下：已复制"dependencies": {  "package": "file:./package.har"} 依赖设置完成后，需要执行ohpm install命令安装依赖包，依赖包会存储在工程的oh_modules目录下。 已复制ohpm install   另外，在安装或卸载共享包时，可在工程的oh-package.json5文件中增加钩子设置，以管理install、uninstall命令的生命周期，配置示例如下： 已复制 "hooks": {    "preInstall": "echo 00 preInstall", // install命令执行之前    "postInstall": "echo 00 postInstall", // install命令执行之后    "preUninstall": "echo 00 preUninstall", // uninstall命令执行之前    "postUninstall": "echo 00 postUninstall"  // uninstall命令执行之后  } 注意：目前只支持执行当前工程的oh-package.json5文件中hooks，不支持执行依赖中hooks。 在引用共享包时，请注意以下事项： 当前只支持在模块和工程下的oh-package.json5文件中声明dependencies依赖，才会被当做依赖使用，并在编译构建过程中进行相应的处理。   上一篇 开发及引用共享包 下一篇 开发及引用静态共享包（API 8） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用密钥对象生成与转换操作使用加解密操作使用签名验签操作使用摘要操作使用密钥协商操作使用消息认证码操作使用随机数操作加解密算法库框架开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
说明
 本开发指导基于API version 9，适用于JS语言开发。 
  使用密钥对象生成与转换操作 场景说明 使用密钥生成操作中，典型的场景有：  随机生成算法库密钥对象。该对象可用于后续的加解密等操作。 根据指定数据生成算法库密钥对象（也就是将外部或存储的二进制数据转换为算法库的密钥对象）。该对象可用于后续的加解密等操作。 获取算法库密钥对象的二进制数据，用于存储或传输。       
说明
 密钥对象Key包括对称密钥SymKey和非对称密钥（公钥PubKey和私钥PriKey），其中公钥和私钥组成密钥对KeyPair。密钥之间的具体关系可参考API参考。 
  接口及参数说明 详细接口说明可参考API参考。 以上场景涉及的常用接口如下表所示：     实例名 接口名 描述    cryptoFramework createAsyKeyGenerator(algName : string) : AsyKeyGenerator 根据algName设置的非对称密钥规格，创建非对称密钥生成器对象   cryptoFramework createSymKeyGenerator(algName : string) : SymKeyGenerator 根据algName设置的对称密钥规格，创建对称密钥生成器对象   AsyKeyGenerator generateKeyPair(callback : AsyncCallback<KeyPair>) : void 使用callback方式，随机生成非对称密钥对象KeyPair   AsyKeyGenerator generateKeyPair() : Promise<KeyPair> 使用Promise方式，随机生成非对称密钥对象KeyPair   SymKeyGenerator generateSymKey(callback : AsyncCallback<SymKey>) : void 使用callback方式，随机生成对称密钥对象SymKey   SymKeyGenerator generateSymKey() : Promise<SymKey> 使用Promise方式，随机生成对称密钥对象SymKey   AsyKeyGenerator convertKey(pubKey : DataBlob, priKey : DataBlob, callback : AsyncCallback<KeyPair>) : void 使用callback方式，根据指定的公钥和私钥二进制数据生成KeyPair对象 （允许公钥/私钥为null，即只传入单一公钥或私钥，生成只携带公钥或私钥的KeyPair对象）   AsyKeyGenerator convertKey(pubKey : DataBlob, priKey : DataBlob) : Promise<KeyPair> 使用Promise方式，根据指定的公钥和私钥二进制数据生成KeyPair对象 （允许公钥/私钥为null，即只传入单一公钥或私钥，生成只携带公钥或私钥的KeyPair对象）   SymKeyGenerator convertKey(key : DataBlob, callback : AsyncCallback<SymKey>) : void 使用callback方式，根据指定的二进制数据，生成对称密钥对象SymKey   SymKeyGenerator convertKey(pubKey : DataBlob, priKey : DataBlob) : Promise<SymKey> 使用Promise方式，根据指定的二进制数据，生成对称密钥对象SymKey   Key getEncoded() : DataBlob 获取Key密钥对象的二进制数据（Key的子类实例包括对称密钥SymKey、公钥PubKey、私钥PriKey）    开发步骤 示例1：随机生成非对称密钥KeyPair，并获得二进制数据（场景1、3）  创建非对称密钥生成器； 通过非对称密钥生成器随机生成非对称密钥； 获取密钥对象的二进制数据；  以使用Promise方式随机生成RSA密钥（1024位，素数个数为2）为例： 已复制import cryptoFramework from '@ohos.security.cryptoFramework';
function generateAsyKey() {  // 创建非对称密钥生成器  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  // 通过非对称密钥生成器，随机生成非对称密钥  let keyGenPromise = rsaGenerator.generateKeyPair();  keyGenPromise.then( keyPair => {    globalKeyPair = keyPair;    let pubKey = globalKeyPair.pubKey;    let priKey = globalKeyPair.priKey;    // 获取非对称密钥的二进制数据    pkBlob = pubKey.getEncoded();    skBlob = priKey.getEncoded();    AlertDialog.show({ message : "pk bin data" + pkBlob.data} );    AlertDialog.show({ message : "sk bin data" + skBlob.data} );  })} 示例2：随机生成对称密钥SymKey，并获得二进制数据（场景1、3）  创建对称密钥生成器； 通过对称密钥生成器随机生成对称密钥； 获取算法库密钥对象的二进制数据；  以使用Promise方式随机生成AES密钥（256位）为例： 已复制import cryptoFramework from '@ohos.security.cryptoFramework';
// 字节流以16进制输出function uint8ArrayToShowStr(uint8Array) {  return Array.prototype.map    .call(uint8Array, (x) => ('00' + x.toString(16)).slice(-2))    .join('');}
function testGenerateAesKey() {  // 创建对称密钥生成器  let symKeyGenerator = cryptoFramework.createSymKeyGenerator('AES256');  // 通过密钥生成器随机生成对称密钥  let promiseSymKey = symKeyGenerator.generateSymKey();  promiseSymKey.then( key => {    // 获取对称密钥的二进制数据，输出长度为256bit的字节流    let encodedKey = key.getEncoded();    console.info('key hex:' + uint8ArrayToShowStr(encodedKey.data));  })} 示例3：根据指定的RSA非对称密钥二进制数据，生成KeyPair对象（场景2）  获取RSA公钥或私钥二进制数据，公钥需满足ASN.1语法、X.509规范、DER编码格式，私钥需满足ASN.1语法、PKCS#8规范、DER编码格式。 创建AsyKeyGenerator对象，调用convertKey方法，传入公钥二进制和私钥二进制（二者非必选项，可只传入其中一个），转换为KeyPair对象。  已复制import cryptoFramework from '@ohos.security.cryptoFramework';
function convertAsyKey() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024");  let pkval = new Uint8Array([48,129,159,48,13,6,9,42,134,72,134,247,13,1,1,1,5,0,3,129,141,0,48,129,137,2,129,129,0,174,203,113,83,113,3,143,213,194,79,91,9,51,142,87,45,97,65,136,24,166,35,5,179,42,47,212,79,111,74,134,120,73,67,21,19,235,80,46,152,209,133,232,87,192,140,18,206,27,106,106,169,106,46,135,111,118,32,129,27,89,255,183,116,247,38,12,7,238,77,151,167,6,102,153,126,66,28,253,253,216,64,20,138,117,72,15,216,178,37,208,179,63,204,39,94,244,170,48,190,21,11,73,169,156,104,193,3,17,100,28,60,50,92,235,218,57,73,119,19,101,164,192,161,197,106,105,73,2,3,1,0,1]);  let pkBlob = {data : pkval};  rsaGenerator.convertKey(pkBlob, null, function(err, keyPair) {    if (keyPair == null) {      AlertDialog.show({message : "Convert keypair fail"});    }    AlertDialog.show({message : "Convert KeyPair success"});  })} 说明 当前convertKey操作，公钥只支持转换满足X.509规范的DER格式，私钥只支持PKCS#8规范的DER格式； 示例4：根据指定的ECC非对称密钥二进制数据，生成KeyPair对象（场景2、3）  获取ECC二进制密钥数据，封装成DataBlob对象。 调用convertKey方法，传入公钥二进制和私钥二进制（二者非必选项，可只传入其中一个），转换为KeyPair对象。  已复制import cryptoFramework from '@ohos.security.cryptoFramework';
function convertEccAsyKey() {    let pubKeyArray = new Uint8Array([48,89,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,3,66,0,4,83,96,142,9,86,214,126,106,247,233,92,125,4,128,138,105,246,162,215,71,81,58,202,121,26,105,211,55,130,45,236,143,55,16,248,75,167,160,167,106,2,152,243,44,68,66,0,167,99,92,235,215,159,239,28,106,124,171,34,145,124,174,57,92]);    let priKeyArray = new Uint8Array([48,49,2,1,1,4,32,115,56,137,35,207,0,60,191,90,61,136,105,210,16,27,4,171,57,10,61,123,40,189,28,34,207,236,22,45,223,10,189,160,10,6,8,42,134,72,206,61,3,1,7]);    let pubKeyBlob = { data: pubKeyArray };    let priKeyBlob = { data: priKeyArray };    let generator = cryptoFramework.createAsyKeyGenerator("ECC256");    generator.convertKey(pubKeyBlob, priKeyBlob, (error, data) => {        if (error) {            AlertDialog.show({message : "Convert keypair fail"});        }        AlertDialog.show({message : "Convert KeyPair success"});    })} 示例5：根据指定的对称密钥二进制数据，生成SymKey对象（场景2、3）  创建对称密钥生成器； 通过对称密钥生成器，根据指定的对称密钥二进制数据，生成SymKey对象； 获取算法库密钥对象的二进制数据；  以使用callback方式生成3DES密钥（3DES密钥只能为192位）为例： 已复制import cryptoFramework from '@ohos.security.cryptoFramework';
// 字节流以16进制输出function uint8ArrayToShowStr(uint8Array) {  return Array.prototype.map    .call(uint8Array, (x) => ('00' + x.toString(16)).slice(-2))    .join('');}
function genKeyMaterialBlob() {  let arr = [    0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,    0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,    0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72];    // keyLen = 192 (24 bytes)  let keyMaterial = new Uint8Array(arr);  return {data : keyMaterial};}
function testConvertAesKey() {  // 生成对称密钥生成器  let symKeyGenerator = cryptoFramework.createSymKeyGenerator('3DES192');  // 根据用户指定的数据，生成对称密钥  let keyMaterialBlob = genKeyMaterialBlob();  try {    symKeyGenerator.convertKey(keyMaterialBlob, (error, key) => {      if (error) {    // 业务逻辑执行错误通过callback的第一个参数返回错误信息        console.error(`convertKey error, ${error.code}, ${error.message}`);        return;      }      console.info(`key algName: ${key.algName}`);      console.info(`key format: ${key.format}`);      let encodedKey = key.getEncoded();    // 获取对称密钥的二进制数据，输出长度为192bit的字节流      console.info('key getEncoded hex: ' + uint8ArrayToShowStr(encodedKey.data));    })  } catch (error) {    // 参数检查的错误以同步的方式立即抛出异常    console.error(`convertKey failed, ${error.code}, ${error.message}`);    return;  }}   使用加解密操作 场景说明 在数据存储或传输场景中，可以使用加解密操作用于保证数据的机密性，防止敏感数据泄露。使用加解密操作中，典型的场景有：  使用对称密钥的加解密操作 使用非对称密钥的加解密操作  接口及参数说明 详细接口说明可参考API参考。 由于密码算法的复杂性，在选取不同规格和参数时，开发差异较大，无法通过代码示例一一列举，请仔细阅读API参考资料中的相关接口，确保使用正确。 以上场景设计的常用接口如下表所示：     实例名 接口名 描述    cryptoFramework createCipher(transformation : string) : Cipher 根据transformation设置的算法参数创建Cipher对象   Cipher init(opMode : CryptoMode, key : Key, params : ParamsSpec, callback : AsyncCallback<void>) : void 使用callback方式设置密钥并初始化Cipher对象   Cipher init(opMode : CryptoMode, key : Key, params : ParamsSpec) : Promise<void> 使用Promise方式设置密钥并初始化Cipher对象   Cipher update(data : DataBlob, callback : AsyncCallback<DataBlob>) : void 使用callback方式添加加解密数据   Cipher update(data : DataBlob) : Promise<DataBlob> 使用Promise方式添加加解密数据   Cipher doFinal(data : DataBlob, callback : AsyncCallback<DataBlob>) : void 使用callback方式结束对所有数据的加解密   Cipher doFinal(data : DataBlob) : Promise<DataBlob> 使用Promise方式结束对所有数据的加解密    开发步骤 示例1：使用对称密钥的加解密操作  创建对称密钥生成器。 通过密钥生成器生成对称密钥。 创建加解密生成器。 通过加解密生成器加密或解密数据。  以AES GCM以Promise方式加解密为例： 已复制import cryptoFramework from '@ohos.security.cryptoFramework';
var globalCipher;var globalGcmParams;var globalKey;var globalCipherText;
function genGcmParamsSpec() {  let arr = [0, 0, 0, 0 , 0, 0, 0, 0, 0, 0 , 0, 0]; // 12 bytes  let dataIv = new Uint8Array(arr);  let ivBlob = {data : dataIv};
  arr = [0, 0, 0, 0 , 0, 0, 0, 0]; // 8 bytes  let dataAad = new Uint8Array(arr);  let aadBlob = {data : dataAad};
  arr = [0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0]; // 16 bytes  let dataTag = new Uint8Array(arr);  let tagBlob = {data : dataTag};  // GCM的authTag在加密时从doFinal结果中获取，在解密时填入init函数的params参数中    let gcmParamsSpec = {iv : ivBlob, aad : aadBlob, authTag : tagBlob, algName : "GcmParamsSpec"};  return gcmParamsSpec;}
// 可理解的字符串转成字节流function stringToUint8Array(str) {  let arr = [];  for (let i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  return new Uint8Array(arr);}
// 字节流以16进制输出function uint8ArrayToShowStr(uint8Array) {  return Array.prototype.map    .call(uint8Array, (x) => ('00' + x.toString(16)).slice(-2))    .join('');}
// 字节流转成可理解的字符串function uint8ArrayToString(array) {  let arrayString = '';  for (let i = 0; i < array.length; i++) {    arrayString += String.fromCharCode(array[i]);  }  return arrayString;}
function genKeyMaterialBlob() {  let arr = [    0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,    0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,    0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72];    // keyLen = 192 (24 bytes)  let keyMaterial = new Uint8Array(arr);  return {data : keyMaterial};}
// AES GCM模式示例，自动生成密钥（promise写法）function testAesGcm() {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve('testAesGcm');    }, 10)  }).then(() => {    // 生成对称密钥生成器    let symAlgName = 'AES128';    let symKeyGenerator = cryptoFramework.createSymKeyGenerator(symAlgName);    if (symKeyGenerator == null) {      console.error('createSymKeyGenerator failed');      return;    }    console.info(`symKeyGenerator algName: ${symKeyGenerator.algName}`);    // 通过密钥生成器随机生成128位长度的对称密钥    let promiseSymKey = symKeyGenerator.generateSymKey();    // 构造参数    globalGcmParams = genGcmParamsSpec();
    // 生成加解密生成器    let cipherAlgName = 'AES128|GCM|PKCS7';    try {      globalCipher = cryptoFramework.createCipher(cipherAlgName);      console.info(`cipher algName: ${globalCipher.algName}`);    } catch (error) {      console.error(`createCipher failed, ${error.code}, ${error.message}`);      return;    }    return promiseSymKey;  }).then(key => {      let encodedKey = key.getEncoded();      console.info('key hex:' + uint8ArrayToShowStr(encodedKey.data));      globalKey = key;      return key;  }).then(key => {      // 初始化加解密操作环境:开始加密      let mode = cryptoFramework.CryptoMode.ENCRYPT_MODE;      let promiseInit = globalCipher.init(mode, key, globalGcmParams);    // init      return promiseInit;  }).then(() => {      let plainText = {data : stringToUint8Array('this is test!')};      let promiseUpdate = globalCipher.update(plainText);   // update      return promiseUpdate;  }).then(updateOutput => {      globalCipherText = updateOutput;      let promiseFinal = globalCipher.doFinal(null);    // doFinal      return promiseFinal;  }).then(authTag => {      // GCM模式需要从doFinal的输出中取出加密后的认证信息并填入globalGcmParams，在解密时传入init()      globalGcmParams.authTag = authTag;      return;  }).then(() => {      // 初始化加解密操作环境:开始解密      let mode = cryptoFramework.CryptoMode.DECRYPT_MODE;      let promiseInit = globalCipher.init(mode, globalKey, globalGcmParams);    // init      return promiseInit;  }).then(() => {      let promiseUpdate = globalCipher.update(globalCipherText);    // update      return promiseUpdate;  }).then(updateOutput => {      console.info('decrypt plainText: ' + uint8ArrayToString(updateOutput.data));      let promiseFinal = globalCipher.doFinal(null);    // doFinal      return promiseFinal;  }).then(finalOutput => {      if (finalOutput == null) {  // 使用finalOutput.data前，先判断结果是否为null          console.info('GCM finalOutput is null');      }  }).catch(error => {      console.error(`catch error, ${error.code}, ${error.message}`);  })} 以3DES ECB以callback方式加解密（采用已有数据生成密钥）为例： 已复制import cryptoFramework from '@ohos.security.cryptoFramework';
var globalCipher;var globalGcmParams;var globalKey;var globalCipherText;
// 可理解的字符串转成字节流function stringToUint8Array(str) {  let arr = [];  for (let i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  return new Uint8Array(arr);}
// 字节流以16进制输出function uint8ArrayToShowStr(uint8Array) {  return Array.prototype.map    .call(uint8Array, (x) => ('00' + x.toString(16)).slice(-2))    .join('');}
// 字节流转成可理解的字符串function uint8ArrayToString(array) {  let arrayString = '';  for (let i = 0; i < array.length; i++) {    arrayString += String.fromCharCode(array[i]);  }  return arrayString;}
function genKeyMaterialBlob() {  let arr = [    0xba, 0x3d, 0xc2, 0x71, 0x21, 0x1e, 0x30, 0x56,    0xad, 0x47, 0xfc, 0x5a, 0x46, 0x39, 0xee, 0x7c,    0xba, 0x3b, 0xc2, 0x71, 0xab, 0xa0, 0x30, 0x72];    // keyLen = 192 (24 bytes)  let keyMaterial = new Uint8Array(arr);  return {data : keyMaterial};}
// 3DES ECB模式示例，采用已有数据生成密钥（callback写法）function test3DesEcb() {  // 生成对称密钥生成器  let symAlgName = '3DES192';  let symKeyGenerator = cryptoFramework.createSymKeyGenerator(symAlgName);  if (symKeyGenerator == null) {    console.error('createSymKeyGenerator failed');    return;  }  console.info(`symKeyGenerator algName: ${symKeyGenerator.algName}`);
  // 生成加解密生成器  let cipherAlgName = '3DES192|ECB|PKCS7';  try {    globalCipher = cryptoFramework.createCipher(cipherAlgName);    console.info(`cipher algName: ${globalCipher.algName}`);  } catch (error) {    console.error(`createCipher failed, ${error.code}, ${error.message}`);    return;  }
  // 根据指定的数据，生成对称密钥  let keyMaterialBlob = genKeyMaterialBlob();  try {    symKeyGenerator.convertKey(keyMaterialBlob, (error, key) => {      if (error) {        console.error(`convertKey error, ${error.code}, ${error.message}`);        return;      }      console.info(`key algName: ${key.algName}`);      console.info(`key format: ${key.format}`);      let encodedKey = key.getEncoded();      console.info('key getEncoded hex: ' + uint8ArrayToShowStr(encodedKey.data));      globalKey = key;
      // 初始化加解密操作环境:开始加密      let mode = cryptoFramework.CryptoMode.ENCRYPT_MODE;      // init      globalCipher.init(mode, key, null, (err, ) => {        let plainText = {data : stringToUint8Array('this is test!')};        // update        globalCipher.update(plainText, (err, updateOutput) => {          globalCipherText = updateOutput;          //doFinal          globalCipher.doFinal(null, (err, finalOutput) => {            if (error) {              console.error(`doFinal error, ${error.code}, ${error.message}`);              return;            }            if (finalOutput != null) {              globalCipherText = Array.from(globalCipherText.data);              finalOutput = Array.from(finalOutput.data);              globalCipherText = globalCipherText.concat(finalOutput);              globalCipherText = new Uint8Array(globalCipherText);              globalCipherText = {data : globalCipherText};            }            // 初始化加解密操作环境:开始解密            let mode = cryptoFramework.CryptoMode.DECRYPT_MODE;            // init            globalCipher.init(mode, globalKey, null, (err, ) => {              // update              globalCipher.update(globalCipherText, (err, updateOutput) => {                console.info('decrypt plainText: ' + uint8ArrayToString(updateOutput.data));                // doFinal                globalCipher.doFinal(null, (error, finalOutput) => {                  if (finalOutput != null) {  // 使用finalOutput.data前，先判断结果是否为null                    console.info("decrypt plainText:" + uint8ArrayToString(finalOutput.data));                  }                })              })            })          })        })      })    })  } catch (error) {    console.error(`convertKey failed, ${error.code}, ${error.message}`);    return;  }} 以AES GCM以promise方式，分段update()实现加解密为例： 已复制import cryptoFramework from '@ohos.security.cryptoFramework';
var globalCipher;var globalGcmParams;var globalKey;var globalCipherText;var globalPlainText;
function genGcmParamsSpec() {  let arr = [0, 0, 0, 0 , 0, 0, 0, 0, 0, 0 , 0, 0]; // 12 bytes  let dataIv = new Uint8Array(arr);  let ivBlob = {data : dataIv};
  arr = [0, 0, 0, 0 , 0, 0, 0, 0]; // 8 bytes  let dataAad = new Uint8Array(arr);  let aadBlob = {data : dataAad};
  arr = [0, 0, 0, 0 , 0, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0]; // 16 bytes  let dataTag = new Uint8Array(arr);  let tagBlob = {data : dataTag};  let gcmParamsSpec = {iv : ivBlob, aad : aadBlob, authTag : tagBlob, algName : "GcmParamsSpec"};  return gcmParamsSpec;}
// 字节流以16进制输出function uint8ArrayToShowStr(uint8Array) {  return Array.prototype.map    .call(uint8Array, (x) => ('00' + x.toString(16)).slice(-2))    .join('');}
// 字节流转成可理解的字符串function uint8ArrayToString(array) {  let arrayString = '';  for (let i = 0; i < array.length; i++) {    arrayString += String.fromCharCode(array[i]);  }  return arrayString;}
// 算法库不限定update的次数和每次加解密的数据量，业务可根据自身内存情况对明文/密文进行多次分段。function testAesMultiUpdate() {  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve('testAesMultiUpdate');    }, 10)  }).then(() => {    // 生成对称密钥生成器    let symAlgName = 'AES128';    let symKeyGenerator = cryptoFramework.createSymKeyGenerator(symAlgName);    if (symKeyGenerator == null) {      console.error('createSymKeyGenerator failed');      return;    }    console.info(`symKeyGenerator algName: ${symKeyGenerator.algName}`);    // 通过密钥生成器随机生成128位长度的对称密钥    let promiseSymKey = symKeyGenerator.generateSymKey();    // 构造参数    globalGcmParams = genGcmParamsSpec();
    // 生成加解密生成器    let cipherAlgName = 'AES128|GCM|PKCS7';    try {      globalCipher = cryptoFramework.createCipher(cipherAlgName);      console.info(`cipher algName: ${globalCipher.algName}`);    } catch (error) {      console.error(`createCipher failed, ${error.code}, ${error.message}`);      return;    }    return promiseSymKey;  }).then(key => {    let encodedKey = key.getEncoded();    console.info('key hex:' + uint8ArrayToShowStr(encodedKey.data));    globalKey = key;    return key;  }).then(key => {    // 初始化加解密操作环境:开始加密    let mode = cryptoFramework.CryptoMode.ENCRYPT_MODE;    let promiseInit = globalCipher.init(mode, key, globalGcmParams);    // init    return promiseInit;  }).then(async () => {    let plainText = "aaaaa.....bbbbb.....ccccc.....ddddd.....eee";   // 假设明文总共43字节    let messageArr = [];    let updateLength = 20;  // 假设每20字节分段update一次    globalCipherText = [];        for (let i = 0; i <= plainText.length; i++) {      if ((i % updateLength == 0 || i == plainText.length) && messageArr.length != 0) {        let message = new Uint8Array(messageArr);        let messageBlob = { data : message };        let updateOutput = await globalCipher.update(messageBlob);    // 分段update        // 把update的结果拼接起来，得到密文（有些情况下还需拼接doFinal的结果，这取决于分组模式        // 和填充模式，本例中GCM模式的doFinal结果只包含authTag而不含密文，所以不需要拼接）        globalCipherText = globalCipherText.concat(Array.from(updateOutput.data));        messageArr = [];      }      if (i < plainText.length) {        messageArr.push(plainText.charCodeAt(i));      }    }    return;  }).then(() => {    let promiseFinal = globalCipher.doFinal(null);    // doFinal    return promiseFinal;  }).then(authTag => {    // 获取加密后的认证信息    globalGcmParams.authTag = authTag;    return;  }).then(() => {    // 初始化加解密操作环境:开始解密    let mode = cryptoFramework.CryptoMode.DECRYPT_MODE;    let promiseInit = globalCipher.init(mode, globalKey, globalGcmParams);    // init    return promiseInit;  }).then(async () => {    let updateLength = 20;    let updateTimes = Math.ceil(globalCipherText.length / updateLength);  // 上取整    globalPlainText = "";    for (let i = 0; i < updateTimes; i++) {      let messageArr = globalCipherText.slice(i * updateLength, (i + 1) * updateLength);      let message = new Uint8Array(messageArr);      let messageBlob = { data : message };      let updateOutput = await globalCipher.update(messageBlob);    // 分段update      globalPlainText += uint8ArrayToString(updateOutput.data);     // 恢复出原始明文    }    return;  }).then(() => {    let promiseFinal = globalCipher.doFinal(null);      // doFinal    return promiseFinal;  }).then(finalOutput => {    if (finalOutput == null) {      console.info('GCM finalOutput is null');    }    console.info(`decrypt output: ${globalPlainText}`);  }).catch(error => {      console.error(`catch error, ${error.code}, ${error.message}`);  })} 示例2：使用非对称密钥的加解密操作  生成RSA密钥。通过createAsyKeyGenerator接口创建AsyKeyGenerator对象，并生成RSA非对称密钥。 生成Cipher对象。通过createCipher接口创建Cipher对象，执行初始化操作，设置密钥及加解密模式。 执行加解密操作。通过调用Cipher对象提供的doFinal接口，执行加密操作生成密文或执行解密操作生成明文。  已复制import cryptoFramework from "@ohos.security.cryptoFramework"
let plan = "This is cipher test.";
function stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  var tmpArray = new Uint8Array(arr);  return tmpArray;}
function encryptMessageProMise() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  let cipher = cryptoFramework.createCipher("RSA1024|PKCS1");  let keyGenPromise = rsaGenerator.generateKeyPair();  keyGenPromise.then(rsaKeyPair => {    let pubKey = rsaKeyPair.pubKey;    return cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, pubKey, null);  }).then(() => {    let input = { data : stringToUint8Array(plan) };    return cipher.doFinal(input);  }).then(dataBlob => {    console.info("EncryptOutPut is " + dataBlob.data);  });}
function encryptMessageCallback() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  let cipher = cryptoFramework.createCipher("RSA1024|PKCS1");  rsaGenerator.generateKeyPair(function (err, keyPair) {    let pubKey = keyPair.pubKey;    cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, pubKey, null, function (err, data) {      let input = {data : stringToUint8Array(plan) };      cipher.doFinal(input, function (err, data) {        console.info("EncryptOutPut is " + data.data);      })    })  })}
function decryptMessageProMise() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  let cipher = cryptoFramework.createCipher("RSA1024|PKCS1");  let decoder = cryptoFramework.createCipher("RSA1024|PKCS1");  let keyGenPromise = rsaGenerator.generateKeyPair();  let keyPair;  let cipherDataBlob;  let input = { data : stringToUint8Array(plan) };  keyGenPromise.then(rsaKeyPair => {    keyPair = rsaKeyPair;    return cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyPair.pubKey, null);  }).then(() => {    return cipher.doFinal(input);  }).then(dataBlob => {    console.info("EncryptOutPut is " + dataBlob.data);    AlertDialog.show({message : "output" + dataBlob.data});    cipherDataBlob = dataBlob;    return decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, keyPair.priKey, null);  }).then(() => {    return decoder.doFinal(cipherDataBlob);  }).then(decodeData => {    if (decodeData.data.toString() === input.data.toString()) {      AlertDialog.show({message : "decrypt success"});      return;    }    AlertDialog.show({message : "decrypt fail"});  });}
function decryptMessageCallback() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  let cipher = cryptoFramework.createCipher("RSA1024|PKCS1");  let decoder = cryptoFramework.createCipher("RSA1024|PKCS1");  let plainText = "this is cipher text";  let input = {data : stringToUint8Array(plainText) };  let cipherData;  let keyPair;  rsaGenerator.generateKeyPair(function (err, newKeyPair) {    keyPair = newKeyPair;    cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, keyPair.pubKey, null, function (err, data) {      cipher.doFinal(input, function (err, data) {        AlertDialog.show({ message : "EncryptOutPut is " + data.data} );        cipherData = data;        decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, keyPair.priKey, null, function (err, data) {          decoder.doFinal(cipherData, function (err, data) {            if (input.data.toString() === data.data.toString()) {              AlertDialog.show({ message : "decrype success"} );              return;            }            AlertDialog.show({ message : "decrype fail"} );          });        });      });    });  });} 以RSA非对称加解密（多次调用doFinal实现分段）为例： 已复制import cryptoFramework from "@ohos.security.cryptoFramework"
function stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  var tmpArray = new Uint8Array(arr);  return tmpArray;}
// 字节流转成可理解的字符串function uint8ArrayToString(array) {  let arrayString = '';  for (let i = 0; i < array.length; i++) {    arrayString += String.fromCharCode(array[i]);  }  return arrayString;}
function encryptLongMessagePromise() {  let globalPlainText = "This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!";  let globalCipherOutput;  let globalDecodeOutput;  var globalKeyPair;  let plainTextSplitLen = 64; // RSA每次加解密允许的原文长度大小与密钥位数和填充模式等有关，详细规格内容见overview文档  let cipherTextSplitLen = 128; // RSA密钥每次加密生成的密文数据长度计算方式：密钥位数/8  let keyGenName = "RSA1024";  let cipherAlgName = "RSA1024|PKCS1";  let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(keyGenName); // 创建非对称密钥生成器对象  let cipher = cryptoFramework.createCipher(cipherAlgName); // 创建加密Cipher对象  let decoder = cryptoFramework.createCipher(cipherAlgName); // 创建解密Decoder对象  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("testRsaMultiDoFinal");    }, 10);  }).then(() => {    return asyKeyGenerator.generateKeyPair(); // 生成rsa密钥  }).then(keyPair => {    globalKeyPair = keyPair; // 保存到密钥对全局变量    return cipher.init(cryptoFramework.CryptoMode.ENCRYPT_MODE, globalKeyPair.pubKey, null);  }).then(async () => {    globalCipherOutput = [];    // 将原文按64字符进行拆分，循环调用doFinal进行加密，使用1024bit密钥时，每次加密生成128B长度的密文    for (let i = 0; i < (globalPlainText.length / plainTextSplitLen); i++) {      let tempStr = globalPlainText.substr(i * plainTextSplitLen, plainTextSplitLen);      let tempBlob = { data : stringToUint8Array(tempStr) };      let tempCipherOutput = await cipher.doFinal(tempBlob);      globalCipherOutput = globalCipherOutput.concat(Array.from(tempCipherOutput.data));    }    console.info(`globalCipherOutput len is ${globalCipherOutput.length}, data is: ${globalCipherOutput.toString()}`);    return;  }).then(() =>{    return decoder.init(cryptoFramework.CryptoMode.DECRYPT_MODE, globalKeyPair.priKey, null);  }).then(async() => {    globalDecodeOutput = [];    // 将密文按128B进行拆分解密，得到原文后进行拼接    for (let i = 0; i < (globalCipherOutput.length / cipherTextSplitLen); i++) {      let tempBlobData = globalCipherOutput.slice(i * cipherTextSplitLen, (i + 1) * cipherTextSplitLen);      let message = new Uint8Array(tempBlobData);      let tempBlob = { data : message };      let tempDecodeOutput = await decoder.doFinal(tempBlob);      globalDecodeOutput += uint8ArrayToString(tempDecodeOutput.data);    }    if (globalDecodeOutput === globalPlainText) {      console.info(`encode and decode success`);    } else {      console.info(`encode and decode error`);    }    return;  }).catch(error => {    console.error(`catch error, ${error.code}, ${error.message}`);  })} 说明  使用RSA加解密时，Cipher对象不可重复调用init方法初始化，在创建了一个加密Cipher对象后，如果要进行解密，则需要重新创建另一个Cipher对象执行解密操作。 RSA加密有长度限制，允许加密明文的最大长度见加解密算法库框架概述中的基本概念章节。 RSA解密每次允许解密的密文长度为，RSA密钥的位数/8。    使用签名验签操作 场景说明 当需要判断接收的数据是否被篡改且是否为指定对象发送的数据时，可以使用签名验签操作。使用签名验签操作中，典型的场景有：  使用RSA签名验签操作 使用ECC签名验签操作  接口及参数说明 详细接口说明可参考API参考。 由于密码算法的复杂性，在选取不同规格和参数时，开发差异较大，无法通过代码示例一一列举，请仔细阅读API参考资料中的相关接口，确保使用正确。     实例名 接口名 描述    cryptoFramework createSign(algName : string) : Sign 根据String设置的参数创建Sign对象   Sign init(priKey : PriKey, callback : AsyncCallback<void>) : void 使用callback方式设置密钥并初始化Sign对象   Sign init(priKey : PriKey) : Promise<void> 使用Promise方式设置密钥并初始化Sign对象   Sign update(data : DataBlob, callback : AsyncCallback<void>) : void 使用callback方式添加签名数据   Sign update(data : DataBlob) : Promise<void> 用Promise方式添加签名数据   Sign sign(data : DataBlob, callback : AsyncCallback<DataBlob>) : void 使用callback方式签名所有数据   Sign sign(data : DataBlob) : Promise<DataBlob> 使用Promise方式签名所有数据   cryptoFramework function createVerify(algName : string) : Verify 根据String设置的参数创建Verify对象   Verify init(priKey : PriKey, callback : AsyncCallback<void>) : void 使用callback方式设置密钥并初始化Verify对象   Verify init(priKey : PriKey) : Promise<void> 使用Promise方式设置密钥并初始化Verify对象   Verify update(data : DataBlob, callback : AsyncCallback<void>) : void 使用callback方式添加验签数据   Verify update(data : DataBlob) : Promise<void> 用Promise方式添加验签数据   Verify verify(data : DataBlob, signatureData : DataBlob, callback : AsyncCallback<boolean>) : void 使用callback方式验签所有数据   Verify verify(data : DataBlob, signatureData : DataBlob) : Promise<boolean> 使用Promise方式验签所有数据    开发步骤 示例1：使用RSA签名验签操作  生成RSA密钥。通过createAsyKeyGenerator接口创建AsyKeyGenerator对象，并生成RSA非对称密钥。 生成Sign对象。通过createSign接口创建Sign对象，执行初始化操作并设置签名私钥。 执行签名操作。通过Sign类提供的update接口，添加签名数据，并调用sign接口生成数据的签名。 生成Verify对象。通过createVerify接口创建Verify对象，执行初始化操作并设置验签公钥。 执行验签操作。通过Verify类提供的update接口，添加签名数据，并调用verify接口传入签名进行验签。  已复制import cryptoFramework from "@ohos.security.cryptoFramework"
function stringToUint8Array(str) {    var arr = [];    for (var i = 0, j = str.length; i < j; ++i) {        arr.push(str.charCodeAt(i));    }    var tmpArray = new Uint8Array(arr);    return tmpArray;}
let globalKeyPair;let SignMessageBlob;let plan1 = "This is Sign test plan1";let plan2 = "This is Sign test plan1";let input1 = { data : stringToUint8Array(plan1) };let input2 = { data : stringToUint8Array(plan2) };
function signMessagePromise() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  let signer = cryptoFramework.createSign("RSA1024|PKCS1|SHA256");  let keyGenPromise = rsaGenerator.generateKeyPair();  keyGenPromise.then( keyPair => {    globalKeyPair = keyPair;    let priKey = globalKeyPair.priKey;    return signer.init(priKey);  }).then(() => {    return signer.update(input1);  }).then(() => {    return signer.sign(input2);  }).then(dataBlob => {    SignMessageBlob = dataBlob;    console.info("sign output is " + SignMessageBlob.data);  });}
function verifyMessagePromise() {  let verifyer = cryptoFramework.createVerify("RSA1024|PKCS1|SHA256");  let verifyInitPromise = verifyer.init(globalKeyPair.pubKey);  verifyInitPromise.then(() => {    return verifyer.update(input1);  }).then(() => {    return verifyer.verify(input2, SignMessageBlob);  }).then(res => {    console.log("Verify result is " + res);  });}
function signMessageCallback() {  let rsaGenerator = cryptoFramework.createAsyKeyGenerator("RSA1024|PRIMES_2");  let signer = cryptoFramework.createSign("RSA1024|PKCS1|SHA256");  rsaGenerator.generateKeyPair(function (err, keyPair) {    globalKeyPair = keyPair;    let priKey = globalKeyPair.priKey;    signer.init(priKey, function (err, data) {      signer.update(input1, function (err, data) {        signer.sign(input2, function (err, data) {          SignMessageBlob = data;          console.info("sign output is " + SignMessageBlob.data);        });      });    });  });}
function verifyMessageCallback() {  let verifyer = cryptoFramework.createVerify("RSA1024|PKCS1|SHA256");  verifyer.init(globalKeyPair.pubKey, function (err, data) {    verifyer.update(input1, function(err, data) {      verifyer.verify(input2, SignMessageBlob, function(err, data) {        console.info("verify result is " + data);      });    });  })} 示例2：使用ECDSA操作 1. 生成ECC密钥。通过createAsyKeyGenerator接口创建AsyKeyGenerator对象，并生成ECC非对称密钥。 2. 生成Sign对象。通过createSign接口创建Sign对象，执行初始化操作并设置签名私钥。 3. 执行签名操作。通过Sign类提供的update接口，添加签名数据，并调用doFinal接口生成数据的签名。 4. 生成Verify对象。通过createVerify接口创建Verify对象，执行初始化操作并设置验签公钥。 5. 执行验签操作。通过Verify类提供的update接口，添加签名数据，并调用doFinal接口传入签名进行验签。 已复制import cryptoFramework from "@ohos.security.cryptoFramework"
function stringToUint8Array(str) {    var arr = [];    for (var i = 0, j = str.length; i < j; ++i) {        arr.push(str.charCodeAt(i));    }    var tmpArray = new Uint8Array(arr);    return tmpArray;}
let globalKeyPair;let SignMessageBlob;let plan1 = "This is Sign test plan1";let plan2 = "This is Sign test plan1";let input1 = { data : stringToUint8Array(plan1) };let input2 = { data : stringToUint8Array(plan2) };
function signMessagePromise() {  let eccGenerator = cryptoFramework.createAsyKeyGenerator("ECC256");  let signer = cryptoFramework.createSign("ECC256|SHA256");  let keyGenPromise = eccGenerator.generateKeyPair();  keyGenPromise.then( keyPair => {    globalKeyPair = keyPair;    let priKey = globalKeyPair.priKey;    return signer.init(priKey);  }).then(() => {    return signer.update(input1);  }).then(() => {    return signer.sign(input2);  }).then(dataBlob => {    SignMessageBlob = dataBlob;    console.info("sign output is " + SignMessageBlob.data);  });}
function verifyMessagePromise() {  let verifyer = cryptoFramework.createVerify("ECC256|SHA256");  let verifyInitPromise = verifyer.init(globalKeyPair.pubKey);  verifyInitPromise.then(() => {    return verifyer.update(input1);  }).then(() => {    return verifyer.verify(input2, SignMessageBlob);  }).then(res => {    console.log("Verify result is " + res);  });}
function signMessageCallback() {  let eccGenerator = cryptoFramework.createAsyKeyGenerator("ECC256");  let signer = cryptoFramework.createSign("ECC256|SHA256");  eccGenerator.generateKeyPair(function (err, keyPair) {    globalKeyPair = keyPair;    let priKey = globalKeyPair.priKey;    signer.init(priKey, function (err, data) {      signer.update(input1, function (err, data) {        signer.sign(input2, function (err, data) {          SignMessageBlob = data;          console.info("sign output is " + SignMessageBlob.data);        });      });    });  });}
function verifyMessageCallback() {  let verifyer = cryptoFramework.createVerify("ECC256|SHA256");  verifyer.init(globalKeyPair.pubKey, function (err, data) {    verifyer.update(input1, function(err, data) {      verifyer.verify(input2, SignMessageBlob, function(err, data) {        console.info("verify result is " + data);      });    });  })} 以执行签名、验签操作时多次调用update实现分段为例： 已复制import cryptoFramework from "@ohos.security.cryptoFramework"
function stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  var tmpArray = new Uint8Array(arr);  return tmpArray;}
function signLongMessagePromise() {  let globalPlainText = "This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!" +  "This is a long plainTest! This is a long plainTest! This is a long plainTest! This is a long plainTest!";  let globalSignData;  let textSplitLen = 64; // 自定义的数据拆分长度  let keyGenName = "RSA1024";  let cipherAlgName = "RSA1024|PKCS1|SHA256";  let globalKeyPair;  let asyKeyGenerator = cryptoFramework.createAsyKeyGenerator(keyGenName); // 创建非对称密钥生成器对象  let signer = cryptoFramework.createSign(cipherAlgName); // 创建加密Cipher对象  let verifier = cryptoFramework.createVerify(cipherAlgName); // 创建解密Decoder对象  return new Promise((resolve, reject) => {    setTimeout(() => {      resolve("testRsaMultiUpdate");    }, 10);  }).then(() => {    return asyKeyGenerator.generateKeyPair(); // 生成rsa密钥  }).then(keyPair => {    globalKeyPair = keyPair; // 保存到密钥对全局变量    return signer.init(globalKeyPair.priKey);  }).then(async () => {    // 当原文过大时，可将原文按理想长度进行拆分，循环调用update添加原文    for (let i = 0; i < (globalPlainText.length / textSplitLen); i++) {      let tempStr = globalPlainText.substr(i * textSplitLen, textSplitLen);      let tempBlob = { data : stringToUint8Array(tempStr) };      await signer.update(tempBlob);    }    return signer.sign(null);  }).then(data =>{    globalSignData = data.data;    console.info(`globalSignOutput len is ${globalSignData.length}, data is: ${globalSignData.toString()}`);    return verifier.init(globalKeyPair.pubKey);  }).then(async() => {    // 将密文按128B进行拆分解密，得到原文后进行拼接    for (let i = 0; i < (globalPlainText.length / textSplitLen); i++) {      let tempData = globalPlainText.slice(i * textSplitLen, (i + 1) * textSplitLen);      let tempBlob = { data : stringToUint8Array(tempData) };      await verifier.update(tempBlob);    }    return verifier.verify(null, { data : globalSignData});  }).then(res => {    console.info(`verify res is ${res}`);  }).catch(error => {    console.error(`catch error, ${error.code}, ${error.message}`);  })}   使用摘要操作 场景说明 用户指定摘要算法（如SHA256）生成Md实例，并输入单段或多段需要摘要的信息，进行摘要计算更新，并返回消息摘要计算结果，在指定算法后可获取当前算法名与摘要计算长度（字节） 使用摘要操作的主要场景为： 用户指定摘要算法（如SHA256）生成Md实例，并输入单段或多段需要摘要的信息，进行摘要计算更新，并返回消息摘要计算结果，在指定算法后可获取当前算法名与摘要计算长度（字节） 接口及参数说明 详细接口说明可参考API参考。     实例名 接口名 描述    cryptoFramework function createMd(algName : string) : Md; 指定摘要算法，生成摘要操作实例Md   Md update(input : DataBlob, callback : AsyncCallback<void>) : void; 接受用户输入数据，通过Callback的方式，异步更新摘要   Md update(input : DataBlob) : Promise<void>; 接受用户输入数据，通过Promise的方式，异步更新摘要   Md digest(callback : AsyncCallback<DataBlob>) : void; 通过Callback的方式，返回结果   Md digest() : Promise<DataBlob>; 通过Promise的方式，返回结果   Md getMdLength() : number; 获取摘要的长度（由指定的摘要算法决定）   Md readonly algName : string; 获取当前设置的摘要算法名    开发步骤  设置算法，通过接口createMd生成摘要操作实例 接受用户数据，通过接口update，更新摘要，此步骤可重复 通过接口digest，返回摘要计算结果 获取当前摘要算法名与摘要计算长度  已复制import cryptoFramework from "@ohos.security.cryptoFramework"
// turn string into uint8Arrfunction stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {      arr.push(str.charCodeAt(i));  }  var tmpUint8Array = new Uint8Array(arr);  return tmpUint8Array;}
// generate dataBlob with given lengthfunction GenDataBlob(dataBlobLen) {  var dataBlob;  if (dataBlobLen == 12) {      dataBlob = {data: stringToUint8Array("my test data")};  } else {      console.error("GenDataBlob: dataBlobLen is invalid");      dataBlob = {data: stringToUint8Array("my test data")};  }  return dataBlob;}
// md with promise asyncfunction doMdByPromise(algName) {  var md;  try {    md = cryptoFramework.createMd(algName);  } catch (error) {    console.error("[Promise]: error code: " + error.code + ", message is: " + error.message);  }  console.error("[Promise]: Md algName is: " + md.algName);  // 初次update  var promiseMdUpdate = md.update(GenDataBlob(12));  promiseMdUpdate.then(() => {    // 可根据情况进行多次update    promiseMdUpdate = md.update(GenDataBlob(12));    return promiseMdUpdate;  }).then(mdOutput => {    var PromiseMdDigest = md.digest();    return PromiseMdDigest;  }).then(mdOutput => {    console.error("[Promise]: MD result: " + mdOutput.data);    var mdLen = md.getMdLength();    console.error("[Promise]: MD len: " + mdLen);  }).catch(error => {    console.error("[Promise]: error: " + error.message);  });}
// md with callback asyncfunction doMdByCallback(algName) {  var md;  try {    md = cryptoFramework.createMd(algName);  } catch (error) {    console.error("[Callback]: error code: " + error.code + ", message is: " + error.message);  }  console.error("[Callback]: Md algName is: " + md.algName);  // 初次update  md.update(GenDataBlob(12), (err,) => {    if (err) {      console.error("[Callback]: err: " + err.code);    }    // 可根据情况进行多次update    md.update(GenDataBlob(12), (err1,) => {      if (err1) {        console.error("[Callback]: err: " + err1.code);      }      md.digest((err2, mdOutput) => {        if (err2) {          console.error("[Callback]: err: " + err2.code);        } else {          console.error("[Callback]: MD result: " + mdOutput.data);          var mdLen = md.getMdLength();          console.error("[Callback]: MD len: " + mdLen);        }      });    });  });} 以MD更新时多次调用update实现分段为例： 已复制import cryptoFramework from "@ohos.security.cryptoFramework"
async function updateData(index, obj, data) {  console.error("update " + (index + 1) + " MB data...");  return obj.update(data);}
function stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  var tmpUint8Array = new Uint8Array(arr);  return tmpUint8Array;}
function GenDataBlob(dataBlobLen) {  var dataBlob;  if (dataBlobLen == 12) {    dataBlob = {data: stringToUint8Array("my test data")};  } else {    console.error("GenDataBlob: dataBlobLen is invalid");    dataBlob = {data: stringToUint8Array("my test data")};  }  return dataBlob;}
function LoopMdPromise(algName, loopSize) {  var md;  try {    md = cryptoFramework.createMd(algName);  } catch (error) {    console.error("[Promise]: error code: " + error.code + ", message is: " + error.message);    return;  }  console.error("[Promise]: Md algName is: " + md.algName);  var promiseMdUpdate = md.update(GenDataBlob(12));  promiseMdUpdate.then(() => {    var PromiseMdDigest = md.digest();    return PromiseMdDigest;  }).then(async () => {    for (var i = 0; i < loopSize; i++) {      await updateData(i, md, GenDataBlob(12));    }    var PromiseMdDigest = md.digest();    return PromiseMdDigest;  }).then(mdOutput => {    console.error("[Promise]: MD result: " + mdOutput.data);    var mdLen = md.getMdLength();    console.error("[Promise]: MD len: " + mdLen);  }).catch(error => {    console.error("[Promise]: error: " + error.message);  });}   使用密钥协商操作 场景说明 使用密钥协商操作中，典型的场景有： 通信双方可以在一个公开的信道上通过相互传送一些消息，共同建立一个安全的共享秘密密钥。 接口及参数说明 详细接口说明可参考API参考。     实例名 接口名 描述    cryptoFramework createKeyAgreement(algName : string) : KeyAgreement 根据String设置的参数创建KeyAgreement对象   KeyAgreement generateSecret(priKey : PriKey, pubKey : PubKey, callback : AsyncCallback<DataBlob>) : void 使用callback方式进行密钥协商   KeyAgreement generateSecret(priKey : PriKey, pubKey : PubKey) : Promise<DataBlob> 使用Promise方式进行密钥协商    开发步骤  通过createKeyAgreement接口创建KeyAgreement对象，用于后续的密钥协商操作。 调用KeyAgreement对象提供的generateSecret方法，传入对端的ECC公钥对象，以及本地生成的ECC私钥对象。  已复制import cryptoFramework from "@ohos.security.cryptoFramework"
let globalSelfPriKey;let globalPeerPubKey;
function ecdhPromise() {  let peerPubKeyArray = new Uint8Array([48,89,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,3,66,0,4,83,96,142,9,86,214,126,106,247,233,92,125,4,128,138,105,246,162,215,71,81,58,202,121,26,105,211,55,130,45,236,143,55,16,248,75,167,160,167,106,2,152,243,44,68,66,0,167,99,92,235,215,159,239,28,106,124,171,34,145,124,174,57,92]);  let peerPubKeyBlob = { data: peerPubKeyArray };  let eccGenerator = cryptoFramework.createAsyKeyGenerator("ECC256");  let eccKeyAgreement = cryptoFramework.createKeyAgreement("ECC256");  eccGenerator.convertKey(peerPubKeyBlob, null).then((peerKeyPair) => {    globalPeerPubKey = peerKeyPair.pubKey;    return eccGenerator.generateKeyPair();  }).then((keyPair) => {    globalSelfPriKey = keyPair.priKey;    return eccKeyAgreement.generateSecret(globalSelfPriKey, globalPeerPubKey);  }).then((secret) => {    console.info("ecdh promise output is " + secret.data);  }).catch((error) => {    console.error("ecdh error.");  });}
function ecdhCallback() {  let peerPubKeyArray = new Uint8Array([48,89,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,3,66,0,4,83,96,142,9,86,214,126,106,247,233,92,125,4,128,138,105,246,162,215,71,81,58,202,121,26,105,211,55,130,45,236,143,55,16,248,75,167,160,167,106,2,152,243,44,68,66,0,167,99,92,235,215,159,239,28,106,124,171,34,145,124,174,57,92]);  let peerPubKeyBlob = { data: peerPubKeyArray };  let eccGenerator = cryptoFramework.createAsyKeyGenerator("ECC256");  let eccKeyAgreement = cryptoFramework.createKeyAgreement("ECC256");  eccGenerator.convertKey(peerPubKeyBlob, null, function (err, peerKeyPair) {    globalPeerPubKey = peerKeyPair.pubKey;    eccGenerator.generateKeyPair(function (err, keyPair) {      globalSelfPriKey = keyPair.priKey;      eccKeyAgreement.generateSecret(globalSelfPriKey, globalPeerPubKey, function (err, secret) {        if (err) {          console.error("ecdh error.");          return;        }        console.info("ecdh callback output is " + secret.data);      });    });  })}   使用消息认证码操作 场景说明 消息认证码操作主要应用于身份认证的场景： Mac(message authentication code)可以对消息进行完整性校验，通过使用双方共享的密钥，识别出信息伪装篡改等行为 用户指定摘要算法（如SHA256）生成消息认证码Mac实例，输入对称密钥初始化Mac，并传入单段或多段需要摘要的信息，进行消息认证码计算，并获取消息认证码计算结果，在指定算法后可获取当前算法名与消息认证码计算长度（字节）。 接口及参数说明 详细接口说明可参考API参考。     实例名 接口名 描述    cryptoFramework function createMac(algName : string) : Mac; 指定摘要算法，生成消息认证码实例Mac   Mac init(key : SymKey, callback : AsyncCallback<void>) : void; 接收输入对称密钥，通过Callback的方式，异步初始化MAC   Mac init(key : SymKey) : Promise<void>; 接收输入对称密钥，通过Promise的方式，异步初始化MAC   Mac update(input : DataBlob, callback : AsyncCallback<void>) : void; 接受输入数据，通过Callback的方式，异步更新MAC   Mac update(input : DataBlob) : Promise<void>; 接受输入数据，通过Promise的方式，异步更新MAC   Mac doFinal(callback : AsyncCallback<DataBlob>) : void; 通过Callback的方式，返回MAC计算结果   Mac doFinal() : Promise<DataBlob>; 通过Promise的方式，返回MAC计算结果   Mac getMacLength() : number; 获取MAC的长度（由指定的摘要算法决定）   Mac readonly algName : string; 获取当前设置的摘要算法名    开发步骤  设置算法，通过接口createMac生成消息认证码操作实例 接受输入对称密钥，通过接口init，初始化Mac 接受数据，通过接口update，更新Mac，此步骤可重复 通过接口doFinal，返回Mac计算结果 获取当前摘要算法名与Mac计算长度  已复制import cryptoFramework from "@ohos.security.cryptoFramework"
// turn string into uint8Arrfunction stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {      arr.push(str.charCodeAt(i));  }  var tmpUint8Array = new Uint8Array(arr);  return tmpUint8Array;}
// generate blob with this funcfunction GenDataBlob(dataBlobLen) {  var dataBlob;  if (dataBlobLen == 12) {      dataBlob = {data: stringToUint8Array("my test data")};  } else {      console.error("GenDataBlob: dataBlobLen is invalid");      dataBlob = {data: stringToUint8Array("my test data")};  }  return dataBlob;}
function doHmacByPromise(algName) {  var mac;  try {    mac = cryptoFramework.createMac(algName);  } catch (error) {    console.error("[Promise]: error code: " + error.code + ", message is: " + error.message);  }  console.error("[Promise]: Mac algName is: " + mac.algName);  var KeyBlob = {    data : stringToUint8Array("12345678abcdefgh")  }  var symKeyGenerator = cryptoFramework.createSymKeyGenerator("AES128");  var promiseConvertKey = symKeyGenerator.convertKey(KeyBlob);  promiseConvertKey.then(symKey => {    var promiseMacInit = mac.init(symKey);    return promiseMacInit;  }).then(() => {    // 初次update    var promiseMacUpdate = mac.update(GenDataBlob(12));    return promiseMacUpdate;  }).then(() => {    // 可根据情况进行多次update    var promiseMacUpdate = mac.update(GenDataBlob(12));    return promiseMacUpdate;  }).then(() => {    var PromiseMacDoFinal = mac.doFinal();    return PromiseMacDoFinal;  }).then(macOutput => {    console.error("[Promise]: HMAC result: " + macOutput.data);    var macLen = mac.getMacLength();    console.error("[Promise]: MAC len: " + macLen);  }).catch(error => {    console.error("[Promise]: error: " + error.message);  });}
// process by callbackfunction doHmacByCallback(algName) {  var mac;  try {    mac = cryptoFramework.createMac(algName);  } catch (error) {    AlertDialog.show({message: "[Callback]: error code: " + error.code + ", message is: " + error.message});    console.error("[Callback]: error code: " + error.code + ", message is: " + error.message);  }  var KeyBlob = {    data : stringToUint8Array("12345678abcdefgh")  }  var symKeyGenerator = cryptoFramework.createSymKeyGenerator("AES128");  symKeyGenerator.convertKey(KeyBlob, (err, symKey) => {    if (err) {      console.error("[Callback]: err: " + err.code);    }    mac.init(symKey, (err1, ) => {      if (err1) {        console.error("[Callback]: err: " + err1.code);      }      // 初次update      mac.update(GenDataBlob(12), (err2, ) => {        if (err2) {          console.error("[Callback]: err: " + err2.code);        }        // 可根据情况进行多次update        mac.update(GenDataBlob(12), (err3, ) => {          if (err3) {            console.error("[Callback]: err: " + err3.code);          }          mac.doFinal((err4, macOutput) => {            if (err4) {              console.error("[Callback]: err: " + err4.code);            } else {              console.error("[Callback]: HMAC result: " + macOutput.data);              var macLen = mac.getMacLength();              console.error("[Callback]: MAC len: " + macLen);            }          });        });      });    });  });} 以HMAC更新MAC时多次调用update实现分段为例： 已复制import cryptoFramework from "@ohos.security.cryptoFramework"
async function updateData(index, obj, data) {  console.error("update " + (index + 1) + " MB data...");  return obj.update(data);}
function stringToUint8Array(str) {  var arr = [];  for (var i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  var tmpUint8Array = new Uint8Array(arr);  return tmpUint8Array;}
function GenDataBlob(dataBlobLen) {  var dataBlob;  if (dataBlobLen == 12) {    dataBlob = {data: stringToUint8Array("my test data")};  } else {    console.error("GenDataBlob: dataBlobLen is invalid");    dataBlob = {data: stringToUint8Array("my test data")};  }  return dataBlob;}
function LoopHmacPromise(algName, loopSize) {  var mac;  try {    mac = cryptoFramework.createMac(algName);  } catch (error) {    console.error("[Promise]: error code: " + error.code + ", message is: " + error.message);    return;  }  console.error("[Promise]: Mac algName is: " + mac.algName);  var KeyBlob = {    data : stringToUint8Array("12345678abcdefgh")  }  var symKeyGenerator = cryptoFramework.createSymKeyGenerator("AES128");  var promiseConvertKey = symKeyGenerator.convertKey(KeyBlob);  promiseConvertKey.then(symKey => {    var promiseMacInit = mac.init(symKey);    return promiseMacInit;  }).then(async () => {    for (var i = 0; i < loopSize; i++) {      await updateData(i, mac, GenDataBlob(12));    }    var promiseMacUpdate = mac.update(GenDataBlob(12));    return promiseMacUpdate;  }).then(() => {    var PromiseMacDoFinal = mac.doFinal();    return PromiseMacDoFinal;  }).then(macOutput => {    console.error("[Promise]: HMAC result: " + macOutput.data);    var macLen = mac.getMacLength();    console.error("[Promise]: MAC len: " + macLen);  }).catch(error => {    console.error("[Promise]: error: " + error.message);  });}   使用随机数操作 场景说明 使用随机数操作的主要场景为：  用户生成随机数Random实例，输入随机数生成的长度（字节），生成指定长度的随机数。 用户使用生成的随机数作为参数，进行种子设置。  接口及参数说明 详细接口说明可参考API参考。     实例名 接口名 描述    cryptoFramework function createRandom() : Random; 生成随机数Random实例   Random generateRandom(len : number, callback: AsyncCallback<DataBlob>) : void; 接受输入长度，通过Callback，异步生成随机数   Random generateRandom(len : number) : Promise<DataBlob>; 接受输入长度，通过Promise，异步生成随机数   Random setSeed(seed : DataBlob) : void; 接受输入Blob，设置种子    开发步骤  通过接口createRandom生成随机数操作实例 接受输入长度，通过接口generateRandom，生成指定长度的随机数 接受DataBlob数据，通过接口setSeed，为随机数生成池设置种子  已复制import cryptoFramework from "@ohos.security.cryptoFramework"
// process by promisefunction doRandByPromise(len) {  var rand;  try {    rand = cryptoFramework.createRandom();  } catch (error) {    console.error("[Promise]: error code: " + error.code + ", message is: " + error.message);  }  var promiseGenerateRand = rand.generateRandom(len);  promiseGenerateRand.then(randData => {    console.error("[Promise]: rand result: " + randData.data);      try {          rand.setSeed(randData);      } catch (error) {          console.log("setSeed failed, errCode: " + error.code + ", errMsg: " + error.message);      }  }).catch(error => {    console.error("[Promise]: error: " + error.message);  });}
// process by callbackfunction doRandByCallback(len) {  var rand;  try {    rand = cryptoFramework.createRandom();  } catch (error) {    console.error("[Callback]: error code: " + error.code + ", message is: " + error.message);  }  rand.generateRandom(len, (err, randData) => {    if (err) {      console.error("[Callback]: err: " + err.code);    } else {      console.error("[Callback]: generate random result: " + randData.data);      try {          rand.setSeed(randData);      } catch (error) {          console.log("setSeed failed, errCode: " + error.code + ", errMsg: " + error.message);      }    }  });}   上一篇 加解密算法库框架概述 下一篇 证书 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。框架实现原理基本概念约束与限制密钥生成规格加解密规格签名验签规格密钥协商规格MD消息摘要算法规格HMAC消息认证码算法规格加解密算法库框架概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 加解密算法库框架是一个屏蔽了第三方密码学算法库实现差异的算法框架，提供加解密、签名验签、消息验证码、哈希、安全随机数等相关功能。开发者可以通过调用加解密算法库框架，忽略底层不同三方算法库的差异，实现迅捷开发。 
说明
加解密算法库框架仅提供密钥的密码学操作，而不提供密钥管理功能。因此，使用算法库时，需要应用自己来保管密钥（适用于临时会话密钥等仅在内存中使用的场景，或者应用自己实现密钥安全存储的场景）。如果业务需要由系统提供密钥管理功能（密钥存储等），请使用HUKS部件。 
 框架实现原理加解密算法库框架提供的组件分为三层：接口层，Framework层和插件层。接口层负责对外提供统一的JS接口，插件层实现针对具体三方算法库的功能，Framework层通过灵活加载插件层的插件适配并屏蔽三方算法库差异。  基本概念对称密钥 对称密钥使用同一个密钥对数据进行加密解密操作。即对称加密算法中，数据发送方使用加密密钥对明文进行特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用同一个加密密钥以及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。 AES加密 AES的全称是Advanced Encryption Standard，是最常见的对称加密。AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。 3DES加密 3DES，也称为 3DESede 或 TripleDES，是三重数据加密算法，相当于是对每个数据块应用三次DES的对称加密算法，它使用3个64位的密钥对数据块进行三次加密。相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。  非对称密钥 非对称密钥使用公钥和私钥两个密钥来进行算法操作，公钥对外公开，私钥对外保密。对于加解密操作，一般使用公钥对明文进行加密形成密文，持有私钥的人即可对密文解密形成明文。对于签名验签操作，使用私钥对明文进行签名，公钥持有者可以通过公钥对签名数据做验签，验证数据是否被篡改。 RSA密钥 RSA密钥以极大整数做因数分解的数学难题作为密钥安全性的基石。生成密钥时，首先需要随机出两个大素数p和q，计算n = p * q并将n做为模，再选择一个大于1且小于(p - 1) * (q - 1)的整数e，确保e与(p - 1)*(q - 1)互素，最后计算d，使得e * d - 1为(p - 1)和(q - 1)的倍数，则可得到公钥(n, e)和私钥(n, d)。 算法库框架除提供了默认的双素数RSA密钥生成外，还提供了多素数密钥生成方式，可以在密钥生成时通过指定primes参数（PRIMES_2, PRIMES_3, PRIMES_4, PRIMES_5）指定素数个数。多素数密钥的优点是可以减少解密、签名的计算量（中国剩余定理），但相对的劣势是密钥强度会越低，算法库依据OpenSSL的素数使用规则制定了相应规格，具体将在约束与限制章节中说明。 ECC密钥 ECC是一种基于椭圆曲线数学的公开密钥加密算法，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性，算法库框架提供了多种椭圆曲线的ECC密钥生成能力。  加解密 对称AES加解密 算法库目前提供了AES加解密常用的7种加密模式：ECB、CBC、OFB、CFB、CTR、GCM和CCM。AES为分组加密算法，分组长度大小为128位。实际应用中明文最后一组可能不足128位，不足数据可以使用各种padding模式做数据填充。下文中描述了各个padding的区别： NoPadding：不带填充；PKCS5：填充字符由一个字节序列组成，每个字节填充该填充字节序列的长度，规定是8字节填充；PKCS7：填充字符和PKCS5填充方法一致，但是可以在1-255字节之间任意填充； 
说明
由于需要填充至分组大小，所以实际算法库中的PKCS5和PKCS7都是以分组大小作为填充长度的，即AES加密填充至16字节。 
 对称3DES加解密 该算法的加解密过程分别是对明文/密文数据进行三次DES加密或解密，得到相应的密文或明文。 算法库目前提供了3DES加解密常用的4种加密模式：ECB、CBC、OFB和CFB。DES为分组加密算法，分组长度大小为64位。实际应用中明文最后一组可能不足64位，不足数据可以使用各种padding模式做数据填充。下文中描述了各个padding的区别： NoPadding：不带填充；PKCS5：填充字符由一个字节序列组成，每个字节填充该填充字节序列的长度，规定是8字节填充；PKCS7：填充字符和PKCS5填充方法一致，但是可以在1-255字节之间任意填充； 
说明
由于需要填充至分组大小，所以实际算法库中的PKCS5和PKCS7都是以分组大小作为填充长度的，即3DES加密填充至8字节。 
 非对称RSA加解密 当持有RSA公钥(n, e)和私钥(n, d)后，RSA加密过程为：密文 = 明文 ^ e mod n, 解密过程为：明文 = 密文 ^ d mod n。算法库目前提供了RSA加解密常用的三种模式：PKCS1、PKCS1_OAEP和NoPadding。RSA为块加密算法，加密长度需要在固定长度进行，实际应用中会使用各种padding模式做数据填充。下文中描述了各个padding的区别： NoPadding：不带填充，输入的数据必须与RSA钥模一样长，输出数据长度与RSA钥模一样长；PKCS1：pkcs1padding V1.5是RSA加解密默认的填充方式，输入的数据必须<=RSA钥模-11，输出数据长度与RSA钥模一样长；PKCS1_OAEP：RSA_PKCS1_OAEP_PADDING填充模式是PKCS#1推出的新填充方式，此模式需要设置两个摘要（md和mgf1_md），输入的数据必须小于RSA钥模 - md摘要长度 - mgf1_md摘要长度 - 2，输出数据长度与RSA钥模一样长；  补充说明： RSA钥模 = (RSA的bits + 7) / 8  签名验签 RSA签名验签 当持有RSA公钥(n, e)和私钥(n, d)后，RSA签名生成过程为：签名 = 消息 ^ d mod n, 验签过程为：消息 = 签名 ^ d mod n。消息发送方发送数据时，同时发送消息和私钥签名后的签名信息，消息接收方接受到数据后，将签名信息用公钥解密并验证消息是否一致。因发送的消息长度大多大于RSA钥模，因此算法库框架提供了两种padding模式，通过摘要提取消息的散列值再做签名。算法库框架中提供了签名验签相关的两种模式：PKCS1和PSS。下问对两种模式做详细描述： PKCS1: pkcs1padding V1.5是RSA加解密默认的填充方式，使用该模式时需要设置摘要（md）；PSS: PSS模式是RSA 算法的基础上叠加上一种填充算法，使用该签名算法时需要使用摘要(md)和掩码函数（mgf1_md）; ECDSA 椭圆曲线数字签名算法（ECDSA）是基于椭圆曲线密码（ECC）模拟数字签名算法（DSA）。相比普通的离散对数问题（DLP）和大数分解问题（IFP），椭圆曲线密码的单位比特强度要高于其他公钥体制。算法库框架提供了多种椭圆曲线及摘要算法组合的椭圆曲线数字签名算法（ECDSA）能力。  密钥协商 ECDH ECDH的全称是椭圆曲线迪菲-赫尔曼秘钥交换，是用来在一个非安全通道中建立起安全的共有加密资料，交换双方可以在不共享任何秘密的情况下协商出一个密钥。算法库框架基于开源算法库提供了多种椭圆曲线的ECDH能力。  摘要 消息摘要MD算法是一种能将任意长度的输入消息，通过哈希算法生成长度固定的摘要的算法。消息摘要算法通过其不可逆的特性能被用于敏感信息的加密。消息摘要算法也被称为哈希算法或单向散列算法。 在摘要算法相同时，生成的摘要值主要有下列特点： 当输入消息相同时，生成摘要序列相同；当输入消息的长度不一致时，生成摘要序列长度固定（摘要长度由算法决定）；当输入消息不一致时，生成摘要序列几乎不会相同（依然存在相同概率，由摘要长度决定相同概率）； 消息摘要算法主要分为三类：MD，SHA与MAC（详见HMAC章节） MD算法包括MD2，MD4和MD5。 SHA算法主要包括SHA1，SHA224，SHA256，SHA384，SHA512。 消息验证码 HMAC（Hash-based Message Authentication Code）是一种基于密钥的消息认证码算法。HMAC通过指定摘要算法，以通信双方共享密钥与消息作为输入，生成消息认证码用于检验传递报文的完整性，HMAC生成的消息认证码为固定长度。HMAC在消息摘要算法的基础上增加了密钥的输入，确保了信息的正确性。 随机数 随机数在加解密过程中主要用于临时会话密钥的生成与非对称加密算法中密钥的生成。随机数由硬件生成的硬件随机数生成器或由软件生成的伪随机数生成器进行生成。在加解密的场景中，安全随机数生成器需要具备随机性，不可预测性，与不可重现性。密码学安全伪随机数生成器CSPRNG（Cryptography Secure Random Number Generators）生成的随机数满足密码学安全伪随机性 内部状态代表随机数生成器内存中的数值，当内部状态相同时，随机数生成器会生成固定的随机数序列种子（seed）是一个用来对伪随机数的内部状态进行初始化的数据，随机数生成器通过种子来生成一系列的随机序列。  约束与限制算法库框架不支持多线程并发操作。算法库当前只支持OpenSSL。  密钥生成规格对称密钥生成规格 支持的对称密钥生成参数： 对称密钥算法  密钥长度（bit）  字符串参数    3DES  192  3DES192   AES  128  AES128   AES  192  AES192   AES  256  AES256     
说明
“字符串参数”是“对称密钥算法”和“密钥长度”拼接而成，用于在创建对称密钥生成器时，指定密钥规格。 
  非对称密钥生成规格 RSA密钥生成 支持的非对称密钥生成参数： 非对称密钥类型  素数个数  字符串参数    RSA512  2  RSA512|PRIMES_2   RSA768  2  RSA768|PRIMES_2   RSA1024  2  RSA1024|PRIMES_2   RSA1024  3  RSA1024|PRIMES_3   RSA2048  2  RSA2048|PRIMES_2   RSA2048  3  RSA2048|PRIMES_3   RSA3072  2  RSA3072|PRIMES_2   RSA3072  3  RSA3072|PRIMES_3   RSA4096  2  RSA4096|PRIMES_2   RSA4096  3  RSA4096|PRIMES_3   RSA4096  4  RSA4096|PRIMES_4   RSA8192  2  RSA8192|PRIMES_2   RSA8192  3  RSA8192|PRIMES_3   RSA8192  4  RSA8192|PRIMES_4   RSA8192  5  RSA8192|PRIMES_5     
说明
生成RSA非对称密钥时，默认素数为2，PRIMES_2参数可省略。 
 ECC密钥生成 支持的非对称密钥生成参数： 非对称密钥算法  密钥长度    ECC  ECC224   ECC  ECC256   ECC  ECC384   ECC  ECC521       加解密规格对称加解密 支持的对称加密算法： 对称加解密算法  分组模式  字符串参数    3DES  ECB  3DES192|ECB|[NoPadding|PKCS5|PKCS7]   3DES  CBC  3DES192|CBC|[NoPadding|PKCS5|PKCS7]   3DES  OFB  3DES192|OFB|[NoPadding|PKCS5|PKCS7]   3DES  CFB  3DES192|CFB|[NoPadding|PKCS5|PKCS7]   AES  ECB  AES[128|192|256]|ECB|[NoPadding|PKCS5|PKCS7]   AES  CBC  AES[128|192|256]|CBC|[NoPadding|PKCS5|PKCS7]   AES  CTR  AES[128|192|256]|CTR|[NoPadding|PKCS5|PKCS7]   AES  OFB  AES[128|192|256]|OFB|[NoPadding|PKCS5|PKCS7]   AES  CFB  AES[128|192|256]|CFB|[NoPadding|PKCS5|PKCS7]   AES  GCM  AES[128|192|256]|GCM|[NoPadding|PKCS5|PKCS7]   AES  CCM  AES[128|192|256]|CCM|[NoPadding|PKCS5|PKCS7]      
说明
[]中只能任选一项。“字符串参数”是“对称加解密算法（含密钥长度）”、“分组模式”、“填充模式”拼接而成，用于在创建对称加解密实例时，指定对称加解密算法规格。 
 非对称RSA加解密 RSA加解密时，涉及三种填充模式：NoPadding, PKCS1和PKCS1_OAEP。 使用NoPadding模式时可以指定的参数: 非对称密钥类型  填充模式  字符串参数    RSA512  NoPadding  RSA512|NoPadding   RSA768  NoPadding  RSA768|NoPadding   RSA1024  NoPadding  RSA1024|NoPadding   RSA2048  NoPadding  RSA2048|NoPadding   RSA3072  NoPadding  RSA3072|NoPadding   RSA4096  NoPadding  RSA4096|NoPadding   RSA8192  NoPadding  RSA8192|NoPadding     使用PKCS1模式时可以指定的参数: 非对称密钥类型  填充模式  字符串参数    RSA512  PKCS1  RSA512|PKCS1   RSA768  PKCS1  RSA768|PKCS1   RSA1024  PKCS1  RSA1024|PKCS1   RSA2048  PKCS1  RSA2048|PKCS1   RSA3072  PKCS1  RSA3072|PKCS1   RSA4096  PKCS1  RSA4096|PKCS1   RSA8192  PKCS1  RSA8192|PKCS1     使用PKCS1_OAEP模式时可以指定的参数： 
说明
1.[]内的参数只能任选一项，非[]内的为固定值； 2.使用时请从表格中选择非对称密钥类型、填充模式、摘要、掩码摘要四个数据，用|拼接成字符串。 例如："RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA256" 
 非对称密钥类型  填充模式  摘要  掩码摘要    RSA512  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA512  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA512  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA512  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224]   RSA768  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA768  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA768  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA768  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384]   RSA768  PKCS1_OAEP  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA768  PKCS1_OAEP  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224]   RSA1024  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PKCS1_OAEP  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PKCS1_OAEP  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384]   RSA2048  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PKCS1_OAEP  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PKCS1_OAEP  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PKCS1_OAEP  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PKCS1_OAEP  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PKCS1_OAEP  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PKCS1_OAEP  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PKCS1_OAEP  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PKCS1_OAEP  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PKCS1_OAEP  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PKCS1_OAEP  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512 ]   RSA8192  PKCS1_OAEP  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PKCS1_OAEP  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]       签名验签规格RSA签名验签 RSA签名验签时，涉及两种填充模式：PKCS1和PSS。 使用PKCS1模式时可以指定的参数: 非对称密钥类型  填充模式  摘要  字符串参数    RSA512  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384]  RSA512|PKCS1| [MD5|SHA1|SHA224|SHA256|SHA384]   RSA768  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384|SHA512]  RSA768|PKCS1|[MD5|SHA1|SHA224|SHA256|SHA384|SHA512]   RSA1024  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384|SHA512]  RSA1024|PKCS1|[MD5|SHA1|SHA224|SHA256|SHA384|SHA512]   RSA2048  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384|SHA512]  RSA2048|PKCS1|[MD5|SHA1|SHA224|SHA256|SHA384|SHA512]   RSA3072  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384|SHA512]  RSA3072|PKCS1|[MD5|SHA1|SHA224|SHA256|SHA384|SHA512]   RSA4096  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384|SHA512]  RSA4096|PKCS1|[MD5|SHA1|SHA224|SHA256|SHA384|SHA512]   RSA8192  PKCS1  [MD5|SHA1|SHA224|SHA256|SHA384|SHA512]  RSA8192|PKCS1|[MD5|SHA1|SHA224|SHA256|SHA384|SHA512]     使用PSS模式时可以指定的参数：
说明
1.[]内的参数只能任选一项，非[]内的为固定值； 2.使用时请从表格中选择非对称密钥类型、填充模式、摘要、掩码摘要四个数据，用|拼接成字符串。 例如："RSA2048|PSS|SHA256|MGF1_SHA256" 
 非对称密钥类型  填充模式  摘要  掩码摘要    RSA512  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA512  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA512  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA512  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224]   RSA768  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA768  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA768  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA768  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384]   RSA768  PSS  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256]   RSA768  PSS  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224]   RSA1024  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PSS  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA1024  PSS  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384]   RSA2048  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PSS  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA2048  PSS  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PSS  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA3072  PSS  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PSS  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA4096  PSS  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PSS  MD5  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PSS  SHA1  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PSS  SHA224  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PSS  SHA256  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PSS  SHA384  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]   RSA8192  PSS  SHA512  [MGF1_MD5|MGF1_SHA1|MGF1_SHA224|MGF1_SHA256|MGF1_SHA384|MGF1_SHA512]      ECDSA签名验签 支持的ECDSA参数： 非对称密钥算法  支持种类    ECC  ECC224   ECC  ECC256   ECC  ECC384   ECC  ECC521     摘要算法  支持种类    HASH  SHA1   HASH  SHA224   HASH  SHA256   HASH  SHA384   HASH  SHA512       密钥协商规格ECDH 支持的ECDH参数： 非对称密钥算法  支持种类    ECC  ECC224   ECC  ECC256   ECC  ECC384   ECC  ECC521       MD消息摘要算法规格加解密算法库框架当前支持的MD算法参数： 摘要算法  支持种类    HASH  SHA1   HASH  SHA224   HASH  SHA256   HASH  SHA384   HASH  SHA512   HASH  MD5       HMAC消息认证码算法规格加解密算法库框架当前支持的HMAC算法参数： 摘要算法  支持种类    HASH  SHA1   HASH  SHA224   HASH  SHA256   HASH  SHA384   HASH  SHA512        上一篇 加解密算法库框架 下一篇 加解密算法库框架开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。定制HAP多目标构建产物定义产物的deviceType定义产物的source源码集定义产物的资源定义C++工程依赖的.so文件定义产物的distroFilter配置APP多目标构建产物定义product的bundleName信息定义product的签名配置信息定义product中包含的target构建定义的目标产物调试和运行指定的Target定制多目标构建产物 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 通常情况下，应用厂商会根据不同的部署环境，不同的目标人群，不同的运行环境等，将同一个应用定制为不同的版本，如国内版、国际版、普通版、VIP版、免费版、付费版等。针对以上场景，DevEco Studio支持通过少量的代码差异化配置处理，在编译构建过程中实现一个应用构建出不同的目标产物版本，从而实现源代码、资源文件等的高效复用。 在了解HarmonyOS应用的多目标构建产物如何定制前，先了解product和target的概念： 一个HarmonyOS工程由一个或多个模块组成，工程的构建产物为APP包，APP包用于应用/服务发布上架应用市场。由于不同的业务场景，需要定制不同的应用包，因此引入product概念。一个工程可以定义多个product，每个product对应一个定制化应用包，通过配置可以实现一个工程构建出多个不同的应用包。工程内的每一个Entry/Feature模块，对应的构建产物为HAP，HAP是应用/服务可以独立运行在设备中的形态。由于在不同的业务场景中，同一个模块可能需要定制不同的功能或资源，因此引入target的概念。一个模块可以定义多个target，每个target对应一个定制的HAP，通过配置可以实现一个模块构建出不同的HAP。 定制HAP多目标构建产物每一个Entry/Feature模块均支持定制不同的target，通过在模块中的build-profile.json5文件中实现差异化定制，当前支持设备类型（deviceType）、源码集（source）、资源（resource）、C++依赖的.so（buildOption）的定制。 同时，在FA模型中，每一个Entry/Feature模块也支持定制不同的分发规则distroFilter，用于定义HAP对应的细分设备规格的分发策略。当前Stage模型中暂不支持定制不同的分发规则distroFilter。  定义目标产物target 每一个target对应一个定制的HAP，因此，在定制HAP多目标构建产物前，应提前规划好需要定制的target名称。例如，以ArkTS Stage模型为例，定义一个免费版和付费版，示例如下： 
说明
如果是FA工程，Feature模块定制的Target，必须是Entry模块定义的Target的子集。Har模块只有默认配置的default Target，不支持定制其它Target。 
 已复制{  "apiType": 'stageMode',  "buildOption": {    },  "targets": [  //定义不同的target    {      "name": "default",  //默认target名称default      "runtimeOS": "HarmonyOS",    },    {      "name": "free",  //免费版target名称      "runtimeOS": "HarmonyOS"    },    {      "name": "pay",  //付费版target名称      "runtimeOS": "HarmonyOS",    }  ]} 在定义HarmonyOS应用/服务的target时，需要通过runtimeOS字段标识该Target是一个可运行在HarmonyOS设备上的HAP。如果未定义该字段，或该字段取值为OpenHarmony，则表示该Target是一个运行在OpenHarmony设备上的HAP，不能运行在HarmonyOS设备上。 按照上述target的定义，在编译构建时，会同时打包生成default、free和pay 3个不同的HAP。  定义产物的deviceType每一个target均可以指定支持的设备类型deviceType，也可以不定义。如果不定义，则该target默认支持config.json或module.json5中定义的设备类型。 同时，在定义每个target的deviceType时，支持的设备类型必须在config.json或module.json5中已经定义。例如，在上述定义的3个target中，分别定义default默认支持所有设备类型，free和pay版本只支持phone设备。 已复制{  "apiType": 'stageMode',  "buildOption": {  },  "targets": [    {      "name": "default",  //未定义deviceType，默认支持config.json或module.json5中定义的设备类型      "runtimeOS": "HarmonyOS",    },    {      "name": "free",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [  //定义free支持的设备类型为phone          "phone"        ]      }    },    {      "name": "pay",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [  //定义pay支持的设备类型为phone          "phone"        ]      }    }  ]}  定义产物的source源码集对于source源码集的定制，由于Stage模型和FA模型的差异，Stage模型支持对pages源码目录的page页面进行定制，FA模型则支持对Ability源码目录下的page页面进行定制。 例如，Stage模型中的工程，在模块的pages目录下分别定义了index.ets、page1.ets和page2.ets三个页面。其中default使用了index.ets页面；free使用了index.ets和page1.ets页面；pay使用了index.ets和page2.ets页面，则示例代码如下所示：已复制{  "apiType": 'stageMode',  "buildOption": {  },  "targets": [    {      "name": "default",      "runtimeOS": "HarmonyOS",      "source": {  //定义Stage模型中默认版target的pages源码文件        "pages": [          "pages/index"        ]      }    },    {      "name": "free",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [          "phone"        ]      },      "source": {  //定义Stage模型中免费版target的pages源码文件        "pages": [          "pages/index",          "pages/page1"        ]      }    },    {      "name": "pay",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [          "phone"        ]      },      "source": {  //定义Stage模型中付费版target的pages源码文件        "pages": [          "pages/index",          "pages/page2"        ]      }    }  ]} 例如，FA模型中的工程，在模块的MainAbility中定义了index.ets、page1.ets和page2.ets，其中：default使用了index.ets页面；free使用了index.ets和page1.ets页面；pay使用了index.ets和page2.ets页面。已复制{  "apiType": 'faMode',  "buildOption": {  },  "targets": [    {      "name": "default",      "runtimeOS": "HarmonyOS",      "source": {  //定义FA模型中默认版target的pages源码文件        "abilities": [          {            "name": ".MainAbility",            "pages": [              "pages/index"            ]          }        ],      }    },    {      "name": "free",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [          "phone"        ]      },      "source": {  //定义FA模型中免费版target的pages源码文件        "abilities": [          {            "name": ".MainAbility",            "pages": [              "pages/index",              "pages/page1"            ]          }        ],      }    },    {      "name": "pay",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [          "phone"        ]      },      "source": {  //定义FA模型中付费版target的pages源码文件        "abilities": [          {            "name": ".MainAbility",            "pages": [              "pages/index",              "pages/page2"            ]          }        ],      }    }  ]}   定义产物的资源每个target使用的资源文件可能存在差异，在开发过程中，开发者可以将每个target所使用的资源存放在不同的资源目录下。其中，ArkTS工程支持对main目录下的资源文件目录（resource）进行定制；JS工程支持对main目录下的资源文件目录（resource）及Ability下的资源文件目录（res）进行定制。如下为ArkTS工程的资源文件目录定制示例： 已复制{  "apiType": 'stageMode',  "buildOption": {  },  "targets": [    {      "name": "default",      "runtimeOS": "HarmonyOS",      "source": {        "pages": [          "pages/index"        ]      },      "resource": {  //定义默认版target使用的资源文件目录        "directories": [          "./src/main/resources_default"        ]      }    },    {      "name": "free",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [          "phone"        ]      },      "source": {          "pages": [          "pages/index",          "pages/page1"        ]      },      "resource": {  //定义免费版target使用的资源文件目录        "directories": [          "./src/main/resources_default",          "./src/main/resources_free"        ]      }    },    {      "name": "pay",      "runtimeOS": "HarmonyOS",      "config": {        "deviceType": [          "phone"        ]      },      "source": {          "pages": [          "pages/index",          "pages/page2"        ]      },      "resource": {  //定义付费版target使用的资源文件目录，该功能在API 9及以上版本的工程中生效        "directories": [          "./src/main/resources_default",          "./src/main/resources_pay"        ]      }    }  ]} 请注意，如果target引用的多个资源文件目录下，存在同名的资源，则在构建打包过程中，将按照配置的资源文件目录顺序进行选择。例如，上述付费版target引用的资源中，resource_default和resource_pay中存在同名的资源文件，则resource_default中的资源会被打包到HAP中。  定义C++工程依赖的.so文件在C++工程中，可以对每个target依赖的.so文件进行定制。例如某模块依赖了function1.so、function2.so和function3.so三个文件，其中target为default的产物依赖了function1.so和function2.so；其中target为vip的产物依赖了function1.so和function3.so，则示例代码如下所示： 已复制{  "apiType": 'stageMode',  "buildOption": {    "externalNativeOptions": {      "path": "./src/main/cpp/CMakeLists.txt",      "arguments": "",      "abiFilters": [        "armeabi-v7a",        "arm64-v8a"      ],      "cppFlags": "",    }  },  "targets": [  //定义不同的target    {      "name": "default",        "runtimeOS": "HarmonyOS",      "config": {        "buildOption": {          "napiLibFilterOption": {            //按照.so文件的优先级顺序，打包最高优先级的function1.so文件            "pickFirsts": [              "**/function1.so"            ],            //排除不打包的function3.so文件            "excludes": [              "**/function3.so"            ],            //允许当.so中资源重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件            "enableOverride": true          }        }      }    },    {      "name": "vip",      "runtimeOS": "HarmonyOS",      "config": {        "buildOption": {          "napiLibFilterOption": {            //按照.so文件的优先级顺序，打包最高优先级的function1.so文件            "pickFirsts": [              "**/function1.so"            ],            //排除不打包的function2.so文件            "excludes": [              "**/function2.so"            ],            //允许当.so中资源重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件            "enableOverride": true          }        }      }    }  ]}  定义产物的distroFilterdistroFilter可配置的分发策略维度包括API Version、屏幕形状、屏幕分辨率、屏幕像素密度、国家地区码。在进行应用分发时，通过deviceType与这几个属性的匹配关系，唯一确定一个用于分发到设备的HAP。 FA模型中的distroFilter的文件路径及配置方法，请参见开发基础知识>应用配置文件（FA模型）>module对象内部结构。  配置APP多目标构建产物APP用于应用/服务上架发布，针对不同的应用场景，可以定制不同的product，每个product中支持对bundleName、签名信息以及包含的target进行定制。  定义目标产物product 每一个product对应一个定制的APP包，因此，在定制APP多目标构建产物前，应提前规划好需要定制的product名称。例如，定义productA和productB。 
说明
在定制product时，必须存在“default”的product，否则编译时会出现错误。 
 已复制  "app": {    "signingConfigs": [],    "compileSdkVersion": 9,    "compatibleSdkVersion": 9,    "products": [      {        "name": "default",  //默认的product，不可更改名称      },      {        "name": "productA",  //定制的productA      },       {        "name": "productB",  //定制的productB      }    ]  }  定义product的bundleName信息针对每个定义的product，均可以定制不同的bundleName，如果product未定义bundleName，则采用工程默认的bundleName。示例如下所示： 已复制"app": {    "signingConfigs": [],    "compileSdkVersion": 9,    "compatibleSdkVersion": 9,    "products": [      {        "name": "default",        "bundleName": "com.example00.com"  //定义default的bundleName信息      },      {        "name": "productA",        "bundleName": "com.example01.com"  //定义productA的bundleName信息      },      {        "name": "productB",        "bundleName": "com.example02.com"  //定义productB的bundleName信息      }    ]  }  定义product的签名配置信息针对每个定义的product，均可以定制不同的signingConfig签名文件，如果product未定义signingConfig，则构建生成未签名的APP包。 通常情况下，您首先需要在签名配置界面或工程的build-profile.json5文件中配置签名信息。例如在File > Project Structure > Project > Signing Configs界面，分别配置default、product_A和product_B的签名信息，如下图所示：  签名信息配置完成后，再添加各个product对应的签名文件，示例如下所示： 
说明
您也可以提前在product中定义签名文件信息，然后在签名界面对每个product进行签名，确保配置的product签名文件与签名界面配置的签名文件保持一致即可。 
 已复制"app": {    "signingConfigs": [],    "compileSdkVersion": 9,    "compatibleSdkVersion": 9,    "products": [      {        "name": "default",        "bundleName": "com.example00.com",        "signingConfig": "default"  //定义default的签名文件信息      },      {        "name": "productA",        "bundleName": "com.example01.com",        "signingConfig": "productA"  //定义productA的签名文件信息      },      {        "name": "productB",        "bundleName": "com.example02.com",        "signingConfig": "productB"  //定义productB的签名文件信息      }    ]  }  定义product中包含的target开发者可以选择需要将定义的target分别打包到哪一个product中，每个product可以指定一个或多个target，同时每个target也可以打包到不同的product中，但是同一个module的不同target不能打包到同一个product中。例如，前面定义了default、free和pay三个target，现需要将default target打包到default product中；将free target打包到productA中；将pay target打包到productB中，对应的示例代码如下所示： 已复制{  "app": {    "signingConfigs": [      {        "name": "productB",        "type": "HarmonyOS",        "material": {          "storePassword": "000000190F49B79861A613EF0D4F24A6F9D52A7EB18CBDC590F8A7D48244508D0B3896E8D0B9DC7F17",          "certpath": "D:/key/Release/myApplication_release.cer",          "keyAlias": "myApplication",          "keyPassword": "00000019111E2366391063DFB79F132A48D666374E1D2FA8E2744EF62E9DDC44245F443F5738FEF242",          "profile": "D:/key/Release/myApplication_release Provision.p7b",          "signAlg": "SHA256withECDSA",          "storeFile": "D:/key/Release/myApplication_release.p12"        }      }    ],    "compileSdkVersion": 9,    "compatibleSdkVersion": 9,    "products": [      {        "name": "default",        "bundleName": "com.example00.com",        "signingConfig": "default"      },      {        "name": "productA",        "bundleName": "com.example01.com",        "signingConfig": "productA"      },      {        "name": "productB",        "bundleName": "com.example02.com",        "signingConfig": "productB"      }    ]  },  "modules": [    {      "name": "entry",      "srcPath": "./entry",      "targets": [        {          "name": "default",  //将default target打包到default APP中          "applyToProducts": [            "default"          ]        },        {          "name": "free",  //将free target打包到productA APP中          "applyToProducts": [            "productA"          ]        },        {          "name": "pay",  //将pay target打包到productB APP中          "applyToProducts": [            "productB"          ]        }      ]    }  ]}  构建定义的目标产物每个target对应一个HAP，每个product对应一个APP包，在编译构建时，如果存在多product或多target时，您可以指定编译具体的包。 单击右上角的图标，指定需要打包的Product及Target，然后单击Apply保存。例如选择“ProductA”中，entry模块对应的“free”Target。 Product：选择需要构建的APP包。Product Info：该APP包的BundleName和SigningConfig信息。Target Select：选择各个模块的Target，该Target需要包含在定义的Product中才能选择，如果未包含则显示“No Target to apply”  然后执行编译构建APP/HAP的任务： 单击菜单栏的Build > Build Hap(s)/APP(s) > Build APP(s) ，构建指定的Product对应的APP。例如，按照上述设置，此时DevEco Studio将构建生成ProductA的APP包。default和ProductB的APP均不会生成。单击菜单栏的Build > Build Hap(s)/APP(s) > Build Hap(s)，构建指定Product下的所有Target对应发的HAP。例如，按照上述配置，此时DevEco Studio将构建生成entry模块下default和free的HAP。 如果您想将某个模块下的指定target打包生成HAP，可以在工程目录中，单击模块名，然后再单击Build > Make Module ‘模块名 ’，此时DevEco Studio将构建生成模块下指定target对应的包。例如，按照上述配置，此时DevEco Studio将构建生成entry模块下free的HAP，不会生成default的HAP。   调试和运行指定的Target使用DevEco Studio调试或运行应用/服务时，每个模块只能选择其中的一个target运行，可以通过单击右上角的图标，指定需要调试或运行的Product下对应的Module Target，然后单击Apply保存。 
说明
在选择需要调试或运行的target时，需要注意选择该target所属的Product，否则将找不到可调试和运行的target。 
    上一篇 构建闭源HAR 下一篇 通过命令行方式构建应用或服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍键值型数据库备份、恢复与删除关系型数据库备份与恢复数据库备份与恢复 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 当应用在处理一项重要的操作，显然是不能被打断的。例如：写入多个表关联的事务。此时，每个表的写入都是单独的，但是表与表之间的事务关联性不能被分割。 如果操作的过程中出现问题，开发者可以使用恢复功能，将数据库恢复到之前的状态，重新对数据库进行操作。 在数据库被篡改、删除、或者设备断电场景下，数据库可能会因为数据丢失、数据损坏、脏数据等而不可用，可以通过数据库的备份恢复能力将数据库恢复至可用状态。  键值型数据库和关系型数据库均支持对数据库的备份和恢复。另外，键值型数据库还支持删除数据库备份，以释放本地存储空间。  键值型数据库备份、恢复与删除 键值型数据库，通过backup接口实现数据库备份，通过restore接口实现数据库恢复，通过deletebackup接口删除数据库备份。具体接口及功能，可见分布式键值数据库。  创建数据库。(1) 创建kvManager。 (2) 配置数据库参数。 (3) 创建kvStore。 已复制import distributedKVStore from '@ohos.data.distributedKVStore';
let kvManager;let context = getContext(this);const kvManagerConfig = {  context: context,  bundleName: 'com.example.datamanagertest'}try {  kvManager = distributedKVStore.createKVManager(kvManagerConfig);  console.info('Succeeded in creating KVManager.');} catch (e) {  console.error(`Failed to create KVManager. Code:${e.code},message:${e.message}`);}let kvStore;try {  const options = {    createIfMissing: true,    encrypt: false,    backup: false,    kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION,    securityLevel: distributedKVStore.SecurityLevel.S2  };  kvManager.getKVStore('storeId', options, (err, store) => {    if (err) {      console.error(`Fail to get KVStore. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in getting KVStore.');    kvStore = store;  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}  使用put()方法插入数据。已复制const KEY_TEST_STRING_ELEMENT = 'key_test_string';const VALUE_TEST_STRING_ELEMENT = 'value_test_string';try {  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {    if (err !== undefined) {      console.error(`Fail to put data. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in putting data.');  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}  使用backup()方法备份数据。已复制let file = 'BK001';try {  kvStore.backup(file, (err) => {    if (err) {      console.error(`Fail to backup data.code:${err.code},message:${err.message}`);    } else {      console.info('Succeeded in backupping data.');    }  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}  使用delete()方法删除数据（模拟意外删除、篡改场景）。已复制try {  kvStore.delete(KEY_TEST_STRING_ELEMENT, (err) => {    if (err !== undefined) {      console.error(`Fail to delete data. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in deleting data.');  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}  使用restore()方法恢复数据。已复制let file = 'BK001';try {  kvStore.restore(file, (err) => {    if (err) {      console.error(`Fail to restore data. Code:${err.code},message:${err.message}`);    } else {      console.info('Succeeded in restoring data.');    }  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}  当本地设备存储空间有限或需要重新备份时，还可使用deleteBackup()方法删除备份，释放存储空间。已复制let kvStore;let files = ['BK001'];try {  kvStore.deleteBackup(files).then((data) => {    console.info(`Succeed in deleting Backup. Data:filename is ${data[0]},result is ${data[1]}.`);  }).catch((err) => {    console.error(`Fail to delete Backup. Code:${err.code},message:${err.message}`);  })} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}     关系型数据库备份与恢复 关系型数据库，通过backup接口实现数据库备份，通过restore接口实现数据库恢复。具体接口及功能，可见关系型数据库。  使用getRdbStore()方法创建关系型数据库。已复制import relationalStore from '@ohos.data.relationalStore';
let store;let context = getContext(this);const STORE_CONFIG = {  name: 'RdbTest.db',  securityLevel: relationalStore.SecurityLevel.S1};relationalStore.getRdbStore(context, STORE_CONFIG, (err, rdbStore) => {  store = rdbStore;  if (err) {    console.error(`Failed to get RdbStore. Code:${err.code},message:${err.message}`);    return;  }  store.executeSql("CREATE TABLE IF NOT EXISTS EMPLOYEE (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER, salary INTEGER, codes Uint8Array);", null);  console.info('Succeeded in getting RdbStore.');})  使用insert()方法插入数据。已复制const valueBucket = {  'NAME': 'Lisa',  'AGE': 18,  'SALARY': 100.5, 'CODES': new Uint8Array([1, 2, 3, 4, 5])};store.insert('EMPLOYEE', valueBucket, relationalStore.ConflictResolution.ON_CONFLICT_REPLACE, (err, rowId) => {  if (err) {    console.error(`Failed to insert data. Code:${err.code},message:${err.message}`);    return;  }  console.info(`Succeeded in inserting data. rowId:${rowId}`);})  使用backup()方法备份数据。已复制store.backup('dbBackup.db', (err) => {  if (err) {    console.error(`Failed to backup data. Code:${err.code},message:${err.message}`);    return;  }  console.info(`Succeeded in backuping data.`);})  使用delete()方法删除数据（模拟意外删除、篡改场景）。已复制let predicates = new relationalStore.RdbPredicates('EMPLOYEE');predicates.equalTo('NAME', 'Lisa');let promise = store.delete(predicates);promise.then((rows) => {  console.info(`Delete rows: ${rows}`);}).catch((err) => {  console.error(`Failed to delete data. Code:${err.code},message:${err.message}`);})  使用restore()方法恢复数据。已复制store.restore('dbBackup.db', (err) => {  if (err) {    console.error(`Failed to restore data. Code:${err.code},message:${err.message}`);    return;  }  console.info(`Succeeded in restoring data.`);})     上一篇 数据可靠性与安全性概述 下一篇 数据库加密 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍键值型数据库加密关系型数据库加密数据库加密 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 为了增强数据库的安全性，数据库提供了一个安全适用的数据库加密能力，从而对数据库存储的内容实施有效保护。通过数据库加密等安全方法实现了数据库数据存储的保密性和完整性要求，使得数据库以密文方式存储并在密态方式下工作，确保了数据安全。 加密后的数据库只能通过接口进行访问，无法通过其它方式打开数据库文件。数据库的加密属性在创建数据库时确认，无法变更。 键值型数据库和关系型数据库均支持数据库加密操作。   键值型数据库加密 键值型数据库，通过options中encrypt参数来设置是否加密，默认为false，表示不加密。encrypt参数为true时表示加密。 具体接口及功能，可见分布式键值数据库。 已复制import distributedKVStore from '@ohos.data.distributedKVStore';
let kvManager;let context = getContext(this);const kvManagerConfig = {  context: context,  bundleName: 'com.example.datamanagertest'}try {  kvManager = distributedKVStore.createKVManager(kvManagerConfig);  console.info('Succeeded in creating KVManager.');} catch (e) {  console.error(`Failed to create KVManager. Code:${e.code},message:${e.message}`);}let kvStore;try {  const options = {    createIfMissing: true,    // 设置数据库加密    encrypt: true,    backup: false,    kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION,    securityLevel: distributedKVStore.SecurityLevel.S2  };  kvManager.getKVStore('storeId', options, (err, store) => {    if (err) {      console.error(`Fail to get KVStore. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in getting KVStore.');    kvStore = store;  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}   关系型数据库加密 关系型数据库，通过StoreConfig中encrypt属性来设置是否加密，默认为false，表示不加密。encrypt参数为true时表示加密。 具体接口及功能，可见关系型数据库。 已复制import relationalStore from '@ohos.data.relationalStore';
let store;let context = getContext(this);const STORE_CONFIG = {  name: 'RdbTest.db',  securityLevel: relationalStore.SecurityLevel.S1,  encrypt: true};relationalStore.getRdbStore(context, STORE_CONFIG, (err, rdbStore) => {  store = rdbStore;  if (err) {    console.error(`Failed to get RdbStore. Code:${err.code},message:${err.message}`);    return;  }  console.info(`Succeeded in getting RdbStore.`);})   上一篇 数据库备份与恢复 下一篇 基于设备分类和数据分级的访问控制 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。功能介绍运作机制数据管理概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 功能介绍数据管理为开发者提供数据存储、数据管理能力，比如联系人应用数据可以保存到数据库中，提供数据库的安全、可靠等管理机制。 数据存储：提供通用数据持久化能力，根据数据特点，分为用户首选项、键值型数据库和关系型数据库。数据管理：提供高效的数据管理能力，包括权限管理、数据备份恢复、数据共享框架等。 应用创建的数据库，都保存到应用沙盒，当应用卸载时，数据库也会自动删除。  运作机制数据管理模块包括用户首选项、键值型数据管理、关系型数据管理、分布式数据对象和跨应用数据管理。Interface接口层提供标准JS API接口，定义这些部件接口描述，供开发者参考。Frameworks&System service层负责实现部件数据存储功能，还有一些SQLite和其他子系统的依赖。 图1 数据管理架构图  用户首选项（Preferences）：提供了轻量级配置数据的持久化能力，并支持订阅数据变化的通知能力。不支持分布式同步，常用于保存应用配置信息、用户偏好设置等。键值型数据管理（KV-Store）：提供了键值型数据库的读写、加密、手动备份能力。分布式功能暂不支持。关系型数据管理（RelationalStore）：提供了关系型数据库的增删改查、加密、手动备份能力。分布式功能暂不支持。分布式数据对象（DataObject）：独立提供对象型结构数据的分布式能力。分布式功能暂不支持。跨应用数据管理（DataShare）：提供了向其他应用共享以及管理其数据的方法。仅系统应用可用，非系统应用无需关注，下文不做具体介绍。  上一篇 数据管理 下一篇 应用数据持久化 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍约束限制接口说明开发步骤通过键值型数据库实现数据持久化 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 键值型数据库存储键值对形式的数据，当需要存储的数据没有复杂的关系模型，比如存储商品名称及对应价格、员工工号及今日是否已出勤等，由于数据复杂度低，更容易兼容不同数据库版本和设备类型，因此推荐使用键值型数据库持久化此类数据。   约束限制  设备协同数据库，针对每条记录，Key的长度≤896 Byte，Value的长度<4 MB。 单版本数据库，针对每条记录，Key的长度≤1 KB，Value的长度<4 MB。 每个应用程序最多支持同时打开16个键值型分布式数据库。 键值型数据库事件回调方法中不允许进行阻塞操作，例如修改UI组件。    接口说明 以下是键值型数据库持久化功能的相关接口，大部分为异步接口。异步接口均有callback和Promise两种返回形式，下表均以callback形式为例，更多接口及使用方式请见分布式键值数据库。     接口名称 描述    createKVManager(config: KVManagerConfig): KVManager 创建一个KVManager对象实例，用于管理数据库对象。   getKVStore<T>(storeId: string, options: Options, callback: AsyncCallback<T>): void 指定Options和storeId，创建并得到指定类型的KVStore数据库。   put(key: string, value: Uint8Array|string|number|boolean, callback: AsyncCallback<void>): void 添加指定类型的键值对到数据库。   get(key: string, callback: AsyncCallback<Uint8Array|string|boolean|number>): void 获取指定键的值。   delete(key: string, callback: AsyncCallback<void>): void 从数据库中删除指定键值的数据。      开发步骤  若要使用键值型数据库，首先要获取一个KVManager实例，用于管理数据库对象。示例代码如下所示：Stage模型示例： 已复制// 导入模块import distributedKVStore from '@ohos.data.distributedKVStore';
// Stage模型import UIAbility from '@ohos.app.ability.UIAbility';
let kvManager;
export default class EntryAbility extends UIAbility {  onCreate() {    let context = this.context;    const kvManagerConfig = {      context: context,      bundleName: 'com.example.datamanagertest'    };    try {      // 创建KVManager实例      kvManager = distributedKVStore.createKVManager(kvManagerConfig);      console.info('Succeeded in creating KVManager.');      // 继续创建获取数据库    } catch (e) {      console.error(`Failed to create KVManager. Code:${e.code},message:${e.message}`);    }  }} FA模型示例： 已复制// 导入模块import distributedKVStore from '@ohos.data.distributedKVStore';
// FA模型import featureAbility from '@ohos.ability.featureAbility';
let kvManager;let context = featureAbility.getContext(); // 获取contextconst kvManagerConfig = {  context: context,  bundleName: 'com.example.datamanagertest'};try {  kvManager = distributedKVStore.createKVManager(kvManagerConfig);  console.info('Succeeded in creating KVManager.');  // 继续创建获取数据库} catch (e) {  console.error(`Failed to create KVManager. Code:${e.code},message:${e.message}`);}  创建并获取键值数据库。示例代码如下所示：已复制try {  const options = {    createIfMissing: true, // 当数据库文件不存在时是否创建数据库，默认创建    encrypt: false, // 设置数据库文件是否加密，默认不加密     backup: false, // 设置数据库文件是否备份，默认备份    kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION, // 设置要创建的数据库类型，默认为多设备协同数据库    securityLevel: distributedKVStore.SecurityLevel.S2 // 设置数据库安全级别  };  // storeId为数据库唯一标识符  kvManager.getKVStore('storeId', options, (err, kvStore) => {    if (err) {      console.error(`Failed to get KVStore. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in getting KVStore.');    // 进行相关数据操作  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}  调用put()方法向键值数据库中插入数据。示例代码如下所示：已复制const KEY_TEST_STRING_ELEMENT = 'key_test_string';const VALUE_TEST_STRING_ELEMENT = 'value_test_string';try {  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {    if (err !== undefined) {      console.error(`Failed to put data. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in putting data.');  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);} 
说明
 当Key值存在时，put()方法会修改其值，否则新增一条数据。 
  调用get()方法获取指定键的值。示例代码如下所示：已复制const KEY_TEST_STRING_ELEMENT = 'key_test_string';const VALUE_TEST_STRING_ELEMENT = 'value_test_string';try {  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {    if (err !== undefined) {      console.error(`Failed to put data. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in putting data.');    kvStore.get(KEY_TEST_STRING_ELEMENT, (err, data) => {      if (err !== undefined) {        console.error(`Failed to get data. Code:${err.code},message:${err.message}`);        return;      }      console.info(`Succeeded in getting data. data:${data}`);    });  });} catch (e) {  console.error(`Failed to get data. Code:${e.code},message:${e.message}`);}  调用delete()方法删除指定键值的数据。示例代码如下所示：已复制const KEY_TEST_STRING_ELEMENT = 'key_test_string';const VALUE_TEST_STRING_ELEMENT = 'value_test_string';try {  kvStore.put(KEY_TEST_STRING_ELEMENT, VALUE_TEST_STRING_ELEMENT, (err) => {    if (err !== undefined) {      console.error(`Failed to put data. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in putting data.');    kvStore.delete(KEY_TEST_STRING_ELEMENT, (err) => {      if (err !== undefined) {        console.error(`Failed to delete data. Code:${err.code},message:${err.message}`);        return;      }      console.info('Succeeded in deleting data.');    });  });} catch (e) {  console.error(`An unexpected error occurred. Code:${e.code},message:${e.message}`);}     上一篇 通过用户首选项实现数据持久化 下一篇 通过关系型数据库实现数据持久化 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍运作机制约束限制接口说明开发步骤通过用户首选项实现数据持久化 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 用户首选项为应用提供Key-Value键值型的数据处理能力，支持应用持久化轻量级数据，并对其修改和查询。当用户希望有一个全局唯一存储的地方，可以采用用户首选项来进行存储。Preferences会将该数据缓存在内存中，当用户读取的时候，能够快速从内存中获取数据，当需要持久化时可以使用flush接口将内存中的数据写入持久化文件中。Preferences会随着存放的数据量越多而导致应用占用的内存越大，因此，Preferences不适合存放过多的数据，适用的场景一般为应用保存用户的个性化设置（字体大小，是否开启夜间模式）等。   运作机制 如图所示，用户程序通过ArkTS接口调用用户首选项读写对应的数据文件。开发者可以将用户首选项持久化文件的内容加载到Preferences实例，每个文件唯一对应到一个Preferences实例，系统会通过静态容器将该实例存储在内存中，直到主动从内存中移除该实例或者删除该文件。 应用首选项的持久化文件保存在应用沙箱内部，可以通过context获取其路径。具体可见获取应用开发路径。  图1 用户首选项运作机制    约束限制  Key键为string类型，要求非空且长度不超过80个字节。 如果Value值为string类型，可以为空，不为空时长度不超过8192个字节。 内存会随着存储数据量的增大而增大，所以存储的数据量应该是轻量级的，建议存储的数据不超过一万条，否则会在内存方面产生较大的开销。    接口说明 以下是用户首选项持久化功能的相关接口，大部分为异步接口。异步接口均有callback和Promise两种返回形式，下表均以callback形式为例，更多接口及使用方式请见用户首选项。     接口名称 描述    getPreferences(context: Context, name: string, callback: AsyncCallback<Preferences>): void 获取Preferences实例。   put(key: string, value: ValueType, callback: AsyncCallback<void>): void 将数据写入Preferences实例，可通过flush将Preferences实例持久化。   has(key: string, callback: AsyncCallback<boolean>): void 检查Preferences实例是否包含名为给定Key的存储键值对。给定的Key值不能为空。   get(key: string, defValue: ValueType, callback: AsyncCallback<ValueType>): void 获取键对应的值，如果值为null或者非默认值类型，返回默认数据defValue。   delete(key: string, callback: AsyncCallback<void>): void 从Preferences实例中删除名为给定Key的存储键值对。   flush(callback: AsyncCallback<void>): void 将当前Preferences实例的数据异步存储到用户首选项持久化文件中。   on(type: 'change', callback: Callback<{ key : string }>): void 订阅数据变更，订阅的Key的值发生变更后，在执行flush方法后，触发callback回调。   off(type: 'change', callback?: Callback<{ key : string }>): void 取消订阅数据变更。   deletePreferences(context: Context, name: string, callback: AsyncCallback<void>): void 从内存中移除指定的Preferences实例。若Preferences实例有对应的持久化文件，则同时删除其持久化文件。      开发步骤  导入用户首选项模块。已复制import dataPreferences from '@ohos.data.preferences';  获取Preferences实例。Stage模型示例： 已复制import UIAbility from '@ohos.app.ability.UIAbility';
class EntryAbility extends UIAbility {  onWindowStageCreate(windowStage) {    try {      dataPreferences.getPreferences(this.context, 'mystore', (err, preferences) => {        if (err) {          console.error(`Failed to get preferences. Code:${err.code},message:${err.message}`);          return;        }        console.info('Succeeded in getting preferences.');        // 进行相关数据操作      })    } catch (err) {      console.error(`Failed to get preferences. Code:${err.code},message:${err.message}`);    }  }} FA模型示例： 已复制import featureAbility from '@ohos.ability.featureAbility';
// 获取contextlet context = featureAbility.getContext();
try {  dataPreferences.getPreferences(context, 'mystore', (err, preferences) => {    if (err) {      console.error(`Failed to get preferences. Code:${err.code},message:${err.message}`);      return;    }    console.info('Succeeded in getting preferences.');    // 进行相关数据操作  })} catch (err) {  console.error(`Failed to get preferences. Code is ${err.code},message:${err.message}`);}  写入数据。使用put()方法保存数据到缓存的Preferences实例中。在写入数据后，如有需要，可使用flush()方法将Preferences实例的数据存储到持久化文件。 
说明
 当对应的键已经存在时，put()方法会修改其值。如果仅需要在键值对不存在时新增键值对，而不修改已有键值对，需使用has()方法检查是否存在对应键值对；如果不关心是否会修改已有键值对，则直接使用put()方法即可。 
 示例代码如下所示： 已复制try {  preferences.has('startup', function (err, val) {    if (err) {      console.error(`Failed to check the key 'startup'. Code:${err.code}, message:${err.message}`);      return;    }    if (val) {      console.info("The key 'startup' is contained.");    } else {      console.info("The key 'startup' does not contain.");      // 此处以此键值对不存在时写入数据为例      try {        preferences.put('startup', 'auto', (err) => {          if (err) {            console.error(`Failed to put data. Code:${err.code}, message:${err.message}`);            return;          }          console.info('Succeeded in putting data.');        })      } catch (err) {        console.error(`Failed to put data. Code: ${err.code},message:${err.message}`);      }    }  })} catch (err) {  console.error(`Failed to check the key 'startup'. Code:${err.code}, message:${err.message}`);}  读取数据。         使用get()方法获取数据，即指定键对应的值。如果值为null或者非默认值类型，则返回默认数据。示例代码如下所示：        已复制try {  preferences.get('startup', 'default', (err, val) => {    if (err) {      console.error(`Failed to get value of 'startup'. Code:${err.code}, message:${err.message}`);      return;    }    console.info(`Succeeded in getting value of 'startup'. val: ${val}.`);  })} catch (err) {  console.error(`Failed to get value of 'startup'. Code:${err.code}, message:${err.message}`);}   删除数据。使用delete()方法删除指定键值对，示例代码如下所示： 已复制try {  preferences.delete('startup', (err) => {    if (err) {      console.error(`Failed to delete the key 'startup'. Code:${err.code}, message:${err.message}`);      return;    }    console.info("Succeeded in deleting the key 'startup'.");  })} catch (err) {  console.error(`Failed to delete the key 'startup'. Code:${err.code}, message:${err.message}`);}  数据持久化。         应用存入数据到Preferences实例后，可以使用flush()方法实现数据持久化。示例代码如下所示：        已复制try {  preferences.flush((err) => {    if (err) {      console.error(`Failed to flush. Code:${err.code}, message:${err.message}`);      return;    }    console.info('Succeeded in flushing.');  })} catch (err) {  console.error(`Failed to flush. Code:${err.code}, message:${err.message}`);}   订阅数据变更。         应用订阅数据变更需要指定observer作为回调方法。订阅的Key值发生变更后，当执行flush()方法时，observer被触发回调。示例代码如下所示：        已复制let observer = function (key) {  console.info('The key' + key + 'changed.');}preferences.on('change', observer);// 数据产生变更，由'auto'变为'manual'preferences.put('startup', 'manual', (err) => {  if (err) {    console.error(`Failed to put the value of 'startup'. Code:${err.code},message:${err.message}`);    return;  }  console.info("Succeeded in putting the value of 'startup'.");  preferences.flush((err) => {    if (err) {      console.error(`Failed to flush. Code:${err.code}, message:${err.message}`);      return;    }    console.info('Succeeded in flushing.');  })})   删除指定文件。使用deletePreferences()方法从内存中移除指定文件对应的Preferences实例，包括内存中的数据。若该Preference存在对应的持久化文件，则同时删除该持久化文件，包括指定文件及其备份文件、损坏文件。 
说明
  调用该接口后，应用不允许再使用该Preferences实例进行数据操作，否则会出现数据一致性问题。 成功删除后，数据及文件将不可恢复。  
 示例代码如下所示： 已复制try {  dataPreferences.deletePreferences(this.context, 'mystore', (err, val) => {    if (err) {      console.error(`Failed to delete preferences. Code:${err.code}, message:${err.message}`);      return;    }    console.info('Succeeded in deleting preferences.');  })} catch (err) {  console.error(`Failed to delete preferences. Code:${err.code}, message:${err.message}`);}     上一篇 应用数据持久化概述 下一篇 通过键值型数据库实现数据持久化 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍基本概念运作机制约束限制接口说明开发步骤通过关系型数据库实现数据持久化 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 关系型数据库基于SQLite组件，适用于存储包含复杂关系数据的场景，比如一个班级的学生信息，需要包括姓名、学号、各科成绩等，又或者公司的雇员信息，需要包括姓名、工号、职位等，由于数据之间有较强的对应关系，复杂程度比键值型数据更高，此时需要使用关系型数据库来持久化保存数据。   基本概念  谓词：数据库中用来代表数据实体的性质、特征或者数据实体之间关系的词项，主要用来定义数据库的操作条件。 结果集：指用户查询之后的结果集合，可以对数据进行访问。结果集提供了灵活的数据访问方式，可以更方便地拿到用户想要的数据。    运作机制 关系型数据库对应用提供通用的操作接口，底层使用SQLite作为持久化存储引擎，支持SQLite具有的数据库特性，包括但不限于事务、索引、视图、触发器、外键、参数化查询和预编译SQL语句。  图1 关系型数据库运作机制     约束限制  系统默认日志方式是WAL（Write Ahead Log）模式，系统默认落盘方式是FULL模式。 数据库中连接池的最大数量是4个，用以管理用户的读操作。 为保证数据的准确性，数据库同一时间只能支持一个写操作。 当应用被卸载完成后，设备上的相关数据库文件及临时文件会被自动清除。    接口说明 以下是关系型数据库持久化功能的相关接口，大部分为异步接口。异步接口均有callback和Promise两种返回形式，下表均以callback形式为例，更多接口及使用方式请见关系型数据库。     接口名称 描述    getRdbStore(context: Context, config: StoreConfig, callback: AsyncCallback<RdbStore>): void 获得一个相关的RdbStore，操作关系型数据库，用户可以根据自己的需求配置RdbStore的参数，然后通过RdbStore调用相关接口可以执行相关的数据操作。   executeSql(sql: string, bindArgs: Array<ValueType>, callback: AsyncCallback<void>):void 执行包含指定参数但不返回值的SQL语句。   insert(table: string, values: ValuesBucket, callback: AsyncCallback<number>):void 向目标表中插入一行数据。   update(values: ValuesBucket, predicates: RdbPredicates, callback: AsyncCallback<number>):void 根据RdbPredicates的指定实例对象更新数据库中的数据。   delete(predicates: RdbPredicates, callback: AsyncCallback<number>):void 根据RdbPredicates的指定实例对象从数据库中删除数据。   query(predicates: RdbPredicates, columns: Array<string>, callback: AsyncCallback<ResultSet>):void 根据指定条件查询数据库中的数据。   deleteRdbStore(context: Context, name: string, callback: AsyncCallback<void>): void 删除数据库。      开发步骤  使用关系型数据库实现数据持久化，需要获取一个RdbStore。示例代码如下所示：         Stage模型示例：        已复制import relationalStore from '@ohos.data.relationalStore'; // 导入模块 import UIAbility from '@ohos.app.ability.UIAbility';
class EntryAbility extends UIAbility {  onWindowStageCreate(windowStage) {    const STORE_CONFIG = {      name: 'RdbTest.db', // 数据库文件名      securityLevel: relationalStore.SecurityLevel.S1 // 数据库安全级别    };
    const SQL_CREATE_TABLE = 'CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB)'; // 建表Sql语句
    relationalStore.getRdbStore(this.context, STORE_CONFIG, (err, store) => {      if (err) {        console.error(`Failed to get RdbStore. Code:${err.code}, message:${err.message}`);        return;      }      console.info(`Succeeded in getting RdbStore.`);      store.executeSql(SQL_CREATE_TABLE); // 创建数据表
      // 这里执行数据库的增、删、改、查等操作
    });  }}  FA模型示例： 已复制import relationalStore from '@ohos.data.relationalStore'; // 导入模块import featureAbility from '@ohos.ability.featureAbility';
// 获取contextlet context = featureAbility.getContext();
const STORE_CONFIG = {  name: 'RdbTest.db', // 数据库文件名  securityLevel: relationalStore.SecurityLevel.S1 // 数据库安全级别};
const SQL_CREATE_TABLE = 'CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB)'; // 建表Sql语句
relationalStore.getRdbStore(context, STORE_CONFIG, (err, store) => {  if (err) {    console.error(`Failed to get RdbStore. Code:${err.code}, message:${err.message}`);    return;  }  console.info(`Succeeded in getting RdbStore.`);  store.executeSql(SQL_CREATE_TABLE); // 创建数据表
  // 这里执行数据库的增、删、改、查等操作
}); 
说明
  应用创建的数据库与其上下文（Context）有关，即使使用同样的数据库名称，但不同的应用上下文，会产生多个数据库，例如每个UIAbility都有各自的上下文。 当应用首次获取数据库（调用getRdbStore）后，在应用沙箱内会产生对应的数据库文件。使用数据库的过程中，在与数据库文件相同的目录下可能会产生以-wal和-shm结尾的临时文件。此时若开发者希望移动数据库文件到其它地方使用查看，则需要同时移动这些临时文件，当应用被卸载完成后，其在设备上产生的数据库文件及临时文件也会被移除。  
  获取到RdbStore后，调用insert()接口插入数据。示例代码如下所示：已复制const valueBucket = {  'NAME': 'Lisa',  'AGE': 18,  'SALARY': 100.5,  'CODES': new Uint8Array([1, 2, 3, 4, 5])};store.insert('EMPLOYEE', valueBucket, (err, rowId) => {  if (err) {    console.error(`Failed to insert data. Code:${err.code}, message:${err.message}`);    return;  }  console.info(`Succeeded in inserting data. rowId:${rowId}`);}) 
说明
 关系型数据库没有显式的flush操作实现持久化，数据插入即保存在持久化文件。 
  根据谓词指定的实例对象，对数据进行修改或删除。         调用update()方法修改数据，调用delete()方法删除数据。示例代码如下所示：        已复制// 修改数据const valueBucket = {  'NAME': 'Rose',  'AGE': 22,  'SALARY': 200.5,  'CODES': new Uint8Array([1, 2, 3, 4, 5])};let predicates = new relationalStore.RdbPredicates('EMPLOYEE'); // 创建表'EMPLOYEE'的predicatespredicates.equalTo('NAME', 'Lisa'); // 匹配表'EMPLOYEE'中'NAME'为'Lisa'的字段store.update(valueBucket, predicates, (err, rows) => {  if (err) {    console.error(`Failed to update data. Code:${err.code}, message:${err.message}`);    return;  }  console.info(`Succeeded in updating data. row count: ${rows}`);})
// 删除数据let predicates = new relationalStore.RdbPredicates('EMPLOYEE');predicates.equalTo('NAME', 'Lisa');store.delete(predicates, (err, rows) => {  if (err) {    console.error(`Failed to delete data. Code:${err.code}, message:${err.message}`);    return;  }  console.info(`Delete rows: ${rows}`);})   根据谓词指定的查询条件查找数据。         调用query()方法查找数据，返回一个ResultSet结果集。示例代码如下所示：        已复制let predicates = new relationalStore.RdbPredicates('EMPLOYEE');predicates.equalTo('NAME', 'Rose');store.query(predicates, ['ID', 'NAME', 'AGE', 'SALARY', 'CODES'], (err, resultSet) => {  if (err) {    console.error(`Failed to query data. Code:${err.code}, message:${err.message}`);    return;  }  console.info(`ResultSet column names: ${resultSet.columnNames}`);  console.info(`ResultSet column count: ${resultSet.columnCount}`);})  
说明
 当应用完成查询数据操作，不再使用结果集（ResultSet）时，请及时调用close方法关闭结果集，释放系统为其分配的内存。 
  删除数据库。调用deleteRdbStore()方法，删除数据库及数据库相关文件。示例代码如下： Stage模型示例： 已复制import UIAbility from '@ohos.app.ability.UIAbility';
class EntryAbility extends UIAbility {  onWindowStageCreate(windowStage) {    relationalStore.deleteRdbStore(this.context, 'RdbTest.db', (err) => {      if (err) {        console.error(`Failed to delete RdbStore. Code:${err.code}, message:${err.message}`);        return;      }      console.info('Succeeded in deleting RdbStore.');    });  }} FA模型示例： 已复制import featureAbility from '@ohos.ability.featureAbility';
// 获取contextlet context = featureAbility.getContext();
relationalStore.deleteRdbStore(context, 'RdbTest.db', (err) => {  if (err) {    console.error(`Failed to delete RdbStore. Code:${err.code}, message:${err.message}`);    return;  }  console.info('Succeeded in deleting RdbStore.');});     上一篇 通过键值型数据库实现数据持久化 下一篇 数据可靠性与安全性 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。数据可靠性与安全性 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    数据可靠性与安全性概述  数据库备份与恢复  数据库加密  基于设备分类和数据分级的访问控制   上一篇 通过关系型数据库实现数据持久化 下一篇 数据可靠性与安全性概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。功能场景基本概念数据库备份与恢复数据库加密数据库分类分级运作机制数据库备份与恢复机制数据库加密机制约束限制数据可靠性与安全性概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   功能场景 在系统运行中，存储损坏、存储空间不足、文件系统权限、系统掉电等都可能导致数据库发生故障。比如联系人应用的数据库损坏，导致用户的联系人丢失；日历应用的数据库损坏，导致丢失日历提醒等。为此数据管理提供了数据可靠性与安全性相关的解决方案和能力保障。  备份、恢复功能：重要业务应用（如银行）数据丢失，出现严重异常场景，可以通过备份恢复数据库，保证关键数据不丢失。 数据库加密功能：当数据库中存储如认证凭据、财务数据等高敏感信息时，可对数据库进行加密，提高数据库安全性。 数据库分类分级：提供基于数据安全标签和设备安全等级进行访问控制的能力，保证数据安全。  另外，备份数据库存储在应用的沙箱内，当存储空间不足时，可以选择删除本地的数据库备份，释放空间。   基本概念 在进行数据可靠性与安全性相关功能的开发前，请先了解以下相关概念。   数据库备份与恢复  数据库备份：指对当前数据库的数据库文件进行完整备份。HarmonyOS数据库备份针对数据库全量文件进行完整的备份。在进行数据库备份的时候，无需关闭数据库，直接调用对应的数据库备份接口就能完成对数据库文件的备份。 数据库恢复：从指定的备份文件恢复到当前数据库文件。恢复完成时，当前数据库数据恢复到和指定备份文件一致。    数据库加密 数据库加密是对整个数据库文件的加密，可以增强数据库的安全性，有效保护数据库内容。   数据库分类分级 分布式数据管理对数据实施分类分级保护，提供基于数据安全标签以及设备安全等级的访问控制机制。 数据安全标签和设备安全等级越高，加密措施和访问控制措施越严格，数据安全性越高。   运作机制   数据库备份与恢复机制 数据库在备份时，会将当前的数据库备份在指定的文件中，后续对数据库的操作不会影响备份的数据库文件。只有当恢复指定数据库文件时，才会将备份的数据库文件覆盖当前数据库，实现数据的回滚。  键值型数据库备份路径：/data/service/el1(el2)/public/database/...{appId}/kvdb/backup/...{storeId} 关系型数据库备份路径：/data/app/el1(el2)/100/database/...{bundlename}/rdb    数据库加密机制 HarmonyOS数据库加密时，应用开发者无需传入密钥，只需要设置数据库加密的状态即可。系统会自动帮助开发者将数据库加密，使用huks通用密钥库系统，完成数据库密钥的生成及加密保护。   约束限制  数据库加密的密钥一年自动更换一次。 键值型数据库最多可以备份5份。 键值型数据库的自动备份需要在熄屏且充电的状态下进行。    上一篇 数据可靠性与安全性 下一篇 数据库备份与恢复 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。分享方被分享方前提条件开发步骤应用间使用Want分享数据 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在应用使用场景中，用户经常需要将应用内的数据（如文字、图片等）分享至其他应用以供进一步处理。以分享PDF文件为例，本文将介绍如何使用Want来实现应用间的数据分享。 数据分享需要使用两个UIAbility组件（分享方和被分享方）以及一个系统组件（应用分享框）。当分享方使用`startAbility()`方法发起数据分享时，系统会隐式匹配所有支持接收分享数据类型的应用，并将其展示给用户以供选择。用户选择应用后，系统将启动该应用来完成数据分享操作。 在本文中，我们将使用按钮的形式触发分享操作，但实际开发中并不限于此。本文主要介绍如何配置Want以实现数据分享的功能。 本文中涉及的两个Action为：  ohos.want.action.select：用于启动应用分享框。 ohos.want.action.sendData：用于发送单个数据记录。此Action用于将数据传递给分享方应用。   分享方  为了实现数据分享功能，分享方需要先拉起应用分享框并将要分享的数据传递给被分享方应用。因此，在分享方的代码中需要嵌套使用两层Want。在第一层中，使用隐式Want和ohos.want.action.select的action来启动应用分享框。在第二层Want中，声明要传递给被分享方应用的数据。 具体来说，可以将要分享的数据放在自定义字段parameters中，然后将包含ohos.want.action.sendData的action和parameters字段的Want作为第二层Want传递给应用分享框。被分享方应用可以通过获取参数parameters来获取分享的数据。 已复制import common from '@ohos.app.ability.common';
let fileType = 'application/pdf';let fileName = 'TestFile.pdf';let fileFd = -1; // 需要获取被分享文件的FDlet fileSize; // 需要获取被分享文件的大小
function implicitStartAbility() {  let context = getContext(this) as common.UIAbilityContext;  let wantInfo = {    // This action is used to implicitly match the application selctor.    action: 'ohos.want.action.select',    // This is the custom parameter in the first layer of want    // which is intended to add info to application selector.    parameters: {      // The MIME type of pdf      'ability.picker.type': fileType,      'ability.picker.fileNames': [fileName],      'ability.picker.fileSizes': [fileSize],      // This a nested want which will be directly send to the user selected application.      'ability.want.params.INTENT': {      'action': 'ohos.want.action.sendData',      'type': 'application/pdf',      'parameters': {        'keyFd': { 'type': 'FD', 'value': fileFd }      }    }  }}context.startAbility(wantInfo).then(() => {  ...  }).catch((err) => {  ...  })} 
说明
 目前仅支持使用文件描述符（FD）格式分享数据。获取被分享文件的文件描述符和文件名，请参考文件管理相关接口。 
 在以上代码中，使用了自定义字段parameters。其中，一级参数parameters中的字段ability.picker.*用于向应用选择器传递展示信息，具体字段如下：  ability.picker.type：用于渲染相应的文件类型图标。 ability.picker.fileNames：用于展示文件名。 ability.picker.fileSizes：用于展示文件大小，单位为字节。 ability.picker.fileNames和ability.picker.fileSizes是数组，两者一一对应。  效果示意如下图所示。   被分享方 为了使分享的内容能够在被分享方识别，需要在被分享方UIAbility的module.json5配置文件中的skills标签进行相应的配置。其中，actions字段和uris内的type字段分别与分享方Want参数中ability.want.params.INTENT内的action和type字段进行匹配。  已复制{  "module": {    ...    "abilities": [    {      ...      "skills": [      {        ...        "actions": [          "action.system.home",          "ohos.want.action.sendData"          ...        ],        "uris": [        {          "type": "application/pdf"        },        ]      }      ]    }    ]  }} 当用户选择分享的应用后，嵌套在ability.want.params.INTENT字段中的Want参数将会传递给所选应用。被分享方的UIAbility被启动后，可以在其onCreate()或者onNewWant()回调中获取传入的Want参数信息。 获取到的Want参数信息示例如下，可以使用被分享文件的文件描述符（FD）进行相应操作。 已复制{  "deviceId": "",  "bundleName": "com.example.myapplication",  "abilityName": "EntryAbility",  "moduleName": "entry",  "uri": "",  "type": "application/pdf",  "flags": 0,  "action": "ohos.want.action.sendData",  "parameters": {    "component.startup.newRules": true,    "keyFd": {      "type": "FD",      "value": 36    },    "mime-type": "application/pdf",    "moduleName": "entry",    "ohos.aafwk.param.callerPid": 3488,    "ohos.aafwk.param.callerToken": 537379209,    "ohos.aafwk.param.callerUid": 20010014  },  "entities": []} 在应用使用场景中，用户经常需要将一个应用内的数据（如文字、图片等）分享至另一个应用内继续操作。下面以PDF文件分享为例，介绍应用间使用Want分享数据的方法。  前提条件  数据分享涉及2个UIAbility组件（分享方和被分享方）和1个系统部件（应用选择框）。当分享方通过startAbility接口发起数据分享后，将拉起应用选择框。其将隐式匹配并展示所有支持接受分享数据类型的应用，由用户主动选取，并由系统拉起点击应用完成数据的分享。 在本章节中，将继续以按钮形式来触发分享，实际开发场景中并不局限于此，此章节着重讲解分享时Want的配置。 本章节涉及的action：  ACTION_SELECT （ohos.want.action.select）：指示显示应用程序选择框的操作。用于拉起应用选择框。 ACTION_SEND_DATA （ohos.want.action.sendData）：指示发送单个数据记录的操作。用于传递数据至分享方。     开发步骤  分享方  Stage模型下经常会遇到需要分享文件的场景，在这种场景下我们需要使用文件描述符（FD）来传递文件。此示例中，默认已获取分享文件的路径。 已复制import fileIO from '@ohos.fileio';
// let path = ...// file open where path is a variable contains the file path.let fileFd = fileIO.openSync(path, 0o102, 0o666); 在前提条件中介绍了分享的流程。分享方需先拉起应用选择框，并将数据分享给应用选择框，并由应用选择框代理传递至被分享方，完成分享。因此分享方的Want需使用2层嵌套，在第1层中使用隐式Want并配合“ohos.want.action.select”action拉起应用选择框，并在自定义字段parameters内声明一个完整的want作为第2层，其中声明传递给被分享方的数据。 已复制import wantConstant from '@ohos.ability.wantConstant';
// let path = ...// let fileFd = ...// let fileSize = ...let want = {    // This action is used to implicitly match the application selctor.    action: wantConstant.Action.ACTION_SELECT,    // This is the custom parameter in the first layer of want    // which is intended to add info to application selector.    parameters: {        // The MIME type of pdf        "ability.picker.type": "application/pdf",        "ability.picker.fileNames": [path],        "ability.picker.fileSizes": [fileSize],        // This a nested want which will be directly send to the user selected application.                 "ability.want.params.INTENT": {            "action": "ohos.want.action.sendData",            "type": "application/pdf",            "parameters": {               "keyFd": {"type": "FD", "value": fileFd}            }        }    }} 以上代码中使用Want自定义字段paramters，其中第一层paramters中的“ability.picker.*”字段用于传递展示信息给应用选择器，具体字段表示为：  "ability.picker.type"：应用选择器根据该字段渲染相应的文件类型图标。 "ability.picker.fileNames"：应用选择器根据该字段展示文件名。 "ability.picker.fileSizes"：应用选择器根据该字段展示文件大小。以字节为单位。 "ability.picker.fileNames"与"ability.picker.fileSizes"为数组，其有一一对应关系。  例如：当"ability.picker.type"为“application/pdf”，"ability.picker.fileNames"为“["接口文档.pdf"]”，"ability.picker.fileSizes"为“[350 * 1024]”时，应用选择器将以下形式展示。  示例代码中“ability.want.params.INTENT”字段是一个嵌套Want，内部所含action、type等字段将由应用选择器进行隐式匹配，具体隐式匹配规则可参考隐式Want匹配原理详解。当用户选择具体应用后，“ability.want.params.INTENT”字段的嵌套Want将传递至所选应用。  被分享方：  上文中提到，应用选择器通过“ability.want.params.INTENT”字段进行隐式匹配。因此被分享方Ability配置文件内（stage模型下的module.json5）skills字段需配置如下。 已复制"skills": [  {    "entities": [      // ...    ],    "actions": [        "ohos.want.action.sendData"        // ...    ],    "uris": [      {        "type": "application/pdf"      },      // ...    ]  },] 其中"actions"字段和“uris”内“type”字段分别与“ability.want.params.INTENT”内“action”，“type”字段匹配。 注意：当前文件传递不支持uri方式传递，仅支持FD方式，但隐式匹配中，Want内的“type”字段需与被分享方配置文件skills内“uris”字段下的“type”字段匹配，因此skills内的“uris”字段建议只声明“type”字段，增加“host”，“port”等字段在上述示例中将匹配失败。因为应用选择框通过“ability.want.params.INTENT”发起隐式匹配，所以在“ability.want.params.INTENT”字段内增加uri字段，且与skills内的“uris”字段匹配时，仍可匹配成功且传递额外数据。 应用选择器拉起被分享方后，系统将调用其“onCreate”接口，并传入“ability.want.params.INTENT”至其入参want内。 已复制onCreate(want, launchParam) {  // note when keyFd is undefined, app crash will happen.  if (want["parameters"]["keyFd"] !== undefined) {    // receive file descriptor    let fd = want["parameters"]["keyFd"].value;    // ...  }}     上一篇 使用隐式Want打开网址 下一篇 进程模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。URI介绍部分配置项介绍DataAbility组件配置 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   URI介绍 DataAbility的提供方和使用方都通过URI（Uniform Resource Identifier）来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。HarmonyOS的URI仍基于URI通用标准，格式如下：   scheme：协议方案名，固定为"dataability"，代表Data Ability所使用的协议类型。 authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。 path：资源的路径信息，代表特定资源的位置信息。 query：查询参数。 fragment：可以用于指示要访问的子资源。  URI示例：  跨设备场景：dataability://device_id/com.domainname.dataability.persondata/person/10 本地设备：dataability:///com.domainname.dataability.persondata/person/1  
说明
 本地设备的"device_id"字段为空，因此在"dataability:"后面有三个"/"。 
   部分配置项介绍 与PageAbility类似，DataAbility的相关配置在config.json配置文件的"module"对象的"abilities"对象中，与PageAbility的区别在于"type"属性及"uri"属性。 表1 DataAbility的部分配置项说明     Json重要字段 备注说明    "name" Ability名称。   "type" UIAbility类型，DataAbility的类型为"data"。   "uri" 通信使用的URI。   "visible" 对其他应用是否可见，设置为true时，DataAbility才能与其他应用进行通信传输数据。    config.json配置样例 已复制"abilities": [{  "srcPath": "DataAbility",  "name": ".DataAbility",  "icon": "$media:icon",  "srcLanguage": "ets",  "description": "$string:description_dataability",  "type": "data",  "visible": true,  "uri": "dataability://ohos.samples.etsdataability.DataAbility"}] DataAbility支持的配置项及详细说明详见module对象内部结构。   上一篇 DataAbility组件概述 下一篇 DataAbility的生命周期 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。DataAbility的生命周期 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 应用开发者可以根据业务场景重写生命周期相关接口。DataAbility生命周期接口说明见下表。  表1 DataAbility相关生命周期API功能介绍 接口名 描述   onInitialized?(info: AbilityInfo): void 在Ability初始化调用，通过此回调方法执行RDB等初始化操作。  update?(uri: string, valueBucket: rdb.ValuesBucket, predicates: dataAbility.DataAbilityPredicates, callback: AsyncCallback<number>): void 更新数据库中的数据。  query?(uri: string, columns: Array<string>, predicates: dataAbility.DataAbilityPredicates, callback: AsyncCallback<ResultSet>): void 查询数据库中的数据。  delete?(uri: string, predicates: dataAbility.DataAbilityPredicates, callback: AsyncCallback<number>): void 删除一条或多条数据。  normalizeUri?(uri: string, callback: AsyncCallback<string>): void 对URI进行规范化。一个规范化的URI可以支持跨设备使用、持久化、备份和还原等，当上下文改变时仍然可以引用到相同的数据项。  batchInsert?(uri: string, valueBuckets: Array<rdb.ValuesBucket>, callback: AsyncCallback<number>): void 向数据库中插入多条数据。  denormalizeUri?(uri: string, callback: AsyncCallback<string>): void 将一个由normalizeUri生产的规范化URI转换成非规范化的URI。  insert?(uri: string, valueBucket: rdb.ValuesBucket, callback: AsyncCallback<number>): void 向数据中插入一条数据。  openFile?(uri: string, mode: string, callback: AsyncCallback<number>): void 打开一个文件。  getFileTypes?(uri: string, mimeTypeFilter: string, callback: AsyncCallback<Array<string>>): void 获取文件的MIME类型。  getType?(uri: string, callback: AsyncCallback<string>): void 获取URI指定数据相匹配的MIME类型。  executeBatch?(ops: Array<DataAbilityOperation>, callback: AsyncCallback<Array<DataAbilityResult>>): void 批量操作数据库中的数据。  call?(method: string, arg: string, extras: PacMap, callback: AsyncCallback<PacMap>): void 自定义方法。     上一篇 DataAbility组件配置 下一篇 创建DataAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。DataAbility组件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 DataAbility，即"使用Data模板的Ability"，主要用于对外部提供统一的数据访问抽象，不提供用户交互界面。DataAbility可由PageAbility、ServiceAbility或其他应用启动，即使用户切换到其他应用，DataAbility仍将在后台继续运行。 使用DataAbility有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。DataAbility既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。 数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。DataAbility对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供。  上一篇 DataAbility组件开发指导 下一篇 DataAbility组件配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。静态权限控制动态权限控制DataAbility权限控制 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 DataAbility提供数据服务，并不是所有的Ability都有权限读写它，DataAbility有一套权限控制机制来保证数据安全。分为静态权限控制和动态权限控制两部分。 静态权限控制DataAbility作为服务端，在被拉起的时候，会根据config.json里面配置的权限来进行校验，有"readPermission"、"writePermission"和"Permission"三个配置项，可以不配或者为空。示例如下: 已复制"abilities": [{  "srcPath": "DataAbility",  "name": ".DataAbility",  "icon": "$media:icon",  "srcLanguage": "ets",  "description": "$string:description_dataability",  "type": "data",  "visible": true,  "uri": "dataability://ohos.samples.etsdataability.DataAbility",  "readPermission":"ohos.permission.READ_CONTACTS",  "writePermission":"ohos.permission.WRITE_CONTACTS"}] 客户端在拉起DataAbility的时候，需要校验客户端是否有权限拉起该DataAbility。客户端的权限配置在config.json配置文件的"module"对象的"reqPermissions"对象中，示例如下： 已复制{  "module": {    "reqPermissions":[      {        "name": "ohos.permission.READ_CONTACTS"      },      {        "name": "ohos.permission.WRITE_CONTACTS"      }    ]  }}  动态权限控制静态权限校验只能控制某个DataAbility是否能被另一个Ability或应用拉起，无法精确校验每个读写接口的权限，因为拉起DataAbility的时候，还不知道应用是否需要读写它的数据。 动态权限控制是校验每个数据操作的接口是否有对应的权限。客户端调用数据操作接口所需的权限如下表所示。 表1 接口对应的读写权限配置 需要配置读权限的接口  需要配置写权限的接口  据实际操作配置读写权限的接口    query、normalizeUri、denormalizeUri、openfile（传入mode有'r'）  insert、batchInsert、delete、update、openfile（传入mode有'w'）  executeBatch     对于需要配置读权限的接口，服务端需要配置readPermission，客户端必须申请相应的读权限才能调用相关的接口。 对于需要配置写权限的接口，服务端需要配置writePermission，客户端必须申请相应的写权限才能调用相关的接口。   上一篇 访问DataAbility 下一篇 服务卡片开发指导（FA模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。当前值可视化连续变化值可视化变量可视化操作指导变量可视化调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在HarmonyOS应用/服务调试过程中，查看变量的变化过程是否符合预期结果是一项常用的调试方法。为此DevEco Studio提供了调试变量的可视化功能，支持Java、C/C++、JS和ArkTS语言的基本数据类型、数值类型的集合和表达式可视化调试，并以Plain（树形）、Line（折线图） 、Bar（柱状图）和Table（表格）的形式呈现。开发者可以根据这些图形化界面观察当前值、数据类型以及数值的连续变化，通过查看、比对、分析当前变量的变化过程和逻辑关系，判断出当前值（变量）是否符合预期结果，从而迅速有效的定位问题。变量可视化支持当前值可视化和连续变化值可视化两种方式。 当前值可视化当前值可视化：通过解析Debugger当前帧的信息，获取指定变量当前栈帧中的值，以Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）方式进行可视化展示。当前值可视化每次只能观察一个变量，开发者可以根据需要切换变量进行观察。 Plain（树形）显示结果示意图  Line（折线图）显示结果示意图  Bar（柱状图）显示结果示意图  Table（表格）显示结果示意图  支持的数据类型包括基本类型（包括基本数据类型和基本数据类型的包装类）、基本类型的集合和表达式（结果为基本数据类型和基本数据类型的包装类）。其中： Java支持的呈现形式如下表所示： 数据类型  支持的展示类型    数值类型：byte、short、int、long、float、double基本数值类型及其包装类型等  Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）   字符类型：char及其包装类、String等  Plain（树形）和Table（表格）   布尔类型：boolean及其包装类  Plain（树形）和Table（表格）   包含数值类型的集合或一维数组：List、vector、set等  Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）   一维对象、键值对map和数值/字符/布尔类型的集合或数组  Plain（树形）和Table（表格）   其它  Plain（树形）     C/C++支持的呈现形式如下表所示： 数据类型  支持的展示类型    数值类型：int、float、double（或者指定大小的类型如int32_t、int64_t）和signed、unsigned、short、long等的组合  Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）   字符类型：char16_t、char32_t、wchar_t等  Plain（树形）和Table（表格）   布尔类型：bool  Plain（树形）和Table（表格）   包含数值类型的集合List、vector、set等  Plain（树形）和Table（表格）   包含数值类型的一维数组  Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）   一维对象、键值对map和数值/字符/布尔类型的集合或数组  Plain（树形）和Table（表格）   其它  Plain（树形）     C/C++可视化功能说明： 如果观察的变量在当前断点之后，则会提示“Variable not initialized”。如果全局静态变量在代码块中未使用，则会提示“error: <user expression 3>:1:1: use of undeclared... ”。如果在全局非静态变量和局部变量中存在同名变量名，则在添加C/C++全局非静态变量时，需要以“::变量名”方式添加，才能正常观察其值。 JS\ArkTS支持的呈现形式如下表所示： 数据类型  支持的展示类型    数值类型：number  Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）   字符类型：string  Plain（树形）和Table（表格）   布尔类型：boolean  Plain（树形）和Table（表格）   一维数值类型的数组：array  Plain（树形）、Line（折线图）、Bar（柱状图）和Table（表格）   一维对象、null和undefined  Plain（树形）和Table（表格）   其它  Plain（树形）     JS\ArkTS可视化功能说明： JS\ArkTS语法定义变量不区分数据类型，因此，可视化功能会依据数据结果进行智能识别。例如，array集合识别为数值集合，则支持Plain、Line、Bar和Table；如果识别为字符集合，则只支持Plain和Table。针对LiteWearable和Smart Vision设备，如果变量在调试变量栏的local中存在，则可视化结果与local中该变量的结果保持一致；如果在local中不存在该变量，则显示结果为Object，如下图中的变量object，在local中存在，则以local中的取值为准。    连续变化值可视化连续变化值可视化：通过折线图的方式，可以同时显示多个变量的连续变化过程，以及变量之间的关系。连续变化值可视化，只支持基本数值类型的数据可视化。 下面以Java语言的变量可视化为例进行说明。  在连续变化值可视化中，会呈现所有变量的连续变化结果，其中横坐标为断点命中clock，纵坐标为变量值，从添加观察变量的clock开始记录变量值的连续变化。在图中，圆圈符号表示支持（只有数值类型支持）连续变化值可视化，三角符号表示不支持。在图中如果有多个变量的连续变化图，为方便查看其中指定的变量的变化趋势，避免非观察变量带来的影响，开发者可以点击图形上方的变量名，将其设置为灰色，这样就可以在坐标图中隐藏该变量，再次点击灰色的变量名，则在坐标图中呈现出该变量的连续变化值。 
说明
横坐标记录范围最大为100，超过100后，则从1开始清除前面的数据。 
  另外，在连续变化值可视化中，可以点击clock节点，会自动跳转到对应值的代码行（断点位置），并且会高亮显示代码行和clock时钟，如下图所示：   变量可视化操作指导Java、C/C++、JS、ArkTS调试变量可视化的操作相同。 在待调试的源代码中打上断点，并启动调试功能。打开变量可视化调试窗口，可通过在编辑器或者调试变量栏窗口中，选中变量，点击鼠标右键，选中“Add to Visual Watches”，自动将该变量添加到可视化窗口中。
说明
变量可视化功能最多同时支持10个变量。如果超过10个变量，请在“Observed Variable”下拉列表中，删除正在显示的变量后添加。 
 查看变量的当前值和连续变化值。   上一篇 调试OpenHarmony应用/服务 下一篇 堆栈可视化调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用/服务调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    调试HarmonyOS应用/服务  调试OpenHarmony应用/服务  变量可视化调试  堆栈可视化调试  Release应用堆栈解析  C/C++时光调试  Hot Reload  跨设备应用/服务调试  打印日志  C/C++内存错误检测   上一篇 运行OpenHarmony应用/服务运行 下一篇 调试HarmonyOS应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。DevEco Studio使用指南 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    工具简介  快速开始  工程管理  应用/服务开发  编译构建  应用/服务运行  应用/服务调试  性能分析  应用/服务测试  HarmonyOS应用/服务发布  命令行工具  附录   下一篇 工具简介 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述应用/服务开发流程文档声明工具简介 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
该文档匹配DevEco Studio 3.1.1 Release版本。 
 概述HUAWEI DevEco Studio（获取工具请单击链接下载，以下简称DevEco Studio）是基于IntelliJ IDEA Community开源版本打造，为运行在HarmonyOS和OpenHarmony系统上的应用和服务（以下简称应用/服务）提供一站式的开发平台。 作为一款开发工具，除了具有基本的代码开发、编译构建及调测等功能外，DevEco Studio还具有如下特点： 高效智能代码编辑：支持ArkTS、JS、C/C++等语言的代码高亮、代码智能补齐、代码错误检查、代码自动跳转、代码格式化、代码查找等功能，提升代码编写效率。更多详细信息，请参考编辑器使用技巧。低代码可视化开发：丰富的UI界面编辑能力，支持自由拖拽组件和可视化数据绑定，可快速预览效果，所见即所得；同时支持卡片的零代码开发，降低开发门槛和提升界面开发效率。更多详细信息，请参考使用低代码开发应用/服务。多端双向实时预览：支持UI界面代码的双向预览、实时预览、动态预览、组件预览以及多端设备预览，便于快速查看代码运行效果。更多详细信息，请参考使用预览器预览应用/服务界面效果。多端设备模拟仿真：提供HarmonyOS本地模拟器，支持手机等设备的模拟仿真，便捷获取调试环境。更多详细信息，请参考使用模拟器运行应用/服务。  应用/服务开发流程使用DevEco Studio，只需要按照如下几步，即可轻松开发并上架一个应用/服务到华为应用市场。  一、开发准备 下载HUAWEI DevEco Studio，完成开发工具的安装。开发工具安装完成后，还需要设置开发环境，对于绝大多数开发者来说，直接下载SDK即可启动开发；只有少部分开发者，如在企业内部访问Internet受限，需要设置对应的代理服务器才能下载SDK。具体操作请参考配置开发环境。 二、开发应用/服务 DevEco Studio集成了手机、智慧屏、智能穿戴等设备的典型场景模板，可以通过工程向导轻松的创建一个新的工程。 接下来还需要定义应用/服务的UI、开发业务功能等编码工作，可以根据HarmonyOS应用开发概述来查看具体的开发过程，通过查看API接口文档查阅需要调用的API接口。 在开发代码的过程中，可以使用预览器查看应用/服务效果，支持实时预览、动态预览、双向预览等功能，使编码的过程更高效。 三、运行、调试和测试应用/服务 应用/服务开发完成后，可以使用真机进行调试（需要申请调测证书进行签名）或者使用模拟器进行调试，支持单步调试、跨设备调试、跨语言调试、变量可视化等调试手段，使得应用/服务调试更加高效。 HarmonyOS应用/服务开发完成后，在发布到应用/服务市场前，还需要对应用进行测试，主要包括漏洞、隐私、兼容性、稳定性、性能等进行测试，确保HarmonyOS应用/服务纯净、安全，给用户带来更好的使用体验。 四、发布应用/服务 HarmonyOS应用/服务开发、测试完成后，需要将应用/服务发布至应用市场，以便应用市场对应用/服务进行分发，普通消费者可以通过应用市场或服务中心获取到对应的HarmonyOS应用/服务。需要注意的是，发布到华为应用市场或服务中心的HarmonyOS应用/服务，必须使用应用市场颁发的发布证书进行签名。  文档声明HUAWEI DevEco Studio使用指南配套DevEco Studio 3.1.1 Release最新版本。如使用DevEco Studio其它版本，可能存在文档与产品功能界面、操作不一致的情况，请以实际功能界面为准。   上一篇 DevEco Studio使用指南 下一篇 快速开始 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。DevEco Service使用指南 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     业务介绍  DevEco低代码  HarmonyOS应用安全测试  HarmonyOS应用云测试  HarmonyOS应用远程真机测试   上一篇 DevEco Studio配置参数列表 下一篇 业务介绍 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。deviceConfig对象内部结构deviceConfig设备对象内部结构network对象的内部结构securityConfig对象的内部结构domainSettings对象内部结构deviceConfig内部结构 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 deviceConfig包含设备上的应用配置信息，可以包含default、tv、car、wearable等属性。default标签内的配置适用于所有通用设备，其他设备类型如果有特殊的需求，则需要在该设备类型的标签下进行配置。 deviceConfig对象内部结构表1 deviceConfig对象内部结构说明 属性名称  含义  数据类型  是否可缺省    default  能够使用全部系统能力的HarmonyOS设备。  对象  可缺省，缺省值为空。   tablet  标识平板特有的应用配置信息。  对象  可缺省，缺省值为空。   tv  标识智慧屏特有的应用配置信息。  对象  可缺省，缺省值为空。   car  标识车机特有的应用配置信息。  对象  可缺省，缺省值为空。   wearable  标识智能穿戴特有的应用配置信息。  对象  可缺省，缺省值为空。     上表中各类设备对象的内部结构说明请见表2。  deviceConfig设备对象内部结构表2 deviceConfig设备对象内部结构说明 属性名称  含义  数据类型  是否可缺省    process  标识应用或者Ability的进程名。如果在deviceConfig标签下配置了process标签，则该应用的所有Ability都运行在这个进程中。如果在abilities标签下也为某个Ability配置了process标签，则该Ability就运行在这个进程中。该标签最大长度为31。  字符串  可缺省，缺省值为空。   keepAlive  标识应用是否始终保持运行状态，仅支持系统应用配置，三方应用配置不生效。该标签为布尔类型，可缺省，缺省值为false，如果配置为true，应用将始终保持为运行状态，并在系统启动的时候被系统驱动起来，应用进程退出后，系统也会重新启动应用进程。  布尔值  可缺省，缺省值为false。   supportBackup  标识应用是否支持备份和恢复。如果配置为"false"，则不支持为该应用执行备份或恢复操作。  布尔值  可缺省，缺省值为false。   compressNativeLibs  标识libs库是否以压缩存储的方式打包到HAP。如果配置为"false"，则libs库以不压缩的方式存储，HAP在安装时无需解压libs，运行时会直接从HAP内加载libs库。  布尔值  可缺省，缺省值为true。   network  标识网络安全性配置。该标签允许应用通过配置文件的安全声明来自定义其网络安全，无需修改应用代码。  对象  可缺省，缺省值为空。      network对象的内部结构表3 network对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    cleartextTraffic  标识是否允许应用使用明文网络流量（例如，明文HTTP）。 true：允许应用使用明文流量的请求。false：拒绝应用使用明文流量的请求。  布尔值  可缺省，缺省值为false。   securityConfig  标识应用的网络安全配置信息。  对象  可缺省，缺省为空。      securityConfig对象的内部结构表4 securityConfig对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    domainSettings  标识自定义的网域范围的安全配置，支持多层嵌套，即一个domainSettings对象中允许嵌套更小网域范围的domainSettings对象。  对象类型  可缺省，缺省为空。      domainSettings对象内部结构表5 domainSettings对象内部结构说明 属性名称  含义  数据类型  是否可缺省    cleartextPermitted  标识自定义的网域范围内是否允许明文流量传输。当cleartextTraffic和security同时存在时，自定义网域是否允许明文流量传输以cleartextPermitted的取值为准。true：允许明文流量传输。false：拒绝明文流量传输。  布尔类型  可缺省，缺省值为空。   domains  标识域名配置信息，包含两个参数：subdomains和name。subdomains(布尔类型)：表示是否包含子域名。如果为"true"，此网域规则将与相应网域及所有子网域（包括子网域的子网域）匹配。否则，该规则仅适用于精确匹配项。name(字符串)：表示域名名称。  对象数组  可缺省，缺省值为空。     deviceConfig示例 已复制"deviceConfig": {  "default": {    "process": "com.example.test.example",    "supportBackup": false,    "network": {      "cleartextTraffic": true,      "securityConfig": {        "domainSettings": {          "cleartextPermitted": true,          "domains": [            {              "subdomains": true,              "name": "example.ohos.com"            }          ]        }      }    }  }}   上一篇 app对象内部结构 下一篇 module对象内部结构 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用本地真机运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    在Phone和Tablet中运行应用/服务  在Car中运行应用/服务  在TV中运行应用/服务  在Wearable中运行应用/服务  在Lite Wearable中运行应用/服务  在Smart Vision设备中运行应用/服务  在Router中运行应用/服务   上一篇 运行HarmonyOS应用/服务 下一篇 在Phone和Tablet中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。工程模板和开发语言介绍 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持多种品类的应用/服务开发，预置丰富的工程模板，可以根据工程向导轻松创建适应于各类设备的工程，并自动生成对应的代码和资源模板。同时，DevEco Studio还提供了多种编程语言供开发者进行应用/服务开发，包括ArkTS、JS和C/C++。   工程模板支持的开发语言、API版本、设备类型，如下表所示： 模板名称  支持的开发语言  支持的API版本  支持的设备  说明    Empty Ability  JS     4、5、6  Phone、Tablet、TV、Wearable  用于Phone、Tablet、TV、Wearable设备的Feature Ability模板，展示了基础的Hello World功能。   7  Phone   8  Phone、Wearable   9  Phone、Tablet   ArkTS   8  Phone   9  Phone、Tablet   Java   4、5、6  Phone、Tablet、TV、Wearable、Car   7  Phone   Native C++  Java   4、5、6  Phone、Car  用于Phone、Tablet、Car设备的Feature Ability模板，作为应用/服务调用C++代码的示例工程，界面显示“Hello World”。   7  Phone   JS   8  Phone   9  Phone、Tablet   ArkTS  8  Phone   9  Phone、Tablet   [Lite]Empty Ability   JS   4、5、6  Lite Wearable、Smart Vision、Router  用于Lite Wearable、Smart Vision、Router设备的Feature Ability模板，包含一个简单的Hello World文本。该模板包含两个组件：div和text，同时演示了数据绑定的使用方式。使用该模板时，不能同时选择多个设备，即不能创建跨设备工程。    7、8  Lite Wearable   About Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的关于页面。模板的上方通过基础组件Image、Text展示了应用的基本信息，点击中间的List组件可以打开详情页，下方使用Web组件加载了用户协议和隐私声明的Html文件。开发者可以在模板的基础上，补充List内容，替换相关显示信息。   Business Card Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的名片页面。模板底部通过Tab组件实现不同名片的切换，中间的详情List组件使用了不同的Widget，如Information图标、Switch开关、右侧箭头图标等。开发者可以根据需要替换用户名称和List组件内容。   Category Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的分类展示页面。模板上方是Navigation组件和search组件，下方是Tab组件。中间的List组件有联动，点击左边List的分类项，右边List会滑动到对应位置，反之亦然。开发者可以根据需要替换相关内容。   Category List Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的卡片型设置页面。模板上方是Navigation组件和search组件，中间的List组件参考Settings的界面风格，由子标题加List卡片组成。开发者可以根据需要替换标题和每一个设置项的内容。   Grid Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的网格布局页面。模板上方是Navigation组件，中间分割成两个大小不同的Grid组件，每个Grid组件的Item等比例显示。开发者可以通过模板学习Grid组件的使用方式。   List Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的列表页面。模板上方是Navigation组件和search组件，下方是Tab组件。中间的List组件使用了双行布局，点击打开详情页。开发者可以根据需要替换双行列表和辅助文本内容。   Login Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的登录页面。用户输入账号和密码之后，才能点击登录按钮。点击登录、注册和遇到问题分别会跳转到示例页面。模板底部使用Web组件加载了隐私声明的Html文件。开发者可以补充账号密码的存储逻辑，完善登录功能。   Splash Screen Ability  ArkTS  9  Phone、Tablet  用于Phone、Tablet设备的模板，可以快速创建应用的启动过程页面。模板右上角显示倒计时图标，点击跳过按钮或者等倒计时结束都会进入应用主界面，下方提供了应用的版权信息。开发者可以设置倒计时时间，根据需要整体替换广告背景。   Empty Ability with CloudDev  ArkTS  9  Phone  端云一体化开发通用模板。更多信息请参见端云一体化。      上一篇 工程介绍 下一篇 创建一个新的工程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。分布式文件系统 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    分布式文件系统概述  设置分布式文件数据等级  跨设备文件访问   上一篇 保存用户文件 下一篇 分布式文件系统概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。分布式文件系统架构分布式文件系统概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  分布式文件系统（hmdfs，HarmonyOS Distributed File System）提供跨设备的文件访问能力，适用于如下场景：  两台设备组网，用户可以利用一台设备上的编辑软件编辑另外一台设备上的文档。 平板保存的音乐，车载系统直接可见并可播放。 户外拍摄的照片，回家打开平板直接访问原设备拍摄的照片。  hmdfs在分布式软总线动态组网的基础上，为网络上各个设备结点提供一个全局一致的访问视图，支持开发者通过基础文件系统接口进行读写访问，具有高性能、低延时等优点。  分布式文件系统架构   distributedfile_daemon：主要负责设备上线监听、通过软总线建立链路，并根据分布式的设备安全等级执行不同的数据流转策略。 hmdfs：实现在内核的网络文件系统，包括缓存管理、文件访问、元数据管理和冲突管理等。        缓存管理          设备分布式组网后，hmdfs提供文件的互访能力，但不会主动进行文件数据传输和拷贝。如果应用需要将数据保存到本地，需主动拷贝。 hmdfs保证Close-to-Open的一致性，即一端写关闭后，另外一端可以读取到最新数据，不保证文件内容的实时一致性。 数据在远端写入，但是由于网络原因未及时回刷，文件系统会在下次网络接入时回刷本地，但是如果远端已修改则无法回刷。  文件访问          文件访问接口与本地一致（ohos.file.fs）。 如果文件在本地，则堆叠访问本地文件系统。 如果文件在其他设备，则同步网络访问远端设备文件。           
说明
 symlink：不支持。 
  元数据管理          分布式组网下，文件一端创建、删除、修改，另一端可以“立即”查看到最新文件，看到速度取决于网络情况。 远端设备离线后，该设备数据将不再在本端设备呈现。但由于设备离线的感知具有延迟，可能会造成部分消息4s超时，因此开发者需要考虑接口的网络超时或一些文件虽然可以看到，但实际设备可能已离线的场景。  冲突处理          本地与远端冲突 ，远端文件被重命名，看到的同名文件是本地同名文件，远端文件被重命名。 远端多个设备冲突，以接入本设备ID为顺序，显示设备ID小的同名文件，其他文件被依次重命名。 如果组网场景，目录树下已经有远端文件，创建同名文件，提示文件已存在。 冲突文件显示_conflict_dev后依次加id，id从1自动递增。 同名目录之间仅融合不存在冲突，文件和远端目录同名冲突，远端目录后缀加_remote_directory。      上一篇 分布式文件系统 下一篇 设置分布式文件数据等级 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明2D图形绘制开发步骤文本绘制开发步骤Drawing开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 Native Drawing模块提供了一系列的接口用于基本图形和字体的绘制。常见的应用场景举例：  2D图形绘制。 文本绘制。    接口说明     接口名 描述    OH_Drawing_BitmapCreate (void) 创建一个位图对象。   OH_Drawing_BitmapBuild (OH_Drawing_Bitmap *, const uint32_t width, const uint32_t height, const OH_Drawing_BitmapFormat *) 初始化位图对象的宽度和高度，并且为该位图设置像素格式。   OH_Drawing_CanvasCreate (void) 创建一个画布对象。   OH_Drawing_CanvasBind (OH_Drawing_Canvas *, OH_Drawing_Bitmap *) 将一个位图对象绑定到画布中，使得画布绘制的内容输出到位图中（即CPU渲染）。   OH_Drawing_CanvasAttachBrush (OH_Drawing_Canvas *, const OH_Drawing_Brush *) 设置画刷给画布，画布将会使用设置的画刷样式和颜色去填充绘制的图形形状。   OH_Drawing_CanvasAttachPen (OH_Drawing_Canvas *, const OH_Drawing_Pen *) 设置画笔给画布，画布将会使用设置画笔的样式和颜色去绘制图形形状的轮廓。   OH_Drawing_CanvasDrawPath (OH_Drawing_Canvas *, const OH_Drawing_Path *) 画一个自定义路径。   OH_Drawing_PathCreate (void) 创建一个路径对象。   OH_Drawing_PathMoveTo (OH_Drawing_Path *, float x, float y) 设置自定义路径的起始点位置。   OH_Drawing_PathLineTo (OH_Drawing_Path *, float x, float y) 添加一条到目标点的线段。   OH_Drawing_PathClose (OH_Drawing_Path *) 闭合路径，会添加一条到路径起点位置的线段。   OH_Drawing_PenCreate (void) 创建一个画笔对象。   OH_Drawing_PenSetAntiAlias (OH_Drawing_Pen *, bool) 设置抗锯齿属性，如果为真则说明画笔会启用抗锯齿功能，在绘制图形时会对图形的边缘像素进行半透明的模糊处理。   OH_Drawing_PenSetWidth (OH_Drawing_Pen *, float width) 设置画笔的厚度属性，厚度属性描述了画笔绘制图形轮廓的宽度。   OH_Drawing_BrushCreate (void) 创建一个画刷对象。   OH_Drawing_BrushSetColor (OH_Drawing_Brush *, uint32_t color) 设置画刷的颜色属性，颜色属性描述了画刷填充图形时使用的颜色，用一个32位（ARGB）的变量表示。   OH_Drawing_CreateTypographyStyle (void) 创建一个排版对象，用于定义排版样式。   OH_Drawing_CreateTextStyle (void) 创建一个文本对象，用于定义文本样式。   OH_Drawing_TypographyHandlerAddText (OH_Drawing_TypographyCreate *, const char *) 设置文本内容。   OH_Drawing_TypographyPaint (OH_Drawing_Typography *, OH_Drawing_Canvas *, double, double) 显示文本。    详细的接口说明请参考Drawing。   2D图形绘制开发步骤 以下步骤描述了如何使用 Native Drawing 模块的画布画笔绘制一个基本的2D图形：  创建Bitmap实例。使用 drawing_bitmap.h 的 OH_Drawing_BitmapCreate 接口创建一个Bitmap实例 cBitmap，并使用 OH_Drawing_BitmapBuild 指定其长宽大小和像素格式。 已复制// 创建一个bitmap对象OH_Drawing_Bitmap* cBitmap = OH_Drawing_BitmapCreate();// 定义bitmap的像素格式OH_Drawing_BitmapFormat cFormat {COLOR_FORMAT_RGBA_8888, ALPHA_FORMAT_OPAQUE};// 构造对应格式的bitmapOH_Drawing_BitmapBuild(cBitmap, width, height, &cFormat); 创建画布实例。使用 drawing_canvas.h 的 OH_Drawing_CanvasCreate 接口创建一个画布实例 cCanvas，并使用 OH_Drawing_CanvasBind 接口将 cBitmap 实例绑定到 cCanvas 上，后续在画布上绘制的内容会输出到绑定的 cBitmap 实例中。 已复制// 创建一个canvas对象OH_Drawing_Canvas* cCanvas = OH_Drawing_CanvasCreate();// 将画布与bitmap绑定，画布画的内容会输出到绑定的bitmap内存中OH_Drawing_CanvasBind(cCanvas, cBitmap);// 使用白色清除画布内容OH_Drawing_CanvasClear(cCanvas, OH_Drawing_ColorSetArgb(0xFF, 0xFF, 0xFF, 0xFF)); 构造Path形状。使用 drawing_path.h 提供的接口完成一个五角星形状的构造 cPath。 已复制int len = 300;
float aX = 500;float aY = 500;
float dX = aX - len * std::sin(18.0f);float dY = aY + len * std::cos(18.0f);
float cX = aX + len * std::sin(18.0f);float cY = dY;
float bX = aX + (len / 2.0);float bY = aY + std::sqrt((cX - dX) * (cX - dX) + (len / 2.0) * (len / 2.0));
float eX = aX - (len / 2.0);float eY = bY;
// 创建一个path对象，然后使用接口连接成一个五角星形状OH_Drawing_Path* cPath = OH_Drawing_PathCreate();// 指定path的起始位置OH_Drawing_PathMoveTo(cPath, aX, aY);// 用直线连接到目标点OH_Drawing_PathLineTo(cPath, bX, bY);OH_Drawing_PathLineTo(cPath, cX, cY);OH_Drawing_PathLineTo(cPath, dX, dY);OH_Drawing_PathLineTo(cPath, eX, eY);// 闭合形状，path绘制完毕OH_Drawing_PathClose(cPath); 设置画笔和画刷样式。使用 drawing_pen.h 的 OH_Drawing_PenCreate 接口创建一个画笔实例 cPen, 并设置抗锯齿、颜色、线宽等属性，画笔用于形状边框线的绘制。使用drawing_brush.h 的 OH_Drawing_BrushCreate 接口创建一个画刷实例 cBrush, 并设置填充颜色， 画刷用于形状内部的填充。使用 drawing_canvas.h 的 OH_Drawing_CanvasAttachPen 和 OH_Drawing_CanvasAttachBrush 接口将画笔画刷的实例设置到画布实例中。 已复制// 创建一个画笔Pen对象，Pen对象用于形状的边框线绘制OH_Drawing_Pen* cPen = OH_Drawing_PenCreate();OH_Drawing_PenSetAntiAlias(cPen, true);OH_Drawing_PenSetColor(cPen, OH_Drawing_ColorSetArgb(0xFF, 0xFF, 0x00, 0x00));OH_Drawing_PenSetWidth(cPen, 10.0);OH_Drawing_PenSetJoin(cPen, LINE_ROUND_JOIN);// 将Pen画笔设置到canvas中OH_Drawing_CanvasAttachPen(cCanvas, cPen);
// 创建一个画刷Brush对象，Brush对象用于形状的填充OH_Drawing_Brush* cBrush = OH_Drawing_BrushCreate();OH_Drawing_BrushSetColor(cBrush, OH_Drawing_ColorSetArgb(0xFF, 0x00, 0xFF, 0x00));
// 将Brush画刷设置到canvas中OH_Drawing_CanvasAttachBrush(cCanvas, cBrush); 绘制Path形状。使用 drawing_canvas.h 的 OH_Drawing_CanvasDrawPath 接口将五角星绘制到画布上，绘制完毕后不再使用的实例需要调用对应的接口进行销毁。 已复制// 在画布上画path的形状，五角星的边框样式为pen设置，颜色填充为Brush设置OH_Drawing_CanvasDrawPath(cCanvas, cPath);// 销毁创建的对象OH_Drawing_BrushDestroy(cBrush);OH_Drawing_PenDestroy(cPen);OH_Drawing_PathDestroy(cPath); 获取像素数据。使用 drawing_bitmap.h 的 OH_Drawing_BitmapGetPixels 接口获取到画布绑定bitmap实例的像素地址，该地址指向的内存包含画布刚刚绘制的像素数据。 已复制// 画完后获取像素地址，地址指向的内存包含画布画的像素数据void* bitmapAddr = OH_Drawing_BitmapGetPixels(cBitmap);std::copy(addr, addr + addrSize, static_cast<uint8_t*>(bitmapAddr));// 销毁canvas对象OH_Drawing_CanvasDestroy(cCanvas);// 销毁bitmap对象OH_Drawing_BitmapDestroy(cBitmap);    文本绘制开发步骤 以下步骤描述了如何使用Native Drawing模块的文字显示功能：  创建画布和bitmap实例。 已复制// 创建bitmapOH_Drawing_Bitmap* cBitmap = OH_Drawing_BitmapCreate();OH_Drawing_BitmapFormat cFormat {COLOR_FORMAT_RGBA_8888, ALPHA_FORMAT_OPAQUE};OH_Drawing_BitmapBuild(cBitmap, width, height, &cFormat);// 创建canvasOH_Drawing_Canvas* cCanvas = OH_Drawing_CanvasCreate();OH_Drawing_CanvasBind(cCanvas, cBitmap);OH_Drawing_CanvasClear(cCanvas, OH_Drawing_ColorSetArgb(0xFF, 0xFF, 0xFF, 0xFF)); 设置排版风格。 已复制// 选择从左到右/左对齐等排版属性OH_Drawing_TypographyStyle* typoStyle = OH_Drawing_CreateTypographyStyle();OH_Drawing_SetTypographyTextDirection(typoStyle, TEXT_DIRECTION_LTR);OH_Drawing_SetTypographyTextAlign(typoStyle, TEXT_ALIGN_LEFT); 设置文本风格。 已复制// 设置文字颜色，例如黑色OH_Drawing_TextStyle* txtStyle = OH_Drawing_CreateTextStyle();OH_Drawing_SetTextStyleColor(txtStyle, OH_Drawing_ColorSetArgb(0xFF, 0x00, 0x00, 0x00));// 设置文字大小、字重等属性double fontSize = 30;OH_Drawing_SetTextStyleFontSize(txtStyle, fontSize);OH_Drawing_SetTextStyleFontWeight(txtStyle, FONT_WEIGHT_400);OH_Drawing_SetTextStyleBaseLine(txtStyle, TEXT_BASELINE_ALPHABETIC);OH_Drawing_SetTextStyleFontHeight(txtStyle, 1);// 设置字体类型等const char* fontFamilies[] = {"Roboto"};OH_Drawing_SetTextStyleFontFamilies(txtStyle, 1, fontFamilies);OH_Drawing_SetTextStyleFontStyle(txtStyle, FONT_STYLE_NORMAL);OH_Drawing_SetTextStyleLocale(txtStyle, "en"); 生成最终文本显示效果。 已复制OH_Drawing_TypographyCreate* handler = OH_Drawing_CreateTypographyHandler(typoStyle,    OH_Drawing_CreateFontCollection());OH_Drawing_TypographyHandlerPushTextStyle(handler, txtStyle);// 设置文字内容const char* text = "HarmonyOS\n";OH_Drawing_TypographyHandlerAddText(handler, text);OH_Drawing_TypographyHandlerPopTextStyle(handler);OH_Drawing_Typography* typography = OH_Drawing_CreateTypography(handler);// 设置页面最大宽度double maxWidth = 800.0;OH_Drawing_TypographyLayout(typography, maxWidth);// 设置文本在画布上绘制的起始位置double position[2] = {10.0, 15.0};// 将文本绘制到画布上OH_Drawing_TypographyPaint(typography, cCanvas, position[0], position[1]);    上一篇 Native API在应用工程中的使用指导 下一篇 Rawfile开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。代码高亮代码自动补全代码错误检查代码自动跳转跨语言跳转代码格式化代码折叠代码快速注释代码结构树代码引用查找代码查找快速查阅API接口及组件参考文档编辑器使用技巧 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持使用多种语言进行应用/服务的开发，包括ArkTS、JS和C/C++。在编写应用/服务阶段，可以通过掌握代码编写的各种常用技巧，来提升编码效率。 代码高亮支持对代码关键字、运算符、字符串、类、标识符、注释等进行高亮显示，您可以打开File > Settings（macOS为DevEco Studio > Preferences）面板，在Editor > Color Scheme自定义各字段的高亮显示颜色。默认情况下，您可以在Language Defaults中设置源代码中的各种高亮显示方案，该设置将对所有语言生效；如果您需要针对具体语言的源码高亮显示方案进行定制，可以在左侧边栏选择对应的语言，然后取消“Inherit values from”选项后设置对应的颜色即可。   代码自动补全提供代码的自动补全能力，编辑器工具会分析上下文，并根据输入的内容，提示可补齐的类、方法、字段和关键字的名称等，支持模糊匹配。 自动补齐功能默认按照最近使用过的类、方法、字段和关键字等名称进行排序，如仅需要按最短路径提供补齐内容排序，可以在Settings>Editor>General>Code Completion 中取消勾选"Sort suggestions by recently uesd"。 
说明
若已勾选代码补全按最近使用排序但未生效，请检查Code Completion页面，确保“Sort suggestions alphabetically”已取消勾选。 
    代码错误检查编辑器会实时的进行代码分析，如果输入的语法不符合编码规范，或者出现语义语法错误，将在代码中突出显示错误或警告，将鼠标放置在错误代码处，会提示详细的错误信息。   代码自动跳转在编辑器中，可以按住Ctrl键，鼠标单击代码中引用的类、方法、参数、变量等名称，自动跳转到定义处。若单击定义处的类、变量等名称，当仅有一处引用时，可直接跳转到引用位置；若有多处引用，在弹窗中可以选择想要查看的引用位置。   跨语言跳转DevEco Studio支持在JS/ArkTS函数上跨语言跳转其对应的C/C++函数，从而提升混合语言开发时的开发效率。您可以在编辑器中右击，在弹出的菜单中选择Go To > Implementation(s)实现跨语言跳转。   代码格式化代码格式化功能可以帮助您快速的调整和规范代码格式，提升代码的美观度和可读性。默认情况下，DevEco Studio已预置了代码格式化的规范，您也可以个性化的设置各个文件的格式化规范，设置方式如下：在File > Settings > Editor > Code Style（macOS为DevEco Studio > Preferences > Editor > Code Style）下，选择需要定制的文件类型，如ArkTS，然后自定义格式化规范即可。  在使用代码格式化功能时，您可以使用快捷键Ctrl + Alt + L（macOS为Option+Command +L） 可以快速对选定范围的代码进行格式化。 如果在进行格式化时，对于部分代码片段不需要进行自动的格式化处理，可以通过如下方式进行设置： 在File>Settings>Editor>Code Style（macOS为DevEco Studio > Preferences > Editor > Code Style），单击“Formatter”，勾选“Turn formatter on/off with markers in code comments”。 在不需要进行格式化操作的代码块前增加“//@formatter:off”，在不格式化代码块的最后增加“//@formatter:on”，即表示对该范围的代码块不需要进行格式化操作。   代码折叠支持对代码块的快速折叠和展开，既可以单击编辑器左侧边栏的折叠和展开按钮对代码块进行折叠和展开操作，还可以对选中的代码块单击鼠标右键选择折叠方式，包括折叠、递归折叠、全部折叠等操作。   代码快速注释支持对选择的代码块进行快速注释，使用快捷键Ctrl+/（macOS为Command+/）进行快速注释。对于已注释的代码块，再次使用快捷键Ctrl+/（macOS为Command+/）取消注释。   代码结构树使用快捷键Alt + 7 / Ctrl + F12（macOS为Command+7）打开代码结构树，快速查看文件代码的结构树，包括全局变量和函数，类成员变量和方法等，并可以跳转到对应代码行。   代码引用查找提供Find Usages代码引用查找功能，帮助开发者快速查看某个对象(变量、函数或者类等)被引用的地方，用于后续的代码重构，可以极大的提升开发者的开发效率。 使用方法：在要查找的对象上，单击鼠标右键 > Find Usages或使用快捷键Alt +F7（macOS为Command + F7）。   代码查找通过对符号、类或文件的即时导航来查找代码。检查调用或类型层次结构，轻松地搜索工程里的所有内容。通过连续点击两次Shift快捷键，打开代码查找界面，在搜索框中输入需要查找内容，下方窗口实时展示搜索结果。双击查找的结果可以快速打开所在文件的位置。   快速查阅API接口及组件参考文档在编辑器中调用ArkTS API或ArkTS/JS组件时，支持在编辑器中快速、精准调取出对应的参考文档。 可在编辑器中，鼠标悬停在需要查阅的接口或组件，弹窗显示当前接口/组件在不同API版本下的参数等信息，单击弹窗右下角Show in API Reference，可以快速查阅更全面的API文档。 
说明
DevEco Studio集成了离线版API参考类文档，最新版本请参考官网HarmonyOS API参考和OpenHarmony API参考。 
    上一篇 应用/服务开发 下一篇 在模块中添加Ability 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。快速开始 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    搭建开发环境流程  下载与安装软件  配置开发环境  创建和运行Hello World   上一篇 工具简介 下一篇 搭建开发环境流程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。下载SDK及工具链配置HDC工具环境变量诊断开发环境参考信息配置DevEco Studio代理配置NPM代理配置OHPM代理启用中文化插件配置开发环境 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 下载SDK及工具链DevEco Studio提供SDK Manager统一管理SDK及工具组件，包括如下组件包： 组件包名  说明  参考    Native  C/C++语言SDK包。  Native API参考   ArkTS  ArkTS语言SDK包。  ArkTS API参考   JS  JS语言SDK包。   Java  Java语言SDK包。从API Version 8开始，不再提供Java语言SDK包。  Java API参考   System-image-phone  本地模拟器Phone设备镜像文件。  使用Local Emulator运行应用/服务   System-image-tv  本地模拟器TV设备镜像文件，仅支持API Version 6。   System-image-wearable  本地模拟器Wearable设备镜像文件，仅支持API Version 6。   Emulator  本地模拟器工具包。   Toolchains  SDK工具链，应用/服务开发必备工具集，包括编译、打包、签名、数据库管理等工具的集合。  -   Previewer  应用/服务预览器，在开发过程中可以动态预览Phone、TV、Wearable、LiteWearable等设备的应用/服务效果，支持JS、ArkTS和Java应用/服务预览。  使用预览器查看应用/服务效果      应用/服务支持API Version 4至9，首次使用DevEco Studio，工具的配置向导会引导您下载SDK及工具链。配置向导默认下载 API Version 9的SDK及工具链，如需下载API Version 4至8，可在工程配置完成后，进入HarmonyOS SDK界面手动下载，方法如下： 在DevEco Studio欢迎页，单击Configure（或图标）> Settings > SDK > HarmonyOS页签（macOS系统为Configure > Preferences > SDK > HarmonyOS）。在DevEco Studio打开工程的情况下，单击Files > Settings > SDK > HarmonyOS页签进入（macOS系统为DevEco Studio > Preferences > SDK > HarmonyOS）。 接下来介绍首次启动DevEco Studio的配置向导： 运行已安装的DevEco Studio，首次使用，请选择Do not import settings，单击OK。安装Node.js与ohpm。可以指定本地已安装的Node.js或ohpm（Node.js版本要求为v14.19.1及以上，且低于v17.0.0；对应的npm版本要求为6.14.16及以上）路径位置；如果本地没有合适的版本，可以选择Install按钮，选择下载源和存储路径后，进行在线下载，单击Next进入下一步。
说明
如果配置向导界面出现的是设置HTTP Proxy Setup，说明网络受限，请根据参考信息配置DevEco Studio代理后，再下载Node.js、ohpm和SDK。 
  在SDK Setup界面，单击按钮，设置HarmonyOS SDK存储路径，单击Next进入下一步。
说明
HarmonyOS SDK路径中不能包含中文字符。 
  在弹出的SDK下载信息页面，单击Next，并在弹出的License Agreement窗口，阅读License协议，需同意License协议后，单击Next。
说明
下载SDK过程中，如果出现下载JS SDK失败，提示“Install Js dependencies failed.”，请根据JS SDK安装失败处理指导进行处理。 
  确认设置项的信息，点击Next开始安装。 等待Node.js、ohpm和SDK下载完成后，单击Finish，界面会进入到DevEco Studio欢迎页。 配置HDC工具环境变量HDC是为开发者提供HarmonyOS应用/服务的调试工具，为方便使用HDC工具，请为HDC端口号设置环境变量。 Windows环境变量设置方法：在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，添加HDC端口变量名为：HDC_SERVER_PORT，变量值可设置为任意未被占用的端口，如7035。  环境变量配置完成后，关闭并重启DevEco Studio。 macOS环境变量设置方法：打开终端工具，执行以下命令，根据输出结果分别执行不同命令。已复制echo $SHELL  如果输出结果为/bin/bash，则执行以下命令，打开.bash_profile文件。已复制vi ~/.bash_profile 如果输出结果为/bin/zsh，则执行以下命令，打开.zshrc文件。已复制vi ~/.zshrc  单击字母“i”，进入Insert模式。输入以下内容，添加HDC_SERVER_PORT端口信息。已复制export HDC_SERVER_PORT=7035 编辑完成后，单击Esc键，退出编辑模式，然后输入“:wq”，单击Enter键保存。执行以下命令，使配置的环境变量生效。如果步骤a时打开的是.bash_profile文件，请执行如下命令：已复制source ~/.bash_profile 如果步骤a时打开的是.zshrc文件，请执行如下命令：已复制source ~/.zshrc  环境变量配置完成后，关闭并重启DevEco Studio。   诊断开发环境为了您开发应用/服务的良好体验，DevEco Studio提供了开发环境诊断的功能，帮助您识别开发环境是否完备。您可以在欢迎界面单击Help > Diagnose Development Environment进行诊断。如果您已经打开了工程开发界面，也可以在菜单栏单击Help > Diagnostic Tools > Diagnose Development Environment进行诊断。  DevEco Studio开发环境诊断项包括电脑的配置、网络的连通情况、依赖的工具或SDK等。如果检测结果为未通过，请根据检查项的描述和修复建议进行处理。   参考信息DevEco Studio开发环境依赖于网络环境，需要连接上网络才能确保工具的正常使用。 一般来说，如果使用的是个人或家庭网络，是不需要配置代理信息的，只有部分企业网络受限的情况下，才需要配置代理信息。 首次使用DevEco Studio，如果配置向导界面出现Set up HTTP Proxy界面，可能需要通过配置代理服务器才能访问，请配置Proxy。   配置DevEco Studio代理启动DevEco Studio，配置向导进入Set up HTTP Proxy界面，勾选Manual proxy configuration，配置DevEco Studio的HTTP Proxy。
说明
如果非首次设置向导进入HTTP Proxy，可以通过如下方式进入HTTP Proxy配置界面： 在欢迎页单击Configure（或图标） > Settings > Appearance & Behavior > System Settings > HTTP Proxy进入HTTP Proxy设置界面（macOS为Configure > Preferences > Appearance & Behavior > System Settings > HTTP Proxy）。在打开了工程的情况下，可以单击File > Settings > Appearance & Behavior > System Settings > HTTP Proxy进入HTTP Proxy设置界面（macOS为DevEco Studio > Preferences > Appearance & Behavior > System Settings > HTTP Proxy）。 
 HTTP配置项，配置代理服务器信息。如果不清楚代理服务器信息，请咨询您的网络管理人员。Host name：代理服务器主机名或IP地址。Port number：代理服务器对应的端口号。No proxy for：不需要通过代理服务器访问的URL或者IP地址（地址之间用英文逗号分隔）。 Proxy authentication配置项，如果代理服务器需要通过认证鉴权才能访问，则需要配置。否则，请跳过该配置项。Login：访问代理服务器的用户名。Password：访问代理服务器的密码。Remember：勾选，记住密码。   配置完成后，单击Check connection，输入网络地址（如：https://developer.harmonyos.com），检查网络连通性。提示“Connection successful”表示代理设置成功。单击Next，继续配置Node.js、ohpm和SDK信息。   配置NPM代理Hvigor、ohpm、SDK在初始化时需要从npm仓库下载依赖，如果需要代理才能访问网络，请配置npm的代理。 可通过如下步骤进入npm代理配置界面：在欢迎页单击Configure（或图标） > Settings > Build, Execution, Deployment > Node.js and npm > Optimize config，进入npm代理设置界面（macOS为Configure > Preferences > Build, Execution, Deployment > Node.js and npm > Optimize config）。在打开了工程的情况下，可以单击File > Settings > Build, Execution, Deployment > Node.js and npm > Optimize config，进入npm代理设置界面（macOS为DevEco Studio > Preferences > Build, Execution, Deployment > Node.js and npm > Optimize config）。  具体配置如下： npm registry：配置npm仓的地址信息。已复制https://repo.huaweicloud.com/repository/npm/ ohos registry：HarmonyOS npm三方包共享仓。已复制https://repo.harmonyos.com/npm/ HTTP proxy：代理服务器信息，默认会与DevEco Studio的HTTP proxy设置项保持一致。如果需要配置帐号密码，请使用如下格式进行配置：已复制http://user:password@proxy.proxyserver.com Enable Https Proxy：同步配置HTTPS Proxy信息。  填写并勾选以上信息后，点击OK。在此界面配置的代理信息将写入“users/用户名”目录下的.npmrc文件。 因此也可直接修改“users/用户名”目录下的.npmrc文件进行配置。 进入C:\Users\用户名目录，打开.npmrc文件。如果该目录下没有.npmrc文件，请新建一个。修改npm仓库信息，示例如下所示：已复制registry=https://repo.huaweicloud.com/repository/npm/@ohos:registry=https://repo.harmonyos.com/npm/ 修改代理信息，在proxy和https-proxy中，将user、password、proxyserver和port按照实际代理服务器进行修改。示例如下所示：已复制proxy=http://user:password@proxy.proxyserver.com:porthttps-proxy=http://user:password@proxy.proxyserver.com:port 
说明
如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下： !：%21@：%40#：%23$：%24&：%26*：%2A 
 将Node.js配置到环境变量中。Windows环境变量设置方法：在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，在系统或者用户的PATH变量中，添加Node.js安装位置的路径。 macOS环境变量设置方法：打开终端工具，执行以下命令。已复制export NODE_HOME=/home/xx/Downloads/node-vxx.xx.x-linux-x64  #本处路径请替换为Node的安装路径export PATH=$NODE_HOME/bin:$PATH   代理配置完成后，打开命令行工具，执行如下命令验证网络是否正常。已复制npm info express 执行结果如下图所示，则说明代理设置成功。    配置OHPM代理若您需要配置OHPM代理信息，可通过如下步骤进入代理配置界面：在欢迎页单击Configure（或图标） > Settings > Build, Execution, Deployment > Ohpm > Optimize Config，进入OHPM代理设置界面（macOS为Configure > Preferences > Build, Execution, Deployment > Ohpm > Optimize Config）。在打开了工程的情况下，可以单击File > Settings > Build, Execution, Deployment > Ohpm > Optimize Config，进入OHPM代理设置界面（macOS为DevEco Studio > Preferences > Build, Execution, Deployment > Ohpm > Optimize Config）。  具体配置如下： ohpm registry：配置ohpm仓的地址信息。已复制https://repo.harmonyos.com/ohpm/  HTTP proxy：代理服务器信息，默认会与DevEco Studio的HTTP proxy设置项保持一致。如果需要配置帐号密码，请使用如下格式进行配置：已复制http://user:password@proxy.proxyserver.com Enable Https Proxy：同步配置HTTPS Proxy信息。 填写并勾选以上信息后，点击OK。  说明：ohpm默认校验registry仓库地址证书。如果环境检查中ohpm registry access出现'SELF_SIGNED_CERT_IN_CHAIN'或'UNABLE_TO_VERIFY_LEAF_SIGNATURE'等证书校验错误时，请查看FAQ-问题现象2解决证书校验错误问题。 在此界面配置的代理信息将写入“users/用户名/.ohpm”目录下的.ohpmrc文件。因此也可直接修改“users/用户名/.ohpm”目录下的.ohpmrc文件进行配置。 进入C:/Users/用户名目录/.ohpm，打开.ohpmrc文件。如果该目录下没有.ohpmrc文件，请新建一个。修改ohpm仓库信息，示例如下所示：已复制registry=https://repo.harmonyos.com/ohpm/ 修改ohpm代理信息，在http_proxy和https_proxy中，将user、password、proxyserver和port按照实际代理服务器进行修改。示例如下所示：已复制http_proxy=http://user:password@proxy.proxyserver.com:porthttps_proxy=http://user:password@proxy.proxyserver.com:port 
说明
如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下： !：%21@：%40#：%23$：%24&：%26*：%2A 
 将ohpm配置到环境变量中。Windows环境变量设置方法：在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，在系统或者用户的PATH变量中，添加ohpm安装位置下bin文件夹的路径。 macOS环境变量设置方法：打开终端工具，执行以下命令。已复制export OHPM_HOME=/home/xx/Downloads/ohpm  #本处路径请替换为ohpm的安装路径export PATH=$OHPM_HOME/bin:$PATH   代理配置完成后，下载并打开命令行工具，执行如下命令验证网络是否正常。已复制ohpm info @ohos/lottie 执行结果如下图所示，则说明代理设置成功。    启用中文化插件单击Files > Settings > Plugins，选择Installed页签，在搜索框输入“Chinese”，搜索结果里将出现Chinese(Simplified)，在右侧单击Enable，单击OK。 在弹窗中单击Restart，重启DevEco Studio后即可生效。    上一篇 下载与安装软件 下一篇 创建和运行Hello World 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明解除注册结果码开发示例错误管理开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  场景介绍当应用的代码存在规范问题或错误时，会在运行中产生异常和错误，如应用未捕获异常、应用生命周期超时等。在错误产生后，应用会异常退出。错误日志通常会保存在用户本地存储上，不方便开发者定位问题。所以，应用开发者可以使用错误管理的接口，在应用退出前，及时将相关错误及日志上报到开发者的服务平台来定位问题。  接口说明应用错误管理接口由errorManager模块提供，开发者可以通过import引入，详见开发示例。 错误管理接口功能介绍： 接口名称 说明   on(type: "error", observer: ErrorObserver): number 注册错误监听接口，当系统监测到应用异常时会回调该监听。该接口为同步接口，返回值为注册的监听对象对应的序号。  off(type: "error", observerId: number, callback: AsyncCallback<void>): void 以callback的形式解除注册监听，传入的number为之前注册监听时返回的序号。  off(type: "error", observerId: number): Promise<void> 以Promise的形式解除注册监听，传入的number为之前注册监听时返回的序号。    当采用callback作为异步回调时，可以在callback中进行下一步处理。当采用Promise对象返回时，可以在Promise对象中类似地处理接口返回值。具体结果码说明见解除注册结果码。 错误监听(ErrorObserver)接口功能介绍： 接口名称 说明   onUnhandledException(errMsg: string): void 系统回调接口，应用注册后，当应用产生未捕获的异常时的回调。     解除注册结果码 结果码 原因   0 正常返回  -1 传入的number不存在  -2 参数错误     开发示例已复制import UIAbility from '@ohos.app.ability.UIAbility';import errorManager from '@ohos.app.ability.errorManager';
let registerId = -1;let callback = {    onUnhandledException: function (errMsg) {        console.log(errMsg);    }}
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        console.log("[Demo] EntryAbility onCreate")        registerId = errorManager.on("error", callback);        globalThis.abilityWant = want;    }
    onDestroy() {        console.log("[Demo] EntryAbility onDestroy")        errorManager.off("error", registerId, (result) => {            console.log("[Demo] result " + result.code + ";" + result.message)        });    }
    onWindowStageCreate(windowStage) {        // Main window is created, set main page for this ability        console.log("[Demo] EntryAbility onWindowStageCreate")
        windowStage.loadContent("pages/index", (err, data) => {            if (err.code) {                console.error('Failed to load the content. Cause:' + JSON.stringify(err));                return;            }            console.info('Succeeded in loading the content. Data: ' + JSON.stringify(data))        });    }
    onWindowStageDestroy() {        // Main window is destroyed, release UI related resources        console.log("[Demo] EntryAbility onWindowStageDestroy")    }
    onForeground() {        // Ability has brought to foreground        console.log("[Demo] EntryAbility onForeground")    }
    onBackground() {        // Ability has back to background        console.log("[Demo] EntryAbility onBackground")    }};   上一篇 错误管理 下一篇 应用恢复开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用规格约束默认开启模块化编译模式 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 应用模块化编译是指基于ESModule的Bundleless编译模式，使用原生ES Module规则构建源码。 API 9及以上版本的Stage工程默认开启模块化编译，可有效缩短增量编译时间、减小编译后的包体积。 当前已知模块化编译如果存在re-export语法、引用了没有对应声明文件(.d.ts)的native文件(.so)、使用export * from 'x.js'导出js文件中的符号等情况将导致工程报错，若原有工程在升级DevEco Studio至3.1 Release版本后出现编译错误，请查看FAQ进行修改。 
说明
API 8及API 9版本FA模板创建的工程依然使用基于bundle打包的构建方式。 
 模块化编译解决了Bundle编译打包模式引入的如下问题： 同一个模块多次引用导致的重复打包及运行时加载，运行状态无法共享，单例模式运行异常修改单个模块文件，需要完整重新编译打包，耗时过长全局变量污染问题 模块化编译模式有以下价值： 修改单个模块代码无需整包编译构建，增量编译构建时间极大减少基于ESModule规则，模块缓存利用率高，模块内变量变化能够及时反映到模块本身，动态实时绑定解决了单例问题减少了包的ROM size解决了变量污染等问题，各模块基于接口进行开发，提升开发效率 使用规格约束支持工程内hap引用同工程下其他hap代码，但不推荐使用此引用方式，建议使用har包方式组织公共代码并引用支持工程内hap通过配置文件（oh-package.json5）使用ohpm包管理的方式引用同工程下其他hap代码，不推荐使用此引用方式，建议使用har包方式组织公共代码并引用不支持引用工程外的代码以及工程内任意创建目录下的代码，否则工程编译报错推荐使用hap通过har（static library）的方式引用公共代码推荐使用hap通过hsp（shared library）的方式引用共享库，共享状态   上一篇 配置编译构建信息 下一篇 开启AOT编译模式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。隐式Want匹配原理详解want参数的action匹配规则want参数的entities匹配规则want参数的uri和type匹配规则uri匹配规则type匹配规则显式Want与隐式Want匹配规则 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在启动目标Ability时，会通过显式Want和隐式Want进行目标Ability的匹配，这里说的匹配规则就是调用方Want中设置的参数如何与目标Ability声明的配置文件进行匹配。  显式Want匹配原理     名称 类型 匹配项 必选 规则    deviceId string 是 否 留空将仅匹配本设备内Ability。   bundleName string 是 是 如果指定abilityName，而不指定bundleName，则匹配失败。   moduleName string 是 否 留空时当同一个应用内存在多个模块且模块间存在重名Ability，将默认匹配第一个。   abilityName string 是 是 该字段必须设置表示显式匹配。   uri string 否 否 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。   type string 否 否 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。   action string 否 否 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。   entities Array<string> 否 否 系统匹配时将忽略该参数，但仍可作为参数传递给目标Ability。   flags number 否 否 不参与匹配，直接传递给系统处理，一般用来设置运行态信息，例如URI数据授权等。   parameters {[key: string]: any} 否 否 不参与匹配，应用自定义数据将直接传递给目标Ability。    隐式Want匹配原理     名称 类型 匹配项 必选 规则    deviceId string 是 否 跨设备目前不支持隐式调用。 
说明
 当前版本暂不支持跨设备能力。 
   abilityName string 否 否 该字段必须留空表示隐式匹配。   bundleName string 是 否 - 声明bundleName时，隐式搜索将仅限于对应应用包内。 - 声明bundleName与moduleName时，隐式搜索将仅限于对应应用的对应Module内。 - 单独声明moduleName时，该字段无效。 - 同时声明bundleName与moduleName时，隐式搜索将仅限于对应应用包内的对应模块内。 这些字段将用来隐式匹配，具体规则可参考隐式Want匹配原理详解。   moduleName string 是 否 -   uri string 是 否 -   type string 是 否 -   action string 是 否 -   entities Array<string> 是 否 -   flags number 否 否 不参与匹配，直接传递给系统处理，一般用来设置运行态信息，例如URI数据授权等。   parameters {[key: string]: any} 否 否 不参与匹配，应用自定义数据将直接传递给目标Ability。      隐式Want匹配原理详解 从隐式Want的定义，可得知：  调用方传入的want参数，表明调用方需要执行的操作，并提供相关数据以及其他应用类型限制。 待匹配Ability的skills配置，声明其具备的能力（module.json5配置文件中的skills标签参数）。  系统将调用方传入的want参数（包含action、entities、uri和type属性）与已安装待匹配的应用Ability的skills配置（包含actions、entities、uris和type属性）依次进行匹配。当四个属性匹配均通过，则此应用才会被应用选择器展示给用户进行选择。   want参数的action匹配规则 将调用方传入的want参数的action与待匹配Ability的skills配置中的actions进行匹配。  调用方传入的want参数的action为空，待匹配Ability的skills配置中的actions为空，则action匹配失败。 调用方传入的want参数的action不为空，待匹配Ability的skills配置中的actions为空，则action匹配失败。 调用方传入的want参数的action为空，待匹配Ability的skills配置中的actions不为空，则action匹配成功。 调用方传入的want参数的action不为空，待匹配Ability的skills配置中的actions不为空且包含调用方传入的want参数的action，则action匹配成功。 调用方传入的want参数的action不为空，待匹配Ability的skills配置中的actions不为空且不包含调用方传入的want参数的action，则action匹配失败。 图1 want参数的action匹配规则     want参数的entities匹配规则 将调用方传入的want参数的entities与待匹配Ability的skills配置中的entities进行匹配。  调用方传入的want参数的entities为空，待匹配Ability的skills配置中的entities不为空，则entities匹配成功。 调用方传入的want参数的entities为空，待匹配Ability的skills配置中的entities为空，则entities匹配成功。 调用方传入的want参数的entities不为空，待匹配Ability的skills配置中的entities为空，则entities匹配失败。 调用方传入的want参数的entities不为空，待匹配Ability的skills配置中的entities不为空且包含调用方传入的want参数的entities，则entities匹配成功。 调用方传入的want参数的entities不为空，待匹配Ability的skills配置中的entities不为空且不完全包含调用方传入的want参数的entities，则entities匹配失败。 图2 want参数的entities匹配规则     want参数的uri和type匹配规则 调用方传入的want参数中设置uri和type参数发起组件启动请求，系统会遍历当前系统已安装的组件列表，并逐个匹配待匹配Ability的skills配置中的uris数组，如果待匹配Ability的skills配置中的uris数组中只要有一个可以匹配调用方传入的want参数中设置的uri和type即为匹配成功。 图3 want参数中uri和type皆不为空时的匹配规则  实际应用中，uri和type共存在四种情况，下面将讲解四种情况的具体匹配规则：  调用方传入的want参数的uri和type都为空。  如果待匹配Ability的skills配置中的uris数组为空，匹配成功。 如果待匹配Ability的skills配置中的uris数组中存在uri的scheme和type都为空的元素，匹配成功。 除以上两种情况，其他情况均为匹配失败。  调用方传入的want参数的uri不为空，type为空。  如果待匹配Ability的skills配置中的uris数组为空，匹配失败。 如果待匹配Ability的skills配置中的uris数组存在一条数据uri匹配成功且type为空，则匹配成功，否则匹配失败。  调用方传入的want参数的uri为空，type不为空。  如果待匹配Ability的skills配置中的uris数组为空，匹配失败。 如果待匹配Ability的skills配置中的uris数组存在一条数据uri的scheme为空且type匹配成功，则匹配成功，否则匹配失败。  调用方传入的want参数的uri和type都不为空，如图3所示。  如果待匹配Ability的skills配置中的uris数组为空，匹配失败。 如果待匹配Ability的skills配置中的uris数组存在一条数据uri匹配和type匹配需要均匹配成功，则匹配成功，否则匹配失败。   下图为了简化描述，称want中传入的uri为w_uri，称want中传入的type为w_type, 待匹配Ability的skills配置中uris为s_uris，其中每个元素为s_uri；按自上而下顺序匹配。 图4 want参数中uri和type的具体匹配规则    uri匹配规则 这里为了简化描述，称want中传入的uri为w_uri，待匹配Ability的skills配置中uri为s_uri，具体的匹配规则如下：  如果s_uri的scheme为空，当w_uri为空时匹配成功，否则匹配失败； 如果s_uri的host为空，当w_uri和s_uri的scheme相同时匹配成功，否则匹配失败； 如果s_uri的path、pathStartWith和pathRegex都为空，当w_uri和s_uri完全相同时匹配成功，否则匹配失败； 如果s_uri的path不为空，当w_uri和s_uri全路径表达式相同时匹配成功，否则继续进行pathStartWith的匹配； 如果s_uri的pathStartWith不为空，当w_uri包含s_uri前缀表达式时匹配成功，否则继续进行pathRegex的匹配； 如果s_uri的pathRegex不为空，当w_uri满足s_uri正则表达式时匹配成功，否则匹配失败；  
说明
 待匹配Ability的skills配置的uris中scheme、host、port、path、pathStartWith和pathRegex属性拼接，如果依次声明了path、pathStartWith和pathRegex属性时，uris将分别拼接为如下三种表达式：  全路径表达式：scheme://host:port/path 前缀表达式：scheme://host:port/pathStartWith 正则表达式：scheme://host:port/pathRegex  
   type匹配规则 
说明
 此小节所述的type匹配规则的适用性需建立在want参数内type不为空的基础上。当want参数内type为空时请参考want参数的uri和type匹配规则。 
 这里为了简化描述，称want中传入的uri为w_type，待匹配Ability的skills数组中uris的type数据为s_type，具体的匹配规则如下：  如果s_type为空，则匹配失败。 如果s_type或者w_type为通配符"*/*"，则匹配成功。 如果s_type最后一个字符为通配符'*'，如"prefixType/*"，则当w_type包含"prefixType/"时匹配成功，否则匹配失败。 如果w_type最后一个字符为通配符'*'，如"prefixType/*"，则当s_type包含"prefixType/"时匹配成功，否则匹配失败。    上一篇 Want概述 下一篇 常见action与entities 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。FA模型开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  基于FA模型开发应用时，在应用模型部分，涉及如下开发过程。 表1 FA模型开发流程     任务 简介 相关指导    应用组件开发 本章节介绍了如何使用FA模型的PageAbility、ServiceAbility、DataAbility以及服务卡片进行应用开发。 应用/组件级配置 PageAbility开发指导 ServiceAbility开发指导 DataAbility开发指导 服务卡片开发指导 FA模型的Context 信息传递载体Want   了解进程模型 本章节介绍了FA模型的进程模型以及几种常用的进程间通信方式。 公共事件   了解线程模型 本章节介绍了FA模型的线程模型以及几种常用的线程间通信方式。 线程间通信   应用配置文件 本章节介绍FA模型中应用配置文件的开发要求。 FA模型应用配置文件     上一篇 FA模型开发指导 下一篇 FA模型应用组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤跨设备文件访问 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 分布式文件系统为应用提供了跨设备文件访问的能力，开发者在多个设备安装同一应用时，通过基础文件接口，可跨设备读写其他设备该应用分布式文件路径（/data/storage/el2/distributedfiles/）下的文件。例如：多设备数据流转的场景，设备组网互联之后，设备A上的应用可访问设备B同应用分布式路径下的文件，当期望应用文件被其他设备访问时，只需将文件移动到分布式文件路径即可。 开发步骤完成分布式组网。首先将需要进行跨设备访问的设备连接到同一局域网中，同帐号认证完成组网。 访问跨设备文件。同一应用不同设备之间实现跨设备文件访问，只需要将对应的文件放在应用沙箱的分布式文件路径即可。 设备A上在分布式路径下创建测试文件，并写入内容。示例中的context的获取方式请参见获取UIAbility的上下文信息。 已复制import fs from '@ohos.file.fs';
let context = ...; // 获取设备A的UIAbilityContext信息let pathDir = context.distributedFilesDir;// 获取分布式目录的文件路径let filePath = pathDir + '/test.txt';
try {  // 在分布式目录下创建文件  let file = fs.openSync(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);  console.info('Succeeded in createing.');  // 向文件中写入内容  fs.writeSync(file.fd, 'content');  // 关闭文件  fs.closeSync(file.fd);} catch (err) {  console.error(`Failed to openSync / writeSync / closeSync. Code: ${err.code}, message: ${err.message}`);} 设备B上在分布式路径下读取测试文件。 已复制import fs from '@ohos.file.fs';
let context = ...; // 获取设备B的UIAbilityContext信息let pathDir = context.distributedFilesDir;// 获取分布式目录的文件路径let filePath = pathDir + '/test.txt';
try {  // 打开分布式目录下的文件  let file = fs.openSync(filePath, fs.OpenMode.READ_WRITE);  // 定义接收读取数据的缓存  let buffer = new ArrayBuffer(4096);  // 读取文件的内容，返回值是读取到的字节个数  let num = fs.readSync(file.fd, buffer, {    offset: 0  });  // 打印读取到的文件数据  console.info('read result: ' + String.fromCharCode.apply(null, new Uint8Array(buffer.slice(0, num))));} catch (err) {  console.error(`Failed to openSync / readSync. Code: ${err.code}, message: ${err.message}`);}    上一篇 设置分布式文件数据等级 下一篇 后台任务（Background Task）管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。文件管理概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在操作系统中，存在各种各样的数据，按数据结构可分为： 结构化数据：能够用统一的数据模型加以描述的数据。常见的是各类数据库数据。在应用开发中，对结构化数据的开发活动隶属于数据管理模块。非结构化数据：指数据结构不规则或不完整，没有预定义的数据结构/模型，不方便用数据库二维逻辑表来表现的数据。常见的是各类文件，如文档、图片、音频、视频等。在应用开发中，对非结构化数据的开发活动隶属于文件管理模块，将在下文展开介绍。 在文件管理模块中，按文件所有者的不同，有如下文件分类模型，其示意图如下面文件分类模型示意图： 应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。用户文件：文件所有者为登录到该终端设备的用户，包括用户私有的图片、视频、音频、文档等。系统文件：与应用和用户无关的其他文件，包括公共库、设备文件、系统资源文件等。这类文件不需要开发者进行文件管理，本文不展开介绍。 按文件系统管理的文件存储位置（数据源位置）的不同，有如下文件系统分类模型： 本地文件系统：提供本地设备或外置存储设备（如U盘、移动硬盘）的文件访问能力。本地文件系统是最基本的文件系统，本文不展开介绍。分布式文件系统：提供跨设备的文件访问能力。所谓跨设备，指文件不一定存储在本地设备或外置存储设备，而是通过计算机网络与其他分布式设备相连。 图1 文件分类模型示意图  上一篇 文件管理 下一篇 应用文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ACDFHIMPS术语 更新时间: 2023-10-16 11:16 毫无帮助帮助不大一般很好非常好
分享
 AAbility应用的重要组成部分，是应用所具备能力的抽象。Ability分为两种类型，Feature Ability和Particle Ability。  AbilitySlice切片，是单个可视化界面及其交互逻辑的总和，是Feature Ability的组成单元。一个Feature Ability可以包含一组业务关系密切的可视化界面，每一个可视化界面对应一个AbilitySlice。  ANSAdvanced Notification Service，通知增强服务，是HarmonyOS中负责处理通知的订阅、发布和更新等操作的系统服务。 Atomic Service，元服务原名原子化服务，是HarmonyOS提供的一种面向未来的服务提供方式，是有独立入口的（用户可通过点击服务卡片打开元服务）、免安装的（无需显式安装，由系统程序框架后台安装后即可使用）用户应用程序形态。 ArkUI方舟开发框架，是为HarmonyOS平台开发极简、高性能、跨设备应用设计研发的UI开发框架，支撑开发者高效地构建跨设备应用UI界面。详情请参考方舟开发框架开发指导。 ArkCompiler方舟编译器，是华为自研的统一编程平台，包含编译器、工具链、运行时等关键部件，支持高级语言在多种芯片平台的编译与运行，可支撑传统方式的显式安装的应用和原子化服务运行在手机、个人电脑、平板、电视、汽车和智能穿戴等多种设备上的需求。   CCESCommon Event Service，是HarmonyOS中负责处理公共事件的订阅、发布和退订的系统服务。 Cross-device migration，跨端迁移是一种实现用户应用程序流转的技术方案。指在A端运行的用户应用程序，迁移到B端上并从迁移时刻A端状态继续运行，然后A端用户应用程序退出。   DDVDevice Virtualization，设备虚拟化，通过虚拟化技术可以实现不同设备的能力和资源融合。   FFAFeature Ability，代表有界面的Ability，用于与用户进行交互。   HHAPHarmonyOS Ability Package，一个HAP文件包含应用的所有内容，由代码、资源、三方库及应用配置文件组成，其文件后缀名为.hap。  HDFHardware Driver Foundation，硬件驱动框架，用于提供统一外设访问能力和驱动开发、管理框架。 HMLHarmonyOS Markup Language，是一套类HTML的标记语言。通过组件、事件构建出页面的内容。页面具备数据绑定、事件绑定、列表渲染、条件渲染等高级能力。 Hop，流转在HarmonyOS中泛指涉及多端的分布式操作。流转能力打破设备界限，多设备联动，使用户应用程序可分可合、可流转，实现如邮件跨设备编辑、多设备协同健身、多屏游戏等分布式业务。 流转为开发者提供更广的使用场景和更新的产品视角，强化产品优势，实现体验升级。   IIDNIntelligent Distributed Networking，是HarmonyOS特有的分布式组网能力单元。开发者可以通过IDN获取分布式网络内的设备列表和设备状态信息，以及注册分布式网络内设备的在网状态变化信息。   MManual hop，用户手动流转是指开发者在用户应用程序中内嵌规范的流转图标，使用户可以手动选择合适的可选设备进行流转。用户点击图标后，会调起系统提供的流转面板。面板中会展示出用户应用程序的信息及可流转的设备，引导用户进行后续的流转操作。  MSDPMobile Sensing Development Platform，移动感知平台。MSDP子系统提供分布式融合感知能力，借助HarmonyOS分布式能力，汇总融合来自多个设备的多种感知源，从而精确感知用户的空间状态、移动状态、手势、运动健康等多种状态，构建全场景泛在基础感知能力，支撑智慧生活新体验。  Multi-device collaboration，多端协同是一种实现用户应用程序流转的技术方案。指多端上的不同FA/PA同时运行、或者接替运行实现完整的业务；或者，多端上的相同FA/PA同时运行实现完整的业务。   PPAParticle Ability，代表无界面的Ability，主要为Feature Ability提供支持，例如作为后台服务提供计算能力，或作为数据仓库提供数据访问能力。   SService widget，服务卡片将用户应用程序的重要信息以服务卡片的形式展示在桌面，用户可通过快捷手势使用卡片，以达到服务直达、减少层级跳转的目的。 卡片作为服务的轻量承载，需要做到易用可见、智能可选和多端可变。每个原子化服务需要配置至少一个服务卡片，每个传统方式的需要安装的应用可选配置服务卡片。 Super virtual device，超级虚拟终端亦称超级终端，通过分布式技术将多个终端的能力进行整合，存放在一个虚拟的硬件资源池里，根据业务需要统一管理和调度终端能力，来对外提供服务。 System suggested hop，系统推荐流转是指当用户使用用户应用程序时，所处环境中存在使用体验更优的可选设备，则系统自动为用户推荐该设备，用户可确认是否启动流转。   以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。适配方法一适配方法二Gradle工程适配为Hvigor工程 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 该适配场景适用于开发者希望将原OpenHarmony API 7的工程升级到OpenHarmony API 9的工程。 原OpenHarmony API 7的工程采用的是Gradle自动化构建工具，而OpenHarmony API 9的工程则采用Hvigor自动化构建工具，由于Gradle构建工具和Hvigor构建工具的配置文件不同，因此，对于采用Gradle编译构建的历史工程，需要手动进行适配，以适用于使用Hvigor工具进行编译构建。 
说明
由于OpenHarmony API 7的工程属于FA模型，因此将工程升级到OpenHarmony API 9时，也只能升级为FA模型，不支持升级为Stage模型。 
 关于OpenHarmony API 7工程的升级适配，提供如下两种方法： 适配方法一使用DevEco Studio创建一个OpenHarmony新工程，请参考创建OpenHarmony工程。在配置工程信息时，请注意：Bundle name：请与需要适配的历史工程的Bundle name保持一致。待适配工程的Bundle name字段可在模块目录下的config.json文件中进行查阅。Compile SDK：请选择将要适配的目标API版本，支持选择9。Model：请选择FA。Language：选择与待适配工程使用的代码语言保持一致。  等待工程ohpm install执行完成后，删除entry下的src目录，请注意，其它配置文件不要删除。 将待适配工程entry模块下的src目录，拷贝到上述工程的entry文件夹下。
说明
如果待适配工程存在多个模块，可拷贝上述整个entry模块文件夹并修改模块名，然后将待适配模块中的源码和资源文件夹，替换到该模块下即可。 
 检查模块下src\main\resources\base目录是否存在layout和graphic文件夹，如果有请删除；没有请跳过该操作。打开模块下的build-profile.json5文件，删除“ohosTest” Target。如果是ArkTS工程，请修改ArkTS源码文件中的引用包的后缀名，由import xx from‘xx.ets’修改为import xx from‘xx’，去掉.ets后缀名。单击File > Sync and Refresh Project进行同步，等待工程同步完成。至此，OpenHarmony历史工程便适配完成，您可以通过单击Build > Build Hap(s)/App(s) > Build Hap(s)验证是否可以正常编译构建HAP。   适配方法二在本地电脑中，进入OpenHarmony工程所在文件夹。在工程根目录下，修改相关配置文件。删除Gradle相关的文件及缓存文件，如下图蓝色框所示的文件及文件夹。 打开工程根目录下local.properties文件，并根据实际路径进行修改。已复制#OpenHarmony SDK路径sdk.dir=D:/OpenHarmony/Sdk#Node.js路径nodejs.dir=D:/nodejs 新建一个文本文件，命名修改为“hvigorfile.ts”。打开hvigorfile.ts文件，写入如下脚本信息。写入后，保存并关闭文件即可。已复制export { legacyAppTasks } from '@ohos/hvigor-ohos-plugin'; 新建oh-package.json5文件，写入如下脚本信息，其中：name和version字段，请根据实际进行填写，其余字段保持不变。写入后，保存并关闭文件即可。已复制{"name": "myapplication",  "version": "1.0.0",  "description": "Please describe the basic information.",  "main": "",  "author": "",  "license": "",  "dependencies": {},  "devDependencies": {    "@ohos/hypium": "1.0.6"  }} 新建一个文本文件，命名修改为“build-profile.json5”。打开build-profile.json5文件，写入如下脚本信息，其中compileSdkVersion和compatibleSdkVersion请修改为9，其余字段请参考1.5.2-工程级build-profile.json5说明进行修改。写入后，保存并关闭文件即可。已复制{  "app": {    "signingConfigs": [],    "compileSdkVersion": 9,    "compatibleSdkVersion": 9,    "products": [      {        "name": "default",        "signingConfig": "default",      }    ]  },  "modules": [    {      "name": "entry",      "srcPath": "./entry",      "targets": [        {          "name": "default",          "applyToProducts": [            "default"          ]        }      ]    }  ]} 工程需要添加ohpm编译构建四件套hvigorw、hvigorw.bat、hvigor-config.json5、hvigor-wrapper.js。可新建一个API 9的新工程，拷贝新工程中hvigorw、hvigorw.bat、hvigor-config.json5、hvigor-wrapper.js四项配置文件，粘贴到历史工程文件夹对应位置。  进入模块目录下，修改相关配置文件。如有多个模块，请逐一修改。删除build文件夹、build.gradle和progurad-rules.pro文件。 检查模块下src\main\resources\base目录是否存在layout和graphic文件夹，如果有请删除；没有请跳过该操作。新建一个文本文件，命名修改为“oh-package.json5”。打开oh-package.json5文件，写入如下脚本信息。已复制{  "name": "entry",  "version": "1.0.0",  "description": "Please describe the basic information.",  "main": "",  "author": "",  "license": "",  "dependencies": {}} 新建一个文本文件，命名修改为“hvigorfile.ts”。打开hvigorfile.ts文件，写入如下脚本信息。写入后，保存并关闭文件即可。已复制export { legacyHapTasks } from '@ohos/hvigor-ohos-plugin';  新建一个文本文件，命名修改为“build-profile.json5”。打开build-profile.json5文件，写入如下脚本信息。写入后，保存并关闭文件即可。已复制{  "apiType": 'faMode',  "buildOption": {  },  "targets": [    {      "name": "default"    }  ]}  如果是ArkTS工程，请修改ArkTS源码文件中的引用包的后缀名，由import xx from‘xx.ets’修改为import xx from‘xx’，去掉.ets后缀名。至此，HarmonyOS历史工程便适配完成，您可以通过单击Build > Build Hap(s)/App(s) > Build Hap(s)验证是否可以正常编译构建HAP。    上一篇 创建一个新的工程 下一篇 导入Sample工程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建HAR模块HAR开发注意事项导出HAR的ArkUI组件、接口、资源导出ArkUI组件导出ts类和方法导出native方法资源引用HAR的ArkUI组件、接口、资源引用HAR的ArkUI组件引用HAR的ts类和方法引用HAR的native方法引用HAR的资源HAR 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 HAR（Harmony Archive）是静态共享包，可以包含代码、C++库、资源和配置文件。通过HAR可以实现多个模块或多个工程共享ArkUI组件、资源等相关代码。HAR不同于HAP，不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。 创建HAR模块通过DevEco Studio创建一个HAR模块，详见创建库模块。HAR模块默认不开启混淆能力，开启混淆能力，需要把HAR模块的build-profile.json5文件中的artifactType字段设置为obfuscation，配置如下所示： 已复制{  "apiType": "stageMode",  "buildOption": {      "artifactType": "obfuscation"  }} artifactType字段有以下两种取值，默认缺省为original。 original：不混淆。obfuscation：混淆。 需要对代码资产进行保护时，建议开启混淆能力，混淆能力开启后，DevEco Studio在构建HAR时，会对代码进行编译、混淆及压缩处理，保护代码资产。 注意：artifactType字段设置为obfuscation时，apiType字段必须设置为stageMode，因为Stage模型才支持混淆。  HAR开发注意事项HAR不支持在配置文件中声明abilities、extensionAbilities组件。HAR不支持在配置文件中声明pages页面。HAR不支持在build-profile.json5文件的buildOption中配置worker。FA模型与Stage模型的HAR不支持相互引用。Stage模型的HAR，不能引用AppScope内的内容。在编译构建时AppScope中的内容不会打包到HAR中，导致HAR资源引用失败。  导出HAR的ArkUI组件、接口、资源Index.ets文件是HAR导出声明文件的入口，HAR需要导出的接口，统一在Index.ets文件中导出。Index.ets文件是DevEco Studio默认自动生成的，用户也可以自定义，在模块的oh-package.json5文件中的main字段配置入口声明文件，配置如下所示： 已复制{  "main": "Index.ets"}  导出ArkUI组件ArkUI组件的导出方式与ts的导出方式一致，通过export导出ArkUI组件，示例如下： 已复制// library/src/main/ets/components/MainPage/MainPage.ets@Componentexport struct MainPage {  @State message: string = 'Hello World'  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }} HAR对外暴露的接口，在Index.ets导出文件中声明如下所示： 已复制// library/Index.etsexport { MainPage } from './src/main/ets/components/MainPage/MainPage'  导出ts类和方法通过export导出ts类和方法，支持导出多个ts类和方法，示例如下所示： 已复制// library/src/main/ts/test.etsexport class Log {    static info(msg: string) {        console.info(msg);    }}
export function func() {  return "har func";}
export function func2() {  return "har func2";} HAR对外暴露的接口，在Index.ets导出文件中声明如下所示： 已复制// library/Index.etsexport { Log } from './src/main/ts/test'export { func } from './src/main/ts/test'export { func2 } from './src/main/ts/test'  导出native方法在HAR中也可以包含C++编写的so。对于so中的native方法，HAR通过以下方式导出，以导出libnative.so的加法接口add为例： 已复制// library/src/main/ets/utils/nativeTest.tsimport native from "libnative.so"
export function nativeAdd(a: number, b: number) {    let result: number = native.add(a, b);    return result;} HAR对外暴露的接口，在Index.ets导出文件中声明如下所示： 已复制// library/Index.etsexport { nativeAdd } from './src/main/ets/utils/nativeTest'  资源HAR模块编译打包时会把资源打包到HAR中。在编译构建HAP时，DevEco Studio会从HAP模块及依赖的模块中收集资源文件，如果不同模块下的资源文件出现重名冲突时，DevEco Studio会按照以下优先级进行覆盖（优先级由高到低）： AppScope（仅API9的Stage模型支持）。HAP包自身模块。依赖的HAR模块，如果依赖的多个HAR之间有资源冲突，会按照依赖顺序进行覆盖（依赖顺序在前的优先级较高）。  引用HAR的ArkUI组件、接口、资源引用HAR前，需要先配置对HAR的依赖，配置方式可参考引用HAR文件和资源。  引用HAR的ArkUI组件HAR的依赖配置成功后，可以引用HAR的ArkUI组件。ArkUI组件的导入方式与ts的导入方式一致，通过import引入HAR导出的ArkUI组件，示例如下所示： 已复制// entry/src/main/ets/pages/Index.etsimport { MainPage } from "library"
@Entry@Componentstruct Index {  @State message: string = 'Hello World'  build() {    Row() {      // 引用HAR的ArkUI组件      MainPage()      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }}  引用HAR的ts类和方法通过import引用HAR导出的ts类和方法，示例如下所示： 已复制// entry/src/main/ets/pages/Index.etsimport { Log } from "library"import { func } from "library"
@Entry@Componentstruct Index {  build() {    Row() {      Column() {        Button('Button')          .onClick(()=>{            // 引用HAR的类和方法            Log.info("har msg");            func();        })      }      .width('100%')    }    .height('100%')  }}  引用HAR的native方法通过import引用HAR导出的native方法，示例如下所示： 已复制// entry/src/main/ets/pages/Index.etsimport { nativeAdd } from "library"
@Entry@Componentstruct Index {  @State message: string = 'Hello World'  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button('nativeAdd(1, 2)')          .onClick(()=> {            this.message = "result: " + nativeAdd(1, 2);          })      }      .width('100%')    }    .height('100%')  }}  引用HAR的资源通过$r引用HAR中的资源，例如在HAR模块的src/main/resources里添加字符串资源（在string.json中定义，name：hello_har）和图片资源（icon_har.png），然后在Entry模块中引用该字符串和图片资源的示例如下所示： 已复制// entry/src/main/ets/pages/Index.ets@Entry@Componentstruct Index {  build() {    Row() {      Column() {        // 引用HAR的字符串资源        Text($r("app.string.hello_har"))          .fontSize(50)          .fontWeight(FontWeight.Bold)        // 引用HAR的图片资源        Image($r("app.media.icon_har"))      }      .width('100%')    }    .height('100%')  }}   上一篇 共享包概述 下一篇 HSP 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。OpenHarmony Test创建OpenHarmony Test测试用例运行OpenHarmony Test测试用例创建OpenHarmony Test测试用例运行任务OpenHarmony Test代码覆盖率统计HarmonyOS Test创建HarmonyOS Test测试用例运行HarmonyOS Test测试用例HarmonyOS JUnit单元测试创建HarmonyOS JUnit测试用例运行HarmonyOS JUnit测试用例测试框架 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持应用/服务测试框架，包含HarmonyOS Test、HarmonyOS JUnit、OpenHarmony Test测试能力。提供测试用例执行能力，提供用例编写基础接口，输出测试结果，支持用户开发简洁易用的自动化测试脚本，支持代码覆盖率统计。 OpenHarmony Test：测试用例存放在ohosTest测试目录下，需要运行在设备或者模拟器上。OpenHarmony Test支持ArkTS/JS语言。适用范围：API 8~9 Hvigor工程。HarmonyOS Test：测试用例存放ohosTest测试目录下，需要运行在设备或者模拟器上。HarmonyOS Test支持ArkTS/JS/Java语言。适用范围：API 4~7 Gradle工程。HarmonyOS JUnit：测试用例存放test测试目录下。单元测试是测试某个类的某个方法能否正常工作的一种手段，这些测试无需在设备或模拟器上运行，可直接于本地JVM上运行，测试执行速度快。HarmonyOS JUnit只支持Java语言。适用范围：API 4~7 Gradle工程。  OpenHarmony Test 创建OpenHarmony Test测试用例在工程目录下打开待测试模块下的ets文件，将光标置于代码中任意位置，单击右键 > Show Context Actions > Create Ohos Test或快捷键Alt+enter > Create Ohos Test创建测试类。 在弹出的Create Ohos Test窗口，输入或选择如下参数。Testing library：测试类型，默认为DECC-ArkTSUnit，JS语言默认为DECC-JSUnitArkTS name：创建的测试套件名称。测试套件为包含了测试用例的文件。测试套件名称要求在工程目录范围内具有唯一性，且不能使用逗号、横线、空格以及\ / : * ? “”< > | （）&等特殊字符。Destination package：测试套件存放的位置，建议存放在待测试模块的test目录下。  DevEco Studio在ohosTest目录下自动生成对应的测试类。在测试类中，DevEco Studio会生成对应方法的用例模板，具体测试代码需要开发者根据业务逻辑进行开发，具体请参考：单元测试框架和UI测试框架
说明
您也可以手动在ohosTest > ets > test文件夹下创建测试用例，手动创建后，需要在List.test.ets文件中添加创建的用例类。 测试用例名称应保持唯一性，并且不能使用逗号、横线、空格以及\ / : * ? “”< > | （）&等特殊字符。 首次在HarmonyOS设备上运行UI测试框架需要使用命令“hdc -n shell param set persist.ace.testmode.enabled 1”使能UiTest测试能力。 
   运行OpenHarmony Test测试用例使用DevEco Studio运行测试用例前，需要将设备与电脑进行连接，将工程编译成带签名信息的HAP，再安装到真机设备或模拟器上运行，具体请参考应用/服务运行。 运行测试用例，可以采用如下几种方式来运行。在工程目录中，单击右键 > Run'测试类名称'，执行测试。 打开测试套件，单击对应方法左侧按钮。 如果要根据自定义的配置执行Ohos Test，在创建测试用例运行任务后，通过如下方式的其中之一，执行Ohos Test：在工具栏主菜单单击Run > Run'测试名称'。在DevEco Studio的右上角，选择测试任务，然后单击右侧的按钮，执行Ohos Test。    执行完测试任务后，查看测试结果。   创建OpenHarmony Test测试用例运行任务可选操作，默认情况下，测试用例可直接运行，如果需要自定义测试用例运行任务，可通过如下方法进行设置。 在工具栏主菜单单击Run>Edit Configurations进入Run/Debug Configurations界面。在Run/Debug Configurations界面，单击+按钮，在弹出的下拉菜单中，单击OpenHarmony Test。  根据实际情况，配置Ohos Test的运行参数。 然后单击OK，完成配置。   OpenHarmony Test代码覆盖率统计
说明
仅API 9的ArkTS工程支持。 
 在OpenHarmony Test运行的基础上支持代码覆盖率统计，当前支持ArkTS语言的工程。可以采用如下几种方式来启动基于代码覆盖率统计的运行。在工程目录中，单击右键 > Run'测试类名称'with coverage，执行测试。 打开测试套件，单击对应方法左侧按钮。   执行完测试任务后，控制台中会打印报告的路径。 在本地找到报告的位置并在浏览器中打开，查看代码覆盖率详情。   HarmonyOS Test 创建HarmonyOS Test测试用例ArkTS、JS和Java的HarmonyOS Test测试用例创建方式相同，本文将以ArkTS为例进行说明。 创建一个待测试的ArkTS工程或者打开一个已有工程。在工程目录下打开待测试模块下的ets文件，将光标置于代码中任意位置，单击右键 > Show Context Actions > Create Ohos Test或快捷键Alt+enter > Create Ohos Test创建测试类。当前支持entry和feature模块的测试。 在弹出的Create Ohos Test窗口，输入或选择如下参数。Testing library：测试类型，默认为DECC-ArkTSUnit，JS语言默认为DECC-JSUnit，Java默认为DECC-JUnitArkTS name：创建的测试套件名称。测试套件为包含了测试用例的文件。测试套件名称要求在工程目录范围内具有唯一性，且不能使用逗号、横线、空格以及\ / : * ? “”< > | （）&等特殊字符。Destination package：测试套件存放的位置，建议存放在待测试模块的test目录下。Generate：通用模板，在创建用例时会自动生成勾选项对应的模板。 选项  含义    beforeAll  在测试套内定义一个预置条件，在所有测试用例开始前执行且仅执行一次，支持一个参数：预置动作函数。   afterAll  在测试套内定义一个清理条件，在所有测试用例结束后执行且仅执行一次，支持一个参数：清理动作函数。   beforeEach  在测试套内定义一个单元预置条件，在每条测试用例开始前执行，执行次数与it定义的测试用例数一致，支持一个参数：预置动作函数。   afterEach  在测试套内定义一个单元清理条件，在每条测试用例结束后执行，执行次数与it定义的测试用例数一致，支持一个参数：清理动作函数。       DevEco Studio在ohosTest目录下自动生成对应的测试类。在测试类中，DevEco Studio会生成对应方法的用例模板，具体测试代码需要开发者根据业务逻辑进行开发，具体请参考：单元测试框架  
说明
您也可以手动在ohosTest > ets > test文件夹下创建测试用例，手动创建后，需要在List.test.ets文件中添加创建的用例类。 测试用例名称应保持唯一性，并且不能使用逗号、横线、空格以及\ / : * ? “”< > | （）&等特殊字符。 
   运行HarmonyOS Test测试用例 HarmonyOS Test测试支持在真机设备及远程模拟器和本地模拟器设备上运行测试。 在真机设备上运行：需要对测试模块进行签名，具体签名指导请参考为应用/服务进行签名。在模拟器上运行：使用远程模拟器运行测试用例，需要登录并授权，具体请参考使用模拟器运行应用/服务。 连接真机设备或者启动远程模拟器或本地模拟器。执行测试用例，有如下多种执行方法。
说明
对于API Version 4至7的工程，如果执行跨设备的分布式测试用例，请先在运行配置页面勾选“Run Cross Device”。在DevEco Studio菜单栏上，单击Run > Edit Configurations，打开运行配置页面。或在工程目录选中测试类，单击右键 > Modify Run Configuration，打开运行配置页面。 
 在工程目录选中测试类，单击右键 > Run'测试类名称'，执行测试。 打开具体的测试类，单击对应方法左侧按钮。 单击Run > Edit Configurations，然后单击+按钮选择“HarmonyOS Test”，新建测试任务。 选择Tests-Task1任务，单击右侧的Run按钮启动测试。   查看测试结果。测试用例执行完成后，测试报告列表将出现在DevEco Studio左下角的run面板上。如果存在失败测试用例，您可以通过单击测试用例名称来查看具体的失败信息。  HarmonyOS JUnit单元测试 创建HarmonyOS JUnit测试用例创建一个待测试的工程或者打开一个已有工程。打开需要测试的类，单击右键 > Show Context Actions > Create Test或快捷键Alt+enter > Create Test创建测试类。 勾选需要测试的方法，测试库选择JUnit，然后单击OK。 选择测试用例目录，选择Test目录，单击OK。 系统在Test目录下自动生成对应的测试类。在测试类中，IDE会生成对应方法的用例模板，具体测试代码需要开发者根据业务逻辑进行开发。    运行HarmonyOS JUnit测试用例可使用以下方法的任意一种运行测试用例。 在工程目录中，单击右键 > Run'测试类名称'，执行测试。 打开测试套件，单击对应方法左侧按钮。 单击Run > Edit Configurations，然后单击+按钮选择“HarmonyOS JUnit“，新建测试任务在工具栏主菜单单击Run > Run'测试名称'。在DevEco Studio的右上角，选择测试任务，然后单击右侧的按钮，执行Harmony JUnit Test。 运行后，查看测试结果。      上一篇 应用/服务测试 下一篇 原子化服务体检 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建一个新工程运行Hello World创建和运行Hello World 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio配置开发环境完成后，可以通过运行Hello World工程来验证环境设置是否正确。接下来以创建一个Phone设备的工程为例进行介绍。 创建一个新工程打开DevEco Studio，在欢迎页单击Create Project，创建一个新工程。根据工程创建向导，选择创建Application应用或Atomic Service元服务。选择“Empty Ability”模板，然后单击Next。关于工程模板的介绍和支持的设备类型，请参考工程模板和开发语言介绍。  填写工程相关信息，保持默认值即可，单击Finish。关于各个参数的详细介绍，请参考创建一个新的工程。
说明
默认情况下，新建工程的Compile SDK为9，在设备中运行该工程时，请选择API 9及以上的设备才能运行该工程。 
   工程创建完成后，DevEco Studio会自动进行工程的同步。   运行Hello WorldHello World工程可以运行在模拟器中，或者运行在真机设备中。本示例以选择将Hello World工程运行在模拟器中进行说明，如果选择运行在真机设备中，需要先对工程进行签名，然后才能运行在真机设备中，详细指导请参考在Phone设备中运行应用/服务。 DevEco Studio提供远程模拟器和本地模拟器，本示例以远程模拟器为例进行说明。关于本地模拟器的使用请参考使用Local Emulator运行应用/服务。 在DevEco Studio菜单栏，单击Tools > Device Manager。在Remote Emulator页签中单击Sign In，在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录。
说明
推荐使用最新版本Chrome浏览器，如果使用Safari、360等其他浏览器，要取消阻止跨站跟踪和阻止所有Cookie功能。点击Sign in之后，如果DevEco Studio一直显示进度条等待弹框，并未有浏览器弹出并打开开发者联盟登录界面，此时您可以主动切换到浏览器查看相应的界面。更多问题可以查看远程模拟器登录常见问题。 
 登录后，请单击界面的允许按钮进行授权，授权完成后，切换回Device Manager界面。 在设备列表中，选择Phone设备P50，并单击按钮，运行模拟器。 单击DevEco Studio工具栏中的按钮运行工程，或使用默认快捷键Shift+F10（macOS为Control+R）运行工程。 DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在模拟器上。    上一篇 配置开发环境 下一篇 工程管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介基本概念事件设计规范接口说明开发步骤应用事件打点开发指导 更新时间: 2024-03-20 16:30 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
   简介 传统的日志系统里汇聚了整个设备上所有程序运行的过程流水日志，难以识别其中的关键信息。因此，应用开发者需要一种数据打点机制，用来评估如访问数、日活、用户操作习惯以及影响用户使用的关键因素等关键信息。 HiAppEvent是在系统层面为应用开发者提供的一种事件打点机制，用于帮助应用记录在运行过程中发生的故障信息、统计信息、安全信息、用户行为信息，以支撑开发者分析应用的运行情况。   基本概念  打点 记录由用户操作引起的变化，提供业务数据信息，以供开发、产品、运维分析。    事件设计规范  事件领域：用于标识事件的领域，建议设置为业务模块名称，以便于区分不同的业务模块。 事件名称：用于指定事件的名称，建议设置为具体的业务名称，以便于描述实际的业务意义。 事件类型：用于指定事件的类型，支持以下四种类型事件：        行为事件：用于记录用户日常操作行为的事件，例如按钮点击、界面跳转等行为。 故障事件：用于定位和分析应用故障的事件，例如界面卡顿、掉网掉话等异常。 统计事件：用于统计和度量应用关键行为的事件，例如对使用时长、访问数等的统计。 安全事件：用于记录涉及应用安全行为的事件，例如密码修改、用户授权等行为。  事件参数：用于指定事件的参数，每个事件可以包含一组参数，建议设置为事件属性或事件发生上下文信息，以便于描述事件的详细信息。    接口说明 应用事件打点接口由hiAppEvent模块提供，API接口的具体使用说明（参数使用限制、具体取值范围等）请参考应用事件打点API文档。 打点接口功能介绍：     接口名 描述    write(AppEventInfo info, AsyncCallback<void> callback): void 应用事件异步打点方法，使用callback方式作为异步回调。   write(AppEventInfo info): Promise<void> 应用事件异步打点方法，使用Promise方式作为异步回调。    订阅接口功能介绍：     接口名 描述    addWatcher(Watcher watcher): AppEventPackageHolder 添加应用事件观察者，以添加对应用事件的订阅。   removeWatcher(Watcher watcher): void 移除应用事件观察者，以移除对应用事件的订阅。      开发步骤 以实现对用户点击按钮行为的事件打点及订阅为例，说明开发步骤。  新建一个ArkTS应用工程，编辑工程中的“entry > src > main > ets > entryability > EntryAbility.ts” 文件，在onCreate函数中添加对用户点击按钮事件的订阅，完整示例代码如下： DOC.hasCopyimport hilog from '@ohos.hilog';import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window'import hiAppEvent from '@ohos.hiviewdfx.hiAppEvent'
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);        hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');        hilog.info(0x0000, 'testTag', '%{public}s', 'want param:' + JSON.stringify(want) ?? '');        hilog.info(0x0000, 'testTag', '%{public}s', 'launchParam:' + JSON.stringify(launchParam) ?? '');        hiAppEvent.addWatcher({            // 开发者可以自定义观察者名称，系统会使用名称来标识不同的观察者            name: "watcher1",            // 开发者可以订阅感兴趣的应用事件，此处是订阅了按钮事件            appEventFilters: [{ domain: "button" }],            // 开发者可以设置订阅回调触发的条件，此处是设置为事件打点数量满足1个            triggerCondition: { row: 1 },            // 开发者可以自行实现订阅回调函数，以便对订阅获取到的事件打点数据进行自定义处理            onTrigger: function (curRow, curSize, holder) {                // 返回的holder对象为null，表示订阅过程发生异常，因此在记录错误日志后直接返回                if (holder == null) {                    hilog.error(0x0000, 'testTag', "HiAppEvent holder is null")                    return                }                let eventPkg = null                // 根据设置阈值大小（默认为512KB）去获取订阅事件包，直到将订阅数据全部取出                // 返回的事件包对象为null，表示当前订阅数据已被全部取出，此次订阅回调触发结束                while ((eventPkg = holder.takeNext()) != null) {                    // 开发者可以对事件包中的事件打点数据进行自定义处理，此处是将事件打点数据打印在日志中                    hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.packageId=%{public}d`, eventPkg.packageId)                    hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.row=%{public}d`, eventPkg.row)                    hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.size=%{public}d`, eventPkg.size)                    for (const eventInfo of eventPkg.data) {                        hilog.info(0x0000, 'testTag', `HiAppEvent eventPkg.info=%{public}s`, eventInfo)                    }                }            }        })    }} 编辑工程中的“entry > src > main > ets > pages > Index.ets” 文件，添加一个按钮并在其onClick函数中进行事件打点，以记录按钮点击事件，完整示例代码如下： DOC.hasCopyimport hiAppEvent from '@ohos.hiviewdfx.hiAppEvent'import hilog from '@ohos.hilog'
@Entry@Componentstruct Index {  @State message: string = 'Hello World'  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button("writeTest").onClick(()=>{          // 在按钮点击函数中进行事件打点，以记录按钮点击事件          hiAppEvent.write({            // 事件领域定义            domain: "button",            // 事件名称定义            name: "click",            // 事件类型定义            eventType: hiAppEvent.EventType.BEHAVIOR,            // 事件参数定义            params: { click_time: 100 }          }).then(() => {            hilog.info(0x0000, 'testTag', `HiAppEvent success to write event`)          }).catch((err) => {            hilog.error(0x0000, 'testTag', `HiAppEvent err.code: ${err.code}, err.message: ${err.message}`)          })        })      }      .width('100%')    }    .height('100%')  }} 点击IDE界面中的运行按钮，运行应用工程，然后在应用界面中点击按钮“writeTest”，触发一次按钮点击事件打点。 最终，可以在Log窗口看到按钮点击事件打点成功的日志，以及触发订阅回调后对打点事件数据的处理日志： DOC.hasCopyHiAppEvent success to write event
HiAppEvent eventPkg.packageId=0HiAppEvent eventPkg.row=1HiAppEvent eventPkg.size=124HiAppEvent eventPkg.info={"domain_":"button","name_":"click","type_":4,"time_":1670268234523,"tz_":"+0800","pid_":3295,"tid_":3309,"click_time":100}    上一篇 DFX 下一篇 性能打点跟踪开发指导 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件收集Hitrace日志Hitrace调用链分析HiTrace日志跟踪定位分析 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
DevEco Studio 3.1 Release版本暂不支持对HarmonyOS设备中运行的应用进行日志跟踪，我们将在后续版本提供全新的日志跟踪工具，敬请期待。如当前需使用该功能，请下载DevEco  Studio 3.0 Release版本进行使用。 
 在HarmonyOS跨设备分布式应用/服务的问题定位过程中，由于跨设备之间的调用关系复杂，导致问题定位困难。DevEco Studio提供了HiTrace日志跟踪的能力，可以分析和梳理跨设备分布式应用/服务之间的调用关系，通过分析调用链，方便开发者定位调用异常、性能瓶颈等问题。 前提条件调测的多个设备成功组网，包括连接到同一个WLAN网络和登录同一个华为帐号。  收集Hitrace日志在需要跟踪调用链的RPC调用处，前后分别添加Hitrace类接口，用于采集Hitrace日志。对应的示例代码如下所示：已复制 HiTraceId saveId = HiTrace.getId(); if (saveId.isValid()) {        HiTrace.clearId(); } HiTraceId id = HiTrace.begin("MyServiceName", HITRACE_FLAG_INCLUDE_ASYNC | HITRACE_FLAG_TP_INFO); ...... HiTrace.end(id); if (saveId.isValid()) {        HiTrace.setId(saveId); } 在设备上运行应用/服务，跨设备运行分布式应用/服务的方法请参考运行/调试分布式应用。在底部工具栏单击Profiler，打开Hitrace工具。 在Hitrace窗口，单击Record（或）按钮，开始收集Hitrace日志信息，然后在设备上操作分布式应用/服务。单击按钮，停止收集Hitrace日志信息。日志采集完成后，可以看到如下的时序视图（上半部分）和调用链详情视图（下半部分）。   Hitrace调用链分析如上图所示，Hitrace日志采集完成后，会生成时序视图和调用链详情视图，可以利用时序图和调用链详细视图来进行性能分析和故障定位。 利用时序图+调用链视图中的Call Tree视图，可以分析分布式跨设备与跨进程的调用关系。在时序图中，使用不同颜色矩形块区分不同的调用关系，在矩形块中，可以查看调用的开始时间、结束时间和处理时长，帮助开发者分析处理性能。单击时序图中的矩形块，则会展示进程的调用方向，从而查看其是调用方或被调用方；同时在Call Tree视图中，也可以清晰的展示进程的调用关系（单设备跨进程调用、跨设备进程调用、调用时长等）。   利用时序图+调用链视图中的Events视图，可以进行分布式调用的故障定位、诊断和分析。在时序图中，可以展示相关的异常事件，包括Java Crash异常、JS Crash异常、C/C++ Crash异常、跨设备FA调用异常、ANR故障等。单击时序图中的异常事件，则会在Events视图中展示具体的异常细节，并会自动抓取异常前30s的详细日志信息。     上一篇 分析HarmonyOS应用/服务能耗 下一篇 OpenHarmony应用性能分析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介基本概念接口说明开发步骤分布式跟踪开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   简介 hiTraceChain是基于云计算分布式跟踪调用链思想，在端侧业务流程（涉及跨线程、跨进程、跨设备）中的一种轻量级实现。hiTraceChain在业务控制面流程中，生成和传递唯一跟踪标识，在业务流程中输出的各类信息中（包括应用事件、系统时间、日志等）记录该跟踪标识。在调试、问题定位过程中，开发者可以通过该唯一跟踪标识将本次业务流程端到端的各类信息快速关联起来。hiTraceChain为开发者提供业务流程调用链跟踪的维测接口，帮助开发者迅速获取指定业务流程调用链的运行日志，定位跨设备/跨进程/跨线程的故障问题。   基本概念  chainId 分布式跟踪标识，属于HiTraceId的一部分，用于标识当前跟踪的业务流程。    接口说明 分布式跟踪接口由hiTraceChain模块提供，详细API请参考分布式跟踪API参考。 分布式跟踪接口功能介绍：     接口名 返回值 描述    hiTraceChain.begin(name: string, flags: number = HiTraceFlag.DEFAULT) HiTraceId 开始跟踪。   hiTraceChain.end(id: HiTraceId) void 结束跟踪。      开发步骤 在应用启动执行页面加载后，开始分布式跟踪，完成业务之后，停止分布式跟踪。  新建一个JS应用工程，在“Project”窗口点击“entry > src > main > js > default > pages > index”，打开工程中的“index.js”文件，在页面执行加载后，在实际业务逻辑中调用hiTraceChain的API，进行分布式跟踪，示例代码如下： 已复制import hiTraceChain from '@ohos.hiTraceChain'
export default {    data: {        title: ""    },    onInit() {        this.title = this.$t('strings.world');
        // 1、开启分布式跟踪        let asyncTraceId = hiTraceChain.begin("business", hiTraceChain.HiTraceFlag.INCLUDE_ASYNC | hiTraceChain.HiTraceFlag.DONOT_CREATE_SPAN);                // 2、业务流程开始        console.log(`business start`);
        // 3、埋点操作        hiTraceChain.tracepoint(hiTraceChain.HiTraceCommunicationMode.THREAD, hiTraceChain.HiTraceTracepointType.SS, asyncTraceId, "Just a example");
        // 4、业务流程执行中        console.log(`business running`);
        // 5、业务流程结束        console.log(`business end`);
        // 6、停止跟踪        hiTraceChain.end(asyncTraceId);    }} 运行项目，点击应用界面上的运行按钮，即可通过日志信息分析实际业务。    上一篇 性能打点跟踪开发指导 下一篇 错误管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介基本概念实现原理约束与限制接口说明开发步骤性能打点跟踪开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   简介 hiTraceMeter为开发者提供系统性能打点接口。开发者通过在自己的业务逻辑中的关键代码位置调用HiTraceMeter接口提供的API接口，能够有效跟踪进程轨迹、查看系统性能。   基本概念  hiTraceMeter Tag 跟踪数据使用类别分类，称作hiTraceMeter Tag或hiTraceMeter Category，一般每个软件子系统对应一个Tag，该Tag在打点API中以类别Tag参数传入。hiTraceMeter命令行工具采集跟踪数据时，只采集给定的Tag类别选项指定的跟踪数据。    实现原理  应用程序通过hiTraceMeter函数接口进行打点，hiTraceMeter函数将跟踪数据通过内核sysfs文件接口输出到内核的ftrace数据缓冲区。 hiTraceMeter命令行工具读取内核ftrace缓冲区中的跟踪数据，将文本格式的跟踪数据保存到设备侧的文件中。    约束与限制  由于JS程序的异步IO特性，现在hiTraceMeter只提供了异步接口。    接口说明 性能打点跟踪接口由hiTraceMeter模块提供，详细API请参考性能打点跟踪API参考。 性能打点跟踪接口功能介绍：     接口名 返回值 描述    hiTraceMeter.startTrace(name: string, taskId: number) void 标记一个预跟踪耗时任务的开始。taskId是trace中用来表示关联的ID,如果有多个name相同的任务是并行执行的，则每次调用startTrace的taskId不同。如果具有相同name的任务是串行执行的，则taskId可以相同。   hiTraceMeter.finishTrace(name: string, taskId: number) void name和taskId必须与流程开始的hiTraceMeter.startTrace对应参数值保持一致。   hiTraceMeter.traceByValue(name: string, value: number) void 用来标记一个预跟踪的数值变量，该变量的数值会不断变化。      开发步骤 在应用启动执行页面加载后，开始分布式跟踪，完成业务之后，停止分布式跟踪。  新建工程，并在业务中调用hiTraceMeter接口，进行性能打点跟踪。        ArkTS应用工程           新建一个ArkTS应用工程，在“Project”窗口点击“entry > src > main > ets > pages > index”，打开工程中的“index.ets”文件，在页面执行加载后，在自己的业务中调用hiTraceMeter的接口，进行性能打点跟踪，以任务名name为HITRACE_TAG_APP为例 示例代码如下：          已复制import hitrace from '@ohos.hiTraceMeter';
@Entry@Componentstruct Index {  @State message: string = 'Hello World';
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            this.message = 'Hello ArkUI';
            // 跟踪并行执行的同名任务            hitrace.startTrace("HITRACE_TAG_APP", 1001);            // 业务流程            console.log(`HITRACE_TAG_APP running`);
            // 第二个跟踪任务开始，同时第一个跟踪的同名任务还没结束，出现了并行执行，对应接口的taskId需要不同。            hitrace.startTrace("HITRACE_TAG_APP", 1002);            // 业务流程            console.log(`HITRACE_TAG_APP running`);
            hitrace.finishTrace("HITRACE_TAG_APP", 1001);            hitrace.finishTrace("HITRACE_TAG_APP", 1002);
            // 跟踪串行执行的同名任务，taskId可以不同，也可以相同            hitrace.startTrace("HITRACE_TAG_APP", 1003);            // 业务流程            console.log(`HITRACE_TAG_APP running`);            //第一个跟踪的任务结束            hitrace.finishTrace("HITRACE_TAG_APP", 1003);
            // 第二个跟踪任务开始，同名的待跟踪任务串行执行，且taskId不同            hitrace.startTrace("HITRACE_TAG_APP", 1004);            // 业务流程            console.log(`HITRACE_TAG_APP running`);            let traceCount = 3;            hitrace.traceByValue("myTestCount", traceCount);            hitrace.finishTrace("HITRACE_TAG_APP", 1004);
            // 第三个跟踪任务开始，同名的待跟踪任务串行执行，且taskId与上一个相同            hitrace.startTrace("HITRACE_TAG_APP", 1004);            // 业务流程            console.log(`HITRACE_TAG_APP running`);            //第三个跟踪的任务结束            hitrace.finishTrace("HITRACE_TAG_APP", 1004);
          })       }       .width('100%')     }     .height('100%')   }}  JS应用工程           新建一个JS应用工程，在“Project”窗口点击“entry > src > main > js > default > pages > index”，打开工程中的“index.js”文件，在页面执行加载后，在自己的业务中调用hiTraceMeter的接口，进行性能打点跟踪，示例代码如下：          已复制import hiTraceMeter from '@ohos.hiTraceMeter'
export default {    data: {        title: ""    },    onInit() {        this.title = this.$t('strings.world');
        // 跟踪并行执行的同名任务        hiTraceMeter.startTrace("business", 1);        // 业务流程        console.log(`business running`);        hiTraceMeter.startTrace("business", 2);  // 第二个跟踪任务开始，同时第一个跟踪的同名任务还没结束，出现了并行执行，对应接口的taskId需要不同。        // 业务流程        console.log(`business running`);        hiTraceMeter.finishTrace("business", 1);        // 业务流程        console.log(`business running`);        hiTraceMeter.finishTrace("business", 2);
        // 跟踪串行执行的同名任务        hiTraceMeter.startTrace("business", 1);        // 业务流程        console.log(`business running`);        hiTraceMeter.finishTrace("business", 1);  // 第一个跟踪的任务结束        // 业务流程        console.log(`business running`);        hiTraceMeter.startTrace("business", 1);   // 第二个跟踪的同名任务开始，同名的待跟踪任务串行执行。        // 业务流程        console.log(`business running`);
        let traceCount = 3;        hiTraceMeter.traceByValue("myTestCount", traceCount);        traceCount = 4;        hiTraceMeter.traceByValue("myTestCount", traceCount);        hiTraceMeter.finishTrace("business", 1);    }}   运行项目，点击应用界面上的运行按钮，在shell中依次执行如下命令： 已复制hdc shellhitrace --trace_begin app 执行抓取trace命令后，先在设备中自己的业务里面调用接口，继续依次执行如下命令： 已复制hitrace --trace_dump | grep tracing_mark_writehitrace --trace_finish 抓取trace成功的数据如下所示 已复制<...>-3310    (-------) [005] .... 351382.921936: tracing_mark_write: S|3310|H:HITRACE_TAG_APP 1001<...>-3310    (-------) [005] .... 351382.922138: tracing_mark_write: S|3310|H:HITRACE_TAG_APP 1002<...>-3310    (-------) [005] .... 351382.922165: tracing_mark_write: F|3310|H:HITRACE_TAG_APP 1001<...>-3310    (-------) [005] .... 351382.922175: tracing_mark_write: F|3310|H:HITRACE_TAG_APP 1002<...>-3310    (-------) [005] .... 351382.922182: tracing_mark_write: S|3310|H:HITRACE_TAG_APP 1003<...>-3310    (-------) [005] .... 351382.922203: tracing_mark_write: F|3310|H:HITRACE_TAG_APP 1003<...>-3310    (-------) [005] .... 351382.922210: tracing_mark_write: S|3310|H:HITRACE_TAG_APP 1004<...>-3310    (-------) [005] .... 351382.922233: tracing_mark_write: C|3310|H:myTestCount 3<...>-3310    (-------) [005] .... 351382.922240: tracing_mark_write: F|3310|H:HITRACE_TAG_APP 1004<...>-3310    (-------) [005] .... 351382.922247: tracing_mark_write: S|3310|H:HITRACE_TAG_APP 1004<...>-3310    (-------) [005] .... 351382.922266: tracing_mark_write: F|3310|H:HITRACE_TAG_APP 1004    上一篇 应用事件打点开发指导 下一篇 分布式跟踪开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Code Linter代码检查配置代码检查规则查看/处理代码检查结果代码Code Linter检查 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 Code Linter代码检查Code-Linter针对ArkTS/TS代码进行最佳实践、编程规范方面的检查，目前还会检查ArkTS语法规则。开发者可根据扫描结果中告警提示手工修复代码缺陷，或者执行一键式自动修复，在代码开发阶段，确保代码质量。 检查方法： 在已打开的代码编辑器窗口单击右键点击Code Linter，或在工程管理窗口中鼠标选中单个或多个工程文件/目录，右键选择Code Linter执行代码检查。    配置代码检查规则在工程根目录下创建code-linter.json5配置文件，可对于代码检查的范围及对应生效的检查规则进行配置，其中files和ignore配置项共同确定了代码检查范围，ruleSet和rules配置项共同确定了生效的规则范围。具体配置项功能如下： files：配置待检查的文件名单，如未指定目录，规则适用于所有文件，例如：[“**/*.ets”,”**/*.js”,”**/*.ts”]； ignore：配置无需检查的文件目录，其指定的目录或文件需使用相对路径格式，相对于code-linter.json5所在工程根目录，例如：build/**/*； ruleSet：配置检查使用的规则集，规则集支持一次导入多条规则；目前仅支持all和recommended两种规则集，规则详情请参见代码检查规则表。 rules：可以基于ruleSet配置的规则集，新增额外规则项，或修改ruleSet中规则默认配置，例如：将规则集中某条规则告警级别由warn改为error。 overrides：针对工程根目录下部分特定目录或文件，可配置定制化检查的规则。 已复制{  "files":   //用于表示配置适用的文件范围的 glob 模式数组。在没有指定的情况下，应用默认配置  [    "**/*.ets",   //字符串类型    "**/*.js",    "**/*.ts"  ],  "ignore":  //一个表示配置对象不应适用的文件的 glob 模式数组。如果没有指定，配置对象将适用于所有由 files 匹配的文件  [    "build/**/*",    //字符串类型    "node_modules/**/*"  ],  "ruleSet":       //设置检查待应用的规则集, 当前仅支持IDE内置规则集all、recommended  [    "plugin:@typescript-eslint/recommended"    //快捷批量引入的规则集, 枚举类型：plugin:@typescript-eslint/all, plugin:@typescript-eslint/recommended  ],  "rules":         //可以对ruleSet配置的规则集中特定的某些规则进行修改、去使能, 或者新增规则集以外的规则；ruleSet和rules共同确定了代码检查所应用的规则  {    "@typescript-eslint/no-explicit-any":  // ruleId后面跟数组时, 第一个元素为告警级别, 后面的对象元素为规则特定开关配置    [      "error",              //告警级别: 枚举类型, 支持配置为error, warn, off      {        "ignoreRestArgs": true   //规则特定的开关配置, 为可选项, 不同规则其下层的配置项不同      }    ],    "@typescript-eslint/explicit-function-return-type": 2,   // ruleId后面跟单独一个数字时, 表示仅设置告警级别, 枚举值为: 2(error), 1(warn), 0(off)    "@typescript-eslint/no-unsafe-return": "warn"            // ruleId后面跟单独一个字符串时, 表示仅设置告警级别, 枚举值为: error, warn, off  },  "overrides":      //针对特定的目录或文件采用定制化的规则配置  [    {      "files":   //指定需要定制化配置规则的文件或目录      [        "entry/**/*.ts"   //字符串类型      ],      "excluded":      [        "entry/**/*.test.js" //指定需要排除的目录或文件, 被排除的目录或文件不会被检查; 字符串类型      ],      "rules":   //支持对overrides外公共配置的规则进行修改、去使能, 或者新增公共配置以外的规则; 该配置将覆盖公共配置      {        "@typescript-eslint/explicit-function-return-type":  // ruleId: 枚举类型        [          "warn",     //告警级别: 枚举类型, 支持配置为error, warn, off; 覆盖公共配置, explicit-function-return-type告警级别为warn          {             allowExpressions: true    //规则特定的开关配置, 为可选项, 不同规则其下层的配置项不同          }        ],        "@typescript-eslint/no-unsafe-return": "off"   // 覆盖公共配置, 不检查no-unsafe-return规则      }    }  ]}  查看/处理代码检查结果扫描完成后，在底部工具面板查看检查结果。双击某条告警结果，可以跳转到对应代码缺陷位置；选中告警结果时，可以在右侧Defect Description窗口查看告警对应的规则详细说明，其中包含正向和反向示例，并根据其中的建议修改代码。打开修复模式开关，查看可修复的代码规则，点击代码修复图标，可以一键式批量修复告警，并刷新检查结果。  屏蔽告警信息： 在某些特殊场景下，若扫描结果中出现误报，点击单条告警结果后的Ignore图标，可以忽略对告警所在行的code linter检查；或勾选多条待屏蔽的告警，点击工具面板右上角“屏蔽告警”图标批量执行；点击文件后的Ignore图标可以忽略对整个文件的code linter检查；在文件顶部添加注释/* eslint-disable */可以屏蔽整个文件执行code linter检查，在eslint-disable 后加入一个或多个以逗号分隔的规则Id，可以屏蔽具体检查规则；在需要忽略检查的代码块前后分别添加/* eslint-disable */和/* eslint-enable */添加注释信息，再执行Code Linter，将不再显示该代码块扫描结果；在待屏蔽的代码行前一行添加/* eslint-disable-next-line */，也可屏蔽对该代码行的codelinter检查。 如需恢复忽略的报错信息，可以直接删除该行上方的注释，重新执行Code Linter检查。  导出检查结果：点击工具面板右上角导出按钮，即可导出检查结果到excel文件，包含告警所在行，告警明细，告警级别等信息。    上一篇 使用预览器查看应用/服务效果 下一篇 代码Quick Fix快速修复 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。调试HarmonyOS应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    为应用/服务进行签名  使用真机进行调试  使用模拟器进行调试   上一篇 应用/服务调试 下一篇 为应用/服务进行签名 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。运行HarmonyOS应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     使用本地真机运行应用/服务  使用模拟器运行应用/服务  使用远程真机运行应用/服务   上一篇 应用/服务运行 下一篇 使用本地真机运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用约束操作步骤Hot Reload 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio提供Hot Reload（热重载）能力，支持开发者在真机上运行/调试运行应用时，修改代码并保存后无需重启应用，在真机上即可使用最新的代码，帮助开发者更快速地进行调试。 
说明
Hot Reload支持API Version 9 Stage模型的ArkTS工程。 
 使用约束只支持真机调试。只允许修改一个文件，超出一个文件无法触发Hot Reload。同一时间只支持一个工程进行热重载。支持修改UI代码，包括增删改、新增代码可以调用本代码文件或其他代码文件的类和方法，但是不支持new任何对象。支持调整组件响应事件的函数，修改函数实现，新增代码可以调用本代码文件或其它代码文件的类和方法，但是不支持new任何对象。  Hot Reload不支持以下场景：不支持增加和删除代码文件。不支持新增和删除类；不支持新增、删除和修改已有类的成员方法和成员变量；不支持调整装饰器；不支持调整import代码。在一个页面中不支持两个及以上的struct组件或class类的修改、引用热重载，可以通过新建页面使用export、import导入导出实现struct组件或class类的引用。不支持资源修改热重载；不支持变量的热重载；不支持so的热重载。调试在命中断点时不支持热重载。  操作步骤通过USB连接真机设备。运行/调试应用，将代码编译打包运行/调试到真机上，请参考使用本地真机运行应用/服务或使用真机进行调试。修改代码后，可以通过如下操作，查看真机上修改后的显示效果。点击Hot Reload按钮： 通过快捷键方式触发Hot Reload：需要先在菜单栏点击File > Settings，选择Tools > Actions on Save，勾选Perform hot reload，点击OK完成设置。修改代码后通过快捷键Ctrl + S即可触发Hot Reload。 点击停止按钮终止运行/调试运行，退出Hot Reload模式。    上一篇 C/C++时光调试 下一篇 跨设备应用/服务调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用约束开发动态共享包创建HSP模块编译HSP模块引用动态共享包在使用方模块中引用HSP运行引用HSP的使用方模块开发及引用动态共享包 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 对于企业大型应用开发，有部分公共的资源和代码，只能在开发态静态共享，并且打包到每个依赖的HAP里，这样导致包体积较大，且有重复多份公共资源和代码重复打包到应用中。 为了解决运行态状态无法共享，以及减少包体积，让多个HAP能够共享同一公共资源代码，DevEco Studio支持动态共享包HSP（Harmony Shared Package）。 应用内HSP指的是专门为某一应用开发的HSP，只能被该应用内部其他HAP/HSP使用，用于应用内部代码、资源的共享。 应用内HSP跟随其宿主应用的APP包一起发布，与该宿主应用具有相同的包名和生命周期。 当前暂不支持跨应用共享包。 使用约束HSP及其使用方都必须是API 9及以上版本Stage模型。HSP及其使用方都必须使用模块化编译模式。  开发动态共享包 创建HSP模块通过如下两种方法，在工程中添加新的Module。方法1：鼠标移到工程目录顶部，单击鼠标右键，选择New > Module，开始创建新的Module。方法2：选中工程目录中任意文件，然后在菜单栏选择File > New > Module，开始创建新的Module。 模板类型选择Shared Library，点击Next。 在Configure New Module界面中，设置新添加的模块信息，设置完成后，单击Finish完成创建。Module name：新增模块的名称，如设置为sharedlibrary。Language：开发语言。Device type：支持的设备类型。Enable native：是否创建一个用于调用C++代码的模块。  创建完成后，会在工程目录中生成库模块及相关文件。    编译HSP模块参考应用内HSP开发指导开发完库模块后，选中模块名，然后通过DevEco Studio菜单栏的Build > Make Module ${libraryName}进行编译构建，生成HSP。  打包HSP时，会同时默认打包出HAR，在模块下build目录下可以看到*.har和*.hsp。    引用动态共享包 在使用方模块中引用HSP在使用方entry/feature模块的oh-package.json5文件中添加HSP模块引用，以引用名为sharedlibrary的HSP为例：已复制{  ...  "dependencies": {    "sharedlibrary": "file:../sharedlibrary"  }} 添加引用后，dependencies字段内的片段将出现报错：  将鼠标放置在报错处会出现提示，在提示框中点击Run 'ohpm install'。HSP目录将映射到entry/feature的oh_modules目录下：  其他引用方法与引用HAR文件和资源一致。
说明
在HSP中，通过如$r(app.string.xxxx)的方式使用本模块resources目录下的资源。注意图片等资源需放置在resources/base下的目录。如果使用相对路径的方式，例如： 在HSP模块中使用Image("common/example.png")，实际上该Image组件访问的是HSP调用方（如entry）下的资源entry/src/main/ets/common/example.png。 
   运行引用HSP的使用方模块连接本地真机或本地模拟器。单击Run > Edit Configurations，选择Deploy Multi Hap标签页，勾选Deploy Multi Hap Packages，选择使用方模块（如entry）和HSP模块（如sharedlibrary），点击OK。单击Run > Run'模块名称'（如Run 'entry'）或。DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在本地真机或模拟器上。    上一篇 开发及引用静态共享包（API 4-7） 下一篇 定义HarmonyOS IDL接口 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明request接口开发步骤HTTP数据请求 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 应用通过HTTP发起一个数据请求，支持常见的GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE、CONNECT方法。   接口说明 HTTP数据请求功能主要由http模块提供。 使用该功能需要申请ohos.permission.INTERNET权限。 权限申请请参考访问控制（权限）开发指导。 涉及的接口如下表，具体的接口说明请参考API文档。     接口名 功能描述    createHttp() 创建一个http请求。   request() 根据URL地址，发起HTTP网络请求。   destroy() 中断请求任务。   on(type: 'headersReceive') 订阅HTTP Response Header 事件。   off(type: 'headersReceive') 取消订阅HTTP Response Header 事件。   once('headersReceive')8+ 订阅HTTP Response Header 事件，但是只触发一次。      request接口开发步骤  从@ohos.net.http.d.ts中导入http命名空间。 调用createHttp()方法，创建一个HttpRequest对象。 调用该对象的on()方法，订阅http响应头事件，此接口会比request请求先返回。可以根据业务需要订阅此消息。 调用该对象的request()方法，传入http请求的url地址和可选参数，发起网络请求。 按照实际业务需要，解析返回结果。 调用该对象的off()方法，取消订阅http响应头事件。 当该请求使用完毕时，调用destroy()方法主动销毁。  已复制// 引入包名import http from '@ohos.net.http';
// 每一个httpRequest对应一个HTTP请求任务，不可复用let httpRequest = http.createHttp();// 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息// 从API 8开始，使用on('headersReceive', Callback)替代on('headerReceive', AsyncCallback)。 8+httpRequest.on('headersReceive', (header) => {    console.info('header: ' + JSON.stringify(header));});httpRequest.request(    // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定    "EXAMPLE_URL",    {        method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET        // 开发者根据自身业务需要添加header字段        header: {            'Content-Type': 'application/json'        },        // 当使用POST请求时此字段用于传递内容        extraData: {            "data": "data to send",        },        expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型        usingCache: true, // 可选，默认为true        priority: 1, // 可选，默认为1        connectTimeout: 60000, // 可选，默认为60000ms        readTimeout: 60000, // 可选，默认为60000ms        usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定    }, (err, data) => {        if (!err) {            // data.result为HTTP响应内容，可根据业务需要进行解析            console.info('Result:' + JSON.stringify(data.result));            console.info('code:' + JSON.stringify(data.responseCode));            // data.header为HTTP响应头，可根据业务需要进行解析            console.info('header:' + JSON.stringify(data.header));            console.info('cookies:' + JSON.stringify(data.cookies)); // 8+        } else {            console.info('error:' + JSON.stringify(err));            // 取消订阅HTTP响应头事件            httpRequest.off('headersReceive');            // 当该请求使用完毕时，调用destroy方法主动销毁            httpRequest.destroy();        }    });   上一篇 网络管理开发概述 下一篇 WebSocket连接 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。支持的算法类型及参数组合导入\生成密钥规格加密&解密流程算法与分组、填充模式的组合规格签名&验签流程算法与摘要算法、填充模式的组合规格密钥协商算法HMAC 密钥长度与摘要组合规格派生算法/摘要组合规格密钥证明密钥材料格式密钥对材料公钥材料私钥材料通用密钥库密码算法规格 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   支持的算法类型及参数组合   导入\生成密钥规格     算法 API级别 支持的密钥长度    AES 8+ 128、192、256   RSA 8+ 2048、3072、4096   HMAC 8+ 8-1024（含），必须是8的倍数   ECC 8+ 256、384、521   ED25519 8+ 256   X25519 8+ 256   DH 8+ 2048   SM2 9+ 256   SM4 9+ 128      加密&解密流程算法与分组、填充模式的组合规格     算法/分组模式/填充模式 API级别 备注    AES/CBC/NoPadding AES/CBC/PKCS7 AES/CTR/NoPadding 8+ IV参数必选   AES/GCM/NoPadding 8+ Nonce、AAD、AEAD参数必选   RSA/ECB/NoPadding RSA/ECB/PKCS1_V1_5 RSA/ECB/OAEP 8+ OAEP填充模式支持的摘要算法：SHA256/SHA384/SHA512   SM4/CTR/NoPadding SM4/CBC/NoPadding 9+ IV 参数必选      签名&验签流程算法与摘要算法、填充模式的组合规格     算法/摘要算法/填充模式 API级别 备注    RSA/SHA256/PKCS1_V1_5 RSA/SHA384/PKCS1_V1_5 RSA/SHA512/PKCS1_V1_5 RSA/SHA256/PSS RSA/SHA384/PSS RSA/SHA512/PSS 8+      ECC/SHA256 ECC/SHA384 ECC/SHA512 8+      ED25519/NoDigest 8+ NoDigest 需要指定TAG HuksKeyDigest.HUKS_DIGEST_NONE   SM2/SM3 9+         密钥协商算法     算法 API级别 备注    ECDH 8+ 协商密钥类型为ECC类型密钥   DH 8+      X25519 8+         HMAC 密钥长度与摘要组合规格     摘要 密钥长度 API级别    SHA256 192-1024(8的倍数) 8+   SHA384 256-1024(8的倍数) 8+   SHA512 256-1024(8的倍数) 8+      派生算法/摘要组合规格     算法/摘要 派生密钥的算法/长度 派生结果密钥可用算法/长度 备注 API级别    HKDF/SHA256 AES/192-256 AES/128/192/256 HMAC/8-1024 SM4/128 派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理 8+   HKDF/SHA384 AES/256 AES/128/192/256 HMAC/8-1024 SM4/128 派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理 8+   HKDF/SHA512 AES/256 AES/128/192/256 HMAC/8-1024 SM4/128 派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理 8+   PBKDF2/SHA256 AES/192-256 AES/128/192/256 HMAC/8-1024 SM4/128 派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理 8+   PBKDF2/SHA384 AES/256 AES/128/192/256 HMAC/8-1024 SM4/128 派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理 8+   PBKDF2/SHA512 AES/256 AES/128/192/256 HMAC/8-1024 SM4/128 派生密钥是业务基于三段式得到密钥会话结果，业务可决定派生密钥是否由HUKS管理（即密钥不出TEE）亦或是业务独立管理 8+      密钥证明     算法 API级别 备注    RSA 9+ 支持Padding为 PSS 与 PKCS1_V1_5的密钥   ECC 9+      X25519 9+         密钥材料格式 针对不同密码算法的密钥对、公钥、私钥，HUKS定义了一套密钥材料格式。   密钥对材料 密钥对材料 = 密钥对材料Header + 密钥对材料原文 以RSA密钥为例，应用需要申请一个Uint8Array，按照RSA密钥对材料内存格式，将各个变量赋值到对应的位置： 图4 RSA密钥材料内存结构  已复制let rsa2048KeyPairMaterial = new Uint8Array([    0x01, 0x00, 0x00, 0x00, // 密钥算法：huks.HuksKeyAlg.HUKS_ALG_RSA = 1    0x00, 0x08, 0x00, 0x00, // 密钥大小（比特）：2048    0x00, 0x01, 0x00, 0x00, // 模数n长度（字节）：256    0x03, 0x00, 0x00, 0x00, // 公钥指数e长度（字节）：3    0x00, 0x01, 0x00, 0x00, // 私钥指数d长度（字节）：256    // 模数n    0xc5, 0x35, 0x62, 0x48, 0xc4, 0x92, 0x87, 0x73, 0x0d, 0x42, 0x96, 0xfc, 0x7b, 0x11, 0x05, 0x06,    0x0f, 0x8d, 0x66, 0xc1, 0x0e, 0xad, 0x37, 0x44, 0x92, 0x95, 0x2f, 0x6a, 0x55, 0xba, 0xec, 0x1d,    0x54, 0x62, 0x0a, 0x4b, 0xd3, 0xc7, 0x05, 0xe4, 0x07, 0x40, 0xd9, 0xb7, 0xc2, 0x12, 0xcb, 0x9a,    0x90, 0xad, 0xe3, 0x24, 0xe8, 0x5e, 0xa6, 0xf8, 0xd0, 0x6e, 0xbc, 0xd1, 0x69, 0x7f, 0x6b, 0xe4,    0x2b, 0x4e, 0x1a, 0x65, 0xbb, 0x73, 0x88, 0x6b, 0x7c, 0xaf, 0x7e, 0xd0, 0x47, 0x26, 0xeb, 0xa5,    0xbe, 0xd6, 0xe8, 0xee, 0x9c, 0xa5, 0x66, 0xa5, 0xc9, 0xd3, 0x25, 0x13, 0xc4, 0x0e, 0x6c, 0xab,    0x50, 0xb6, 0x50, 0xc9, 0xce, 0x8f, 0x0a, 0x0b, 0xc6, 0x28, 0x69, 0xe9, 0x83, 0x69, 0xde, 0x42,    0x56, 0x79, 0x7f, 0xde, 0x86, 0x24, 0xca, 0xfc, 0xaa, 0xc0, 0xf3, 0xf3, 0x7f, 0x92, 0x8e, 0x8a,    0x12, 0x52, 0xfe, 0x50, 0xb1, 0x5e, 0x8c, 0x01, 0xce, 0xfc, 0x7e, 0xf2, 0x4f, 0x5f, 0x03, 0xfe,    0xa7, 0xcd, 0xa1, 0xfc, 0x94, 0x52, 0x00, 0x8b, 0x9b, 0x7f, 0x09, 0xab, 0xa8, 0xa4, 0xf5, 0xb4,    0xa5, 0xaa, 0xfc, 0x72, 0xeb, 0x17, 0x40, 0xa9, 0xee, 0xbe, 0x8f, 0xc2, 0xd1, 0x80, 0xc2, 0x0d,    0x44, 0xa9, 0x59, 0x44, 0x59, 0x81, 0x3b, 0x5d, 0x4a, 0xde, 0xfb, 0xae, 0x24, 0xfc, 0xa3, 0xd9,    0xbc, 0x57, 0x55, 0xc2, 0x26, 0xbc, 0x19, 0xa7, 0x9a, 0xc5, 0x59, 0xa3, 0xee, 0x5a, 0xef, 0x41,    0x80, 0x7d, 0xf8, 0x5e, 0xc1, 0x1d, 0x32, 0x38, 0x41, 0x5b, 0xb6, 0x92, 0xb8, 0xb7, 0x03, 0x0d,    0x3e, 0x59, 0x0f, 0x1c, 0xb3, 0xe1, 0x2a, 0x95, 0x1a, 0x3b, 0x50, 0x4f, 0xc4, 0x1d, 0xcf, 0x73,    0x7c, 0x14, 0xca, 0xe3, 0x0b, 0xa7, 0xc7, 0x1a, 0x41, 0x4a, 0xee, 0xbe, 0x1f, 0x43, 0xdd, 0xf9,    // 公钥指数e    0x01, 0x00, 0x01,    // 私钥指数d    0x88, 0x4b, 0x82, 0xe7, 0xe3, 0xe3, 0x99, 0x75, 0x6c, 0x9e, 0xaf, 0x17, 0x44, 0x3e, 0xd9, 0x07,    0xfd, 0x4b, 0xae, 0xce, 0x92, 0xc4, 0x28, 0x44, 0x5e, 0x42, 0x79, 0x08, 0xb6, 0xc3, 0x7f, 0x58,    0x2d, 0xef, 0xac, 0x4a, 0x07, 0xcd, 0xaf, 0x46, 0x8f, 0xb4, 0xc4, 0x43, 0xf9, 0xff, 0x5f, 0x74,    0x2d, 0xb5, 0xe0, 0x1c, 0xab, 0xf4, 0x6e, 0xd5, 0xdb, 0xc8, 0x0c, 0xfb, 0x76, 0x3c, 0x38, 0x66,    0xf3, 0x7f, 0x01, 0x43, 0x7a, 0x30, 0x39, 0x02, 0x80, 0xa4, 0x11, 0xb3, 0x04, 0xd9, 0xe3, 0x57,    0x23, 0xf4, 0x07, 0xfc, 0x91, 0x8a, 0xc6, 0xcc, 0xa2, 0x16, 0x29, 0xb3, 0xe5, 0x76, 0x4a, 0xa8,    0x84, 0x19, 0xdc, 0xef, 0xfc, 0xb0, 0x63, 0x33, 0x0b, 0xfa, 0xf6, 0x68, 0x0b, 0x08, 0xea, 0x31,    0x52, 0xee, 0x99, 0xef, 0x43, 0x2a, 0xbe, 0x97, 0xad, 0xb3, 0xb9, 0x66, 0x7a, 0xae, 0xe1, 0x8f,    0x57, 0x86, 0xe5, 0xfe, 0x14, 0x3c, 0x81, 0xd0, 0x64, 0xf8, 0x86, 0x1a, 0x0b, 0x40, 0x58, 0xc9,    0x33, 0x49, 0xb8, 0x99, 0xc6, 0x2e, 0x94, 0x70, 0xee, 0x09, 0x88, 0xe1, 0x5c, 0x4e, 0x6c, 0x22,    0x72, 0xa7, 0x2a, 0x21, 0xdd, 0xd7, 0x1d, 0xfc, 0x63, 0x15, 0x0b, 0xde, 0x06, 0x9c, 0xf3, 0x28,    0xf3, 0xac, 0x4a, 0xa8, 0xb5, 0x50, 0xca, 0x9b, 0xcc, 0x0a, 0x04, 0xfe, 0x3f, 0x98, 0x68, 0x81,    0xac, 0x24, 0x53, 0xea, 0x1f, 0x1c, 0x6e, 0x5e, 0xca, 0xe8, 0x31, 0x0d, 0x08, 0x12, 0xf3, 0x26,    0xf8, 0x5e, 0xeb, 0x10, 0x27, 0xae, 0xaa, 0xc3, 0xad, 0x6c, 0xc1, 0x89, 0xdb, 0x7d, 0x5a, 0x12,    0x55, 0xad, 0x11, 0x19, 0xa1, 0xa9, 0x8f, 0x0b, 0x6d, 0x78, 0x8d, 0x1c, 0xdf, 0xe5, 0x63, 0x82,    0x0b, 0x7d, 0x23, 0x04, 0xb4, 0x75, 0x8c, 0xed, 0x77, 0xfc, 0x1a, 0x85, 0x29, 0x11, 0xe0, 0x61,    ]); 其中，密钥算法的值取自枚举类HuksKeyAlg。  RSA密钥对材料格式：     密钥算法 密钥大小 模数n长度Ln 公钥指数e长度Le 私钥指数d长度Ld n e d    4字节 4字节 4字节 4字节 4字节 Ln字节 Le字节 Ld字节    ECC密钥对材料格式：     密钥算法 密钥大小 坐标x长度Lx 坐标y长度Ly 坐标z长度Lz x y z    4字节 4字节 4字节 4字节 4字节 Lx字节 Ly字节 Lz字节    DSA密钥对材料格式：     密钥算法 密钥大小 私钥x长度Lx 公钥y长度Ly 素数p长度Lp 素因子q长度Lq g长度Lg x y p q g    4字节 4字节 4字节 4字节 4字节 4字节 4字节 Lx字节 Ly字节 Lp字节 Lq字节 Lg字节    DH密钥对材料格式：     密钥算法 密钥大小 公钥pk长度Lpk 私钥sk长度Lsk 保留字段 pk sk    4字节 4字节 4字节 4字节 4字节 Lpk字节 Lsk字节    Curve25519密钥对材料格式：     密钥算法 密钥大小 公钥pk长度Lpk 私钥sk长度Lsk 保留字段 pk sk    4字节 4字节 4字节 4字节 4字节 Lpk字节 Lsk字节       公钥材料 在公钥导出/导入时，密钥材料采用标准的X.509规范的DER格式封装。 如下是一个DER编码的ECC公钥： 已复制let eccP256PubKey = new Uint8Array([  0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a,  0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xc0, 0xfe, 0x1c, 0x67, 0xde,  0x86, 0x0e, 0xfb, 0xaf, 0xb5, 0x85, 0x52, 0xb4, 0x0e, 0x1f, 0x6c, 0x6c, 0xaa, 0xc5, 0xd9, 0xd2,  0x4d, 0xb0, 0x8a, 0x72, 0x24, 0xa1, 0x99, 0xaf, 0xfc, 0x3e, 0x55, 0x5a, 0xac, 0x99, 0x3d, 0xe8,  0x34, 0x72, 0xb9, 0x47, 0x9c, 0xa6, 0xd8, 0xfb, 0x00, 0xa0, 0x1f, 0x9f, 0x7a, 0x41, 0xe5, 0x44,  0x3e, 0xb2, 0x76, 0x08, 0xa2, 0xbd, 0xe9, 0x41, 0xd5, 0x2b, 0x9e]);   私钥材料 复用密钥对的材料格式，私钥材料的封装是把密钥对材料Header中的公钥部分的长度字段置0，同时密钥对材料原文部分拼接私钥材料即可。 私钥材料 = 密钥对材料Header + 私钥材料原文 以RSA私钥材料为例：  已复制let rsa2048PrivateKeyMaterial = new Uint8Array([    0x01, 0x00, 0x00, 0x00, // 密钥算法：huks.HuksKeyAlg.HUKS_ALG_RSA = 1    0x00, 0x08, 0x00, 0x00, // 密钥大小（比特）：2048    0x00, 0x01, 0x00, 0x00, // 模数n长度（字节）：256    0x00, 0x00, 0x00, 0x00, // 公钥指数e长度（字节）：0    0x00, 0x01, 0x00, 0x00, // 私钥指数d长度（字节）：256    // 模数n    0xc5, 0x35, 0x62, 0x48, 0xc4, 0x92, 0x87, 0x73, 0x0d, 0x42, 0x96, 0xfc, 0x7b, 0x11, 0x05, 0x06,    0x0f, 0x8d, 0x66, 0xc1, 0x0e, 0xad, 0x37, 0x44, 0x92, 0x95, 0x2f, 0x6a, 0x55, 0xba, 0xec, 0x1d,    0x54, 0x62, 0x0a, 0x4b, 0xd3, 0xc7, 0x05, 0xe4, 0x07, 0x40, 0xd9, 0xb7, 0xc2, 0x12, 0xcb, 0x9a,    0x90, 0xad, 0xe3, 0x24, 0xe8, 0x5e, 0xa6, 0xf8, 0xd0, 0x6e, 0xbc, 0xd1, 0x69, 0x7f, 0x6b, 0xe4,    0x2b, 0x4e, 0x1a, 0x65, 0xbb, 0x73, 0x88, 0x6b, 0x7c, 0xaf, 0x7e, 0xd0, 0x47, 0x26, 0xeb, 0xa5,    0xbe, 0xd6, 0xe8, 0xee, 0x9c, 0xa5, 0x66, 0xa5, 0xc9, 0xd3, 0x25, 0x13, 0xc4, 0x0e, 0x6c, 0xab,    0x50, 0xb6, 0x50, 0xc9, 0xce, 0x8f, 0x0a, 0x0b, 0xc6, 0x28, 0x69, 0xe9, 0x83, 0x69, 0xde, 0x42,    0x56, 0x79, 0x7f, 0xde, 0x86, 0x24, 0xca, 0xfc, 0xaa, 0xc0, 0xf3, 0xf3, 0x7f, 0x92, 0x8e, 0x8a,    0x12, 0x52, 0xfe, 0x50, 0xb1, 0x5e, 0x8c, 0x01, 0xce, 0xfc, 0x7e, 0xf2, 0x4f, 0x5f, 0x03, 0xfe,    0xa7, 0xcd, 0xa1, 0xfc, 0x94, 0x52, 0x00, 0x8b, 0x9b, 0x7f, 0x09, 0xab, 0xa8, 0xa4, 0xf5, 0xb4,    0xa5, 0xaa, 0xfc, 0x72, 0xeb, 0x17, 0x40, 0xa9, 0xee, 0xbe, 0x8f, 0xc2, 0xd1, 0x80, 0xc2, 0x0d,    0x44, 0xa9, 0x59, 0x44, 0x59, 0x81, 0x3b, 0x5d, 0x4a, 0xde, 0xfb, 0xae, 0x24, 0xfc, 0xa3, 0xd9,    0xbc, 0x57, 0x55, 0xc2, 0x26, 0xbc, 0x19, 0xa7, 0x9a, 0xc5, 0x59, 0xa3, 0xee, 0x5a, 0xef, 0x41,    0x80, 0x7d, 0xf8, 0x5e, 0xc1, 0x1d, 0x32, 0x38, 0x41, 0x5b, 0xb6, 0x92, 0xb8, 0xb7, 0x03, 0x0d,    0x3e, 0x59, 0x0f, 0x1c, 0xb3, 0xe1, 0x2a, 0x95, 0x1a, 0x3b, 0x50, 0x4f, 0xc4, 0x1d, 0xcf, 0x73,    0x7c, 0x14, 0xca, 0xe3, 0x0b, 0xa7, 0xc7, 0x1a, 0x41, 0x4a, 0xee, 0xbe, 0x1f, 0x43, 0xdd, 0xf9,    // 私钥指数d    0x88, 0x4b, 0x82, 0xe7, 0xe3, 0xe3, 0x99, 0x75, 0x6c, 0x9e, 0xaf, 0x17, 0x44, 0x3e, 0xd9, 0x07,    0xfd, 0x4b, 0xae, 0xce, 0x92, 0xc4, 0x28, 0x44, 0x5e, 0x42, 0x79, 0x08, 0xb6, 0xc3, 0x7f, 0x58,    0x2d, 0xef, 0xac, 0x4a, 0x07, 0xcd, 0xaf, 0x46, 0x8f, 0xb4, 0xc4, 0x43, 0xf9, 0xff, 0x5f, 0x74,    0x2d, 0xb5, 0xe0, 0x1c, 0xab, 0xf4, 0x6e, 0xd5, 0xdb, 0xc8, 0x0c, 0xfb, 0x76, 0x3c, 0x38, 0x66,    0xf3, 0x7f, 0x01, 0x43, 0x7a, 0x30, 0x39, 0x02, 0x80, 0xa4, 0x11, 0xb3, 0x04, 0xd9, 0xe3, 0x57,    0x23, 0xf4, 0x07, 0xfc, 0x91, 0x8a, 0xc6, 0xcc, 0xa2, 0x16, 0x29, 0xb3, 0xe5, 0x76, 0x4a, 0xa8,    0x84, 0x19, 0xdc, 0xef, 0xfc, 0xb0, 0x63, 0x33, 0x0b, 0xfa, 0xf6, 0x68, 0x0b, 0x08, 0xea, 0x31,    0x52, 0xee, 0x99, 0xef, 0x43, 0x2a, 0xbe, 0x97, 0xad, 0xb3, 0xb9, 0x66, 0x7a, 0xae, 0xe1, 0x8f,    0x57, 0x86, 0xe5, 0xfe, 0x14, 0x3c, 0x81, 0xd0, 0x64, 0xf8, 0x86, 0x1a, 0x0b, 0x40, 0x58, 0xc9,    0x33, 0x49, 0xb8, 0x99, 0xc6, 0x2e, 0x94, 0x70, 0xee, 0x09, 0x88, 0xe1, 0x5c, 0x4e, 0x6c, 0x22,    0x72, 0xa7, 0x2a, 0x21, 0xdd, 0xd7, 0x1d, 0xfc, 0x63, 0x15, 0x0b, 0xde, 0x06, 0x9c, 0xf3, 0x28,    0xf3, 0xac, 0x4a, 0xa8, 0xb5, 0x50, 0xca, 0x9b, 0xcc, 0x0a, 0x04, 0xfe, 0x3f, 0x98, 0x68, 0x81,    0xac, 0x24, 0x53, 0xea, 0x1f, 0x1c, 0x6e, 0x5e, 0xca, 0xe8, 0x31, 0x0d, 0x08, 0x12, 0xf3, 0x26,    0xf8, 0x5e, 0xeb, 0x10, 0x27, 0xae, 0xaa, 0xc3, 0xad, 0x6c, 0xc1, 0x89, 0xdb, 0x7d, 0x5a, 0x12,    0x55, 0xad, 0x11, 0x19, 0xa1, 0xa9, 0x8f, 0x0b, 0x6d, 0x78, 0x8d, 0x1c, 0xdf, 0xe5, 0x63, 0x82,    0x0b, 0x7d, 0x23, 0x04, 0xb4, 0x75, 0x8c, 0xed, 0x77, 0xfc, 0x1a, 0x85, 0x29, 0x11, 0xe0, 0x61,    ]);   上一篇 通用密钥库开发指导 下一篇 加解密算法库框架 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。生成新密钥导入外部密钥明文导入加密导入常见密钥操作加密解密密钥协商密钥派生密钥访问控制密钥证明通用密钥库开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   生成新密钥 HUKS提供为业务安全随机生成密钥的能力。通过HUKS生成的密钥，密钥的全生命周期明文不会出安全环境，能保证任何人都无法接触获取到密钥的明文。即使生成密钥的业务自身，后续也只能通过HUKS提供的接口请求执行密钥操作，获取操作结果，但无法接触到密钥自身。 开发步骤 生成密钥时使用huks.generateKeyItem方法，传入keyAlias作为密钥别名，传入options包含该密钥的属性集，传入callback用于回调异步结果。关于接口的具体信息，可在API参考文档中查看。  确定密钥别名； 初始化密钥属性集：通过HuksParam封装密钥属性，搭配Array组成密钥属性集，并赋值给HuksOptions（properties字段），其中必须包含HuksKeyAlg,HuksKeySize,HuksKeyPurpose属性； 将密钥别名与密钥参数集作为参数传入，生成密钥。  
说明
 存储的 keyAlias 密钥别名最大为64字节 
 代码示例： 已复制/* * 以下以生成DH密钥的Callback操作使用为例 */import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let keyAlias = 'dh_key';let properties = new Array();properties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_DH}properties[1] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE}properties[2] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_DH_KEY_SIZE_2048}properties[3] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256}let huksOptions = {    properties: properties,    inData: new Uint8Array(new Array())}
/* * 生成密钥 */function generateKeyItem(keyAlias: string, huksOptions: huks.HuksOptions) {    return new Promise((resolve, reject) => {        try {            huks.generateKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throw (error);        }    });}
async function publicGenKeyFunc(keyAlias: string, huksOptions: huks.HuksOptions) {    console.info(`enter callback generateKeyItem`);    try {        await generateKeyItem(keyAlias, huksOptions)            .then((data) => {                console.info(`callback: generateKeyItem success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                console.error(`callback: generateKeyItem failed, code: ${error.code}, msg: ${error.message}`);            });    } catch (error) {        console.error(`callback: generateKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
async function TestGenKey() {    await publicGenKeyFunc(keyAlias, huksOptions);}   导入外部密钥 如果密钥是在HUKS外部生成（比如应用间协商生成、服务器端生成），应用可以将密钥导入到HUKS托管。HUKS支持直接将密钥明文导入到HUKS，但是明文导入会导致密钥暴露在REE内存中，一般适用于轻量级设备或低安业务。对于高安敏感业务，HUKS还提供了安全导入密钥的能力，允许业务自己生成密钥，并通过与处于安全环境中的HUKS建立端到端的加密传输通道，将密钥安全加密导入到HUKS中，确保导入传入过程中密钥不被泄露。 与生成密钥一样，密钥一旦导入到HUKS中，密钥的生命周期明文不出安全环境，同样能保证任何人都无法接触获取到密钥的明文。   明文导入 导入明文密钥时使用huks.importKeyItem(keyAlias,options,callback)方法，传入keyAlias作为密钥别名，传入options，其中必须包含密钥材料和密钥属性集，传入callback用于回调异步结果。关于接口的具体信息，可在API参考文档中查看。  确定密钥别名； 封装密钥材料和密钥属性集：密钥材料须符合HUKS密钥材料格式并以Uint8Array形式赋值给HuksOptions的inData字段；另外，通过HuksParam封装密钥属性，搭配Array组成密钥属性集赋值给properties字段，其中必须包含HuksKeyAlg,HuksKeySize,HuksKeyPurpose属性； 导入密钥。  代码示例： 已复制/* * 以导入AES256密钥为例 */ /* 密钥 */let plainTextSize32 = new Uint8Array([  0xfb, 0x8b, 0x9f, 0x12, 0xa0, 0x83, 0x19, 0xbe, 0x6a, 0x6f, 0x63, 0x2a, 0x7c, 0x86, 0xba, 0xca,  0x64, 0x0b, 0x88, 0x96, 0xe2, 0xfa, 0x77, 0xbc, 0x71, 0xe3, 0x0f, 0x0f, 0x9e, 0x3c, 0xe5, 0xf9]);
/* * 确定密钥别名 */let keyAlias = 'AES256Alias_sample';
/* * 封装密钥属性集和密钥材料 */ let properties = new Array();properties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES};properties[1] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256};properties[2] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value:    huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT};let options = {    properties: properties,    inData: plainTextSize32};
/* * 导入密钥 */try {    huks.importKeyItem(keyAlias, options, function (error, data) {        if (error) {            console.error(`callback: importKeyItem failed, code: ${error.code}, msg: ${error.message}`);        } else {            console.info(`callback: importKeyItem success`);        }    });} catch (error) {    console.error(`callback: importKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);} 调测验证 验证时查询密钥是否存在，如密钥存在即表示生成密钥成功。 代码示例： 已复制import huks from '@ohos.security.huks';
let keyAlias = 'AES256Alias_sample';let isKeyExist;
let keyProperties = new Array();keyProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES,}let huksOptions = {    properties: keyProperties, // 非空填充    inData: new Uint8Array(new Array()) // 非空填充}try {    huks.isKeyItemExist(keyAlias, huksOptions, function (error, data) {        if (error) {            console.error(`callback: isKeyItemExist failed, code: ${error.code}, msg: ${error.message}`);        } else {            if (data !== null && data.valueOf() !== null) {                isKeyExist = data.valueOf();                console.info(`callback: isKeyItemExist success, isKeyExist = ${isKeyExist}`);            }        }    });} catch (error) {    console.error(`callback: isKeyItemExist input arg invalid, code: ${error.code}, msg: ${error.message}`);}   加密导入 相比明文导入，加密导入步骤更多，密钥材料更复杂，此章节将展示开发过程中关键的开发流程和密钥材料数据结构。下图是加密导入的基本开发流程。 图2 加密导入开发流程  接口说明 根据开发流程，在导入加密密钥过程中，需要依次调用HUKS的生成密钥、导出公钥、导入加密密钥、删除密钥接口。     接口名 描述    generateKeyItem(keyAlias: string, options: HuksOptions, callback: AsyncCallback<void>) : void 生成新密钥   exportKeyItem(keyAlias: string, options: HuksOptions, callback: AsyncCallback<HuksReturnResult>) : void 导出密钥对的公钥   importWrappedKeyItem(keyAlias: string, wrappingKeyAlias: string, options: HuksOptions, callback: AsyncCallback<void>) : void 导入加密密钥   deleteKeyItem(keyAlias: string, options: HuksOptions, callback: AsyncCallback<void>) : void 删除密钥    需要注意的是，导出密钥接口返回的公钥明文材料是按照X.509格式封装，导入加密密钥接口中的密钥材料需满足LengthData-Data 的格式封装。具体，应用需要申请一个Uint8Array按照以下表格中的顺序依次封装。 表2 加密密钥材料格式     内容 业务公钥长度Lpk2 业务公钥pk2 k2加密参数AAD2长度LAAD2 k2加密参数AAD2 k2加密参数Nonce2长度LNonce2 k2加密参数Nonce2    长度 4字节 Lpk2字节 4字节 LAAD2字节 4字节 LNonce2字节   内容 k2加密参数AEAD2长度LAEAD2 k2加密参数AEAD2 k3密文长度Lk3_enc k3密文k3_enc k3加密参数AAD3长度LAAD3 k3加密参数AAD3   长度 4字节 LAEAD2字节 4字节 Lk3_enc字节 4字节 LAAD3字节   内容 k3加密参数Nonce3长度LNonce3 k3加密参数Nonce3 k3加密参数AEAD3长度LAEAD3 k3加密参数AEAD3 密钥明文材料长度 的长度Lk1'_size 密钥明文材料长度k1'_size   长度 4字节 LNonce3字节 4字节 LAEAD3字节 4字节 Lk1'_size字节   内容 k1'密文长度Lk1'_enc k1'密文k1'_enc               长度 4字节 Lk1'_enc字节                开发步骤 这里主要展示涉及调用HUKS的开发样例（使用ECDH密钥协商套件），部分在业务本地执行的步骤不在这里展示详细样例。  转换成HUKS格式的密钥材料 生成加密导入用途的密钥 导出公钥材料 封装加密导入密钥材料 导入封装的加密密钥材料 删除用于加密导入的密钥  代码示例： 已复制/* * 以下以SM2密钥的Callback操作验证为例 */import huks from '@ohos.security.huks';
/* * 确定密钥别名 */let importAlias = "importAlias";let wrapAlias = "wrappingKeyAlias";let exportKey;
/* * 加密导入用途的密钥材料原文：转换成HUKS ECC-P-256密钥对格式的密钥材料 */let inputEccPair = new Uint8Array([    0x02, 0x00, 0x00, 0x00, // 密钥算法：huks.HuksKeyAlg.HUKS_ALG_ECC = 2    0x00, 0x01, 0x00, 0x00, // 密钥大小（比特）：256    0x20, 0x00, 0x00, 0x00, // 坐标x长度（字节）：32    0x20, 0x00, 0x00, 0x00, // 坐标y长度（字节）：32    0x20, 0x00, 0x00, 0x00, // 坐标z长度（字节）：32    // 坐标x    0xa5, 0xb8, 0xa3, 0x78, 0x1d, 0x6d, 0x76, 0xe0, 0xb3, 0xf5, 0x6f, 0x43, 0x9d, 0xcf, 0x60, 0xf6,    0x0b, 0x3f, 0x64, 0x45, 0xa8, 0x3f, 0x1a, 0x96, 0xf1, 0xa1, 0xa4, 0x5d, 0x3e, 0x2c, 0x3f, 0x13,    // 坐标y    0xd7, 0x81, 0xf7, 0x2a, 0xb5, 0x8d, 0x19, 0x3d, 0x9b, 0x96, 0xc7, 0x6a, 0x10, 0xf0, 0xaa, 0xbc,    0x91, 0x6f, 0x4d, 0xa7, 0x09, 0xb3, 0x57, 0x88, 0x19, 0x6f, 0x00, 0x4b, 0xad, 0xee, 0x34, 0x35,    // 坐标z    0xfb, 0x8b, 0x9f, 0x12, 0xa0, 0x83, 0x19, 0xbe, 0x6a, 0x6f, 0x63, 0x2a, 0x7c, 0x86, 0xba, 0xca,    0x64, 0x0b, 0x88, 0x96, 0xe2, 0xfa, 0x77, 0xbc, 0x71, 0xe3, 0x0f, 0x0f, 0x9e, 0x3c, 0xe5, 0xf9    ]);
/* * 封装密钥属性参数集 */// 生成加密导入用途的密钥的属性集let properties = new Array();properties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_ECC};properties[1] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_ECC_KEY_SIZE_256};properties[2] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_UNWRAP};properties[3] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256};properties[4] = {    tag: huks.HuksTag.HUKS_TAG_IMPORT_KEY_TYPE,    value: huks.HuksImportKeyType.HUKS_KEY_TYPE_KEY_PAIR,};let huksOptions = {    properties: properties,    inData: inputEccPair};
// 待导入密钥的属性集:AES256let importProperties = new Array();importProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES};importProperties[1] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256};importProperties[2] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT};importProperties[3] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_CBC};importProperties[4] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_NONE};importProperties[5] = {    tag: huks.HuksTag.HUKS_TAG_UNWRAP_ALGORITHM_SUITE,    value: huks.HuksUnwrapSuite.HUKS_UNWRAP_SUITE_ECDH_AES_256_GCM_NOPADDING // 使用“ECDH+AES256GCM”加密导入套件};let importOptions = {    properties: importProperties,    inData: new Uint8Array(new Array())};
// 导出加密导入用途的公钥function exportKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult> {    return new Promise((resolve, reject) => {        try {            huks.exportKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicExportKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback export`);    let throwObject = {isThrow: false};    try {        await exportKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: exportKeyItem success, data = ${JSON.stringify(data)}`);                exportKey = data.outData;            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: exportKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: exportKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
// 此处用导入密钥来模拟“生成加密导入用途的密钥”function importKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.importKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicImportKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter promise importKeyItem`);    let throwObject = {isThrow: false};    try {        await importKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: importKeyItem success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: importKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: importKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
// 执行加密导入async function publicImportWrappedKey(keyAlias:string, wrappingKeyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback importWrappedKeyItem`);    var throwObject = {isThrow: false};    try {        await importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: importWrappedKeyItem success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: importWrappedKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: importWrappedKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function importWrappedKeyItem(keyAlias:string, wrappingKeyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.importWrappedKeyItem(keyAlias, wrappingKeyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
// 删除加密导入用途的密钥function deleteKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.deleteKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicDeleteKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback deleteKeyItem`);    let throwObject = {isThrow: false};    try {        await deleteKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: deleteKeyItem key success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: deleteKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: deletKeeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
async function ImportWrappedKeyNormalTest() {    console.info(`enter ImportWrapKey test`);    /*     * 生成加密导入用途的密钥（此处使用导入进行模拟）     */    await publicImportKeyFunc(wrapAlias, huksOptions);
    /*     * 导出加密导入用途密钥的公钥材料     */    await publicExportKeyFunc(wrapAlias, huksOptions);
    /*----------------------------------------------------------------------------------------------     * 此处省略业务本地生成ECC密钥对、业务本地ECDH密钥协商、业务本地生成密钥加密密钥K3、业务本地加密K1'和K3的流程     *----------------------------------------------------------------------------------------------*/
    /* 封装加密导入密钥材料：参考加密导入     * 拼接importOptions.inData字段，满足以下格式:     * PK2长度（4字节）     + PK2的数据     + AAD2的长度（4字节） + AAD2的数据 +     * Nonce2的长度（4字节）+ Nonce2的数据  + AEAD2的长度（4字节） + AEAD2的数据 +     * K3密文的长度（4字节） + K3密文的数据  + AAD3的长度（4字节） + AAD3的数据 +     * Nonce3的长度（4字节） + Nonce3的数据  + AEAD3的长度（4字节） + AEAD3的数据 +     * K1'_size的长度（4字节） + K1'_size   + K1'_enc的长度（4字节） + K1'_enc的数据     */    let inputKey = new Uint8Array([        0x5b, 0x00, 0x00, 0x00, // ECC-P-256 公钥长度（X.509规范DER格式）：91        // ECC-P-256 公钥        0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a,        0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, 0x03, 0x42, 0x00, 0x04, 0xc0, 0xfe, 0x1c, 0x67, 0xde,        0x86, 0x0e, 0xfb, 0xaf, 0xb5, 0x85, 0x52, 0xb4, 0x0e, 0x1f, 0x6c, 0x6c, 0xaa, 0xc5, 0xd9, 0xd2,        0x4d, 0xb0, 0x8a, 0x72, 0x24, 0xa1, 0x99, 0xaf, 0xfc, 0x3e, 0x55, 0x5a, 0xac, 0x99, 0x3d, 0xe8,        0x34, 0x72, 0xb9, 0x47, 0x9c, 0xa6, 0xd8, 0xfb, 0x00, 0xa0, 0x1f, 0x9f, 0x7a, 0x41, 0xe5, 0x44,        0x3e, 0xb2, 0x76, 0x08, 0xa2, 0xbd, 0xe9, 0x41, 0xd5, 0x2b, 0x9e,
        0x10, 0x00, 0x00, 0x00, // AAD2长度：16        // AAD2        0xbf, 0xf9, 0x69, 0x41, 0xf5, 0x49, 0x85, 0x31, 0x35, 0x14, 0x69, 0x12, 0x57, 0x9c, 0xc8, 0xb7,
        0x10, 0x00, 0x00, 0x00, // Nonce2长度：16        // Nonce2        0x2d, 0xb7, 0xf1, 0x5a, 0x0f, 0xb8, 0x20, 0xc5, 0x90, 0xe5, 0xca, 0x45, 0x84, 0x5c, 0x08, 0x08,
        0x10, 0x00, 0x00, 0x00, // AEAD2长度：16        // AEAD2        0x43, 0x25, 0x1b, 0x2f, 0x5b, 0x86, 0xd8, 0x87, 0x04, 0x4d, 0x38, 0xc2, 0x65, 0xcc, 0x9e, 0xb7,
        0x20, 0x00, 0x00, 0x00, // K3密文长度：32        // K3密文        0xf4, 0xe8, 0x93, 0x28, 0x0c, 0xfa, 0x4e, 0x11, 0x6b, 0xe8, 0xbd, 0xa8, 0xe9, 0x3f, 0xa7, 0x8f,        0x2f, 0xe3, 0xb3, 0xbf, 0xaf, 0xce, 0xe5, 0x06, 0x2d, 0xe6, 0x45, 0x5d, 0x19, 0x26, 0x09, 0xe7,
        0x10, 0x00, 0x00, 0x00, // AAD3长度：16        // AAD3        0xf4, 0x1e, 0x7b, 0x01, 0x7a, 0x84, 0x36, 0xa4, 0xa8, 0x1c, 0x0d, 0x3d, 0xde, 0x57, 0x66, 0x73,
        0x10, 0x00, 0x00, 0x00, // Nonce3长度：16        // Nonce3        0xe3, 0xff, 0x29, 0x97, 0xad, 0xb3, 0x4a, 0x2c, 0x50, 0x08, 0xb5, 0x68, 0xe1, 0x90, 0x5a, 0xdc,
        0x10, 0x00, 0x00, 0x00, // AEAD3长度：16        // AEAD3        0x26, 0xae, 0xdc, 0x4e, 0xa5, 0x6e, 0xb1, 0x38, 0x14, 0x24, 0x47, 0x1c, 0x41, 0x89, 0x63, 0x11,
        0x04, 0x00, 0x00, 0x00, // “密钥明文材料长度”的长度（字节）：4        // 密钥明文材料的长度：32字节        0x20, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, // 待导入密钥密文长度（字节）：32        // 待导入密钥密文        0x0b, 0xcb, 0xa9, 0xa8, 0x5f, 0x5a, 0x9d, 0xbf, 0xa1, 0xfc, 0x72, 0x74, 0x87, 0x79, 0xf2, 0xf4,        0x22, 0x0c, 0x8a, 0x4d, 0xd8, 0x7e, 0x10, 0xc8, 0x44, 0x17, 0x95, 0xab, 0x3b, 0xd2, 0x8f, 0x0a    ]);    importOptions.inData = inputKey;
    /*     * 导入封装的加密密钥材料     */    await publicImportWrappedKey(importAlias, wrapAlias, importOptions);
    /*     * 删除用于加密导入的密钥     */    await publicDeleteKeyFunc(wrapAlias, huksOptions);} 调测验证 验证时查询密钥是否存在，如密钥存在即表示生成密钥成功。 代码示例： 已复制import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let keyAlias = 'importAlias';let isKeyExist;
let keyProperties = new Array();keyProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES,}let huksOptions = {    properties: keyProperties, // 非空填充    inData: new Uint8Array(new Array()) // 非空填充}try {    huks.isKeyItemExist(keyAlias, huksOptions, function (error, data) {        if (error) {            console.error(`callback: isKeyItemExist failed, code: ${error.code}, msg: ${error.message}`);        } else {            if (data !== null && data.valueOf() !== null) {                isKeyExist = data.valueOf();                console.info(`callback: isKeyItemExist success, isKeyExist = ${isKeyExist}`);            }        }    });} catch (error) {    console.error(`callback: isKeyItemExist input arg invalid, code: ${error.code}, msg: ${error.message}`);}   常见密钥操作 场景概述 为了实现对数据机密性、完整性等保护，在生成/导入密钥后，需要对数据进行密钥操作，比如加密解密、签名验签、密钥协商、密钥派生等，本章节提供了常用的密钥操作的示例。本章节提供的示例都没有设置二次身份访问控制，如设置了密钥访问控制请参考密钥访问控制用法。 通用开发流程 HUKS基于密钥会话来操作数据，使用密钥时基于以下流程：  初始化密钥会话huks.initSession()： 传入密钥别名和密钥操作参数，初始化一个密钥会话并获取会话句柄。其中密钥操作参数中必须包含对应密码算法所必须的参数，包括密码算法、密钥大小、密钥目的、工作模式、填充模式、散列模式、IV、Nonce、AAD等。如果密钥设置了访问控制属性，还需要其他参数具体密钥访问控制。此步骤必选！ 分段操作数据huks.updateSession()： 如数据过大（超过100K）或密码算法的要求需要对数据进行分段操作，反之可跳过此步。此步骤可选！ 结束密钥会话huks.finishSession()： 操作最后一段数据并结束密钥会话，如过程中发生错误或不需要此次密钥操作数据，必须取消会话huks.abortSession()。此步骤必选！    加密解密 已复制/* * 以下以AES 128密钥的Callback操作使用为例 */import huks from '@ohos.security.huks';import promptAction from '@ohos.promptAction';
let aesKeyAlias = 'test_aesKeyAlias';let handle;let plainText = '123456';let IV = '001122334455';let cipherData:Uint8Array;let plainData:Uint8Array;
function StringToUint8Array(str) {  let arr = [];  for (let i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  return new Uint8Array(arr);}
function Uint8ArrayToString(fileData) {  let dataString = '';  for (let i = 0; i < fileData.length; i++) {    dataString += String.fromCharCode(fileData[i]);  }  return dataString;}
function GetAesGenerateProperties() {  var properties = new Array();  var index = 0;  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES  };  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128  };  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |           huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT  }  return properties;}
function GetAesEncryptProperties() {  var properties = new Array();  var index = 0;  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES  };  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128  };  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT  }  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7  }  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_CBC  }  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_IV,    value: StringToUint8Array(IV)  }  return properties;}
function GetAesDecryptProperties() {  var properties = new Array();  var index = 0;  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES  };  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128  };  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT  }  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_PKCS7  }  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_CBC  }  properties[index++] = {    tag: huks.HuksTag.HUKS_TAG_IV,    value: StringToUint8Array(IV)  }  return properties;}
async function GenerateAesKey() {  var genProperties = GetAesGenerateProperties();  var options = {    properties: genProperties  }  await huks.generateKeyItem(aesKeyAlias, options).then((data) => {    promptAction.showToast({      message: "成功生成了 一个 AES 密钥",      duration: 2500,    })  }).catch((err)=>{    promptAction.showToast({      message: "密钥生成失败，错误码是： " + err.code + " 错误吗信息： " + err.message,      duration: 6500,    })  })}
async function EncryptData() {    var encryptProperties = GetAesEncryptProperties();    var options = {        properties:encryptProperties,        inData: StringToUint8Array(plainText)    }    await huks.initSession(aesKeyAlias, options).then((data) => {      handle = data.handle;    }).catch((err)=>{      promptAction.showToast({        message: "密钥初始化失败，错误码是： " + err.code + " 错误吗信息： " + err.message,        duration: 6500,      })    })    await huks.finishSession(handle, options).then((data) => {      promptAction.showToast({        message: "加密数据成功， 密文是： " + Uint8ArrayToString(data.outData),        duration: 6500,      })      cipherData = data.outData    }).catch((err)=>{      promptAction.showToast({        message: "加密流程捕获了异常，错误码是： " + err.code + " 错误码信息： " + err.message,        duration: 6500,      })    })}
async function DecryptData() {   var decryptOptions = GetAesDecryptProperties()   var options = {     properties:decryptOptions,     inData: cipherData   }  await huks.initSession(aesKeyAlias, options).then((data) => {    handle = data.handle;  }).catch((err)=>{    promptAction.showToast({      message: "密钥初始化失败，错误码是： " + err.code + " 错误吗信息： " + err.message,      duration: 6500,    })  })  await huks.finishSession(handle, options).then((data) => {    promptAction.showToast({      message: "解密成功， 解密的明文是： " + Uint8ArrayToString(data.outData),      duration: 6500,    })  }).catch((err)=>{    promptAction.showToast({      message: "解密流程捕获了异常，错误码是： " + err.code + " 错误码信息： " + err.message,      duration: 6500,    })  })}
async function DeleteKey() {  let emptyOptions = {    properties:[]  }    await huks.deleteKeyItem(aesKeyAlias, emptyOptions).then((data) => {      promptAction.showToast({        message: "密钥删除成功！",        duration: 6500,      })    }).catch((err)=>{      promptAction.showToast({        message: "密钥删除失败，错误码是： " + err.code + " 错误吗信息： " + err.message,        duration: 6500,      })    })}
@Entry@Componentstruct Index {  @State message: string = 'Hello Huks'  controller: TextInputController = new TextInputController();  build() {    Column() {      Row() {        Text('输入您要加密得内容').fontSize(20).margin({ left: 2, top: 10 })      }
      Row() {        TextInput({ placeholder: '默认加密123456', controller: this.controller })          .placeholderColor(Color.Grey)          .placeholderFont({ size: 14, weight: 400 })          .caretColor(Color.Blue)          .width(400)          .height(40)          .margin(20)          .fontSize(14)          .fontColor(Color.Black)          .type(InputType.Normal)          .onChange((value: string) => {            this.message += '您输入得明文是: ' + value + '\n'            plainText = value          })          .margin({ top: 10 })      }
      Row() {        Button({ type: ButtonType.Normal, stateEffect: true }) {          Text('generateAesKey')            .fontColor(Color.White)            .fontSize(20)        }        .borderRadius(8)        .width('45%')        .height('5%')        .backgroundColor(0x317aff)        .onClick(() => {          GenerateAesKey()        })        .margin(10)
        Button({ type: ButtonType.Normal, stateEffect: true }) {          Text('deleteAesKey')            .fontColor(Color.White)            .fontSize(20)        }        .borderRadius(8)        .width('45%')        .height('5%')        .backgroundColor(0x317aff)        .onClick(() => {          DeleteKey()        })        .margin(10)      }
      Row() {        Button({ type: ButtonType.Normal, stateEffect: true }) {          Text('EncryptData')            .fontColor(Color.White)            .fontSize(20)        }        .borderRadius(8)        .width('45%')        .height('5%')        .backgroundColor(0x317aff)        .onClick(() => {          EncryptData()        })        .margin(10)
        Button({ type: ButtonType.Normal, stateEffect: true }) {          Text('DecryptData')            .fontColor(Color.White)            .fontSize(20)        }        .borderRadius(8)        .width('45%')        .height('5%')        .backgroundColor(0x317aff)        .onClick(() => {          DecryptData()        })        .margin(10)      }    }  }}   密钥协商 已复制/* * 以下以X25519 256 TEMP密钥的Callback操作使用为例 */import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let srcKeyAliasFirst = "AgreeX25519KeyFirstAlias";let srcKeyAliasSecond = "AgreeX25519KeySecondAlias";let agreeX25519InData = 'AgreeX25519TestIndata';let finishOutData;let handle;let exportKey;let exportKeyFrist;let exportKeySecond;
/* 集成生成密钥参数集 */let properties = new Array();properties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_X25519,}properties[1] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_AGREE,}properties[2] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_CURVE25519_KEY_SIZE_256,}properties[3] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,}properties[4] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_NONE,}properties[5] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_CBC,}let HuksOptions = {    properties: properties,    inData: new Uint8Array(new Array())}
/* 集成第一个协商参数集 */let finishProperties = new Array();finishProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_KEY_STORAGE_FLAG,    value: huks.HuksKeyStorageType.HUKS_STORAGE_TEMP,}finishProperties[1] = {    tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,    value: true}finishProperties[2] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES,}finishProperties[3] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,}finishProperties[4] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value:    huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |    huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,}finishProperties[5] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,}finishProperties[6] = {    tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,    value: StringToUint8Array(srcKeyAliasFirst+ 'final'),}finishProperties[7] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_NONE,}finishProperties[8] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_ECB,}let finishOptionsFrist = {    properties: finishProperties,    inData: StringToUint8Array(agreeX25519InData)}/* 集成第二个协商参数集 */let finishOptionsSecond = {    properties: finishProperties,    inData: StringToUint8Array(agreeX25519InData)}finishOptionsSecond.properties.splice(6, 1, {    tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,    value: StringToUint8Array(srcKeyAliasSecond + 'final'),})
function StringToUint8Array(str) {    let arr = [];    for (let i = 0, j = str.length; i < j; ++i) {        arr.push(str.charCodeAt(i));    }    return new Uint8Array(arr);}
function generateKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.generateKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicGenKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback generateKeyItem`);    let throwObject = {isThrow: false};    try {        await generateKeyItem(keyAlias, huksOptions, throwObject)            .then((data) => {                console.info(`callback: generateKeyItem success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: generateKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: generateKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function initSession(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksSessionHandle> {    return new Promise((resolve, reject) => {        try {            huks.initSession(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicInitFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback doInit`);    let throwObject = {isThrow: false};    try {        await initSession(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: doInit success, data = ${JSON.stringify(data)}`);                handle = data.handle;            })            .catch((error) => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: doInit failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: doInit input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function updateSession(handle:number, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult> {    return new Promise((resolve, reject) => {        try {            huks.updateSession(handle, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicUpdateFunc(handle:number, huksOptions:huks.HuksOptions) {    console.info(`enter callback doUpdate`);    let throwObject = {isThrow: false};    try {        await updateSession(handle, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: doUpdate success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: doUpdate failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: doUpdate input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function finishSession(handle:number, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult> {    return new Promise((resolve, reject) => {        try {            huks.finishSession(handle, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicFinishFunc(handle:number, huksOptions:huks.HuksOptions) {    console.info(`enter callback doFinish`);    let throwObject = {isThrow: false};    try {        await finishSession(handle, huksOptions, throwObject)            .then ((data) => {                finishOutData = data.outData;                console.info(`callback: doFinish success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: doFinish failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: doFinish input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function exportKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult> {    return new Promise((resolve, reject) => {        try {            huks.exportKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicExportKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback export`);    let throwObject = {isThrow: false};    try {        await exportKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: exportKeyItem success, data = ${JSON.stringify(data)}`);                exportKey = data.outData;            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: exportKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: exportKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function deleteKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.deleteKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicDeleteKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback deleteKeyItem`);    let throwObject = {isThrow: false};    try {        await deleteKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: deleteKeyItem key success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: deleteKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: deletKeeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
async function testAgree() {    /* 1.生成两个密钥并导出 */    await publicGenKeyFunc(srcKeyAliasFirst, HuksOptions);    await publicGenKeyFunc(srcKeyAliasSecond, HuksOptions);
    await publicExportKeyFunc(srcKeyAliasFirst, HuksOptions);    exportKeyFrist = exportKey;    await publicExportKeyFunc(srcKeyAliasFirst, HuksOptions);    exportKeySecond = exportKey;
    /* 对第一个密钥进行协商 */    await publicInitFunc(srcKeyAliasFirst, HuksOptions);    HuksOptions.inData = exportKeySecond;    await publicUpdateFunc(handle, HuksOptions);    await publicFinishFunc(handle, finishOptionsFrist);
    /* 对第二个密钥进行协商 */    await publicInitFunc(srcKeyAliasSecond, HuksOptions);    HuksOptions.inData = exportKeyFrist;    await publicUpdateFunc(handle, HuksOptions);    await publicFinishFunc(handle, finishOptionsSecond);
    await publicDeleteKeyFunc(srcKeyAliasFirst, HuksOptions);    await publicDeleteKeyFunc(srcKeyAliasSecond, HuksOptions);}   密钥派生 已复制/* * 以下以HKDF256密钥的Promise操作使用为例 */import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let srcKeyAlias = "hkdf_Key";let deriveHkdfInData = "deriveHkdfTestIndata";let handle;let finishOutData;let HuksKeyDeriveKeySize = 32;
/* 集成生成密钥参数集 */let properties = new Array();properties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES,}properties[1] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,}properties[2] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,}properties[3] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_128,}let huksOptions = {    properties: properties,    inData: new Uint8Array(new Array())}
/* 集成init时密钥参数集 */let initProperties = new Array();initProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_HKDF,}initProperties[1] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DERIVE,}initProperties[2] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256,}initProperties[3] = {    tag: huks.HuksTag.HUKS_TAG_DERIVE_KEY_SIZE,    value: HuksKeyDeriveKeySize,}let initOptions = {    properties: initProperties,    inData: new Uint8Array(new Array())}
/* 集成finish时密钥参数集 */let finishProperties = new Array();finishProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_KEY_STORAGE_FLAG,    value: huks.HuksKeyStorageType.HUKS_STORAGE_PERSISTENT,}finishProperties[1] = {    tag: huks.HuksTag.HUKS_TAG_IS_KEY_ALIAS,    value: true,}finishProperties[2] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_AES,}finishProperties[3] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_AES_KEY_SIZE_256,}finishProperties[4] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value:    huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT |    huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,}finishProperties[5] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_NONE,}finishProperties[6] = {    tag: huks.HuksTag.HUKS_TAG_KEY_ALIAS,    value: StringToUint8Array(srcKeyAlias),}finishProperties[7] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_NONE,}finishProperties[8] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_ECB,}let finishOptions = {    properties: finishProperties,    inData: new Uint8Array(new Array())}
function StringToUint8Array(str) {    let arr = [];    for (let i = 0, j = str.length; i < j; ++i) {        arr.push(str.charCodeAt(i));    }    return new Uint8Array(arr);}
function generateKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.generateKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicGenKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback generateKeyItem`);    let throwObject = {isThrow: false};    try {        await generateKeyItem(keyAlias, huksOptions, throwObject)            .then((data) => {                console.info(`callback: generateKeyItem success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: generateKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: generateKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function initSession(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksSessionHandle> {    return new Promise((resolve, reject) => {        try {            huks.initSession(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicInitFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback doInit`);    let throwObject = {isThrow: false};    try {        await initSession(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: doInit success, data = ${JSON.stringify(data)}`);                handle = data.handle;            })            .catch((error) => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: doInit failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: doInit input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function updateSession(handle:number, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult> {    return new Promise((resolve, reject) => {        try {            huks.updateSession(handle, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicUpdateFunc(handle:number, huksOptions:huks.HuksOptions) {    console.info(`enter callback doUpdate`);    let throwObject = {isThrow: false};    try {        await updateSession(handle, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: doUpdate success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: doUpdate failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: doUpdate input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function finishSession(handle:number, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult> {    return new Promise((resolve, reject) => {        try {            huks.finishSession(handle, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicFinishFunc(handle:number, huksOptions:huks.HuksOptions) {    console.info(`enter callback doFinish`);    let throwObject = {isThrow: false};    try {        await finishSession(handle, huksOptions, throwObject)            .then ((data) => {                finishOutData = data.outData;                console.info(`callback: doFinish success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: doFinish failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: doFinish input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function deleteKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.deleteKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicDeleteKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback deleteKeyItem`);    let throwObject = {isThrow: false};    try {        await deleteKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: deleteKeyItem key success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: deleteKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: deletKeeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
async function testDerive() {    /* 生成密钥 */    await publicGenKeyFunc(srcKeyAlias, huksOptions);
    /* 进行派生操作 */    await publicInitFunc(srcKeyAlias, initOptions);
    initOptions.inData = StringToUint8Array(deriveHkdfInData);    await publicUpdateFunc(handle, initOptions);    await publicFinishFunc(handle, finishOptions);
    await publicDeleteKeyFunc(srcKeyAlias, huksOptions);}   密钥访问控制 HUKS提供了全面完善的密钥访问控制能力，确保存储在HUKS中的密钥被合法正确的访问。 首先，业务只能访问属于自己的密钥，即只能访问通过HUKS生成或导入的密钥。 其次，支持密钥的用户身份认证访问控制，对于高安敏感的业务密钥，需要在使用密钥的时候，再次要求用户即时的验证锁屏密码或生物特征，验证通过后，才能使用业务密钥。 除此之外，HUKS还支持严格限制密钥的使用用途，如支持只允许AES密钥进行加密解密，只允许RSA密钥进行签名验签。 用户身份认证访问控制 生成或导入密钥时，可以指定密钥必须经过用户身份认证后才能使用。您可以指定用于解锁设备锁屏的凭据（指纹、人脸）的子集进行身份认证。在生成/导入密钥后，即使应用进程被攻击也不会导致未经用户授权的密钥访问，一般用于高敏感且高级别安全保护的场景，比如免密登录、免密支付、自动填充密码保护场景。 除用户身份认证外，应用还须将密钥的授权访问类型（即失效条件）设置为以下两种类型之一：  清除锁屏密码后密钥永久无效。 设置此模式的前提是当前用户已经设置了锁屏密码，在生成/导入密钥后，一旦清除了锁屏密码，此类密钥将永久失效。注意，修改密码不会导致失效情况发生。此模式适合那些需要锁屏密码授权访问或用户强相关的数据保护的场景。 用户新录入生物特征后永久无效。 此模式需要当前用户至少录入了一个生物特征（如指纹）才能生效，在生成/导入密钥后，一旦录入新的生物特征，这些密钥将永久失效。注意，仅删除生物特征不会导致失效情况发生。如果您不希望新录入的生物特征后，用户还可以授权访问原有数据（密钥保护的数据），那么可以使用此模式，如免密登录，免密支付等场景。  此外，为了保证密钥使用时用户认证结果的有效性（不可重放），HUKS支持挑战值校验：在身份认证前，需要从HUKS获取挑战值（调用huks.initSession()返回的HuksSessionHandle中）传给用户身份认证方法（userIAM_userAuth.getAuthInstance），然后在密钥操作时校验认证令牌的挑战值。 开发流程 设置了二次用户身份认证的密钥，需要先初始化密钥会话并获取挑战值，然后将HUKS生成的挑战值传至用户身份认证方法进行用户身份认证，认证通过后获取一个认证令牌，将认证令牌传至HUKS进行密钥操作。  接口说明  生成或导入密钥时，在密钥属性集中需指定三个参数：用户认证类型HuksUserAuthType、授权访问类型HuksAuthAccessType、挑战值类型HuksChallengeType。 表3 用户认证类型：两种类型的子集     名称 值 说明    HUKS_USER_AUTH_TYPE_FINGERPRINT 0x0001 用户认证类型为指纹，允许和人脸同时设置   HUKS_USER_AUTH_TYPE_FACE 0x0002 用户认证类型为人脸 ，允许和指纹同时设置    表4 安全访问类型：二选一     名称 值 说明    HUKS_AUTH_ACCESS_INVALID_CLEAR_PASSWORD 1 清除锁屏密码后密钥无法访问。   HUKS_AUTH_ACCESS_INVALID_NEW_BIO_ENROLL 2 新录入生物特征后密钥无法访问，用户认证类型须包含生物认证类型。    表5 挑战值类型：三选一     名称 值 说明    HUKS_CHALLENGE_TYPE_NORMAL 0 普通类型，每次密钥的使用需要独立的一次用户认证   HUKS_CHALLENGE_TYPE_CUSTOM 1 自定义类型，支持和多个密钥共享一次用户认证   HUKS_CHALLENGE_TYPE_NONE 2 无挑战值类型，用户认证时不需要挑战值    
注意
 当指定挑战值类型为HUKS_CHALLENGE_TYPE_NONE 时，不需要传递挑战值，但是存在新的限制：在用户身份认证后，一段时间内允许访问该密钥，超时后不能访问，需要重新认证才能访问。因此应用需要额外指定超时时间HUKS_TAG_AUTH_TIMEOUT属性（最大60秒）。 
 使用密钥时，先初始化密钥会话，然后根据密钥生成/导入阶段指定的挑战值类型属性是否需要获取挑战值，或组装新的挑战值。 表6 使用密钥的接口介绍     接口名 描述    initSession(keyAlias: string, options: HuksOptions, callback: AsyncCallback<HuksSessionHandle>) : void 初始化密钥会话，获取挑战值   updateSession(handle: number, options: HuksOptions, token: Uint8Array, callback: AsyncCallback<HuksReturnResult>) : void 分段操作数据，传递认证令牌   finishSession(handle: number, options: HuksOptions, token: Uint8Array, callback: AsyncCallback<HuksReturnResult>) : void 结束密钥会话，传递认证令牌     开发步骤  生成密钥并指定指纹访问控制和相关属性 已复制import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let keyAlias = 'dh_key_fingerprint_access';let properties = new Array();properties[0] = {  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,  value: huks.HuksKeyAlg.HUKS_ALG_SM4,}properties[1] = {  tag: huks.HuksTag.HUKS_TAG_PURPOSE,  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,}properties[2] = {  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,  value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,}properties[3] = {  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,  value: huks.HuksCipherMode.HUKS_MODE_CBC,}properties[4] = {  tag: huks.HuksTag.HUKS_TAG_PADDING,  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,}// 指定密钥身份认证的类型：指纹properties[5] = {  tag: huks.HuksTag.HUKS_TAG_USER_AUTH_TYPE,  value: huks.HuksUserAuthType.HUKS_USER_AUTH_TYPE_FINGERPRINT}// 指定密钥安全授权的类型（失效类型）：新录入生物特征（指纹）后无效properties[6] = {  tag: huks.HuksTag.HUKS_TAG_KEY_AUTH_ACCESS_TYPE,  value: huks.HuksAuthAccessType.HUKS_AUTH_ACCESS_INVALID_NEW_BIO_ENROLL}// 指定挑战值的类型：默认类型properties[7] = {  tag: huks.HuksTag.HUKS_TAG_CHALLENGE_TYPE,  value: huks.HuksChallengeType.HUKS_CHALLENGE_TYPE_NORMAL}let huksOptions = {  properties: properties,  inData: new Uint8Array(new Array())}
/* *生成密钥 */function generateKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {  return new Promise((resolve, reject) => {    try {      huks.generateKeyItem(keyAlias, huksOptions, function (error, data) {        if (error) {          reject(error);        } else {          resolve(data);        }      });    } catch (error) {      throwObject.isThrow = true;      throw(error);    }  });}
async function publicGenKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {  console.info(enter callback generateKeyItem);  let throwObject = {isThrow: false};  try {    await generateKeyItem(keyAlias, huksOptions, throwObject)      .then((data) => {        console.info(callback: generateKeyItem success, data = ${JSON.stringify(data)});      })      .catch(error => {        if (throwObject.isThrow) {          throw(error);        } else {          console.error(callback: generateKeyItem failed, code: ${error.code}, msg: ${error.message});        }      });  } catch (error) {    console.error(callback: generateKeyItem input arg invalid, code: ${error.code}, msg: ${error.message});  }}
async function TestGenKeyForFingerprintAccessControl() {  await publicGenKeyFunc(keyAlias, huksOptions);} 初始化密钥会话获取挑战值并发起指纹认证获取认证令牌已复制import huks from '@ohos.security.huks';import userIAM_userAuth from '@ohos.userIAM.userAuth';
/* * 确定密钥别名和封装密钥属性参数集 */let srcKeyAlias = 'sm4_key_fingerprint_access';let handle;let challenge;let fingerAuthToken;let authType = userIAM_userAuth.UserAuthType.FINGERPRINT;let authTrustLevel = userIAM_userAuth.AuthTrustLevel.ATL1;
/* 集成生成密钥参数集 & 加密参数集 */let properties = new Array();properties[0] = {  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,  value: huks.HuksKeyAlg.HUKS_ALG_SM4,}properties[1] = {  tag: huks.HuksTag.HUKS_TAG_PURPOSE,  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT | huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_DECRYPT,}properties[2] = {  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,  value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,}properties[3] = {  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,  value: huks.HuksCipherMode.HUKS_MODE_CBC,}properties[4] = {  tag: huks.HuksTag.HUKS_TAG_PADDING,  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,}let huksOptions = {  properties: properties,  inData: new Uint8Array(new Array())}
function initSession(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksSessionHandle> {  return new Promise((resolve, reject) => {    try {      huks.initSession(keyAlias, huksOptions, function (error, data) {        if (error) {          reject(error);        } else {          resolve(data);        }      });    } catch (error) {      throwObject.isThrow = true;      throw(error);    }  });}
async function publicInitFunc(keyAlias:string, huksOptions:huks.HuksOptions) {  console.info(`enter callback doInit`);  let throwObject = {isThrow: false};  try {    await initSession(keyAlias, huksOptions, throwObject)      .then ((data) => {        console.info(`callback: doInit success, data = ${JSON.stringify(data)}`);        handle = data.handle;        challenge = data.challenge;      })      .catch((error) => {        if (throwObject.isThrow) {          throw(error);        } else {          console.error(`callback: doInit failed, code: ${error.code}, msg: ${error.message}`);        }      });  } catch (error) {    console.error(`callback: doInit input arg invalid, code: ${error.code}, msg: ${error.message}`);  }}
function userIAMAuthFinger(huksChallenge:Uint8Array) {  // 获取认证对象  let auth;  try {    auth = userIAM_userAuth.getAuthInstance(huksChallenge, authType, authTrustLevel);    console.log("get auth instance success");  } catch (error) {    console.log("get auth instance failed" + error);  }
  // 订阅认证结果  try {    auth.on("result", {      callback: (result: userIAM_userAuth.AuthResultInfo) => {        /* 认证成功获取认证令牌 */        fingerAuthToken = result.token;      }    });    console.log("subscribe authentication event success");  } catch (error) {    console.log("subscribe authentication event failed " + error);  }
  // 开始认证  try {    auth.start();    console.info("authV9 start auth success");  } catch (error) {    console.info("authV9 start auth failed, error = " + error);  }}
async function testInitAndAuthFinger() {  /* 初始化密钥会话获取挑战值 */  await publicInitFunc(srcKeyAlias, huksOptions);  /* 调用userIAM进行身份认证 */  userIAMAuthFinger(challenge);} 传入认证令牌进行数据操作已复制/* * 以下以SM4 128密钥的Callback操作使用为例 */import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let srcKeyAlias = 'sm4_key_fingerprint_access';let IV = '1234567890123456';let cipherInData = 'Hks_SM4_Cipher_Test_101010101010101010110_string';let handle;let fingerAuthToken;let updateResult = new Array();let finishOutData;
/* 集成生成密钥参数集 & 加密参数集 */let propertiesEncrypt = new Array();propertiesEncrypt[0] = {  tag: huks.HuksTag.HUKS_TAG_ALGORITHM,  value: huks.HuksKeyAlg.HUKS_ALG_SM4,}propertiesEncrypt[1] = {  tag: huks.HuksTag.HUKS_TAG_PURPOSE,  value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_ENCRYPT,}propertiesEncrypt[2] = {  tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,  value: huks.HuksKeySize.HUKS_SM4_KEY_SIZE_128,}propertiesEncrypt[3] = {  tag: huks.HuksTag.HUKS_TAG_PADDING,  value: huks.HuksKeyPadding.HUKS_PADDING_NONE,}propertiesEncrypt[4] = {  tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,  value: huks.HuksCipherMode.HUKS_MODE_CBC,}propertiesEncrypt[5] = {  tag: huks.HuksTag.HUKS_TAG_IV,  value: StringToUint8Array(IV),}let encryptOptions = {  properties: propertiesEncrypt,  inData: new Uint8Array(new Array())}
function StringToUint8Array(str) {  let arr = [];  for (let i = 0, j = str.length; i < j; ++i) {    arr.push(str.charCodeAt(i));  }  return new Uint8Array(arr);}
function updateSession(handle:number, huksOptions:huks.HuksOptions, token:Uint8Array, throwObject) : Promise<huks.HuksReturnResult> {  return new Promise((resolve, reject) => {    try {      huks.updateSession(handle, huksOptions, token, function (error, data) {        if (error) {          reject(error);        } else {          resolve(data);        }      });    } catch (error) {      throwObject.isThrow = true;      throw(error);    }  });}
async function publicUpdateFunc(handle:number, token:Uint8Array, huksOptions:huks.HuksOptions) {  console.info(enter callback doUpdate);  let throwObject = {isThrow: false};  try {    await updateSession(handle, huksOptions, token, throwObject)      .then ((data) => {        console.info(callback: doUpdate success, data = ${JSON.stringify(data)});      })      .catch(error => {        if (throwObject.isThrow) {          throw(error);        } else {          console.error(callback: doUpdate failed, code: ${error.code}, msg: ${error.message});        }      });    } catch (error) {      console.error(callback: doUpdate input arg invalid, code: ${error.code}, msg: ${error.message});    }  }
function finishSession(handle:number, huksOptions:huks.HuksOptions, token:Uint8Array, throwObject) : Promise<huks.HuksReturnResult> {  return new Promise((resolve, reject) => {    try {      huks.finishSession(handle, huksOptions, token, function (error, data) {        if (error) {          reject(error);        } else {          resolve(data);        }      });    } catch (error) {      throwObject.isThrow = true;      throw(error);    }  });}
async function publicFinishFunc(handle:number, token:Uint8Array, huksOptions:huks.HuksOptions) {  console.info(enter callback doFinish);  let throwObject = {isThrow: false};  try {    await finishSession(handle, huksOptions, token, throwObject)      .then ((data) => {        finishOutData = data.outData;        console.info(callback: doFinish success, data = ${JSON.stringify(data)});      })      .catch(error => {        if (throwObject.isThrow) {          throw(error);        } else {          console.error(callback: doFinish failed, code: ${error.code}, msg: ${error.message});        }      });  } catch (error) {    console.error(callback: doFinish input arg invalid, code: ${error.code}, msg: ${error.message});  }}
async function testSm4Cipher() {  encryptOptions.inData = StringToUint8Array(cipherInData);  /* 传入认证令牌 */  await publicUpdateFunc(handle, fingerAuthToken, encryptOptions);  encryptUpdateResult = updateResult;
  encryptOptions.inData = new Uint8Array(new Array());  /* 传入认证令牌 */  await publicFinishFunc(handle, fingerAuthToken, encryptOptions);  if (finishOutData === cipherInData) {    console.info('test finish encrypt err ');  } else {  console.info('test finish encrypt success');  }}    密钥证明 HUKS提供了全面完善的密钥访问控制能力，确保存储在HUKS中的密钥被合法正确的访问。 首先，业务只能访问属于自己的密钥，即只能访问通过HUKS生成或导入的密钥。 其次，支持密钥的用户身份认证访问控制，对于高安敏感的业务密钥，需要在使用密钥的时候，再次要求用户即时的验证锁屏密码或生物特征，验证通过后，才能使用业务密钥。 除此之外，HUKS还支持严格限制密钥的使用用途，如支持只允许AES密钥进行加密解密，只允许RSA密钥进行签名验签。 开发流程  指定密钥别名和需要证明的密钥属性的标签传入HUKS。 调用HUKS为应用生成一个依次由根CA证书、设备CA证书、设备证书、密钥证书组成的X.509证书链。 将证书链传输至受信任的服务器，并在服务器上解析和验证证书链的有效性和单个证书是否吊销。  接口说明 表7 密钥认证接口介绍     接口名 描述    attestKeyItem(keyAlias: string, options: HuksOptions, callback: AsyncCallback<HuksReturnResult>) : void 密钥认证    开发步骤 已复制/* * 以下以attestKey Callback接口操作验证为例 */import huks from '@ohos.security.huks';
/* * 确定密钥别名和封装密钥属性参数集 */let keyAliasString = "key attest";let aliasString = keyAliasString;let aliasUint8 = StringToUint8Array(keyAliasString);let securityLevel = StringToUint8Array('sec_level');let challenge = StringToUint8Array('challenge_data');let versionInfo = StringToUint8Array('version_info');let attestCertChain;
let genKeyProperties = new Array();genKeyProperties[0] = {    tag: huks.HuksTag.HUKS_TAG_ALGORITHM,    value: huks.HuksKeyAlg.HUKS_ALG_RSA};genKeyProperties[1] = {    tag: huks.HuksTag.HUKS_TAG_KEY_STORAGE_FLAG,    value: huks.HuksKeyStorageType.HUKS_STORAGE_PERSISTENT};genKeyProperties[2] = {    tag: huks.HuksTag.HUKS_TAG_KEY_SIZE,    value: huks.HuksKeySize.HUKS_RSA_KEY_SIZE_2048};genKeyProperties[3] = {    tag: huks.HuksTag.HUKS_TAG_PURPOSE,    value: huks.HuksKeyPurpose.HUKS_KEY_PURPOSE_VERIFY};genKeyProperties[4] = {    tag: huks.HuksTag.HUKS_TAG_DIGEST,    value: huks.HuksKeyDigest.HUKS_DIGEST_SHA256};genKeyProperties[5] = {    tag: huks.HuksTag.HUKS_TAG_PADDING,    value: huks.HuksKeyPadding.HUKS_PADDING_PSS};genKeyProperties[6] = {    tag: huks.HuksTag.HUKS_TAG_KEY_GENERATE_TYPE,    value: huks.HuksKeyGenerateType.HUKS_KEY_GENERATE_TYPE_DEFAULT};genKeyProperties[7] = {    tag: huks.HuksTag.HUKS_TAG_BLOCK_MODE,    value: huks.HuksCipherMode.HUKS_MODE_ECB};let genOptions = {    properties: genKeyProperties};
let attestKeyproperties = new Array();attestKeyproperties[0] = {    tag: huks.HuksTag.HUKS_TAG_ATTESTATION_ID_SEC_LEVEL_INFO,    value: securityLevel};attestKeyproperties[1] = {    tag: huks.HuksTag.HUKS_TAG_ATTESTATION_CHALLENGE,    value: challenge};attestKeyproperties[2] = {    tag: huks.HuksTag.HUKS_TAG_ATTESTATION_ID_VERSION_INFO,    value: versionInfo};attestKeyproperties[3] = {    tag: huks.HuksTag.HUKS_TAG_ATTESTATION_ID_ALIAS,    value: aliasUint8};let huksOptions = {    properties: attestKeyproperties};
function StringToUint8Array(str) {    let arr = [];    for (let i = 0, j = str.length; i < j; ++i) {        arr.push(str.charCodeAt(i));    }    return new Uint8Array(arr);}
function generateKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) {    return new Promise((resolve, reject) => {        try {            huks.generateKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicGenKeyFunc(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback generateKeyItem`);    let throwObject = {isThrow: false};    try {        await generateKeyItem(keyAlias, huksOptions, throwObject)            .then((data) => {                console.info(`callback: generateKeyItem success, data = ${JSON.stringify(data)}`);            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: generateKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: generateKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
function attestKeyItem(keyAlias:string, huksOptions:huks.HuksOptions, throwObject) : Promise<huks.HuksReturnResult>{    return new Promise((resolve, reject) => {        try {            huks.attestKeyItem(keyAlias, huksOptions, function (error, data) {                if (error) {                    reject(error);                } else {                    resolve(data);                }            });        } catch (error) {            throwObject.isThrow = true;            throw(error);        }    });}
async function publicAttestKey(keyAlias:string, huksOptions:huks.HuksOptions) {    console.info(`enter callback attestKeyItem`);    let throwObject = {isThrow: false};    try {        await attestKeyItem(keyAlias, huksOptions, throwObject)            .then ((data) => {                console.info(`callback: attestKeyItem success, data = ${JSON.stringify(data)}`);                if (data !== null && data.certChains !== null) {                    attestCertChain = data.certChains;                }            })            .catch(error => {                if (throwObject.isThrow) {                    throw(error);                } else {                    console.error(`callback: attestKeyItem failed, code: ${error.code}, msg: ${error.message}`);                }            });    } catch (error) {        console.error(`callback: attestKeyItem input arg invalid, code: ${error.code}, msg: ${error.message}`);    }}
async function AttestKeyTest() {    await publicGenKeyFunc(aliasString, genOptions);
    await publicAttestKey(aliasString, huksOptions);    console.info('attest certChain data: ' + attestCertChain)}  常见问题  Cannot find name 'huks'. 不能找到huks，使用了接口函数但没导入security.huks.d.ts，添加import huks from '@ohos.security.huks';即可。 Property 'finishSession' does not exist on type 'typeof huks'. Did you mean 'finish'? 不能在huks库中找到finishSession，finishSession是API9版本的，请更新SDK版本或替换新版本的security.huks.d.ts文件。   上一篇 通用密钥库开发概述 下一篇 通用密钥库密码算法规格 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介基本概念实现原理约束与限制通用密钥库开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 简介通用密钥库系统（HarmonyOS Universal KeyStore，以下简称HUKS）是HarmonyOS提供的系统级的密钥管理系统服务，提供密钥的全生命周期管理能力，包括密钥生成、密钥存储、密钥使用、密钥销毁等功能，以及对存储在HUKS中的密钥提供合法性证明。 HUKS基于系统安全能力，为业务提供密钥全生命周期的安全管理，业务无需自己实现，利用HUKS的系统能力，就能确保业务密钥的安全。 以下目录文档主要介绍了HUKS在典型场景下的用法、原理以及支持的密码算法规格。 生成新密钥导入外部密钥常见密钥操作密钥访问控制支持的算法类型及参数组合密钥材料格式  基本概念在使用HUKS开发之前，建议了解以下基本概念： HUKS Core HUKS核心组件，承载HUKS的核心功能，包括密钥的密码学运算、明文密钥的加解密、密钥访问控制等。一般运行在设备的安全环境中（如TEE、安全芯片等，不同的厂商有所不同），保证密钥明文不出HUKS Core。 密钥会话 应用通过指定密钥别名，给当前操作的密钥建立一个会话，HUKS为每个会话生成一个全局唯一的句柄值来索引该会话。它的作用是缓存密钥使用期间的信息，包括操作数据、密钥信息、访问控制属性等。密钥操作一般需要经过建立会话、传入数据和参数、结束会话（中止会话） 三个阶段。   实现原理HUKS的核心安全设计包括以下几点： 密钥不出安全环境 HUKS的核心特点是密钥全生命周期明文不出HUKS Core，在有硬件条件的设备上，如有TEE（Trusted Execution Environment)或安全芯片的设备，HUKS Core运行在硬件安全环境中。能确保即使REE（Rich Execution Environment）环境被攻破，密钥明文也不会泄露。 系统级安全加密存储 基于设备根密钥加密业务密钥，在有条件的设备上，叠加用户口令加密保护密钥。 严格的访问控制 只有合法的业务才有权访问密钥，同时支持用户身份认证访问控制以支持业务的高安敏感场景下安全访问密钥的诉求。 密钥的合法性证明 可为业务提供硬件厂商级别的密钥的合法性证明，证明密钥没有被篡改，并确实存在于有硬件保护的HUKS Core中，以及拥有正确的密钥属性。  此外，密钥会话是HUKS中承载密钥使用的基础，它的主要作用是初始化密钥信息、缓存业务数据等。对数据的密码学运算和对密钥密文的加解密都是在HUKS Core中进行，以此保证密钥明文和运算过程的安全。 图1 HUKS运行机制   约束与限制基于别名的访问 由于密钥材料不出HUKS的限制，应用只能以别名的方式访问密钥材料，而且密钥的别名必须保证应用内唯一(否则已存在的同别名密钥会被覆盖），长度不能超过64个字节。 数据分片大小限制 所有数据需要经过IPC通道传输到HUKS，受IPC缓冲区大小限制，建议对总大小超过100K的数据进行分片传输，且分片大小不超过100K。 指定必选参数 在生成密钥或导入密钥时，必须指定密码算法、密钥大小和使用目的参数，其他参数可选（如工作模式、填充模式、散列算法等），但是在使用密钥时必须传入密码算法相关的完整的参数。 密钥材料格式 导入/导出密钥时（包括密钥对、公钥、私钥），密钥材料的数据格式必须满足HUKS要求的格式，具体各个密码算法密钥材料见密钥材料格式。    上一篇 密钥管理 下一篇 通用密钥库开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。获取和设置系统国际化相关信息接口说明开发步骤获取日历信息接口说明开发步骤电话号码格式化接口说明开发步骤度量衡转换接口说明开发步骤字母表索引接口说明开发步骤获取文本断点位置接口说明开发步骤获取时区接口说明开发步骤获取音译对象接口说明开发步骤字符类型判断接口说明开发步骤获取日期中年月日的排列顺序接口说明开发步骤I18n开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  本模块提供系统相关的或者增强的国际化能力，包括区域管理、电话号码处理、日历等，相关接口为ECMA 402标准中未定义的补充接口。更多接口和使用方式请见I18N。 Intl模块提供了ECMA 402标准定义的基础国际化接口，与本模块共同使用可提供完整地国际化支持能力。  获取和设置系统国际化相关信息 调用接口访问和设置系统语言、偏好语言、地区、24小时制、本地数字等国际化信息。   接口说明     类名 接口名称 描述    System getDisplayCountry(country:string,locale:string,sentenceCase?:boolean):string9+ 获取国家的本地化表示。   System getDisplayLanguage(language:string,locale:string,sentenceCase?:boolean):string9+ 获取语言的本地化表示。   System getSystemLanguages():Array9+ 获取系统语言列表。   System getSystemCountries(language: string):Array9+ 获取针对输入语言系统支持的国家或地区列表。   System isSuggested(language: string, region?: string): boolean9+ 判断当前语言和地区是否匹配   System getSystemLanguage():string9+ 获取系统语言。   System getSystemRegion():string9+ 获取系统地区。   System getSystemLocale():string9+ 获取系统Locale。   System is24HourClock():boolean9+ 判断系统时间是否为24小时制。   System getPreferredLanguageList()9+ 获取系统偏好语言列表。   System getFirstPreferredLanguage()9+ 获取系统偏好语言列表中的第一个偏好语言。   System getAppPreferredLanguage()9+ 获取应用偏好语言。   System getUsingLocalDigit()9+ 判断系统是否使用本地数字。   System isRTL(locale:string):boolean9+ locale对应的语言是否为从右到左语言。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 判断Locale的语言是否为从右到左语言。 调用isRTL接口获取Locale的语言是否为从右到左语言。 已复制try {   let rtl = I18n.isRTL("zh-CN"); // rtl = false   rtl = I18n.isRTL("ar"); // rtl = true} catch(error) {   console.error(`call i18n.System interface failed, error code: ${error.code}, message: ${error.message}`);} 获取语言的本地化表示。 调用getDisplayLanguage接口获取某一语言的本地化表示。其中，language表示待本地化显示的语言，locale表示本地化的Locale，sentenceCase结果是否需要首字母大写。 已复制try {   let language = "en";   let locale = "zh-CN";   let sentenceCase = false;   let localizedLanguage = I18n.System.getDisplayLanguage(language, locale, sentenceCase); // localizedLanguage = "英语"} catch(error) {   console.error(`call i18n.System interface failed, error code: ${error.code}, message: ${error.message}`);} 获取国家的本地化表示。 调用getDisplayCountry接口获取某一国家的本地化表示。其中，country表示待本地化显示的国家，locale表示本地化的Locale，sentenceCase结果是否需要首字母大写。 已复制try {   let country = "US";   let locale = "zh-CN";   let sentenceCase = false;   let localizedCountry = I18n.System.getDisplayCountry(country, locale, sentenceCase); // localizedCountry = "美国"} catch(error) {   console.error(`call i18n.System interface failed, error code: ${error.code}, message: ${error.message}`);} 获取系统语言列表和某个语言系统支持的国家列表。 调用getSystemLanguages接口获取系统支持的语言列表。 调用getSystemCountries接口获取某一语言系统支持的地区列表。 已复制try {   let languageList = I18n.System.getSystemLanguages();  // languageList = ["en-Latn-US", "zh-Hans"]   let countryList = I18n.System.getSystemCountries("zh"); // countryList = ["ZW", "YT", ..., "CN", "DE"], 共240个国家和地区} catch(error) {   console.error(`call i18n.System interface failed, error code: ${error.code}, message: ${error.message}`);} 判断语言和国家是否匹配。 调用isSuggested接口判断语言和地区是否匹配。 已复制try {   let isSuggest = I18n.System.isSuggested("zh", "CN"); // isSuggest = true} catch(error) {   console.error(`call i18n.System interface failed, error code: ${error.code}, message: ${error.message}`);}    获取日历信息 调用日历Calendar相关接口来获取日历的相关信息，例如获取日历的本地化显示、一周起始日、一年中第一周的最小天数等。   接口说明     类名 接口名称 描述    Calendar getCalendar(locale:string,type?:string):Calendar8+ 获取指定locale和type的日历对象。   Calendar setTime(date:Date): void8+ 设置日历对象内部的时间日期。   Calendar setTime(time:number): void8+ 设置日历对象内部的时间日期。   Calendar set(year:number,month:number,date:number,hour?:number,minute?:number,second?:number): void8+ 设置日历对象的年、月、日、时、分、秒。   Calendar setTimeZone(timezone:string): void8+ 设置日历对象的时区。   Calendar getTimeZone():string8+ 获取日历对象的时区。   Calendar getFirstDayOfWeek():number8+ 获取日历对象的一周起始日。   Calendar setFirstDayOfWeek(value:number): void8+ 设置日历对象的一周起始日。   Calendar getMinimalDaysInFirstWeek():number8+ 获取一年中第一周的最小天数。   Calendar setMinimalDaysInFirstWeek(value:number): void8+ 设置一年中第一周的最小天数。   Calendar getDisplayName(locale:string):string8+ 获取日历对象的本地化表示。   Calendar isWeekend(date?:Date):boolean8+ 判断给定的日期在日历中是否是周末。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 实例化日历对象。 调用getCalendar接口获取指定locale和type的时区对象（i18n为导入的模块）。其中，type表示合法的日历类型，目前合法的日历类型包括："buddhist", "chinese", "coptic", "ethiopic", "hebrew", "gregory", "indian", "islamic_civil", "islamic_tbla", "islamic_umalqura", "japanese", "persian"。当type没有给出时，采用区域默认的日历类型。 已复制let calendar = I18n.getCalendar("zh-CN", "chinese"); // 创建中文农历日历 设置日历对象的时间。 调用setTime接口设置日历对象的时间。setTime接口接收两种类型的参数。一种是传入一个Date对象，另一种是传入一个数值表示从1970.1.1 00:00:00 GMT逝去的毫秒数。 已复制let date1 = new Date();calendar.setTime(date1);let date2 = 1000;calendar.setTime(date2); 设置日历对象的年、月、日、时、分、秒。 调用set接口设置日历对象的年、月、日、时、分、秒。 已复制calendar.set(2021, 12, 21, 6, 0, 0); 设置、获取日历对象的时区。 调用setTimeZone接口和getTimeZone接口来设置、获取日历对象的时区。其中，setTimeZone接口需要传入一个字符串表示需要设置的时区。 已复制calendar.setTimeZone("Asia/Shanghai");let timezone = calendar.getTimeZone();  // timezone = "China Standard Time" 设置、获取日历对象的一周起始日。 调用setFirstDayOfWeek接口和getFirstDayOfWeek接口设置、获取日历对象的一周起始日。其中，setFirstDayOfWeek需要传入一个数值表示一周的起始日，1代表周日，7代表周六。 已复制calendar.setFirstDayOfWeek(1);let firstDayOfWeek = calendar.getFirstDayOfWeek(); // firstDayOfWeek = 1 设置、获取日历对象第一周的最小天数。 调用setMinimalDaysInFirstWeek接口和getMinimalDaysInFirstWeek接口来设置、获取日历对象第一周的最小天数。 已复制calendar.setMinimalDaysInFirstWeek(3);let minimalDaysInFirstWeek = calendar.getMinimalDaysInFirstWeek(); // minimalDaysInFirstWeek = 3 获取日历对象的本地化显示。 调用getDisplayName来获取日历对象的本地化显示。 已复制let localizedName = calendar.getDisplayName("zh-CN"); // localizedName = "农历" 判断某一个日期是否为周末。 调用isWeekend接口来判断输入的Date是否为周末。 已复制let date = new Date(2022, 12, 12, 12, 12, 12);let weekend = calendar.isWeekend(date); // weekend = false    电话号码格式化 调用电话号码格式化PhoneNumberFormat的接口，实现对针对不同国家电话号码的格式化以及判断电话号码格式是否正确的功能。   接口说明     类名 接口名称 描述    PhoneNumberFormat constructor(country:string,options?:PhoneNumberFormatOptions)8+ 实例化PhoneNumberFormat对象。   PhoneNumberFormat isValidNumber(number:string):boolean8+ 判断number是否是一个格式正确的电话号码。   PhoneNumberFormat format(number:string):string8+ 对number按照指定国家及风格进行格式化。   PhoneNumberFormat getLocationName(number: string, locale: string): string9+ 获取电话号码归属地。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 实例化电话号码格式化对象。 调用PhoneNumberFormat的构造函数来实例化电话号码格式化对象，需要传入电话号码的国家代码及格式化选项。其中，格式化选项是可选的，包括style选项，该选项的取值包括："E164", "INTERNATIONAL", "NATIONAL", "RFC3966"。 已复制let phoneNumberFormat = new I18n.PhoneNumberFormat("CN", {type: "E164"}); 判断电话号码格式是否正确。 调用isValidNumber接口来判断输入的电话号码的格式是否正确。 已复制let validNumber = phoneNumberFormat.isValidNumber("123****8911"); // validNumber = true 电话号码格式化。 调用电话号码格式化对象的format接口来对输入的电话号码进行格式化。 已复制let formattedNumber = phoneNumberFormat.format("123****8911"); // formattedNumber = "+86123****8911"    度量衡转换 度量衡转换接口可以实现度量衡转换的相关功能。   接口说明     类名 接口名称 描述    I18NUtil unitConvert(fromUnit:UnitInfo,toUnit:UnitInfo,value:number,locale:string,style?:string):string9+ 将fromUnit的单位转换为toUnit的单位，并根据区域与风格进行格式化。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 度量衡单位转换。 调用unitConvert接口实现度量衡单位转换，并进行格式化显示的功能。 已复制let fromUnit = {unit: "cup", measureSystem: "US"};let toUnit = {unit: "liter", measureSystem: "SI"};let number = 1000;let locale = "en-US";let style = "long";let converttedUnit = I18n.I18NUtil.unitConvert(fromUnit, toUnit, number, locale, style); // converttedUnit = "236.588 liters"    字母表索引 调用字母表索引IndexUtil的接口可以获取不同Locale的字母表索引，以及实现计算字符串所属索引的功能。   接口说明     类名 接口名称 描述    IndexUtil getInstance(locale?:string):IndexUtil8+ 实例化字母表索引对象。   IndexUtil getIndexList():Array<string>8+ 获取当前Locale的索引列表。   IndexUtil addLocale(locale:string): void8+ 将新的Locale对应的索引加入当前索引列表。   IndexUtil getIndex(text:string):string8+ 获取text对应的索引。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 实例化字母表索引对象。 调用getInstance接口来实例化特定locale对应的字母表索引对象。当locale参数为空时，实例化系统默认Locale的字母表索引对象。 已复制let indexUtil = I18n.getInstance("zh-CN"); 获取索引列表。 调用getIndexList接口来获取当前Locale对应的字母表索引列表。 已复制let indexList = indexUtil.getIndexList(); // indexList = ["...", "A", "B", "C", ..., "X", "Y", "Z", "..."] 增加新的索引。 调用addLocale接口，将新的Locale对应的字母表索引添加到当前字母表索引列表中。 已复制indexUtil.addLocale("ar"); 获取字符串对应的索引。 调用getIndex接口来获取某一字符串对应的字母表索引。 已复制let text = "access index";let index = indexUtil.getIndex(text); // index = "A"    获取文本断点位置 当文本比较长无法在一行进行显示时，调用文本断点BreakIterator8的接口，来获取文本可以断行的位置。   接口说明     类名 接口名称 描述    BreakIterator getLineInstance(locale:string):BreakIterator8+ 实例化断行对象。   BreakIterator setLineBreakText(text:string): void8+ 设置要处理的文本。   BreakIterator getLineBreakText():string8+ 获取要处理的文本。   BreakIterator current():number8+ 获取当前断行对象在处理文本的位置。   BreakIterator first():number8+ 将断行对象设置到第一个可断句的分割点。   BreakIterator last():number8+ 将断行对象设置到最后一个可断句的分割点。   BreakIterator next(index?:number):number8+ 将断行对象移动index个分割点的位置。   BreakIterator previous():number8+ 将断行对象移动到前一个分割点的位置。   BreakIterator following(offset:number):number8+ 将断行对象移动到offset指定位置的后面一个分割点的位置。   BreakIterator isBoundary(offset:number):boolean8+ 判断某个位置是否是分割点。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 实例化断行对象。 调用getLineInstance接口来实例化断行对象。 已复制let locale = "en-US";let breakIterator = I18n.getLineInstance(locale); 设置、访问要断行处理的文本。 调用setLineBreakText接口和getLineBreakText接口来设置、访问要断行处理的文本。 已复制let text = "Apple is my favorite fruit";breakIterator.setLineBreakText(text);let breakText = breakIterator.getLineBreakText();  // breakText = "Apple is my favorite fruit" 获取断行对象当前的位置。 调用current接口来获取断行对象在当前处理文本中的位置。 已复制let pos = breakIterator.current(); // pos = 0 设置断行对象的位置。 系统提供了很多接口可以用于调整断行对象在处理文本中的位置，包括first, last, next, previous, following。 已复制let firstPos = breakIterator.first(); // 将断行对象设置到第一个分割点的位置，即文本的起始位置；firstPos = 0let lastPos = breakIterator.last();  // 将断行对象设置到最后一个分割点的位置，即文本末尾的下一个位置；lastPos = 26// 将断行对象向前或向后移动一定数量的分割点。// 当传入正数时，向后移动；当传入负数时，向前移动；当未传入数值时，则向后移动一个位置；// 当移动超出了文本的长度范围，则返回-1；let nextPos = breakIterator.next(-2); // nextPos = 12let previousPos = breakIterator.previous();  // 将断行对象向前移动向前移动一个分割点，当超出文本长度范围时返回-1； previousPos = 9// 将断行对象移动到offset指定位置的后面一个分割点。如果offset所指定的位置的下一个分割点超出了文本的长度范围，则返回-1；let followingPos = breakIterator.following(10); // followingPos = 12 判断某个位置是否为分割点。 调用isBoundary接口来判断一个接口是否为分割点；如果该位置是分割点，则返回true，并且将断行对象移动到该位置；如果该位置不是分割点，则返回false，并且将断行对象移动到该位置后的一个分割点。 已复制let isboundary = breakIterator.isBoundary(5); // isboundary = false    获取时区 调用时区TimeZone相关接口来获取时区的相关信息，例如获取时区的ID、本地化显示、时区偏移量等。   接口说明     类名 接口名称 描述    TimeZone getTimeZone(zoneID?: string): TimeZone7+ 获取时区对象。   TimeZone getID(): string7+ 获取时区ID。   TimeZone getDisplayName(locale?: string, isDST?: boolean): string7+ 获取时区的本地化显示。   TimeZone getRawOffset(): number7+ 获取时区对象与UTC时区的偏移量。   TimeZone getOffset(date?: number): number7+ 获取某一时间点时区对象与UTC时区的偏移量。   TimeZone getAvailableIDs(): Array9+ 获取系统支持的时区ID列表。   TimeZone getAvailableZoneCityIDs(): Array9+ 获取系统支持的时区城市ID列表。   TimeZone getCityDisplayName(cityID: string, locale: string): string9+ 获取时区城市ID的本地化显示。   TimeZone getTimezoneFromCity(cityID: string): TimeZone9+ 获取时区城市ID对应的时区对象。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 实例化时区对象，并获取相关时区信息。 调用getTimeZone接口来获取时区对象。 已复制let timezone = I18n.getTimeZone(); // 使用默认参数可以获取系统时区对象。 获取时区ID、本地化显示、时区偏移量、某一时刻的时区偏移量信息。 已复制let timezoneID = timezone.getID(); // timezoneID = "Asia/Shanghai"let timezoneDisplayName = timezone.getDisplayName(); // timezoneDisplayName = "中国标准时间"let rawOffset = timezone.getRawOffset(); // rawOffset = 28800000let offset = timezone.getOffset(new Date().getTime()); // offset = 28800000 获取系统支持的时区ID。 调用getAvailableIDs接口获取系统支持的时区ID列表。 时区ID列表中的时区ID可以作为getTimeZone接口的参数，来创建TimeZone对象。 已复制let timezoneIDs = I18n.TimeZone.getAvailableIDs(); // timezoneIDs = ["America/Adak", ...]，共包含24个时区IDlet timezone = I18n.getTimeZone(timezoneIDs[0]);let timezoneDisplayName = timezone.getDisplayName(); // timezoneDisplayName = "夏威夷-阿留申时间" 获取系统支持的时区城市ID。 调用getAvailableZoneCityIDs接口获取系统支持的时区城市ID列表。 调用getCityDisplayName接口获取时区城市ID的本地化显示。 调用getTimezoneFromCity接口基于时区城市ID创建时区对象。 已复制let zoneCityIDs = I18n.TimeZone.getAvailableZoneCityIDs(); // ["Auckland", "Magadan", ...]let cityDisplayName = I18n.TimeZone.getCityDisplayName(zoneCityIDs[0], "zh-Hans"); // cityDisplayName = "奥克兰(新西兰)"let timezone = I18n.TimeZone.getTimezoneFromCity(zoneCityIDs[0]);let timezoneDisplayName = timezone.getDisplayName(); // timezoneDisplayName = "新西兰时间"    获取音译对象 调用音译Transliterator相关接口来创建音译对象，获取音译字符串。   接口说明     类名 接口名称 描述    Transliterator getAvailableIDs():Array9+ 获取音译支持的ID列表。   Transliterator getInstance(): Transliterator9+ 创建音译对象。   Transliterator transform(text: string): string9+ 获取音译字符串。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 获取支持音译的ID列表。 调用getAvailableIDs接口来获取支持音译的ID列表。 每个ID的格式为 source-destination，例如 ASCII-Latin，表示将ASCII转换为Latin的音译ID。 已复制let ids = I18n.Transliterator.getAvailableIDs(); // ids = ["ASCII-Latin", "Accents-Any", ... ]，共支持671个语言 创建音译对象，获取音译字符串。 支持音译的ID列表中的ID可以作为getInstance接口的参数，创建音译对象。 已复制let transliterator = I18n.Transliterator.getInstance("Any-Latin");   // Any-Latn表示将任意文本转换为Latn文本let transformText = transliterator.transform("你好");   // transformText = "nǐ hǎo "let transliterator2 = I18n.Transliterator.getInstance("Latin-ASCII"); // Latin-ASCII表示将Latin文本转换为ASCII文本let transformText = transliterator2.transform(transformText);  // transformText = "ni hao"    字符类型判断 调用字符Unicode相关接口来获取字符的相关信息，例如字符是否是数字、字符是否是空格符等。   接口说明     类名 接口名称 描述    Unicode isDigit(char: string): boolean9+ 判断字符是否是数字。   Unicode isSpaceChar(char: string): boolean9+ 判断字符是否是空格符。   Unicode isWhitespace(char: string): boolean9+ 判断字符是否是空白符。   Unicode isRTL(char: string): boolean9+ 判断字符是否是从左到右显示的字符。   Unicode isIdeograph(char: string): boolean9+ 判断字符是否是表意文字。   Unicode isLetter(char: string): boolean9+ 判断字符是否是字母。   Unicode isLowerCase(char: string): boolean9+ 判断字符是否是小写字母。   Unicode isUpperCase(char: string): boolean9+ 判断字符是否是大写字母。   Unicode getType(char: string): string9+ 获取字符的类型。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 判断字符是否具有某种性质。 判断字符是否是数字。 已复制let isDigit = I18n.Unicode.isDigit("1"); // isDigit = trueisDigit = I18n.Unicode.isDigit("a"); // isDigit = false 判断字符是否是空格符。 已复制let isSpaceChar = I18n.Unicode.isSpaceChar(" "); // isSpaceChar = trueisSpaceChar = I18n.Unicode.isSpaceChar("\n"); // isSpaceChar = false 判断字符是否是空白符。 已复制let isWhitespace = I18n.Unicode.isWhitespace(" "); // isWhitespace = trueisWhitespace = I18n.Unicode.isWhitespace("\n"); // isWhitespace = true 判断字符是否是从左到右书写的文字。 已复制let isRTL = I18n.Unicode.isRTL("مرحبًا"); // isRTL = true，阿拉伯语的文字是从左到右书写的文字isRTL = I18n.Unicode.isRTL("a"); // isRTL = false 判断字符是否是表意文字。 已复制let isIdeograph = I18n.Unicode.isIdeograph("你好"); // isIdeograph = trueisIdeograph = I18n.Unicode.isIdeograph("a"); // isIdeograph = false 判断字符是否是字母。 已复制let isLetter = I18n.Unicode.isLetter("a"); // isLetter = trueisLetter = I18n.Unicode.isLetter("."); // isLetter = false 判断字符是否是小写字母。 已复制let isLowerCase = I18n.Unicode.isLowerCase("a"); // isLetter = trueisLowerCase = I18n.Unicode.isLowerCase("A"); // isLetter = false 判断字符是否是大写字母。 已复制let isUpperCase = I18n.Unicode.isUpperCase("a"); // isUpperCase = falseisUpperCase = I18n.Unicode.isUpperCase("A"); // isUpperCase = true 获取字符的类型。 调用getType接口获取字符的类型。 已复制let type = I18n.Unicode.getType("a"); // type = U_LOWER_CASE_LETTER    获取日期中年月日的排列顺序   接口说明     类名 接口名称 描述    I18NUtil getDateOrder(locale: string): string9+ 判断日期中年月日的排列顺序。      开发步骤  导入I18n模块。 已复制import I18n from '@ohos.i18n'; 判断日期的年月日的排序顺序。 调用getDateOrder接口判断某一Locale的日期中，年月日的排列顺序。 接口返回一个字符串，由"y"，"L"，"d"三部分组成，分别表示年、月、日，使用中划线进行拼接。例如，"y-L-d"。 已复制let order = I18n.I18NUtil.getDateOrder("zh-CN"); // order = "y-L-d"，表示中文中年月日的顺序为年-月-日。    上一篇 Intl开发指导 下一篇 应用测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。功能介绍前提条件HarmonyOS应用测试评分方法及规则原子化服务体检 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 功能介绍原子化服务体检（Scoring Tool）是用于测试并评价HarmonyOS应用/服务的质量，应用于开发者对HarmonyOS应用/服务进行自测试，能快速提供评估结果和改进建议，帮助开发者迅速提升产品质量。 
说明
原子化服务体验功能适用于API Version4~7的工程。 
 开发者可以通过DevEco Studio连接本地设备或远程真机，自主遍历HarmonyOS应用/服务的功能，快速进行自测试，查看测试结果及评分。当前支持的测试类型包括兼容性、性能和设计约束。具体测试项及评分标准请参考评分方法及规则。  前提条件在使用Scoring Tool对HarmonyOS应用/服务进行测试之前，先要确保DevEco Studio与真机设备已连接或已连接远程真机。对需要测试的HarmonyOS应用/服务提前根据为应用/服务进行签名章节和编译生成HAP，打包带签名信息的HAP。  HarmonyOS应用测试在DevEco Studio中，单击菜单栏Tools > Scoring Tool，弹出Scoring Tool页面。在Scoring Tool页面选择HarmonyOS应用或原子化服务安装的Device。 在Scoring Tool页面单击+按钮，添加已签名的HAP。
说明
支持同时添加多个HAP，要求所有HAP的“bundleName”相同，且多个HAP中只能包含一个Entry。 
  在Scoring Tool页面底部单击Start开始测试。在测试过程中，请保持连接的设备为解锁状态，屏幕为点亮的状态，并在设备上手动遍历HarmonyOS应用或原子化服务的功能。遍历操作完成后，单击Stop停止测试任务，查看测试结果。    评分方法及规则原子化服务体检当前支持三种测试类型检测：兼容性、性能和设计约束。DevEco Studio会根据体检结果，计算出最后评分，满分为100分。评分的计算公式为： 评分 = 100*{Sum(单项得分*权重）/131} 
说明
单项得分：满足检测规则为1分，不满足为0分。 
 各体检项检测规则及权重如下表所示： 体检类别  检测规则  权重    兼容性  APP要求在其支持的OS版本上安装无问题  7   APP要求在其支持的OS版本上启动无问题  7   APP要求在其支持的OS版本上卸载无问题  7   APP运行稳定，无Crash，无冻屏  7   运行不会出现崩溃、无响应问题  7   性能  冷启动时间≤2000 ms  7   滑动帧率，被测服务的各个界面帧率≥55 FPS  7   前台内存占用，被测服务启动30 s后，前台内存暂用≤500 MB  7   设计约束  必须明确FA支持设备类型  5   应用或者服务的Entry FA有且仅有一个  5   每个服务至少支持1张服务卡片  5   HarmonyOS服务中的FA为免安装且小于10M  5   HarmonyOS服务中的FA要求为非免安装  5   禁止APP安装后在桌面自动添加多个图标  5   FA对应的Module需配置为免安装  5   所有Ability的label需唯一  5   FA必须指定唯一MainAbility为操作入口  5   MainAbility需配置默认服务卡片、图标、名称  5   需声明最小和目标OS的SDK版本号  5   APP集成native so需要64位  5   分布式场景，必须配置兼容版本信息  5   服务需配置图标、名称、描述、快照  5   服务卡片主动刷新最高频率限定在30分钟1次  5       上一篇 测试框架 下一篇 HarmonyOS应用/服务发布 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介参数说明使用实例bytrace使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 简介bytrace是开发人员用于追踪进程轨迹、分析性能的一种工具，主要对内核ftrace进行了封装和扩展，来支持用户态的打点。通过该工具可以打开想要查看的用户态和内核label（通过下面命令行bytrace -l，查看支持的所有label），然后通过命令行进行抓取trace信息到指定文件中。  参数说明bytrace当前支持以下命令: 表1 命令行列表Option  Description    -h，--help  查看option帮助   -b n，--buffer_size n  指定n(KB)内存大小用于存取trace日志，默认2048KB   -t n，--time n  用来指定trace运行的时间（单位：s），取决于需要分析过程的时间   --trace_clock clock  trace输出的时钟类型，一般设备支持boot、global、mono、uptime、perf等，默认为boot   --trace_begin  启动抓trace   --trace_dump  将数据输出到指定位置（默认控制台）   --trace_finish  停止抓trace，并将数据输出到指定位置（默认控制台）   -l，--list_categories  输出手机能支持的trace模块   --overwrite  当缓冲区满的时候，将丢弃最新的信息。（默认丢弃最老的日志）   -o filename，--output filename  指定输出的目标文件名称   -z  抓取trace后进行压缩      使用实例准备工作，使用bytrace工具需要先进入shell命令行： 已复制hdc shell 以下是常用bytrace命令示例，供开发者参考： 查询支持的label。 已复制bytrace -l   或者 已复制bytrace --list_categories 设置4M缓存，抓取10秒，抓取label为ability的trace信息。 已复制bytrace -b 4096 -t 10 --overwrite ability > /data/mytrace.ftrace 设置trace的输出时钟为mono。 已复制bytrace --trace_clock mono  -b 4096 -t 10 --overwrite ability > /data/mytrace.ftrace 抓取trace后进行压缩。 已复制bytrace -z  -b 4096 -t 10 --overwrite ability > /data/mytrace.ftrace    上一篇 命令行工具 下一篇 SDK管理使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。codelinter使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 codelinter同时支持使用命令行执行代码检查与修复。 表1 code linter命令行指令指令  说明    --config/-c  指定执行codelinter检查的规则配置文件。   --source/-s  指定执行检查的工程根目录。   --fix/-f  设置codelinter检查同时执行QuickFix。   --output/-o  检查结果保存位置。   --version/-v  查看codelinter版本。   --help/-h  查询codelinter命令行帮助。     从DevEco Studio官网获取并安装Command Line Tools工具，将命令行工具bin目录配置到环境变量中。 打开命令行，执行如下命令，查看codelinter使用帮助，检查环境变量是否配置成功。已复制codelinter -h  进行codelinter代码检查与修复。在工程根目录下使用命令行工具：直接执行 codelinter 指令。此时根据默认codelinter检查规则，对该工程中的TS/ArkTS文件进行代码检查。默认的规则清单可在检查完成后，根据命令行提示，查看相应位置的code-linter.json5文件。已复制codelinter // 进行codelinter检查  执行如下命令，指定codelinter检查所使用的code-linter.json5规则配置文件，并进行代码检查。已复制codelinter -c filepath // 指定执行检查的规则配置文件位置  执行如下命令，对指定工程将根据指定的规则配置文件执行codelinter检查，并对部分支持修复的告警信息进行自动修复。已复制codelinter -c filepath --fix true // 对工程中的告警进行修复   在非工程根目录下使用命令行工具：执行如下命令，指定需要进行检查的工程根目录。此时根据默认codelinter检查规则，对该工程中的TS/ArkTS文件进行代码检查。默认的规则清单可在检查完成后，根据命令行提示，查看相应位置的code-linter.json5文件。已复制codelinter -s filepath // 指定执行检查的工程根目录  在指定的工程目录下，根据指定的codelinter规则配置文件进行代码检查。已复制codelinter -c filepath -s filepath2 // filepath为指定的规则配置文件所在位置，filepath2指定执行检查的工程根目录 执行如下命令，对指定工程重新执行codelinter检查，并对部分支持修复的告警进行自动修复。已复制codelinter -c filepath -s filepath2 --fix true // 对指定工程中的告警进行修复    执行如下指令，指定代码检查结果保存位置。默认放在命令行工具文件夹result文件下。已复制codelinter -o filepath3  // filepath3为指定存放代码检查结果的位置                     上一篇 SDK管理命令行工具高级配置 下一篇 ohpm使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介环境准备注意事项开发指导全局option查询相关命令行服务进程相关命令网络相关命令文件相关命令app相关命令调试相关命令hdc使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 简介hdc（HarmonyOS Device Connector）是HarmonyOS为开发人员提供的用于调试的命令行工具，通过该工具可以在windows/linux/mac系统上与真实设备或者模拟器进行交互。  环境准备hdc工具通过HarmonyOS SDK获取，存放于SDK的toolchains目录下，使用时将SDK的toolchains目录添加到环境变量。 Windows环境变量设置方法：在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，添加HDC端口变量名为：HDC_SERVER_PORT，变量值可设置为任意未被占用的端口，如7035。  环境变量配置完成后，关闭并重启DevEco Studio。 macOS环境变量设置方法：打开终端工具，执行以下命令，根据输出结果分别执行不同命令。已复制echo $SHELL  如果输出结果为/bin/bash，则执行以下命令，打开.bash_profile文件。已复制vi ~/.bash_profile 如果输出结果为/bin/zsh，则执行以下命令，打开.zshrc文件。已复制vi ~/.zshrc  单击字母“i”，进入Insert模式。输入以下内容，添加HDC_SERVER_PORT端口信息。已复制export HDC_SERVER_PORT=7035 编辑完成后，单击Esc键，退出编辑模式，然后输入“:wq”，单击Enter键保存。执行以下命令，使配置的环境变量生效。如果步骤a时打开的是.bash_profile文件，请执行如下命令：已复制source ~/.bash_profile 如果步骤a时打开的是.zshrc文件，请执行如下命令：已复制source ~/.zshrc  环境变量配置完成后，关闭并重启DevEco Studio。   注意事项使用hdc，如果出现异常，可以尝试通过hdc kill -r命令杀掉并重启hdc服务。如果出现hdc list targets获取不到设备信息的情况，可以通过任务管理器查看是否有hdc进程存在。若进程存在，则通过hdc kill -r命令杀掉该进程。 
说明
命令行中被[]修饰的参数表示可选参数。命令行中的参数若是斜体，表示在使用时该参数需替换为具体的信息，例如：file send local remote命令中的local和remote，使用时需替换为本地待发送和远端待接收的文件路径。 
  开发指导 全局option Option  说明    -t [key] [command]  指定连接唯一标识的目标设备。   -h  打印hdc帮助信息。   -v  打印hdc版本信息。   -n/-c  手机/平板镜像为3.1及以上版本时，如果开发者需要操作（安装/卸载等）API 9的应用，使用 -n或不带 -n；手机/平板镜像为3.1及以上版本时，如果开发者需要操作（安装/卸载等）应用为API 8及以下版本，使用 -c；手机/平板镜像为3.1之前版本，如果开发者需要操作（安装/卸载等）应用为API 8及以下版本，使用 -c。     显示hdc相关的帮助信息，命令格式如下：已复制hdc -h 返回值：返回hdc的帮助信息。 使用方法：已复制hdc -h  显示hdc的版本信息，命令格式如下：已复制hdc -v 返回值：返回hdc的版本信息。 使用方法：已复制hdc -v  连接设备时，若仅有一台，无需指定设备标识。若有多台，一次仅能连接一台，每次连接时需要指定连接设备的标识，命令格式如下：已复制hdc -t [key] [command] 参数： 参数名  说明    key  IP地址或USB序列号。   command  hdc支持的命令。     返回值：若连接的设备不存在，返回 Invalid arguments ***。若附件的命令不存在，返回unknown command ***。 使用方法：该方法需要与具体的操作命令搭配使用，下面以shell命令举例： 已复制hdc list targets  （获取设备信息）hdc -t [key] shell （-t后面添加的key需要替换为查询到的某一个设备信息） 
说明
一台开发机可连接多个设备，每个设备有唯一的标识。如果通过网络连接设备，标识为IP地址，如果通过usb连接，标识为USB序列号。该命令需要跟随具体的操作命令。 
    查询相关命令行 命令  说明    help  打印hdc帮助信息。   version  打印hdc版本信息。   list targets [-v]  查询已连接的所有目标设备，添加-v选项，则会打印设备详细信息。     显示所有已经连接的设备列表，命令格式如下：已复制hdc list targets[-v] 返回值若没有查询到设备信息，返回[Empty]。若查询到已经连接的的设备，返回设备列表。 使用方法：已复制hdc list targetshdc list targets -v    服务进程相关命令 命令  说明    target mount  读写模式挂载系统分区。   target boot  重启目标设备，查看目标列表可用list targets命令。   smode [off]  授予设备端hdc后台服务进程root权限， 使用off参数取消授权。   kill  终止hdc服务进程。     以读写模式挂载系统分区，命令格式如下：已复制hdc target mount 返回值挂载成功，返回remount succeeded。挂载失败，返回具体的失败信息。 使用方法：已复制hdc target mount  授予设备端hdc后台服务进程root权限，命令格式如下：已复制hdc smode [off] 使用方法：已复制hdc smode  hdc smode off  // 取消root权限  终止hdc服务进程，命令格式如下：已复制hdc kill [-r] 返回值服务进程终止成功，无返回值。服务进程终止失败，返回具体的失败信息。 使用方法：已复制hdc killhdc kill -r    网络相关命令 命令  说明    fport ls  展示全部“端口转发主机端口转发数据到设备侧端口”的转发任务。   fport local remote  端口转发主机端口转发数据到设备侧端口。   fport rm local remote  删除指定“端口转发主机端口转发数据到设备侧端口”的转发任务。   rport ls  展示全部“端口转发设备侧端口转发数据到主机端口”的转发任务   rport local remote  端口转发设备侧端口转发数据到主机端口   rport rm local remote  删除指定“端口转发设备侧端口转发数据到主机端口”的转发任务      文件相关命令 命令  说明    file send local remote  从本地发送文件至远端设备。   file recv remote local  从远端设备发送文件至本地。     从本地发送文件至远端设备，命令格式如下：已复制hdc file send local remote 参数 参数名  说明    local  本地待发送的文件路径。   remote  远程待接收的文件路径。     返回值文件发送成功，返回传输成功的结果信息。文件发送失败，返回传输失败的具体信息。 使用方法：已复制hdc file send E:\example.txt /data/local/tmp/example.txt  从远端设备发送文件至本地，命令格式如下：已复制hdc file recv remote local 参数 参数名  说明    local  本地待接收的文件路径。   remote  远程待发送的文件路径。     返回值文件接收成功，返回传输成功的结果信息。文件接收失败，返回传输失败的具体信息。 使用方法：已复制hdc file recv  /data/local/tmp/a.txt   ./a.txt    app相关命令 命令  说明    install packageFile  安装指定的应用package文件。   uninstall packageName  卸载指定的应用包package包名。     安装HarmonyOS package，命令格式如下：已复制hdc install packageFile 参数 参数名  说明    packageFile  HarmonyOS应用安装包文件。     返回值：packageFile安装成功，无返回值。packageFile安装失败，返回具体的失败信息。 使用方法，以安装com.example.hello包为例：已复制hdc install E:\com.example.hello.hap  卸载HarmonyOS应用，命令格式如下：已复制hdc uninstall packageName 参数： 参数名  说明    packageName  应用安装包包名。     返回值：packageName卸载成功，无返回值。packageName卸载失败，返回具体的失败信息。 使用方法，以卸载com.example.hello包为例：已复制hdc uninstall com.example.hello    调试相关命令 命令  说明    shell [COMMAND]  交互命令，COMMAND表示需要执行的单次命令。其中当OS镜像API≥9时，不支持交互式进入设备，仅支持交互式命令。   jpid  显示可调试应用列表。   track-jpid  动态显示可调试应用列表。   hilog [options]  打印设备端的日志信息，options表示hilog支持的参数，可通过hdc hilog -h查阅支持的参数列表 。     抓取log信息，命令格式如下：已复制hdc hilog [options] 返回值：返回抓取到的日志信息。 使用方法：已复制hdc hilog   交互命令，命令格式如下：已复制hdc shell [COMMAND] 返回值：返回shell后面执行命令的结果信息。 使用方法：已复制hdc shell ps -ef     上一篇 ohpm使用指导 下一篇 hvigor命令行 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。hvigor命令行 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
当前hvigor暂不支持全局命令行工具，依赖工程中的hvigorw工具。 
 hvigorw命令行使用方式: 已复制./hvigorw [taskNames...] <options>  查询相关命令行: 选项  说明    -h, --help  打印hvigor的命令帮助信息   -v, --version  打印hvigor版本信息     日志相关命令行: 选项  说明    -e, --error  设置hvigor的日志级别为error   -w, --warn  设置hvigor的日志级别为warn   -i, --info  设置hvigor的日志级别为info   -d, --debug  设置hvigor的日志级别为debug   --stacktrace  打印所有异常的堆栈信息     hvigor Daemon进程相关命令行: 选项  说明    --no-daemon  hvigor默认使能daemon，如需关闭在命令行后添加该选项   --stop-daemon  关闭当前工程的Daemon进程，可以使用--stop-daemon-all命令关闭所有工程的Daemon进程   --status-daemon  查询当前环境中所有的hvigor Daemon进程信息     hvigor 性能相关命令行: 选项  说明    --parallel, --no-parallel  hvigor默认使能并行编译能力，如需关闭在命令行后添加该选项   --incremental, --no-incremental  hvigor默认使能增量编译能力，如需关闭在命令行后添加该选项     hvigor 公共命令: 选项  说明    tasks  打印工程各模块包含的任务信息   taskTree  打印工程各模块的任务依赖关系信息   version  打印 hvigor的相关版本信息     hvigor 其他命令行: 选项  说明    -s，--sync  处理并持久化hvigor部分工程信息到工程./hvigor/outputs/sync/output.json中   --enable-build-script-type-check  使能工程中hvigorfile.ts的类型检查      上一篇 hdc使用指导 下一篇 附录 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。如何安装如何更改配置常用命令ohpm使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 OHPM CLI 作为鸿蒙生态三方库的包管理工具，支持OpenHarmony共享包的发布、安装和依赖管理。 如何安装下载ohpm工具包，点击链接获取。解压文件，进入“ohpm/bin”目录，打开命令行工具，执行如下指令初始化ohpm。
说明
初始化ohpm前，需先完成node.js环境变量配置。 
 Windows环境下执行：已复制init.bat  Linux/macOS环境下执行：已复制./init  将ohpm配置到环境变量中。Windows环境变量设置方法：在此电脑 > 属性 > 高级系统设置 > 高级 > 环境变量中，将ohpm命令行工具的bin目录配置到系统或者用户的PATH变量中。 macOS环境变量设置方法：打开终端工具，执行以下命令。已复制export OHPM_HOME=/home/xx/Downloads/ohpm  #本处路径请替换为ohpm的安装路径export PATH=${OHPM_HOME}/bin:${PATH}   安装完成之后，执行如下命令：已复制ohpm -v 终端输出为版本号（如：0.6.10），则表示安装成功。   如何更改配置用户级配置文件存放在C:/Users/用户名目录/.ohpm/.ohpmrc文件，显示默认配置，可执行如下命令： 已复制ohpm config list -j 设置配置项，可执行如下命令： 已复制ohpm config set key value 默认配置项如下所示： 配置项  字段名称  字段说明  字段类型  默认值  备注    仓库设置  registry  仓库地址  字符串  https://repo.harmonyos.com/ohpm/  可以配置多个仓库地址，多个仓库地址的优先级按照配置顺序排序。   @group:registry  指定仓库  字符串  ""  根据 group 指定组织的仓库地址。支持多个仓库地址，且优先级大于 registry 配置，多个仓库地址的优先级按照配置顺序排序。   发布设置  publish_registry  发布仓库  字符串  https://repo.harmonyos.com/ohpm/  配置发布的仓库地址，仅支持配置一个仓库地址。   publish_id  用户发布号  字符串  ""  用户发布号，用来发布鸿蒙生态三方库，全局唯一。   路径设置  cache  缓存路径  字符串  C:/Users/用户名目录/.ohpm/cache  -   key_path  私钥路径  字符串  ""  利用ssh-keygen 工具生成的私钥的放置路径地址。   网络设置   no_proxy  不使用proxy代理  字符串  ""  配置不使用代理的仓库地址，可配置多个，以英文逗号间隔；值可以是域名或者ip，支持二级域名通配符*（例如：*.huawei.com）。   http_proxy  http代理  字符串  ""  支持用户名和密码的网络代理，示例：http://proxy_server:port。   https_proxy  https代理  字符串  ""  支持用户名和密码的网络代理，示例：http://proxy_server:port。   strict_ssl  ssl校验  布尔  true  默认值为 true，校验 https 证书；若配置为 false，则不校验 https 证书。   ca_files  ca证书路径  字符串  ""  strict_ssl=true时校验服务端证书需要的ca证书放置路径，可以放置多个证书路径，以英文逗号间隔。   fetch_timeout  请求超时时间  数值  60000  单位为毫秒。   其他设置  log_level  日志级别  字符串  info  可设置日志输出级别，对应级别类型有 debug、info、warn、error。      常用命令 命令类别  命令格式  含义说明    版本查询  ohpm -v 或 ohpm --version  查看ohpm-cli 版本号   帮助查询  ohpm help 或 ohpm -h 或 ohpm --help  查看命令帮助列表   创建  ohpm init  创建 oh-package.json5 文件   安装    ohpm install [[<@group>/]<pkg> [@<version>]] ...  安装指定版本的三方库，当未指定三方库名称时，会根据当前目录下oh-package.json5 定义的依赖关系进行全量安装   ohpm install <folder>  安装本地文件夹   ohpm install <tarball file>  安装压缩包   卸载  ohpm uninstall [<@group>/]<pkg> ...  卸载三方库   查看  ohpm list [[<@group>/]<pkg>[@<version>]]  列出已安装的三方库   查询  ohpm info [<@group>/]<pkg>[@<version>]  查询指定三方库的具体信息   设置ohpm配置项     ohpm config set key value  设置配置值，如服务器地址，网络代理   ohpm config delete key  删除配置   ohpm config get key  获取单个配置项   ohpm config list  获取所有的配置项列表   更新  ohpm update [[<@group>/]<pkg>] ...  更新三方库   发布  ohpm publish [<folder> | <tarball file>]  发布三方库   下架  ohpm unpublish [<@group>]<pkg>[@<version>]  下架已发布的三方库   校验仓库地址  ohpm ping  校验仓库地址是否有效     更多命令使用以及命令支持的配置项，请参阅ohpm-cli。   上一篇 codelinter使用指导 下一篇 hdc使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看SDK组件安装组件卸载组件查看ohsdkmgr版本查看ohsdkmgr帮助options选项说明ohsdkmgr使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 ohsdkmgr（单击链接获取）是一个OpenHarmony SDK命令行管理工具，支持Windows、Mac、Linux三个平台。 ohsdkmgr支持查看、安装和卸载SDK组件，SDK组件包括API和工具链。 适用于DevEco Studio 3.1 Canary1（3.1.0.100）及以上版本。 ohsdkmgr命令行格式为： 已复制ohsdkmgr <command> --[options] [<component>]  command：包括list、install、uninstall、version、help。 options：可选配置参数，请参考options选项说明。 component：组件，支持的组件请使用list命令查看。 查看SDK组件查看本地和远程组件命令格式如下： 已复制ohsdkmgr list --[options] [<component>]  查询SDK组件的示例如下所示： 查看所有组件的安装情况：已复制ohsdkmgr list 运行结果片段示例： 已复制 Component  | API Version | Version  | Stage   | Status        | Available Update ---------- | ----------- | -------- | ------- | ------------- | ---------------- ets        | 9           | 3.2.10.6 | Beta5   | Not Installed | js         | 9           | 3.2.10.6 | Beta5   | Not Installed | native     | 9           | 3.2.10.6 | Beta5   | Not Installed | previewer  | 9           | 3.2.10.6 | Beta5   | Not Installed | toolchains | 9           | 3.2.10.6 | Beta5   | Not Installed | ---------- | ----------- | -------- | ------- | ------------- | ---------------- ... ---------- | ----------- | -------- | ------- | ------------- | ----------------  查看指定路径下所有组件的安装情况：已复制ohsdkmgr list --sdk-directory="/data/sdk" 查看指定API Version版本的JS组件：已复制ohsdkmgr list js:9   安装组件安装一个或多个组件命令格式如下： 已复制ohsdkmgr install --[options] <component1> [<component2>]  安装组件的示例如下所示： 安装最新版本的JS组件：已复制ohsdkmgr install js 安装API Version为9的JS组件：已复制ohsdkmgr install js:9 同时安装API Version为9的JS组件和Native组件：已复制ohsdkmgr install js:9 native:9 安装最新版本的JS组件，并指定SDK存储路径：已复制ohsdkmgr install --sdk-directory="/data/sdk" js 安装最新版本的JS组件，需要使用http代理来安装，代理信息文件通过config参数进行指定：已复制ohsdkmgr install js --config="/data/sdk/config.properties" 其中，config参数指定的配置文件config.properties中包含代理服务器信息和组件存储路径。 已复制sdk-directory="/data/sdk"proxy-type=httpproxy=host:port 安装comp.txt中指定的组件，并安装到指定的目录。已复制ohsdkmgr install --component-file="/data/sdk/comp.txt" --sdk-directory="/data/sdk" 其中，comp.txt中包含的内容举例如下所示： 已复制ets:9js:9native:9toolchains   卸载组件卸载一个或多个组件命令格式如下： 已复制ohsdkmgr uninstall --[options] <component1> [<component2>]  卸载组件的示例如下所示： 卸载本地的JS组件，可以指定具体的API Version，如果不指定，则会卸载最高API Version的最新版本。已复制ohsdkmgr uninstall js:9 同时卸载本地已安装的API Version为9的JS组件和Native组件版本。已复制ohsdkmgr uninstall js:9 native:9   查看ohsdkmgr版本查看ohsdkmgr版本号的命令格式为： 已复制ohsdkmgr version | --version  查看ohsdkmgr帮助查看ohsdkmgr帮助文档的命令格式为： 已复制ohsdkmgr help | --help   options选项说明options是ohsdkmgr的可选配置参数，这些参数可以直接在命令行中执行外，还可以将这些参数配置到ohsdkmgr配置文件（ohsdkmgr工具默认配置文件路径为sdkmanager/conf/config.properties）中。 
说明
config=<filePath>、component-file=<filePath>和accept-license参数只能在命令行中执行，不能写到配置文件中。 
 选项  说明    config=<filePath>  ohsdkmgr配置文件存放目录，默认为sdkmanager/conf/config.properties。   sdk-directory=<filePath>  指定存放组件的根目录，默认路径为ohsdkmgr工具根目录的上一级目录。   component-file=<filePath>  指定一个文本文件，文件内容指定需要安装的组件。   node-home=<filePath>  <filePath>指定为Node.js所在的根目录。   proxy-type=<none | http | socks>  代理类型，取值为none或者http或者socks。   proxy=<host:port>  代理服务器的主机和端口。   accept-license  自动签署SDK License协议。   no-ssl-verify  访问OpenHarmony SDK下载路径时，是否进行HTTPS的证书校验，默认进行证书校验，设置该参数则会关闭证书校验。 
说明
关闭证书校验，可能会带来安全风险，请谨慎使用。 
   debug  开启debug模式。       上一篇 sdkmgr使用指导 下一篇 SDK管理命令行工具高级配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看SDK组件安装组件卸载组件查看sdkmgr版本查看sdkmgr帮助options选项说明sdkmgr使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 sdkmgr（点击链接获取）是一个HarmonyOS SDK命令行管理工具，支持Windows、Mac、Linux三个平台。 sdkmgr支持查看、安装和卸载SDK组件，SDK组件包括API和工具链。 适用于DevEco Studio 3.1 Canary1（3.1.0.100）及以上版本。 sdkmgr命令行格式为： 已复制sdkmgr <command> --[options] [<component>]  command：包括list、install、uninstall、version、help。 options：可选配置参数，请参考options选项说明。 component：组件，支持的组件请使用list命令查看。 查看SDK组件查看本地和远程组件命令格式如下： 已复制sdkmgr list --[options] [<component>]  查询SDK组件的示例如下所示： 查看所有组件的安装情况：已复制sdkmgr list 运行结果片段示例： 已复制 Component                 | API Version | Version   | Stage   | Status        | Available Update ------------------------- | ----------- | --------- | ------- | ------------- | ---------------- previewer                 | 9           | 3.2.2.2   | Beta1   | Not Installed | system-image,phone_x86    | 9           | 3.1.0.106 | Beta1   | Not Installed | toolchains                | 9           | 3.2.2.2   | Beta1   | Not Installed | OpenHarmony/ets           | 9           | 3.2.2.6   | Beta1   | Not Installed | OpenHarmony/js            | 9           | 3.2.2.6   | Beta1   | Not Installed | ... ------------------------- | ----------- | --------- | ------- | ------------- | ---------------- ... ------------------------- | ----------- | --------- | ------- | ------------- | ---------------- ets                       | 7           | 3.0.0.5   | Release | Not Installed | java                      | 7           | 3.0.0.5   | Release | Not Installed | js                        | 7           | 3.0.0.5   | Release | Not Installed | ... ------------------------- | ----------- | --------- | ------- | ------------- | ---------------- ... system-image,phone_x86    | 6           | 2.0.0.211 | Release | Not Installed | ... ------------------------- | ----------- | --------- | ------- | ------------- | ---------------- ... ------------------------- | ----------- | --------- | ------- | ------------- | ---------------- emulator                  | 0           | 3.1.0.100 | Beta1   | Not Installed | ------------------------- | ----------- | --------- | ------- | ------------- | ----------------  查看指定路径下所有组件的安装情况：已复制sdkmgr list --sdk-directory="/data/sdk" 查看指定API Version版本的JS组件：已复制sdkmgr list OpenHarmony/js:9   安装组件安装一个或多个组件命令格式如下： 已复制sdkmgr install --[options] <component1> [<component2>]  安装组件的示例如下所示： 安装最新版本的JS组件：已复制sdkmgr install OpenHarmony/js 安装API Version为9的JS组件：已复制sdkmgr install OpenHarmony/js:9 安装API Version为7的JS组件：已复制sdkmgr install js:7 同时安装API Version为9的JS组件和Native组件：已复制sdkmgr install OpenHarmony/js:9 OpenHarmony/native:9 安装最新版本的JS组件，并指定SDK存储路径：已复制sdkmgr install --sdk-directory="/data/sdk" OpenHarmony/js 安装最新版本的JS组件，需要使用http代理来安装，代理信息文件通过config参数进行指定：已复制sdkmgr install OpenHarmony/js --config="/data/sdk/config.properties" 其中，config参数指定的配置文件config.properties中包含代理服务器信息和组件存储路径。 已复制sdk-directory="/data/sdk"proxy-type=httpproxy=host:port 安装comp.txt中指定的组件，并安装到指定的目录。已复制sdkmgr install --component-file="/data/sdk/comp.txt" --sdk-directory="/data/sdk" 其中，comp.txt中包含的内容举例如下所示： 已复制OpenHarmony/ets:9OpenHarmony/js:9OpenHarmony/native:9toolchains 安装镜像：已复制sdkmgr install system-image,phone_x86 安装模拟器：已复制sdkmgr install emulator    卸载组件卸载一个或多个组件命令格式如下： 已复制sdkmgr uninstall --[options] <component1> [<component2>] 卸载组件的示例如下所示： 卸载本地的JS组件，可以指定具体的API Version，如果不指定，则会卸载最高API Version的最新版本。已复制sdkmgr uninstall OpenHarmony/js:9 同时卸载本地已安装的API Version为5的Java组件和JS组件版本。已复制sdkmgr uninstall java:5 js:5   查看sdkmgr版本查看sdkmgr版本号的命令格式为： 已复制sdkmgr version | --version  查看sdkmgr帮助查看sdkmgr帮助文档的命令格式为： 已复制sdkmgr help | --help   options选项说明options是sdkmgr的可选配置参数，这些参数可以直接在命令行中执行外，还可以将这些参数配置到sdkmgr配置文件（sdkmgr工具默认配置文件路径为sdkmanager/conf/config.properties）中。 
说明
config=<filePath>、component-file=<filePath>和accept-license参数只能在命令行中执行，不能写到配置文件中。 
 选项  说明    config=<filePath>  sdkmgr配置文件存放目录，默认为sdkmanager/conf/config.properties。   sdk-directory=<filePath>  指定存放组件的根目录，默认路径为sdkmgr工具根目录的上一级目录。   component-file=<filePath>  指定一个文本文件，文件内容指定需要安装的组件。   node-home=<filePath>  <filePath>指定为Node.js所在的根目录。   proxy-type=<none | http | socks>  代理类型，取值为none或者http或者socks。   proxy=<host:port>  代理服务器的主机和端口。   accept-license  自动签署SDK License协议。   no-ssl-verify  访问HarmonyOS SDK下载路径时，是否进行HTTPS的证书校验，默认进行证书校验，设置该参数则会关闭证书校验。 
说明
关闭证书校验，可能会带来安全风险，请谨慎使用。 
   debug  开启debug模式。       上一篇 SDK管理使用指导 下一篇 ohsdkmgr使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。SDK管理使用指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     sdkmgr使用指导  ohsdkmgr使用指导  SDK管理命令行工具高级配置   上一篇 bytrace使用指导 下一篇 sdkmgr使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告功耗测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 功耗测试主要验证HarmonyOS应用在华为真机设备上运行的功耗，包括屏幕占用时长、WLAN占用时长、音频占用时长等。具体功耗测试项的详细说明请参考功耗测试标准。 功耗测试支持Phone，包格式包括Hap/App。 前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。选择或者创建一个项目，如果新创建一个项目，注意选择HarmonyOS。 进入项目空间，在左侧导航栏中选择测试服务 > HarmonyOS云测试，进入HarmonyOS云测试页面，点击HarmonyOS云测试页面右侧的创建测试按钮，进入创建测试任务页面。 在创建测试任务页面选择功耗测试，设置如下信息后，点击下一步。应用程序：选择待测试的HarmonyOS应用包，包括HAP和APP两种格式，如果未上传应用，请先从本地上传一个HarmonyOS应用包。应用分类：设置应用的一级分类、二级分类和三级分类。 
说明
每天只能进行100次功耗测试任务，请合理安排测试任务。 
  选择测试设备，功耗测试支持手机（Phone）和轻量级智能穿戴（LiteWearable）。任务创建完成后，请等待测试任务完成，可以在HarmonyOS云测试任务列表中查看任务状态。   查看测试报告测试任务执行完成后，在任务列表中，可以点击查看测试报告按钮，查看测试结果详细信息。  在测试报告的概览页，可以查看测试任务的整体情况，如测试通过率、问题分布、在各个测试终端上的问题分布情况。  点击测试设备后的查看详情按钮，可以查看测试任务详情信息，如测试截屏、异常信息和日志信息。    上一篇 性能测试 下一篇 UX测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。打印Hilog日志输出日志查看日志信息日志打印实例打印FaultLog日志打印日志 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio的日志系统包括HiLog日志和FaultLog日志系统，其中： HiLog日志系统：让应用/服务可以按照指定类型、指定级别、指定格式字符串打印日志内容，帮助开发者了解应用/服务的运行状态，更好地调试程序。FaultLog日志系统：FaultLog是为了满足HarmonyOS应用/服务开发者基本的故障定位需求而设计，能够帮助应用开发者快速查询、定位、导出应用故障信息。 打印Hilog日志 输出日志在输出日志前，需要先调用isLoggable确认某个domain、tag和日志级别是否被禁止打印日志。使用示例： 已复制hilog.isLoggable(0x0000, "testTag", hilog.LogLevel.INFO); 参数domain：用于指定输出日志所对应的业务领域，取值范围为0x0~0xFFFFF，开发者可以根据需要进行自定义。参数tag：用于指定日志标识，可以为任意字符串，建议标识调用所在的类或者业务行为。参数level：用于指定日志级别。 hilog中定义了DEBUG、INFO、WARN、ERROR、FATAL五种日志级别，并提供了对应的方法用于输出不同级别的日志，如下表所示： 表1 HiLog提供的主要接口接口名  功能描述    debug(domain: number, tag: string, format: string, ...args: Array<Object>)  输出DEBUG级别的日志。DEBUG级别日志表示仅用于应用/服务调试。 可以在DevEco Studio的terminal窗口或cmd里，通过命令“hdc shell hilogcat”设置可打印日志的等级为DEBUG。   info(domain: number, tag: string, format: string, ...args: Array<Object>)  输出INFO级别的日志。INFO级别日志表示普通的信息。   warn(domain: number, tag: string, format: string, ...args: Array<Object>)  输出WARN级别的日志。WARN级别日志表示存在警告。   error(domain: number, tag: string, format: string, ...args: Array<Object>)  输出ERROR级别的日志。ERROR级别日志表示存在错误。   fatal(domain: number, tag: string, format: string, ...args: Array<Object>)  输出FATAL级别的日志。FATAL级别日志表示出现致命错误、不可恢复错误。     参数domain和tag应与isLoggable中使用的一致。参数format：格式字符串，用于日志的格式化输出。格式字符串中可以设置多个参数，例如格式字符串为“%s World”，“%s”为参数类型为string的变参标识，具体取值在args中定义。每个参数需添加隐私标识，分为{public}或{private}，默认为{private}。{public}表示日志打印结果可见；{private}表示日志打印结果不可见，输出结果为<private>。 调试时可以通过命令“hilog -p off”指令，关闭隐私开关，明文显示private日志内容。 参数args：可以为0个或多个参数，是格式字符串中参数类型对应的参数列表。参数的数量、类型必须与格式字符串中的标识一一对应。 以输出一条INFO级别的信息为例，示例代码： 已复制hilog.info(0xFF00, "testTag", "%{public}s World %{public}d", "hello", 3); 该行代码表示输出一个普通信息，格式字符串为：”%{public}s World %{public}d”。其中变参"%{public}s"为公共的字符串；%{public}d为公共的整型数。  查看日志信息DevEco Studio提供了“Log > HiLog”窗口查看日志信息，开发者可通过设置设备、进程、日志级别和搜索关键词来筛选日志信息。搜索功能支持使用正则表达式，开发者可通过搜索自定义的业务领域值和TAG来筛选日志信息。 根据实际情况选择了设备和进程后，搜索标签“testTag”进行筛选，得到对应的日志信息。  结果输出： 已复制10-27 10:07:04.456 20680-20939/com.example.myapplication I 0FF00/testTag: hello World 3 20680-20939表示进程的进程ID和线程ID。com.example.myapplication表示应用进程名。I表示日志级别为INFO。testTag为开发者自定义的日志标签。日志内容中显示将实际取值填入字符串的结果。 HiLog窗口左侧各个按钮的作用为： ：单击该按钮可以向上翻页，日志窗口取消自动滚动。 ：单击该按钮可以向下翻页，日志窗口取消自动滚动。如果翻页已到底部，日志窗口自动滚动。 ：当该按钮处于选中状态时，日志自动换行显示，否则日志按行显示。 ：当该按钮处于选中状态时，日志自动滚动到窗口底部，否则停留在当前日志显示处。 ：单击该按钮可以重新开启日志接收，会清空日志缓存和窗口日志。 ：单击该按钮可以清空窗口日志。 :  单击该按钮可以对当前选择的设备屏幕进行截屏，并保存在本地。不支持对包含密码输入的界面进行截屏。 ：单击该按钮可以保存日志缓存到指定文件。 ：自动选择和切换已连接的设备。 ：过滤只展示App日志。 ：单击该按钮可以关闭当前日志窗口。  日志打印实例在按钮中增加一个单击事件，单击按钮时打印一条日志。 
说明
本示例采用ArkTS语言为例，使用JS语言开发仅在UI部分代码有所不同，hilog部分代码通用。 
 新建一个工程，选择“Empty Ability”。工程配置界面中，Model选择“FA ”、Language选择“ArkTS”。在Project窗口单击“entry > src > main > ets > MainAbility > pages ”，打开工程中的“index.ets”文件，添加一个按钮，点击按钮打印日志。示例代码如下：已复制// index.ets
import hilog from '@ohos.hilog';
@Entry@Componentstruct Index {  build() {    Row() {      Column() {        // 添加按钮，以响应用户点击        Button() {          Text('Next')            .fontSize(30)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')        // 跳转按钮绑定onClick事件，点击时打印日志        .onClick(() => {          hilog.isLoggable(0xFF00, "testTag", hilog.LogLevel.INFO);              hilog.info(0xFF00, "testTag", "%{public}s World %d", "hello", 3);        })      }      .width('100%')    }    .height('100%')  }}  在真机/远程模拟器上运行该工程，单击应用/服务界面上的“Next”按钮。在DevEco Studio的底部，切换到“Log”窗口，设置日志的过滤条件。选择当前的设备及进程，日志级别选择Info，搜索内容设置为“testTag”。此时窗口仅显示符合条件的日志。    打印FaultLog日志FaultLog是由系统自动从设备进行收集，包括如下四类故障信息： App FreezeCPP CrashJS CrashJava Crash FaultLog故障信息如下图所示，支持按照应用包名进行过滤、日志刷新、日志导出等功能。  如上图所示，FaultLog故障信息左侧按照应用/服务包名 > 故障类型 > 故障时间结构组成，选中具体的故障日期，则会在右侧展示详细的故障信息，便于开发者进行故障定位。   上一篇 跨设备应用/服务调试 下一篇 C/C++内存错误检测 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。导入Sample工程 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持Sample工程的导入功能，通过对接Gitee开源社区中的Sample资源，可一键导入Sample工程到DevEco Studio中。 下面介绍导入Sample的方法。 在DevEco Studio的欢迎页，进入Configure > Settings > Version Control > Git界面，单击Test按钮检测是否安装Git工具。
说明
在打开工程的情况下，可以单击File > Settings进入设置界面。 
 已安装，请根据2开始导入Sample。 未安装，请单击Download and Install，DevEco Studio会自动下载并安装。安装完成后，请根据2开始导入Sample。  在DevEco Studio的欢迎页，单击Import Sample按钮，导入Sample工程。
说明
在打开工程的情况下，可以单击File > New >Import >Import Sample来进行导入。 
  在勾选框中选择HarmonyOS/OpenHarmony的页签，选择需要导入的Sample工程，然后单击Next。 设置Project name和Project location，然后单击Finish，等待Sample工程导入完成。 导入Sample后，等待工程同步完成即可。
说明
如果网络受限，导入时会提示“Failed to connect to gitee.com port 443: Time out”连接超时错误，请配置Git代理信息。 
   上一篇 Gradle工程适配为Hvigor工程 下一篇 添加/删除Module 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。低代码开发 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    低代码开发概述  使用低代码开发应用或服务  使用低代码开发服务卡片  低代码开发Demo示例  导入Sketch文件生成界面  低代码开发中使用业务组件  低代码开发中使用自定义组件  使用数据模型和连接器  低代码多语言支持及屏幕适配   上一篇 代码Quick Fix快速修复 下一篇 低代码开发概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。登录组件准备工作使用登录组件使用支付组件准备工作使用支付组件低代码开发中使用业务组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 开发者在DevEco Studio低代码可以通过拖拽组件栏提供的业务组件，快速开发包含华为帐号登录、华为支付场景的应用。低代码的登录、支付业务组件都是通过集成AGC提供的SDK实现，低代码简化了手动集成SDK、调用SDK接口的工作。 
说明
该功能在DevEco Studio 3.1 Beta2及更高版本中支持，且创建的工程必须是compileSdkVersion为6的JS工程。 
 登录组件与手动使用华为登录SDK类似，在低代码中使用登录组件，仍然需要准备工作。  准备工作创建项目，可参考在AGC创建项目。创建应用，可参考在AGC创建应用。获取agconnect-services.json文件。 开通认证服务并启用“华为帐号”认证方式，详情请参见认证服务-华为帐号。  使用登录组件在DevEco Studio中新建API6 JS低代码工程，在菜单栏中点击“File > New > Create Project”，选择“Atomic Service”或“Application”。这里以创建元服务为例，选择“Atomic Service”。选择Empty Ablity模板，点击“Next”。填写工程信息，注意Bundle Name要和云控制台里设置的包名一致，否则运行时会报错bundleName不一致。 将准备工作步骤3下载的agconnect-services.json文件，放置在工程的entry目录下。 拖拽登录组件到设计器，自动同步依赖，生成调用登录功能代码。开发者可以绑定自己登录成功或者失败的回调。开发者根据应用功能，配置登录组件的样式属性。如需要其他登录功能（如登出、获取用户信息等）可参考：登录后，调用LOW_CODE_LOGIN.getCurrentUser()接口查询用户信息。JavaScript已复制agcLogin.getCurrentUser().then((data) => {    this.showToast(" currUser is " + data.accessToken.token);}, (err) => {    this.showToast(" get user fail, error code: " + err);}); 调用登出接口LOW_CODE_LOGIN.signOut()退出登录。JavaScript已复制var result = await agcLogin.signOut();  配置应用签名和指纹，可参考应用签名。配置完成后，可以在真机上进行调试。
说明
配置应用指纹后，需要等待一段时间指纹才能生效。在生效之前，登录组件调SDK接口可能会返回错误码6003。 如果配置完指纹，运行本地客户端仍然出现6003的错误，这是由于默认运行的是debug证书，请尝试清除HMS Core（APK）的缓存后再次运行 
   使用支付组件与手动使用华为支付SDK类似，在低代码中使用支付组件，仍然需要准备工作。  准备工作创建项目，可参考在AGC创建项目。创建应用，可参考在AGC创建应用。获取agconnect-services.json文件。已注册成为商户。开通应用内支付服务，详情请参见配置支付服务参数。配置支付相关数据模型。登录AppGallery Connect，选择“我的项目”，选择您的项目。选择“低代码平台 > 数据模型”，点击页面中的“新建数据模型”。基础商品表主键字段： 商品表主键字段： 订单表主键字段：  选择“低代码平台 > 数据模型”，点击页面中的“新建数据模型”，分别配置“商品表”、“基础商品表”和“订单表”的数据模型字段。基础商品表字段信息： 商品表字段信息： 订单表字段信息：  数据模型配置完成后，点击数据模型“操作”列的发布。在已发布的数据模型中，点击操作列的“管理数据”进入页面，点击“新建”，新增数据，填写完成后点击“提交”。在“基础商品表”数据模型中新增基础商品信息，数据如下： 在“商品表”数据模型中新增商品信息，数据如下：
说明
“基础商品ID”字段与基础商品表中的主键必须保持一致。 
    配置IAP商品表。新建IAP商品表，具体操作请参见创建应用内商品。商品信息表字段信息如下： 
说明
商品表中的“商品ID”必须与商品表数据模型中的“IAP商品ID”保持一致。 
    使用支付组件在DevEco Studio中新建API6 JS 低代码工程，在菜单栏中点击“File > New > Create Project”，选择“Atomic Service”或“Application”。这里以创建元服务为例，选择“Atomic Service”> Empty Ablity模板，点击“Next”。填写工程信息，注意Bundle Name要和云控制台里设置的包名一致，否则运行时会报错bundleName不一致。将准备工作步骤3下载的agconnect-services.json文件，放置在工程的entry目录下。 在entry模块添加配置信息。在“entry/src/main/config.json”的module节点增加如下属性配置，其中${clientID}为开发者的OAuth 2.0客户端ID（在AppGallery Connect网站点击“我的项目”，在项目列表中找到您的项目，在“项目设置 > 常规”页面的“应用”区域获取“OAuth 2.0客户端ID（凭据）：Client ID”的值）。 已复制"metaData": {  "customizeData": [    {      "name": "com.huawei.hms.client.appid",      "value": "${clientID}"    }  ]} 拖拽支付组件到设计器，自动同步依赖，生成调用支付功能代码。开发者可以绑定自己支付成功或者失败的回调。开发者需要根据应用的业务场景提供购买商品的类型、数量等信息，写入data区。
说明
publicKey为项目下应用内支付公钥，在“我的项目 > 盈利 > 应用内支付服务”页面中获取。goodsModelId和orderModelId为“商品表”和“订单表”的发布态的数据模型ID。basicGoodsId为基础商品表数据模型的主键。 
  配置应用签名和指纹，可参考应用签名。配置完成后，可以在真机上进行调试。   上一篇 导入Sketch文件生成界面 下一篇 低代码开发中使用自定义组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建新工程支持低代码开发在已有工程中添加Visual支持低代码开发使用低代码开发应用或服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 使用低代码开发应用或服务有以下两种开发方式： 创建一个支持低代码开发的新工程，开发应用或服务的UI界面。在已有工程中，创建Visual文件来开发应用或服务的UI界面。 ArkTS工程和JS工程使用低代码的步骤相同，接下来以JS工程为例分别讲解这两种开发方式。 创建新工程支持低代码开发在工程模板中，提供了低代码开发的工程模板，您可以直接选择一个支持低代码开发的工程模板来开发应用或服务的UI界面。 
说明
该功能在DevEco Studio 3.0 Beta2及更高版本中支持，且compileSdkVersion必须为7或以上。ArkTS低代码要求compileSdkVersion必须为8或以上。 
 接下来我们以创建一个Empty Ability工程模板为示例进行说明。 打开DevEco Studio，创建一个新的工程，选择Empty Ability模板。 打开Enable Super Visual，表示使用低代码开发功能开发应用/服务。单击Finish等待工程同步完成。 同步完成后，工程目录中自动生成低代码目录结构。  pages > index > index.js：低代码页面的逻辑描述文件，定义了页面里所用到的所有的逻辑关系，比如数据、事件等，详情请参考JS语法参考。如果创建了多个低代码页面，则pages目录下会生成多个页面文件夹及对应的js文件。
说明
使用低代码页面开发时，其关联js文件的同级目录中不能包含hml和css页面，例如上图中的js > MainAbility > pages > index目录下不能包含hml与css文件，可能出现报错。 
 pages > index > index.visual：visual文件存储低代码页面的数据模型，双击该文件即可打开低代码页面，进行可视化开发设计。如果创建了多个低代码页面，则pages目录下会生成多个页面文件夹及对应的visual文件。 打开“index.visual”文件，即可进行页面的可视化布局设计与开发。
说明
使用低代码开发界面过程中，如果界面需要使用到其它暂不支持可视化布局的控件时，可以在低代码界面开发完成后，单击按钮，将低代码界面转换为hml和css代码。注意，代码转换操作会删除visual文件及其父目录，且为不可逆过程，代码转换后不能通过hml/css文件反向生成visual文件。多设备开发的场景，可以单击界面画布右上角设备/模式切换按钮，进行设备切换或模式切换。其中，单击按钮，切换到Media Query模式，可以针对不同设备和屏幕状态设置专属的样式和属性值，如下图，当前模式仅针对P40竖屏状态有效 
    在已有工程中添加Visual支持低代码开发在已有的HarmonyOS工程中，可以通过创建Visual文件的方式，使用低代码开发应用或服务的UI界面，要求compileSdkVersion必须为7或以上。ArkTS低代码要求compileSdkVersion必须为8或以上。 在打开的工程中，选中模块的pages文件夹，单击鼠标右键，选择New > Visual > Page。 在弹出的对话框中，输入Visual name，单击Finish。创建Visual后，会在工程中自动生成低代码的目录结构，如下图所示： pages > page > page.js：低代码页面的逻辑描述文件，定义了页面里所用到的所有的逻辑关系，比如数据、事件等，详情请参考JS语法参考。如果创建了多个低代码页面，则pages目录下会生成多个页面文件夹及对应的js文件。
说明
使用低代码页面开发时，其关联js文件的同级目录中不能包含hml和css页面，例如上图中的js > MainAbility > pages > page目录下不能包含hml与css文件，否则可能报错。 
 pages > page > page.visual：visual文件存储低代码页面的数据模型，双击该文件即可打开低代码页面，进行可视化开发设计。如果创建了多个低代码页面，则pages目录下会生成多个页面文件夹及对应的visual文件。
说明
DevEco Studio预置了JS Visual模板，该模板对应的SDK版本为API 7。因此，在创建JS Visual文件时，如果模块的compileSdkVersion低于7，则会对新建的JS Visual文件对应的SDK版本进行降级处理，使其与模块对应的SDK版本保持一致。 不建议通过文本编辑的方式更改visual文件，否则，可能导致不能正常使用低代码功能。 
  打开“page.visual”文件，即可进行页面的可视化布局设计与开发。
说明
使用低代码开发界面过程中，如果界面需要使用到其它暂不支持可视化布局的控件时，可以在低代码界面开发完成后，单击按钮，将低代码界面转换为hml和css代码。注意，代码转换操作会删除visual文件及其父目录，且为不可逆过程，代码转换后不能通过hml/css文件反向生成visual文件。多设备开发的场景，可以单击界面画布右上角设备/模式切换按钮，进行设备切换或模式切换。其中，单击按钮，切换到media query模式，可以为组件设置不同的样式和属性。当前media query模式仅针对不同设备类型和不同屏幕状态（横屏\竖屏）有效。 
     上一篇 低代码开发概述 下一篇 使用低代码开发服务卡片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用低代码开发服务卡片 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio还支持使用低代码开发功能开发服务卡片，目前只支持JS语言，且compileSdkVersion必须为7或以上。 下面以创建一个新的服务卡片为例进行说明。 打开一个工程，创建服务卡片，创建方法包括如下两种方式：选择模块（如entry模块）下的任意文件，单击菜单栏File > New > Service Widget创建服务卡片。选择模块（如entry模块）下的任意文件，单击右键 > New > Service Widget创建服务卡片。 在Choose a Template for Your Service Widget界面中，选择卡片模板，单击Next。 在Configure Your Service Widget界面中，配置卡片的基本信息，包括：Service widget name：卡片的名称，在同一个FA中，卡片名称不能重复，且只能包含数字、字母和下划线。Description：卡片的描述信息。Enable Super Visual：是否选择低代码方式开发，这里选择打开低代码开关。Language：界面开发语言。Support dimensions：选择卡片的规格。部分卡片支持同时设置多种规格。Ability name：选择一个挂靠服务卡片的Page Ability，或者创建一个新的Page Ability。
说明
如果选择的Ability是继承AceAbility时，请参考JS卡片开发指导的步骤2进行修改。 
 Module name：卡片所属的模块。  单击Finish，完成卡片创建。卡片创建完成后，在工程目录中自动生成卡片的低代码目录结构。 打开“index.visual”文件，即可进行卡片的可视化设计与开发。  上一篇 使用低代码开发应用或服务 下一篇 低代码开发Demo示例 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自定义组件由已有的基础组件（或组合）创建自定义组件新建一个自定义组件使用自定义组件自定义属性自定义事件低代码开发中使用自定义组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 开发者在使用DevEco Studio的低代码功能进行可视化开发时，可以通过自定义组件功能自由封装业务逻辑类组件，实现能力复用，降低开发及维护成本。 
说明
该功能在DevEco Studio 3.1 Beta2及更高版本中支持，且创建的工程必须是compileSdkVersion为8或以上的ArkTS工程。 
 自定义组件 由已有的基础组件（或组合）创建自定义组件右击基础组件（或组件组合），在弹出的菜单中选择Create Custom Component。 在弹出的对话框中输入自定义组件名称，然后单击OK。 自定义组件创建完成后，DevEco Studio将会自动生成.visual和.ets文件，Stage模型和FA模型下生成的文件路径有所区别： Stage模型：.visual文件：src/main/supervisual/page/xxx.visual.ets文件：src/main/ets/page/xxx.ets FA模型：.visual文件：src/main/supervisual/xxxAbility/common/xxx.visual.ets文件：src/main/ets/xxxAbility/common/xxx.ets  自定义组件创建完成后，DevEco Studio将自动打开自定义组件设计界面，开发者可以在设计界面编辑自定义组件的属性、事件和布局。   新建一个自定义组件选中支持的目录，选择File > New > Visual > Component，或者右击目录，选择New > Visual > Component。其中支持新建自定义组件的目录，Stage模型和FA模型有所区别： Stage模型：切换到Ohos视图后的ets目录及下属目录（不包含test目录）。FA模型：切换到Ohos视图后的Page类型Ability目录及下属目录。 在弹出的New Visual Component对话框中，输入自定义组件名称，单击Finish。 自定义组件创建完成后，DevEco Studio将自动打开自定义组件设计界面，开发者可以在设计界面编辑自定义组件的属性、事件和布局。  使用自定义组件自定义组件创建后，开发者可以直接在应用设计界面的Custom页签查看到已经创建的自定义组件，并可以直接拖拽到画布中使用，另外开发者也可以在.ets代码页面直接导入并使用自定义组件。  在.ets代码页面使用自定义组件示例如下所示： 已复制import ImgButton from '../CustomComponents/ImgButton'@Entry@Componentstruct Index {
  @State message: string = 'Hello World'
  build() {    Column(){      ImgButton()    }    .width('100%')    .height('100%')  }}  自定义属性开发者可以为自定义组件设置自定义属性。 在自定义组件的.ets文件中定义变量。例如： 已复制@Preview@Componentexport default struct ImgButton {  @State customLable:string = 'This is my comp'  build() {  }} 在使用自定义组件的设计界面中，选择该自定义组件，在属性栏中将显示自定义属性。开发者可自行设置属性值，设置属性值后可同步修改自定义组件显示效果。   自定义事件开发者可以为自定义组件设置自定义事件。 在自定义组件的.ets文件中定义事件函数。例如： 已复制@Preview@Componentexport default struct ImgButton {  @State customLable:string = 'This is my comp'
  customKeyEvent:(event:KeyEvent) => void =(event:KeyEvent):void =>{    console.log("customKeyEvent")  }
  build() {  }} 在使用自定义组件的设计界面中，选择该自定义组件，在事件栏中将显示自定义事件。开发者可自行绑定事件函数。    上一篇 低代码开发中使用业务组件 下一篇 使用数据模型和连接器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。低代码开发Demo示例 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 接下来为大家展示一个低代码开发的JS工程的Demo示例，使用低代码开发如下华为手机介绍列表的HarmonyOS应用/服务示例。  删除模板页面中的控件后，选中组件栏中的List组件，将其拖至中央画布区域，松开鼠标，实现一个List组件的添加。在List组件添加完成后，用同样的方法拖拽一个ListItem组件至List组件内。 选中画布内的List组件，按住控件的resize按钮，将List拉大。 依次选中组件栏中的Div、Image、Div、Text组件，将Div组件拖至中央画布区域的ListItem组件内，Image、Div组件拖至画布内Div组件内，Text组件拖至最内层Div组件内。 分别选中组件树中的ListItem和外层Div组件，单击右侧属性样式栏中的样式图标（General），在展开的General栏中修改ListItem和Div组件的高度。 对内层Div组件的样式进行调整 。 js的数据及方法关联。js文件用来定义页面的业务逻辑，基于JS语言的动态化能力，可以使应用/服务更加富有表现力，具备更加灵活的设计。低代码页面支持设置属性（Properties）和绑定事件（Events）时关联js文件中的数据及方法。 在低代码页面关联js文件的data对象中定义phoneList数组。 选中组件树中的ListItem组件，单击右侧属性样式栏中的属性图标（Properties），在展开的Properties栏中单击For属性对应的输入框，并在弹出的下拉框中选中{{phoneList}}，实现在低代码页面内引用关联js文件中定义的数据。成功实现关联后，For属性会根据设置的数据列表（phoneList），展开当前元素，即复制出3个结构一致的ListItem。 选中画布中的Image组件，修改右侧属性栏中的Src属性为{{$item.img}}，为Image设置图片资源。其中item为phoneList数组中定义的对象，item.img即为对象中的img属性。 选中画布中的Text组件，修改右侧属性栏中的Content属性为{{$item.title}}，为Text设置文本内容并调整Text的Width样式。 复制并粘贴画布中的Text组件，修改被粘贴出来的Text组件右侧属性栏中的Content属性为{{$item.subTitle}}，为其设置文本内容并调整FontSize样式。 在关联js文件中定义switchTitle()方法，为粘贴出来的Text组件绑定Click事件，并关联js文件中的switchTitle方法。关联后，在previewer、模拟器及真机中单击该Text组件，会将文本内容从"Leap Further Ahead"切换成"Kirin 9000"。  使用预览器预览界面效果。打开.visual文件，并单击DevEco Studio右侧Previewer，即可实现实时的预览功能，开发者在低代码页面中的每一步操作都会在Previewer上实时显示。   上一篇 使用低代码开发服务卡片 下一篇 导入Sketch文件生成界面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。多语言支持屏幕适配低代码多语言支持及屏幕适配 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 多语言支持低代码页面支持多语言能力，让应用开发者无需开发多个不同语言的版本。开发者可以通过定义资源文件和引用资源两个步骤以使用多语言能力。 在指定的i18n文件夹内创建多语言资源文件及对应字符串信息。 在低代码页面的属性样式栏中使用$t方法引用资源，系统将根据当前语言环境和指定的资源路径（通过$t的path参数设置），显示对应语言的资源文件中的内容。$t相关说明请参考多语言支持。如下图所示，在属性栏中引用了字符串资源后，打开预览器即可预览展示效果。 
说明
引用资源后，暂不支持在低代码页面内显示多语言的内容，开发者可通过previewer、模拟器及真机查看引用资源后的具体效果。 
    屏幕适配对于屏幕适配问题，低代码页面支持两种配置方法。 指定designWidth为720px。designWidth为屏幕逻辑宽度，所有与大小相关的样式（例如Width、FontSize）均以designWidth和实际屏幕宽度的比例进行缩放。例如设置Width为100px时，在实际宽度为1440物理像素的屏幕上，Width实际渲染像素为200物理像素。设置autoDesignWidth为true，此时designWidth字段将会被忽略，渲染组件和布局时按屏幕密度进行缩放。低代码页面仅支持分辨率1080*2340（P40），屏幕密度为3的场景，此场景下1px等于渲染出3个物理像素。例如设置Width为100px时，Width实际渲染像素为300物理像素。 
说明
designWidth和autoDesignWidth相关具体概念请参考js标签配置。 
    上一篇 使用数据模型和连接器 下一篇 端云一体化开发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。低代码开发界面介绍低代码开发概述 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
该特性支持使用低代码进行JS/ArkTS页面开发，在DevEco Studio V2.2 Beta1及更高版本中支持，其中，ArkTS低代码特性在DevEco Studio 3.0 Beta4及更高版本中支持。 
 HarmonyOS低代码开发方式，具有丰富的UI界面编辑功能，例如基于图形化的自由拖拽、数据的参数化配置等，遵循HarmonyOS JS开发规范，通过可视化界面开发方式快速构建布局，可有效降低用户的时间成本和提升用户构建UI界面的效率。 低代码开发界面介绍低代码开发界面如下图所示：  ：UI Control：UI控件栏，可以将相应的组件选中并拖动到画布（Canvas）中，实现控件的添加。 ：Component Tree：组件树，在低代码开发界面中，开发者可以直观地看到组件的层级结构、摘要信息以及错误提示。开发者可以通过选中组件树中的组件（画布中对应的组件被同步选中），实现画布内组件的快速定位；单击组件后的或图标，可以隐藏/显示相应的组件。 ：Panel：功能面板，包括常用的画布缩小放大、撤销、显示/隐藏组件虚拟边框、设备切换、明暗模式切换、Media query切换、可视化布局界面一键转换为hml和css文件等。 ：Canvas：画布，开发者可在此区域对组件进行拖拽、拉伸等可视化操作，构建UI界面布局效果。 ：Attributes & Styles：属性样式栏，选中画布中的相应组件后，在右侧属性样式栏可以对该组件的属性样式进行配置。包括：Properties：对应图标，用于设置组件基本标识和外观显示特征的属性，如组件的ID、If等属性。 General：对应图标，用于设置Width、Height、Background、Position、Display等常规样式。Feature：对应图标，用于设置组件的特有样式，如描述Text组件文字大小的FontSize样式等。Flex：对应图标，用于设置Flex布局相关样式。Events：对应图标，为组件绑定相关事件，并设置绑定事件的回调函数。Dimension：对应图标，用于设置Padding、Border、Margin等与盒式模型相关的样式。 Grid：对应图标，用于设置Grid网格布局相关样式，该图标只有Div组件的Display样式被设置为grid时才会出现。Atomic：对应图标，用于设置原子布局相关样式。    上一篇 低代码开发 下一篇 使用低代码开发应用或服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。工程配置数据模型管理与使用管理数据模型使用数据模型连接器管理与使用连接器管理连接器使用使用数据模型和连接器 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 Serverless低代码开发平台是一个可视化的平台， 打通了HarmonyOS云侧与端侧能力，能够轻松实现HMS Core、AGC Serverless能力调用。其中，数据模型和连接器是两大主要元素。开发者在使用DevEco Studio的低代码功能进行开发时，可以使用其可视化、傻瓜式的操作配置构建HarmonyOS元服务、PC Web应用，助力元服务快速开发与降本增效。 
说明
该功能在DevEco Studio 3.1 Beta2及更高版本中支持，且创建的工程必须是compileSdkVersion为6的JS工程。 
 工程配置登录AppGallery Connect云控制台并创建自己的目标项目，并创建一个目标工程。 DevEco中新建API6 JS 低代码工程，注意Bundle Name要和云控制台里设置的包名一致，否则运行时会报错bundleName不一致。 在AppGallery Connect云平台，点击‘项目设置’，下载agconnect-services.json文件，放置在MyApplication工程的entry目录下。   至此完成了开发低代码云端工程的初始化配置。   数据模型管理与使用在AppGallery Connect云平台创建数据模型以后，能够在DevEco Studio端使用定义好的数据模型。  管理数据模型在数据模型界面， 可以新建、修改、更新、删除数据模型及其详细信息。   使用数据模型  连接器管理与使用同样，在AppGallery Connect云平台创建连接器以后，能够在DevEco Studio端使用定义好的连接器。  连接器管理在连接器管理界面，可以新建、修改、更新、删除连接器及其详细信息。   连接器使用在云平台定义好连接器以后，可以在DevEco Studio桌面端使用。 打开一个低代码visual文件。选择刚刚定义好的连接器， 点击submit，DevEco Studio会在同名的js文件中自动生成相应代码。 Build项目，生成HAP，推送到真机或者模拟器上即可查看效果。    上一篇 低代码开发中使用自定义组件 下一篇 低代码多语言支持及屏幕适配 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。导入Sketch文件生成界面 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS应用开发网站提供了用于HarmonyOS设备的设计资源文件，内容包括色彩、控件和界面模板，可以帮助开发者设计符合HarmonyOS风格的界面。 DevEco Studio的低代码开发功能，支持通过导入Sketch源文件生成界面。导入时，可以转换的元素为： HarmonyOS设计资源中的元素由HarmonyOS设计资源中的元素组成的自定义组件原生的图像元素和文字元素组件样式和属性 
说明
该功能在DevEco Studio 3.1 Beta1及更高版本中支持，且创建的工程必须是compileSdkVersion为8或以上的ArkTS工程。 
 在菜单栏选择File > New > Import... > Import Sketch，打开Sketch To Visual对话框。 单击Choose Sketch File，选择本地需要导入的Sketch源文件。如果Sketch文件中包含不支持的组件及属性，在导入后将会收到提示，不支持的组件及属性将不会被导入。 在Pages和Custom components页签完成页面及组件配置。Sketch中包含的页面及组件，在导入时，将分别在Pages和Custom components页签中展示，您可以勾选需要导入的页面及组件，并设置相应的文件路径及归属的Ability。 单击OK，完成Sketch文件导入。完成导入后，DevEco Studio将自动生成页面.visual文件、自定义组件.visual文件以及.ets文件。   上一篇 低代码开发Demo示例 下一篇 低代码开发中使用业务组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Profiler性能分析 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    Profiler性能分析器介绍  分析HarmonyOS应用/服务的CPU活动性能  分析HarmonyOS应用/服务的内存使用  分析HarmonyOS应用/服务网络活动  分析HarmonyOS应用/服务能耗   上一篇 HarmonyOS应用性能分析 下一篇 Profiler性能分析器介绍 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述前提条件操作步骤使用远程真机运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 概述
说明
该特性在DevEco Studio V2.2 Beta1及更高版本中支持。 
 如果开发者没有真机设备资源，则不能很方便的调试和验证HarmonyOS应用，为方便开发者，DevEco Studio提供了Remote Device远程真机设备资源供开发者使用，减少开发成本。目前，远程真机支持Phone和Wearable设备，开发者使用远程真机调试和运行应用时，同本地物理真机设备一样，需要对应用/服务进行签名才能运行。 相比远程模拟器，远程真机是部署在云端的真机设备资源，远程真机的界面渲染和操作体验更加流畅，同时也可以更好的验证应用/服务在真机设备上的运行效果，比如性能、手机网络环境等。  前提条件已注册成为华为开发者，并完成华为开发者实名认证。已对应用/服务进行签名，具体签名指导请参考为应用/服务进行签名。
说明
需要注意的是，远程真机每次释放后重新申请，服务端分配的设备都不一样。因此，每次重新申请远程真机后，都需要对应用/服务重新进行签名。 
   操作步骤在DevEco Studio菜单栏，单击Tools > Device Manager。在Remote Device页签中，单击Sign In，在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录（查看登录授权常见问题）。 登录后，请单击界面的允许按钮进行授权。 在Single device中，单击设备运行按钮，启动远程真机设备（同一时间只能启动一个设备）。 单击DevEco Studio的Run > Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）。 DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在远程真机上。    上一篇 使用模拟器运行应用/服务 下一篇 运行OpenHarmony应用/服务运行 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告HarmonyOS应用远程真机测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 通过远程连接方式控制云端真机对HarmonyOS应用进行测试，包括HarmonyOS应用在远程真机上的安装、测试等，当前支持的真机设备包含TV、Lite Wearable设备、Phone和平板电脑（Tablet）。 通过HUAWEI DevEco Service调用远程真机对HarmonyOS应用进行测试，HUAWEI DevEco Service根据远程设备信息自动为Hap包签名，开发者无须事先对Hap包进行签名；已经签名的Hap包，HUAWEI DevEco Service也会根据远程设备信息自动为Hap包重新签名。 前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap包，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。选择或者创建一个项目，如果新创建一个项目，注意选择HarmonyOS。 进入项目空间，在左侧导航栏中选择远程实验室 > 远程真机，进入远程真机页面。在远程真机页面的“机型选择”页签中选中要远程连接的设备，点击“开始测试”按钮，在弹出的“申请使用”对话框中选择使用额度，点击“确定”按钮，跳转到“正在使用的机型”页签。 
说明
远程真机测试支持预约远程设备进行测试。如果当前选择的设备机型没有空闲资源时，可在“机型选择”页签中选中要预约的设备，点击“预约测试”按钮，在弹出的“预约测试”对话框中选择“预约使用日期”和“使用时间段”，预约远程真机的使用时间。 预约后，在预约使用时间段，如果HUAWEI DevEco Service服务端为开发者成功锁定设备，将通过华为开发者帐号中预留的联系方式发送设备锁定消息。请注意查收设备锁定消息，及时登录HUAWEI DevEco Service，进入“我的信息”页面，在预约列表中选择预约的设备，点击“申请使用”，连接远程真机设备进行测试。 
 在“正在使用的机型”页签的“应用”子页签中，选择HAP格式的应用或从本地上传HAP格式的文件。从本地上传的HAP格式的文件会自动安装到远程真机上。如果安装失败，可以在HAP包的右上角点击按钮重新安装。 通过“正在使用的机型”页签左侧的远程真机的模拟屏幕对安装的应用进行使用，测试该应用是否正常。 
说明
在测试中，可以在“控制面板”子页签的shell 脚本中输入HDC命令，与远程真机进行交互。或在"HiLog"子页签中获取远程真机的日志。 
   查看测试报告在“测试报告”页签中，可以查看使用远程真机进行测试的情况。点击“查看”按钮查看测试报告详情。     上一篇 UX测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件操作步骤在Router中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在Router（路由器）中安装和运行HarmonyOS应用/服务，可以使用网线连接PC和路由器，或者将PC和路由器连接到同一个WLAN。 前提条件已将Router升级为开发者版本，获取开发者版本参考获取路由器开发版本。已将PC连接到Router。在Router中运行应用/服务，需要根据为应用/服务进行签名章节，提前对应用/服务进行签名。  操作步骤使用网线或WLAN方式，将PC和路由器进行连接。在DevEco Studio的Terminal窗口，执行ipconfig命令，查看路由器IP地址。 在Terminal窗口，使用telnet命令登录到Router串口，示例如下，IP地址请根据上一步查询的结果进行修改。已复制telnet 192.168.3.1 在Terminal窗口，依次执行sh、su和setconsole，打开路由器串口打印功能。 在DevEco Studio菜单栏中，单击Run>Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）运行应用/服务。 界面会弹出设备选择框，选择要推送的Router进行安装运行，单击OK。界面会弹出输入密码的提示框，该密码是Router的Web维护页面登录密码，输入后单击OK，即可把HAP推送到Router安装。DevEco Studio启动HAP的编译构建和安装。安装成功后，会在Terminal中打印日志信息。
说明
具体打印日志信息，由开发者在应用/服务中自行定义。 
    上一篇 在Smart Vision设备中运行应用/服务 下一篇 使用模拟器运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告UX测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 UX测试主要验证HarmonyOS服务卡片和应用的显示相关问题，可检测问题类别包括圆角类、位置类、尺寸类、形状类、字体类、配置类、交互类等。 UX测试支持手机，包格式目前支持Hap、App和Zip格式。关于各测试项的说明如下： UX测试项  说明  支持的设备    深色模式  服务卡片需要适配深色模式，该检测项当前为建议项  手机（phone）   卡片圆角  服务卡片有圆角裁切的情况不符合规范，卡片应为直角矩形，不可自行设计圆角，圆角裁切由桌面统一进行  手机（phone）   内容圆角  服务卡片内容（组件）如用到圆角，则需使用规范定义的通用圆角，内容圆角请在4vp、8vp、12vp参数中选择  手机（phone）   右上角(pin)热区  为保证服务卡片在任何状态下的交互体验，服务卡片控件热区设置不得与卡片右上角30*30vp范围重合  手机（phone）   最小点击热区  为保证服务卡片在任何状态下的交互体验，服务卡片中需要点击操作的元素，最长边不得小于32vp，物理尺寸大于5mm  手机（phone）   四周安全边距  服务卡片内容不得过于接近服务卡片四周。1*2服务卡片的四周安全距离不得小于8vp；2*2、2*4、4*4服务卡片的四周安全距离不得小于12vp  手机（phone）   卡片留白  为保证服务卡片在任何状态下的交互体验，服务卡片中四边留白不得超过60vp范围；建议服务卡片中间留白不超过50vp  手机（phone）   文字可识别度  服务卡片中不应存在文本被截断、卡片窗口截断、内容重叠以及拉伸变形的情况，避免用户在查看信息时出现显示信息不全等情况  手机（phone）   异形卡片  服务卡片内不得使用纯透明/半透明图片，不允许在服务卡片中露出桌面壁纸  手机（phone）   字体范围  为保证服务卡片中文字清晰易读，服务卡片中最小字号不得小于10fp；建议选择使用通用字号，通用字号请在10vp、12vp、14vp、16vp、20vp、30vp、38vp中进行选择  手机（phone）   默认卡片  支持服务卡片的HarmonyOS应用，为保证HarmonyOS应用服务卡片的上滑交互体验，必须设定默认卡片  手机（phone）   交互手势  不能在服务卡片内使用滑动、拖拽和长按等交互手势，导致与系统层级交互产生冲突  手机（phone）   纯图卡片  不能以一张图片作为服务卡片整体，否则缺乏布局自适应能力，且无法支持无障碍能力  手机（phone）     前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。选择或者创建一个项目，如果新创建一个项目，注意选择HarmonyOS。 进入项目空间，在左侧导航栏中选择测试服务>云测试，进入HarmonyOS云测试页面，点击HarmonyOS云测试页面右侧的创建测试按钮，进入创建测试任务页面。 在创建测试任务页面选择UX测试，选择待测试的HarmonyOS应用包，包括HAP、APP和ZIP三1种格式，如果未上传应用，请先从本地上传一个HarmonyOS应用包。点击下一步。
说明
每天只能进行100次UX测试任务，请合理安排测试任务。 
  选择测试设备，UX测试目前可支持手机（Phone），后续会持续更新其他设备类型。 任务创建完成后，请等待测试任务完成，可以在HarmonyOS云测试任务列表中查看任务状态。    查看测试报告测试任务执行完成后，在任务列表中，可以点击查看测试报告按钮，查看测试结果详细信息。  在测试报告的概览页，可以查看测试任务的整体情况，如测试通过率、问题分布、在各个测试终端上的问题分布情况。  点击测试设备后的查看详情按钮，可以查看测试任务详情信息，如测试截屏、异常描述等信息。     上一篇 功耗测试 下一篇 HarmonyOS应用远程真机测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用/服务测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     测试框架  原子化服务体检   上一篇 分析OpenHarmony应用/服务的内存使用 下一篇 测试框架 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告兼容性测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 兼容性测试主要验证HarmonyOS应用在华为真机设备上运行的兼容性问题，包括首次安装、再次安装、启动、卸载、崩溃、黑白屏、闪退、运行错误、无法回退、无响应、设计约束场景。具体兼容性测试项的详细说明请参考兼容性测试标准。 兼容性测试支持TV、智能穿戴 (Wearable)设备和Phone。 前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。选择或者创建一个项目，如果新创建一个项目，注意选择HarmonyOS。 进入项目空间，在左侧导航栏中选择测试服务 > HarmonyOS云测试，进入HarmonyOS云测试页面，点击HarmonyOS云测试页面右侧的创建测试按钮，进入创建测试任务页面。 在创建测试任务页面选择兼容性测试，并选择待测试的HarmonyOS应用包，包括HAP和APP两种格式，点击下一步。如果未上传应用，请先从本地上传一个HarmonyOS应用包。
说明
每天只能创建100次兼容性测试任务，请合理安排测试任务。 
  选择测试设备，兼容性测试支持智慧屏（TV）、手机（Phone）和智能穿戴（Wearable）设备。任务创建完成后，请等待测试任务完成，可以在HarmonyOS云测试任务列表中查看任务状态。   查看测试报告测试任务执行完成后，在任务列表中，可以点击查看测试报告按钮，查看测试结果详细信息。  在测试报告的概览页，可以查看测试任务的整体情况，如测试通过率、问题分布、在各个测试终端上的问题分布情况。  点击测试设备后的查看详情按钮，可以查看测试任务详情信息，如测试截屏、资源轨迹、异常信息和日志信息。   上一篇 HarmonyOS应用云测试 下一篇 稳定性测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。