您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍基本概念接口说明Context 相关接口Model 相关接口Tensor 相关接口开发步骤调测验证使用MindSpore Lite引擎进行模型推理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 场景介绍MindSpore Lite是一款AI引擎，它提供了面向不同硬件设备AI模型推理的功能，目前已经在图像分类、目标识别、人脸识别、文字识别等应用中广泛使用。 本文介绍使用MindSpore Lite推理引擎进行模型推理的通用开发流程。  基本概念在进行开发前，请先了解以下概念。 张量：它与数组和矩阵非常相似，是MindSpore Lite网络运算中的基本数据结构。 Float16推理模式： Float16又称半精度，它使用16比特表示一个数。Float16推理模式表示推理的时候用半精度进行推理。  接口说明这里给出MindSpore Lite推理的通用开发流程中涉及的一些接口，具体请见下列表格。  Context 相关接口 接口名称  描述    OH_AI_ContextHandle OH_AI_ContextCreate()  创建一个上下文的对象。   void OH_AI_ContextSetThreadNum(OH_AI_ContextHandle context, int32_t thread_num)  设置运行时的线程数量。   void OH_AI_ContextSetThreadAffinityMode(OH_AI_ContextHandle context, int mode)  设置运行时线程绑定CPU核心的策略，按照CPU物理核频率分为大、中、小三种类型的核心，并且仅需绑大核或者绑中核，不需要绑小核。   OH_AI_DeviceInfoHandle OH_AI_DeviceInfoCreate(OH_AI_DeviceType device_type)  创建一个运行时设备信息对象。   void OH_AI_ContextDestroy(OH_AI_ContextHandle *context)  释放上下文对象。   void OH_AI_DeviceInfoSetEnableFP16(OH_AI_DeviceInfoHandle device_info, bool is_fp16)  设置是否开启Float16推理模式，仅CPU/GPU设备可用。   void OH_AI_ContextAddDeviceInfo(OH_AI_ContextHandle context, OH_AI_DeviceInfoHandle device_info)  添加运行时设备信息。      Model 相关接口 接口名称  描述    OH_AI_ModelHandle OH_AI_ModelCreate()  创建一个模型对象。   OH_AI_Status OH_AI_ModelBuildFromFile(OH_AI_ModelHandle model, const char *model_path,OH_AI_ModelType odel_type, const OH_AI_ContextHandle model_context)  通过模型文件加载并编译MindSpore模型。   void OH_AI_ModelDestroy(OH_AI_ModelHandle *model)  释放一个模型对象。      Tensor 相关接口 接口名称  描述    OH_AI_TensorHandleArray OH_AI_ModelGetInputs(const OH_AI_ModelHandle model)  获取模型的输入张量数组结构体。   int64_t OH_AI_TensorGetElementNum(const OH_AI_TensorHandle tensor)  获取张量元素数量。   const char *OH_AI_TensorGetName(const OH_AI_TensorHandle tensor)  获取张量的名称。   OH_AI_DataType OH_AI_TensorGetDataType(const OH_AI_TensorHandle tensor)  获取张量数据类型。   void *OH_AI_TensorGetMutableData(const OH_AI_TensorHandle tensor)  获取可变的张量数据指针。      开发步骤使用MindSpore Lite进行模型推理的开发流程如下图所示。图1 使用MindSpore  Lite进行模型推理的开发流程  进入主要流程之前需要先引用相关的头文件，并编写函数生成随机的输入，具体如下： 已复制#include <stdlib.h>#include <stdio.h>#include "mindspore/model.h"
//生成随机的输入int GenerateInputDataWithRandom(OH_AI_TensorHandleArray inputs) {  for (size_t i = 0; i < inputs.handle_num; ++i) {    float *input_data = (float *)OH_AI_TensorGetMutableData(inputs.handle_list[i]);    if (input_data == NULL) {      printf("MSTensorGetMutableData failed.\n");      return OH_AI_STATUS_LITE_ERROR;    }    int64_t num = OH_AI_TensorGetElementNum(inputs.handle_list[i]);    const int divisor = 10;    for (size_t j = 0; j < num; j++) {      input_data[j] = (float)(rand() % divisor) / divisor;  // 0--0.9f    }  }  return OH_AI_STATUS_SUCCESS;} 然后进入主要的开发步骤，具括包括模型的准备、读取、编译、推理和释放，具体开发过程及细节请见下文的开发步骤及示例。 模型准备。 需要的模型可以直接下载，也可以通过模型转换工具获得。 下载模型的格式若为.ms，则可以直接使用。本文以mobilenetv2.ms为例。如果是第三方框架的模型，比如 TensorFlow、TensorFlow Lite、Caffe、ONNX等，可以使用模型转换工具转换为.ms格式的模型文件。 创建上下文，设置线程数、设备类型等参数。 已复制// 创建并配置上下文，设置运行时的线程数量为2，绑核策略为大核优先OH_AI_ContextHandle context = OH_AI_ContextCreate();if (context == NULL) {  printf("OH_AI_ContextCreate failed.\n");  return OH_AI_STATUS_LITE_ERROR;}const int thread_num = 2;OH_AI_ContextSetThreadNum(context, thread_num);OH_AI_ContextSetThreadAffinityMode(context, 1);//设置运行设备为CPU，不使用Float16推理OH_AI_DeviceInfoHandle cpu_device_info = OH_AI_DeviceInfoCreate(OH_AI_DEVICETYPE_CPU);if (cpu_device_info == NULL) {  printf("OH_AI_DeviceInfoCreate failed.\n");  OH_AI_ContextDestroy(&context);  return OH_AI_STATUS_LITE_ERROR;}OH_AI_DeviceInfoSetEnableFP16(cpu_device_info, false);OH_AI_ContextAddDeviceInfo(context, cpu_device_info); 创建、加载与编译模型。 调用OH_AI_ModelBuildFromFile加载并编译模型。 本例中传入OH_AI_ModelBuildFromFile的argv[1]参数是从控制台中输入的模型文件路径。 已复制// 创建模型OH_AI_ModelHandle model = OH_AI_ModelCreate();if (model == NULL) {  printf("OH_AI_ModelCreate failed.\n");  OH_AI_ContextDestroy(&context);  return OH_AI_STATUS_LITE_ERROR;}
// 加载与编译模型，模型的类型为OH_AI_MODELTYPE_MINDIRint ret = OH_AI_ModelBuildFromFile(model, argv[1], OH_AI_MODELTYPE_MINDIR, context);if (ret != OH_AI_STATUS_SUCCESS) {  printf("OH_AI_ModelBuildFromFile failed, ret: %d.\n", ret);  OH_AI_ModelDestroy(&model);  return ret;} 输入数据。 模型执行之前需要向输入的张量中填充数据。本例使用随机的数据对模型进行填充。 已复制// 获得输入张量OH_AI_TensorHandleArray inputs = OH_AI_ModelGetInputs(model);if (inputs.handle_list == NULL) {  printf("OH_AI_ModelGetInputs failed, ret: %d.\n", ret);  OH_AI_ModelDestroy(&model);  return ret;}// 使用随机数据填充张量ret = GenerateInputDataWithRandom(inputs);if (ret != OH_AI_STATUS_SUCCESS) {  printf("GenerateInputDataWithRandom failed, ret: %d.\n", ret);  OH_AI_ModelDestroy(&model);  return ret;} 执行推理。 使用OH_AI_ModelPredict接口进行模型推理。 已复制// 执行模型推理OH_AI_TensorHandleArray outputs;ret = OH_AI_ModelPredict(model, inputs, &outputs, NULL, NULL);if (ret != OH_AI_STATUS_SUCCESS) {  printf("OH_AI_ModelPredict failed, ret: %d.\n", ret);  OH_AI_ModelDestroy(&model);  return ret;} 获取输出。 模型推理结束之后，可以通过输出张量得到推理结果。 已复制// 获取模型的输出张量，并打印for (size_t i = 0; i < outputs.handle_num; ++i) {  OH_AI_TensorHandle tensor = outputs.handle_list[i];  int64_t element_num = OH_AI_TensorGetElementNum(tensor);  printf("Tensor name: %s, tensor size is %zu ,elements num: %lld.\n", OH_AI_TensorGetName(tensor),        OH_AI_TensorGetDataSize(tensor), element_num);  const float *data = (const float *)OH_AI_TensorGetData(tensor);  printf("output data is:\n");  const int max_print_num = 50;  for (int j = 0; j < element_num && j <= max_print_num; ++j) {    printf("%f ", data[j]);  }  printf("\n");} 释放模型。 不再使用MindSpore Lite推理框架时，需要释放已经创建的模型。 已复制// 释放模型OH_AI_ModelDestroy(&model);   调测验证编写CMakeLists.txt。 已复制cmake_minimum_required(VERSION 3.14)project(Demo)
add_executable(demo main.c)
target_link_libraries(        demo        mindspore-lite.huawei        pthread        dl) 使用ohos-sdk交叉编译，需要对CMake设置native工具链路径，即：-DCMAKE_TOOLCHAIN_FILE="/xxx/native/build/cmake/ohos.toolchain.camke"。 工具链默认编译64位的程序，如果要编译32位，需要添加：-DOHOS_ARCH="armeabi-v7a"。  运行。 使用hdc_std连接设备，并将demo和mobilenetv2.ms推送到设备中的相同目录。使用hdc_std shell进入设备，并进入demo所在的目录执行如下命令，即可得到结果。 已复制./demo mobilenetv2.ms 得到如下输出: 已复制# ./QuickStart ./mobilenetv2.ms                                            Tensor name: Softmax-65, tensor size is 4004 ,elements num: 1001.output data is:0.000018 0.000012 0.000026 0.000194 0.000156 0.001501 0.000240 0.000825 0.000016 0.000006 0.000007 0.000004 0.000004 0.000004 0.000015 0.000099 0.000011 0.000013 0.000005 0.000023 0.000004 0.000008 0.000003 0.000003 0.000008 0.000014 0.000012 0.000006 0.000019 0.000006 0.000018 0.000024 0.000010 0.000002 0.000028 0.000372 0.000010 0.000017 0.000008 0.000004 0.000007 0.000010 0.000007 0.000012 0.000005 0.000015 0.000007 0.000040 0.000004 0.000085 0.000023     上一篇 NativeWindow 开发指导 下一篇 Neural Network Runtime对接AI推理框架开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。deviceTypes标签pages标签metadata标签abilities标签skills标签extensionAbilities标签requestPermissions标签shortcuts标签distroFilter标签testRunner标签module.json5配置文件 更新时间: 2024-04-01 19:24 毫无帮助帮助不大一般很好非常好
分享
  先通过一个示例，整体认识一下module.json5配置文件。 已复制{  "module": {    "name": "entry",    "type": "entry",    "description": "$string:module_desc",    "mainElement": "EntryAbility",    "deviceTypes": [      "tv",      "tablet"    ],    "deliveryWithInstall": true,    "installationFree": false,    "pages": "$profile:main_pages",    "virtualMachine": "ark",    "metadata": [      {        "name": "string",        "value": "string",        "resource": "$profile:distributionFilter_config"      }    ],    "abilities": [      {        "name": "EntryAbility",        "srcEntry": "./ets/entryability/EntryAbility.ts",        "description": "$string:EntryAbility_desc",        "icon": "$media:icon",        "label": "$string:EntryAbility_label",        "startWindowIcon": "$media:icon",        "startWindowBackground": "$color:start_window_background",        "exported": true,        "skills": [          {            "entities": [              "entity.system.home"            ],            "actions": [              "ohos.want.action.home"            ]          }        ]      }    ],    "requestPermissions": [      {        "name": "ohos.abilitydemo.permission.PROVIDER",        "reason": "$string:reason",        "usedScene": {          "abilities": [            "FormAbility"          ],          "when": "inuse"        }      }    ]  }} module.json5配置文件包含以下标签。    表1 module.json5配置文件配置标签说明         属性名称 含义 数据类型 是否可缺省    name 标识当前Module的名称，标签值采用字符串表示（最大长度31个字节），该名称在整个应用要唯一，仅支持英文字符。 字符串 该标签不可缺省。   type 标识当前Module的类型。类型有两种，分别： - entry：应用的主模块。 - feature：应用的动态特性模块。 -har：静态共享包模块。 -shared：动态共享包模块。 字符串 该标签不可缺省。   srcEntry 标识当前Module所对应的代码路径，标签值为字符串（最长为127字节）。 字符串 该标签可缺省，缺省值为空。   description 标识当前Module的描述信息，标签值是字符串类型（最长255字节）或对描述内容的字符串资源索引。 字符串 该标签可缺省，缺省值为空。   process 标识当前Module的进程名，标签值为字符串类型（最长为31个字节）。如果在HAP标签下配置了process，该应用的所有UIAbility、DataShareExtensionAbility、ServiceExtensionAbility都运行在该进程中。 说明： - 仅支持系统应用配置，三方应用配置不生效。 字符串 可缺省，缺省为app.json5文件下app标签下的bundleName。   mainElement 标识当前Module的入口UIAbility名称或者ExtensionAbility名称。标签最大字节长度为255。 字符串 该标签可缺省，缺省值为空。   deviceTypes 标识当前Module可以运行在哪类设备上，标签值采用字符串数组的表示。 字符串数组 该标签不可缺省。   deliveryWithInstall 标识当前Module是否在用户主动安装的时候安装，表示该Module对应的HAP是否跟随应用一起安装。 - true：主动安装时安装。 - false：主动安装时不安装。 布尔值 该标签不可缺省。   installationFree 标识当前Module是否支持免安装特性。 - true：表示支持免安装特性，且符合免安装约束。 - false：表示不支持免安装特性。 说明： - 当应用的entry类型Module的该字段配置为true时，该应用的feature类型的该字段也需要配置为true。 - 当应用的entry类型Module的该字段配置为false时，该应用的feature类型的该字段根据业务需求配置true或false。 布尔值 该标签不可缺省。   virtualMachine 标识当前Module运行的目标虚拟机类型，供云端分发使用，如应用市场和分发中心。 该标签值为字符串。如果目标虚拟机类型为ArkTS引擎，则其值为“ark+版本号”。 字符串 该标签由IDE构建HAP的时候自动插入。   pages 标识当前Module的profile资源，用于列举每个页面信息。该标签最大长度为255个字节。 字符串 在有UIAbility的场景下，该标签不可缺省。   metadata 标识当前Module的自定义元信息，标签值为数组类型，只对当前Module、UIAbility、ExtensionAbility生效。 对象数组 该标签可缺省，缺省值为空。   abilities 标识当前Module中UIAbility的配置信息，标签值为数组类型，只对当前UIAbility生效。 对象 该标签可缺省，缺省值为空。   extensionAbilities 标识当前Module中ExtensionAbility的配置信息，标签值为数组类型，只对当前ExtensionAbility生效。 对象 该标签可缺省，缺省值为空。   requestPermissions 标识当前应用运行时需向系统申请的权限集合。 对象 该标签可缺省，缺省值为空。   testRunner 标识当前Module用于支持对测试框架的配置。 对象 该标签可缺省，缺省值为空。     deviceTypes标签    表2 deviceType标签配置说明          设备类型 枚举值 说明    平板 tablet -   智慧屏 tv -   智能手表 wearable 系统能力较丰富的手表，具备电话功能。   车机 car -   手机 phone -    deviceTypes示例： 已复制{  "module": {    "name": "myHapName",    "type": "feature",    "deviceTypes" : [       "tablet"    ]  }}   pages标签 该标签是一个profile文件资源，用于指定描述页面信息的配置文件。 已复制{  "module": {    // ...    "pages": "$profile:main_pages", // 通过profile下的资源文件配置  }} 在开发视图的resources/base/profile下面定义配置文件main_pages.json，其中文件名(main_pages)可自定义，需要和前文中pages标签指定的信息对应，配置文件中列举了当前应用组件中的页面信息。    表3 pages配置文件标签说明          属性名称 含义 数据类型 是否可缺省    src 描述有关JavaScript模块中所有页面的路由信息，包括页面路径和页面名称。该值是一个字符串数组，其中每个元素表示一个页面。 字符串数组 该标签不可缺省。   window 用于定义与显示窗口相关的配置。 对象 该标签可缺省，缺省值为空。       表4 pages配置文件中的window标签说明          属性名称 含义 数据类型 是否可缺省    designWidth 标识页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。 数值 可缺省，缺省值为720px。   autoDesignWidth 标识页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。 布尔值 可缺省，缺省值为false。    已复制{  "src": [    "pages/index/mainPage",    "pages/second/payment",    "pages/third/shopping_cart",    "pages/four/owner"  ]}   metadata标签 该标签标识HAP的自定义元信息，标签值为数组类型，包含name，value，resource三个子标签。    表5 metadata标签说明          属性名称 含义 数据类型 是否可缺省    name 该标签标识数据项的键名称，字符串类型（最大长度255字节）。 字符串 该标签可缺省，缺省值为空。   value 该标签标识数据项的值，标签值为字符串（最大长度255字节）。 字符串 该标签可缺省，缺省值为空。   resource 该标签标识定义用户自定义数据格式，标签值为标识该数据的资源的索引值。该标签最大字节长度为255字节。 字符串 该标签可缺省，缺省值为空。    已复制{  "module": {    "metadata": [{      "name": "module_metadata",      "value": "a test demo for module metadata",      "resource": "$profile:shortcuts_config",    }],
    "abilities": [{      "metadata": [{        "name": "ability_metadata",        "value": "a test demo for ability",        "resource": "$profile:config_file"      },      {        "name": "ability_metadata_2",        "value": "a string test",        "resource": "$profile:config_file"      }],    }],
    "extensionAbilities": [{      "metadata": [{        "name": "extensionAbility_metadata",        "value": "a test for extensionAbility",        "resource": "$profile:config_file"      },      {        "name": "extensionAbility_metadata_2",        "value": "a string test",        "resource": "$profile:config_file"      }],    }]  }}   abilities标签 abilities标签描述UIAbility组件的配置信息，标签值为数组类型，该标签下的配置只对当前UIAbility生效。    表6 abilities标签说明          属性名称 含义 数据类型 是否可缺省    name 标识当前UIAbility组件的名称，该名称在整个应用要唯一，标签值采用字符串表示（最大长度127个字节），仅支持英文字符。 字符串 该标签不可缺省。   srcEntry 该标签标识入口UIAbility的代码路径，标签值为字符串（最长为127字节）。 字符串 该标签不可缺省。   launchType 标识当前UIAbility组件的启动模式，可选标签值： - multiton：多实例模式，每次启动创建一个新的实例。 - singleton：单实例模式，仅第一次启动创建新实例。 - specified：指定实例模式，运行时由开发者决定是否创建新实例。 字符串 可缺省，该标签缺省为“singleton”。   description 标识当前UIAbility组件的描述信息，标签值是字符串类型（最长255字节）或对描述内容的资源索引，要求采用资源索引方式，以支持多语言。 字符串 该标签可缺省，缺省值为空。   icon 标识当前UIAbility组件的图标，标签值为图标资源文件的索引。 字符串 该标签可缺省，缺省值为空。 如果UIAbility被配置为MainElement，该标签必须配置。   label 标识当前UIAbility组件对用户显示的名称，标签值配置为该名称的资源索引以支持多语言。 如果UIAbility被配置当前Module的mainElement时，该标签必须配置，且应用内唯一。 字符串 该标签不可缺省。   permissions 标识当前UIAbility组件自定义的权限信息。当其他应用访问该UIAbility时，需要申请相应的权限信息。 一个数组元素为一个权限名称。通常采用反向域名格式（最大255字节），取值为系统预定义的权限。 字符串数组 该标签可缺省，缺省值为空。   metadata 标识当前UIAbility组件的元信息。 对象数组 该标签可缺省，缺省值为空。   exported 标识当前UIAbility组件是否可以被其他应用调用。 - true：表示可以被其他应用调用。 - false：表示不可以被其他应用调用。 布尔值 该标签可缺省，缺省值为false。   continuable 标识当前UIAbility组件是否可以迁移。 - true：表示可以被迁移。 - false：表示不可以被迁移。 
说明
 当前版本暂不支持跨设备能力。 
 布尔值 该标签可缺省，缺省值为false。   skills 标识当前UIAbility组件或ExtensionAbility组件能够接收的Want的特征集，为数组格式。 配置规则： - 对于Entry类型的HAP，应用可以配置多个具有入口能力的skills标签（即配置了ohos.want.action.home和entity.system.home）。 - 对于Feature类型的HAP，只有应用可以配置具有入口能力的skills标签，服务不允许配置。 对象数组 该标签可缺省，缺省值为空。   backgroundModes 标识当前UIAbility组件的长时任务集合。指定用于满足特定类型的长时任务。 长时任务类型有如下： - dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等业务。 - audioPlayback：音频输出业务。 - audioRecording：音频输入业务。 - location：定位、导航业务。 - bluetoothInteraction：蓝牙扫描、连接、传输业务（穿戴）。 - multiDeviceConnection：多设备互联业务。 - wifiInteraction：Wi-Fi扫描、连接、传输业务（克隆多屏）。 - voip：音视频电话，VoIP业务。 - taskKeeping：计算业务。 字符串数组 该标签可缺省，缺省值为空。   startWindowIcon 标识当前UIAbility组件启动页面图标资源文件的索引。取值示例：$media:icon。 该标签最大字节长度为255。 字符串 不可缺省。   startWindowBackground 标识当前UIAbility组件启动页面背景颜色资源文件的索引。取值示例：$color:red。 该标签最大字节长度为255。 字符串 不可缺省。   removeMissionAfterTerminate 标识当前UIAbility组件销毁后是否从任务列表中移除任务，为布尔类型： - true表示销毁后移除任务。 - false表示销毁后不移除任务。 布尔值 该标签可缺省，缺省值为false。   orientation 标识当前UIAbility组件启动时的方向。该方向的取值范围包括： - unspecified：未指定方向，由系统自动判断显示方向。 - landscape：横屏。 - portrait：竖屏。 - landscape_inverted：反向横屏。 - portrait_inverted：反向竖屏。 - auto_rotation：随传感器旋转。 - auto_rotation_landscape：传感器横屏旋转，包括了横屏和反向横屏。 - auto_rotation_portrait：传感器竖屏旋转，包括了竖屏和反向竖屏。 - auto_rotation_restricted：传感器开关打开，方向可随传感器旋转。 - auto_rotation_landscape_restricted：传感器开关打开，方向可随传感器旋转为横屏， 包括了横屏和反向横屏。 - auto_rotation_portrait_restricted：传感器开关打开，方向随可传感器旋转为竖屏， 包括了竖屏和反向竖屏。 - locked：传感器开关关闭，方向锁定。 字符串 该标签可缺省，缺省值为unspecified。   supportWindowMode 标识当前UIAbility组件所支持的窗口模式，包含： - fullscreen：全屏模式。 - split：分屏模式。 - floating：悬浮窗模式。 字符串数组 该标签可缺省，缺省值为 ["fullscreen", "split", "floating"]。   priority 标识当前UIAbility组件的优先级，仅支持系统应用配置，三方应用配置不生效。隐式查询时，优先级越高，UIAbility在返回列表越靠前。该标签取值为integer类型，取值范围0-10。数值越大，优先级越高。 数值 该标签可缺省，缺省值为0。   maxWindowRatio 标识当前UIAbility组件支持的最大的宽高比。该标签最小取值为0。 数值 该标签可缺省，缺省值为平台支持的最大的宽高比。   minWindowRatio 标识当前UIAbility组件支持的最小的宽高比。该标签最小取值为0。 数值 该标签可缺省，缺省值为平台支持的最小的宽高比。   maxWindowWidth 标识当前UIAbility组件支持的最大的窗口宽度，宽度单位为vp。该标签最小取值为0。 数值 该标签可缺省，缺省值为平台支持的最大的窗口宽度。   minWindowWidth 标识当前UIAbility组件支持的最小的窗口宽度, 宽度单位为vp。该标签最小取值为0。 数值 该标签可缺省，缺省值为平台支持的最小的窗口宽度。   maxWindowHeight 标识当前UIAbility组件支持的最大的窗口高度, 高度单位为vp。该标签最小取值为0。 数值 该标签可缺省，缺省值为平台支持的最大的窗口高度。   minWindowHeight 标识当前UIAbility组件支持的最小的窗口高度, 高度单位为vp。该标签最小取值为0。 数值 该标签可缺省，缺省值为平台支持的最小的窗口高度。   excludeFromMissions 标识当前UIAbility组件是否在最近任务列表中显示。 - true：表示不在任务列表中显示。 - false：表示在任务列表中显示。 说明： - 仅支持系统应用配置，三方应用配置不生效。 布尔值 该标签可缺省，缺省值为false。    abilities示例： 已复制{  "abilities": [{    "name": "EntryAbility",    "srcEntry": "./ets/entryability/EntryAbility.ts",    "launchType":"singleton",    "description": "$string:description_main_ability",    "icon": "$media:icon",    "label": "Login",    "permissions": [],    "metadata": [],    "exported": true,    "continuable": true,    "skills": [{      "actions": ["ohos.want.action.home"],      "entities": ["entity.system.home"],      "uris": []    }],    "backgroundModes": [      "dataTransfer",      "audioPlayback",      "audioRecording",      "location",      "bluetoothInteraction",      "multiDeviceConnection",      "wifiInteraction",      "voip",      "taskKeeping"    ],    "startWindowIcon": "$media:icon",    "startWindowBackground": "$color:red",    "removeMissionAfterTerminate": true,    "orientation": " ",    "supportWindowMode": ["fullscreen", "split", "floating"],    "maxWindowRatio": 3.5,    "minWindowRatio": 0.5,    "maxWindowWidth": 2560,    "minWindowWidth": 1400,    "maxWindowHeight": 300,    "minWindowHeight": 200,    "excludeFromMissions": false  }]}   skills标签 该标签标识UIAbility组件或者ExtensionAbility组件能够接收的Want的特征。    表7 skills标签说明          属性名称 含义 数据类型 是否可缺省    actions 标识能够接收的Want的Action值的集合，取值通常为系统预定义的action值，也允许自定义。 字符串数组 可缺省，缺省值为空。   entities 标识能够接收Want的Entity值的集合。 字符串数组 可缺省，缺省值为空。   uris 标识与Want中URI（Uniform Resource Identifier）相匹配的集合。 对象数组 可缺省，缺省值为空。       表8 uris对象内部结构说明          属性名称 含义 数据类型 是否可缺省    scheme 标识URI的协议名部分，常见的有http、https、file、ftp等。 字符串 uris中仅配置type时可以缺省，缺省值为空，否则不可缺省。   host 标识URI的主机地址部分，该字段要在scheme存在时才有意义。常见的方式： - 域名方式，如example.com。 - IP地址方式，如10.10.10.1。 字符串 可缺省，缺省值为空。   port 标识URI的端口部分。如http默认端口为80，https默认端口是443，ftp默认端口是21。该字段要在scheme和host都存在时才有意义。 字符串 可缺省，缺省值为空。   path | pathStartWith | pathRegex 标识URI的路径部分，path、pathStartWith和pathRegex配置时三选一。path标识URI与want中的路径部分全匹配，pathStartWith标识URI与want中的路径部分允许前缀匹配，pathRegex标识URI与want中的路径部分允许正则匹配。该字段要在scheme和host都存在时才有意义。 字符串 可缺省，缺省值为空。   type 标识与Want相匹配的数据类型，使用MIME（Multipurpose Internet Mail Extensions）类型规范。可与scheme同时配置，也可以单独配置。 字符串 可缺省，缺省值为空。    skills示例： 已复制{  "abilities": [    {      "skills": [        {          "actions": [            "ohos.want.action.home"          ],          "entities": [            "entity.system.home"          ],          "uris": [            {              "scheme":"http",              "host":"example.com",              "port":"80",              "path":"path",              "type": "text/*"            }          ]        }      ]    }  ]}   extensionAbilities标签 描述extensionAbilities的配置信息，标签值为数组类型，该标签下的配置只对当前extensionAbilities生效。    表9 extensionAbilities标签说明          属性名称 含义 数据类型 是否可缺省    name 标识当前ExtensionAbility组件的名称，标签值最大长度为127个字节，该名称在整个应用要唯一。 字符串 该标签不可缺省。   srcEntry 标识当前ExtensionAbility组件所对应的代码路径，标签值最大长度为127字节。 字符串 该标签不可缺省。   description 标识当前ExtensionAbility组件的描述，标签值最大长度为255字节，标签也可以是描述内容的资源索引，用于支持多语言。 字符串 该标签可缺省，缺省值为空。   icon 标识当前ExtensionAbility组件的图标，标签值为资源文件的索引。如果ExtensionAbility组件被配置为MainElement，该标签必须配置。 字符串 该标签可缺省，缺省值为空。   label 标识当前ExtensionAbility组件对用户显示的名称，标签值配置为该名称的资源索引以支持多语言。 说明： - 如果ExtensionAbility被配置当前Module的mainElement时，该标签必须配置，且应用内唯一。 字符串 该标签不可缺省。   type 标识当前ExtensionAbility组件的类型，取值为： - form：卡片的ExtensionAbility。 - workScheduler：延时任务的ExtensionAbility。 - inputMethod：输入法的ExtensionAbility。 - service：后台运行的service组件。 - accessibility：辅助能力的ExtensionAbility。 - dataShare：数据共享的ExtensionAbility。 - fileShare：文件共享的ExtensionAbility。 - staticSubscriber：静态广播的ExtensionAbility。 - wallpaper：壁纸的ExtensionAbility。 - backup：数据备份的ExtensionAbility。 - window：该ExtensionAbility会在启动过程中创建一个window，为开发者提供界面开发。开发者开发出来的界面将通过abilityComponent控件组合到其他应用的窗口中。 - thumbnail：获取文件缩略图的ExtensionAbility，开发者可以对自定义文件类型的文件提供缩略。 - preview：该ExtensionAbility会将文件解析后在一个窗口中显示，开发者可以通过将此窗口组合到其他应用窗口中。 说明： - 其中service和dataShare类型，仅支持系统应用配置，三方应用配置不生效。 字符串 该标签不可缺省。   permissions 标识当前ExtensionAbility组件自定义的权限信息。当其他应用访问该ExtensionAbility时，需要申请相应的权限信息。 一个数组元素为一个权限名称。通常采用反向域名格式（最大255字节），可以是系统预定义的权限，也可以是该应用自定义的权限。如果是后者，需与defPermissions标签中定义的某个权限的name标签值一致。 字符串数组 该标签可缺省，缺省值为空。   uri 标识当前ExtensionAbility组件提供的数据URI，为字符数组类型（最大长度255），用反向域名的格式表示。 说明： - 该标签在type为dataShare类型的ExtensionAbility时，不可缺省。 字符串 该标签可缺省，缺省值为空。   skills 标识当前ExtensionAbility组件能够接收的Want的特征集，为数组格式。 配置规则：entry包可以配置多个具有入口能力的skills标签（配置了ohos.want.action.home和entity.system.home）的ExtensionAbility，其中第一个配置了skills标签的ExtensionAbility中的label和icon作为应用或服务的label和icon。 说明： - 应用的Feature包可以配置具有入口能力的skills标签。 - 服务的Feature包不能配置具有入口能力的skills标签。 数组 该标签可缺省，缺省值为空。   metadata 标识当前ExtensionAbility组件的元信息。 对象 该标签可缺省，缺省值为空。   exported 标识当前ExtensionAbility组件是否可以被其他应用调用，为布尔类型。 - true：表示可以被其他应用调用。 - false：表示不可以被其他应用调用。 布尔值 该标签可缺省，缺省值为false。    extensionAbilities示例： 已复制{  "extensionAbilities": [    {      "name": "FormName",      "srcEntry": "./form/MyForm.ts",      "icon": "$media:icon",      "label" : "$string:extension_name",      "description": "$string:form_description",      "type": "form",       "permissions": ["ohos.abilitydemo.permission.PROVIDER"],      "readPermission": "",      "writePermission": "",      "exported": true,      "uri":"scheme://authority/path/query",      "skills": [{        "actions": [],        "entities": [],        "uris": []      }],      "metadata": [        {          "name": "ohos.extension.form",          "resource": "$profile:form_config",         }      ]    }  ]}   requestPermissions标签 该标签标识应用运行时需向系统申请的权限集合。 
说明
  在requestPermissions标签中配置的权限项将在应用级别生效，即该权限适用于整个应用程序。 如果应用需要订阅自己发布的事件，而且应用在extensionAbilities标签中的permissions字段中设置了访问该应用所需要的权限，那么应用也需要在requestPermissions标签中注册相关权限才能收到该事件。  
    表10 requestPermissions标签说明          属性 含义 类型 取值范围 默认值    name 必须，填写需要使用的权限名称。 字符串 自定义。 无。   reason 可选，当申请的权限为user_grant权限时此字段必填，用于描述申请权限的原因。 说明： - 当申请的权限为user_grant权限时，如果未填写该字段则不允许在应用市场上架，并且需要进行多语种适配。 字符串 使用string类资源引用。格式为$string: ***。 空。   usedScene 可选，当申请的权限为user_grant权限时此字段必填。描述权限使用的场景由abilities和when组成。其中abilities可以配置为多个UIAbility组件，when表示调用时机。 说明： - 默认为可选，当申请的权限为user_grant权限时，abilities标签必填，when标签可选。 abilities：UIAbility或者ExtensionAbility名称的字符串数组 when：字符串 abilities：UIAbility或者ExtensionAbility组件的名称。 when：inuse（使用时）、always（始终）。 abilities：空。 when：空。    requestPermissions示例： 已复制{  "module" : {    "requestPermissions": [      {        "name": "ohos.abilitydemo.permission.PROVIDER",        "reason": "$string:reason",        "usedScene": {          "abilities": [            "EntryFormAbility"          ],          "when": "inuse"        }      }    ]  }}   shortcuts标签 shortcuts标识应用的快捷方式信息。标签值为数组，最多可以配置四个快捷方式。其包含四个子标签shortcutId、label、icon、wants。 metadata中指定shortcut信息，其中：  name：指定shortcuts的名称。使用ohos.ability.shortcuts作为shortcuts信息的标识。 resource：指定shortcuts信息的资源位置。     表11 shortcuts标签说明          属性 含义 类型 默认值    shortcutId 标识快捷方式的ID。字符串的最大长度为63字节。 字符串 该标签不可缺省。   label 标识快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值可以是描述性内容，也可以是标识label的资源索引。字符串最大长度为255字节。 字符串 该标签可缺省，缺省值为空。   icon 标识快捷方式的图标，标签值为资源文件的索引。 字符串 该标签可缺省，缺省值为空。   wants 标识快捷方式内定义的目标wants信息集合，每个wants可配置bundleName和abilityName两个子标签。 bundleName：表示快捷方式的目标Bundle名称，字符串类型。 abilityName：表示快捷方式的目标组件名，字符串类型。 对象 该标签可缺省，缺省为空。     在/resource/base/profile/目录下配置shortcuts_config.json配置文件。 已复制{  "shortcuts": [    {      "shortcutId": "id_test1",      "label": "$string:shortcut",      "icon": "$media:aa_icon",      "wants": [        {          "bundleName": "com.ohos.hello",          "abilityName": "EntryAbility"        }      ]    }  ]} 在module.json5配置文件的abilities标签中，针对需要添加快捷方式的UIAbility进行配置metadata标签，使shortcut配置文件对该UIAbility生效。 已复制{  "module": {    // ...    "abilities": [      {        "name": "EntryAbility",        "srcEntry": "./ets/entryability/EntryAbility.ts",        // ...        "skills": [          {            "entities": [              "entity.system.home"            ],            "actions": [              "ohos.want.action.home"            ]          }        ],        "metadata": [          {            "name": "ohos.ability.shortcuts",            "resource": "$profile:shortcuts_config"          }        ]      }    ]  }}    distroFilter标签 该标签下的子标签均为可选字段，在应用市场云端分发时使用，distroFilter标签用于定义HAP对应的细分设备规格的分发策略，以便在应用市场进行云端分发应用包时做精准匹配。该标签可配置的分发策略维度包括API Version、屏幕形状、屏幕尺寸、屏幕分辨率，设备的国家与地区码。在进行分发时，通过deviceType与这五个属性的匹配关系，唯一确定一个用于分发到设备的HAP。 该标签需要配置在/resource/profile资源目录下，并在模块的metadata的resource字段中引用。    表12 distroFilter标签说明          属性名称 含义 数据类型 是否可缺省    apiVersion 标识支持的apiVersion范围。 对象数组 该标签可缺省，缺省值为空。   screenShape 标识屏幕形状的支持策略。 对象数组 该标签可缺省，缺省值为空。   screenWindow 标识应用运行时窗口的分辨率支持策略。该字段仅支持对轻量级智能穿戴设备进行配置。 对象数组 该标签可缺省，缺省值为空。   screenDensity 标识屏幕的像素密度（dpi：Dot Per Inch）。 对象数组 该标签可缺省，缺省值为空。   countryCode 表示应用需要分发的国家地区码，具体值以ISO-3166-1标准为准。支持多个国家和地区枚举定义。 对象数组 该标签可缺省，缺省值为空。       表13 screenShape对象的内部结构          属性名称 含义 数据类型 是否可缺省    policy 标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 字符串 该标签不可缺省。   value 支持的取值为circle（圆形）、rect（矩形）。场景示例：针对智能穿戴设备，可为圆形表盘和矩形表盘分别提供不同的HAP。 字符串数组 该标签不可缺省。       表14 screenWindow对象的内部结构说明          属性名称 含义 数据类型 是否可缺省    policy 标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示该字段取值不包含value枚举值匹配规则的匹配该属性。 - include：表示该字段取值满足value枚举值匹配规则的匹配该属性。 字符串 该标签不可缺省。   value 单个字符串的取值格式为“宽 * 高”，取值为整数像素值，例如“454 * 454”。 字符串数组 该标签不可缺省。       表15 screenDensity对象的内部结构说明          属性名称 含义 数据类型 是否可缺省    policy 标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 字符串 该标签不可缺省。   value 该标签标识屏幕的像素密度（dpi :Dot Per Inch）。 该标签为字符串数组，字符串范围如下。 - sdpi：表示小规模的屏幕密度（Small-scale Dots per Inch），适用于dpi取值为(0,120]的设备。 - mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120,160]的设备。 - ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160,240]的设备。 - xldpi：表示大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240,320]的设备。 - xxldpi：表示大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320，480]的设备。 - xxxldpi：表示大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。 字符串数组 该标签不可缺省。       表16 countryCode对象的内部结构说明          属性名称 含义 数据类型 是否可缺省    policy 标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。 字符串 该标签不可缺省。   value 标识应用需要分发的国家地区码。 字符串数组 该标签不可缺省。    在开发视图的resources/base/profile下面定义配置文件distro_filter_config.json，文件名可以自定义。 已复制{  "distroFilter": {    "screenShape": {      "policy": "include",      "value": [        "circle",        "rect"      ]    },    "screenWindow": {      "policy": "include",      "value": [        "454*454",        "466*466"      ]    },    "screenDensity": {      "policy": "exclude",      "value": [        "ldpi",        "xldpi"      ]    },    "countryCode": { // 支持中国和香港地区分发      "policy": "include",      "value": [        "CN",        "HK"      ]    }  }} 在module.json5配置文件的module标签中定义metadata信息。 已复制{  "module": {    // ...    "metadata": [      {        "name": "ohos.module.distro",        "resource": "$profile:distro_filter_config",      }    ]  }}   testRunner标签 此标签用于支持对测试框架的配置。    表17 testRunner标签说明          属性名称 含义 数据类型 是否可缺省    name 标识测试框架对象名称。该标签最大字节长度为255个字节。 字符串 不可缺省。   srcPath 标识测试框架代码路径。该标签最大字节长度为255个字节。 字符串 不可缺省。    testRunner标签示例： 已复制{  "module": {    // ...    "testRunner": {      "name": "myTestRunnerName",      "srcPath": "etc/test/TestRunner.ts"    }  }}   上一篇 app.json5配置文件 下一篇 应用配置文件（FA模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。distro对象内部结构metadata对象内部结构parameters对象内部结构results对象内部结构customizeData对象的内部结构deviceType标签abilities对象的内部结构uriPermission对象的内部结构skills对象的内部结构uris对象的内部结构reqPermissions权限申请usedScene对象内部结构js对象的内部结构window对象的内部结构mode对象的内部结构shortcuts对象的内部结构intents对象的内部结构forms对象的内部结构customizeData对象内部结构distroFilter对象的内部结构apiVersion对象的内部结构screenShape对象的内部结构screenWindow对象的内部结构screenDensity对象的内部结构countryCode对象的内部结构commonEvents对象的内部结构testRunner对象的内部结构definePermissions对象内部结构module对象内部结构 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 module对象包含HAP的配置信息。 表1 module对象内部结构说明 属性名称  含义  数据类型  是否可缺省    mainAbility  服务中心图标露出的Ability，常驻进程拉起时会启动mainAbility。  字符串  可缺省，缺省值为空。   package  标识HAP的包结构名称，在应用内保证唯一性。采用反向域名格式（建议与HAP的工程目录保持一致）。字符串长度为1-127个字节。  字符串  不可缺省。   name  标识HAP的类名。采用反向域名方式标识，前缀要与同级的package标签指定的包名一致，也可采用"."开头的命名方式。字符串长度不超过255字节。  字符串  可缺省，缺省值为空。   description  标识HAP的描述信息。字符串长度不超过255字节。如果字符串超出长度或者需要支持多语言，可以采用资源索引的方式添加描述内容。  字符串  可缺省，缺省值为空。   supportedModes  标识应用支持的运行模式，当前只定义了驾驶模式（drive）。该标签只适用于车机。  字符串数组  可缺省，缺省值为空。   deviceType  标识允许Ability运行的设备类型。系统预定义的设备类型包括：phone（手机）、tablet(平板)、tv（智慧屏）、car(车机)、wearable(智能穿戴)等。  字符串数组  不可缺省。   distro  标识HAP发布的具体描述。  对象  不可缺省。   metaData  标识HAP的元信息。  对象  可缺省，缺省值为空。   abilities  标识当前模块内的所有Ability。采用对象数据格式。  对象数组  可缺省，缺省值为空。   js  标识基于ArkUI框架开发的JS模块集合，其中的每个元素代表一个JS模块的信息。  对象数组  可缺省，缺省值为空。   shortcuts  标识应用的快捷方式信息。采用对象数组格式，其中的每个元素表示一个快捷方式对象。  对象数组  可缺省，缺省值为空。   reqPermissions  标识应用运行时向系统申请的权限。  对象数组  可缺省，缺省值为空。   colorMode  标识应用自身的颜色模式，目前支持如下三种模式： - dark：表示按照深色模式选取资源。 - light：表示按照浅色模式选取资源。 - auto：表示跟随系统的颜色模式值选取资源。  字符串  可缺省，缺省值为"auto"。   distroFilter  标识应用的分发规则。该标签用于定义HAP对应的细分设备规格的分发策略，以便在应用市场进行云端分发应用包时做精准匹配。该标签可配置的分发策略维度包括API Version、屏幕形状、屏幕分辨率。在进行分发时，通过deviceType与这三个属性的匹配关系，唯一确定一个用于分发到设备的HAP。  对象  可缺省，缺省值为空。但当应用中包含多个entry模块时，必须配置该标签。   commonEvents  定义了公共事件静态订阅者的信息，该字段中需要声明静态订阅者的名称、权限要求及订阅事件列表信息，当订阅的公共事件发送时，该公共事件静态订阅者将被拉起。这里的静态订阅者区分于常用的动态订阅者，前者无需在业务代码中主动调用订阅事件的接口，在公共事件发布时可能未被拉起，而动态订阅者则在业务代码中主动调用公共事件订阅的相关API，因此需要应用处于活动状态。  对象数组  可缺省，缺省为空。   entryTheme  此标签标识HarmonyOS内部主题的关键字。将标记值设置为名称的资源索引。  字符串  可缺省，缺省值为空。   testRunner  此标签用于支持对测试框架的配置。  对象  可缺省，缺省值为空。     module示例： 已复制{  "module": {    "mainAbility": ".EntryAbility",    "deviceType": [      "tv",      "tablet"    ],    "abilities": [      {        "skills": [          {            "entities": [              "entity.system.home"            ],            "actions": [              "action.system.home"            ]          }        ],        "orientation": "unspecified",        "visible": true,        "srcPath": "EntryAbility",        "name": ".EntryAbility",        "srcLanguage": "ets",        "icon": "$media:icon",        "description": "$string:MainAbility_desc",        "formsEnabled": false,        "label": "$string:MainAbility_label",        "type": "page",        "launchType": "multiton"      }    ],    "distro": {      "moduleType": "entry",      "installationFree": false,      "deliveryWithInstall": true,      "moduleName": "entry"    },    "package": "com.example.entry",    "srcPath": "",    "name": ".entry",    "js": [      {        "mode": {          "syntax": "ets",          "type": "pageAbility"        },        "pages": [          "pages/Index"        ],        "name": ".EntryAbility",        "window": {          "designWidth": 720,          "autoDesignWidth": false        }      }    ]  }} distro对象内部结构表2 distro对象内部结构说明 属性名称  含义  数据类型  是否可缺省    moduleName  标识当前HAP的名称，最大长度为31个字节。  字符串  不可缺省。   moduleType  标识当前HAP的类型，包括三种类型：entry、feature和har。  字符串  不可缺省。   installationFree  标识当前HAP是否支持免安装特性。true：表示支持免安装特性，且符合免安装约束。false：表示不支持免安装特性。另外还需注意：当entry.hap该字段配置为true时，与该entry.hap相关的所有feature.hap该字段也需要配置为true。当entry.hap该字段配置为false时，与该entry.hap相关的各feature.hap该字段可按业务需求配置true或false。  布尔值  不可缺省。   deliveryWithInstall  标识当前HAP是否在用户主动安装HAP所在应用的时候一起安装。true： 安装应用时当前HAP随应用一起下载安装。false：安装应用时当前HAP并不下载安装，后续使用是按需下载。  布尔值  不可缺省。     distro示例： 已复制"distro": {  "moduleName": "ohos_entry",  "moduleType": "entry",  "installationFree": true,  "deliveryWithInstall": true}  metadata对象内部结构表3 metadata对象内部结构说明 属性名称  含义  数据类型  是否可缺省    parameters  标识调用Ability时所有调用参数的元信息。每个调用参数的元信息由以下三个标签组成：description、name、type。  对象数组  可缺省，缺省值为空   results  标识Ability返回值的元信息。每个返回值的元信息由以下三个标签组成：description、name、type。  对象数组  可缺省，缺省值为空。   customizeData  该标签标识父级组件的自定义元信息，Parameters和results在application不可配。  对象数组  可缺省，缺省值为空。      parameters对象内部结构表4 parameters对象内部结构说明 属性名称  含义  数据类型  是否可缺省    description  标识对调用参数的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。该标签最大长度为255个字节。  字符串  可缺省，缺省值为空。   name  标识调用参数的名称。该标签最大长度为255个字节。  字符串  不可缺省。   type  标识调用参数的类型，如Integer。  字符串  不可缺省。      results对象内部结构表5 results对象内部结构说明 属性名称  含义  数据类型  是否可缺省    description  标识对返回值的描述，可以是表示描述内容的字符串，也可以是对描述内容的资源索引以支持多语言。该标签最大长度为255个字节。  字符串  可缺省，缺省值为空。   name  标识返回值的名字。该标签最大长度为255个字节。  字符串  可缺省，缺省值为空。   type  标识返回值的类型，如Integer。  字符串  不可缺省      customizeData对象的内部结构表6 customizeData对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识数据项的键名称，字符串类型（最大长度255字节）。  字符串  可缺省，缺省值为空。   value  标识数据项的值名称，字符串类型（最大长度255字节）。  字符串  可缺省，缺省值为空。   extra  标识用户自定义数据格式，标签值为标识该数据的资源的索引值。  字符串  可缺省，缺省值为空。     metadata对象示例： 已复制"metaData": {  "parameters" : [{    "name" : "a test for metadata parameter",    "type" : "Float",    // "$string:parameters_description"为文件资源索引值    "description" : "$string:parameters_description"  }],  "results" : [{    "name" : "a test for metadata result",    "type" : "Float",    "description" : "$string:results_description"  }],  "customizeData" : [{    "name" : "a customizeData",    "value" : "string",    "extra" : "$string:customizeData_description"  }]}  deviceType标签表7 deviceType标签配置说明 设备类型  枚举值  说明    平板  tablet  -   智慧屏  tv  -   智能手表  wearable  系统能力较丰富的手表，具备电话功能。   车机  car  -   手机  phone  -      abilities对象的内部结构表8 abilities对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    process  运行应用程序或Ability的进程名称。如果在deviceConfig标记中配置了进程，则应用程序的所有能力都在此进程中运行。您还可以为特定能力设置流程属性，以便该能力可以在此流程中运行。如果此属性设置为与其他应用程序相同的进程名称，则所有这些应用程序可以在同一进程中运行，前提是他们具有相同的联合用户ID和相同的签名。该标签最大字节数为31个字节。  字符串  可缺省，缺省值为空。   name  标识Ability名称。取值可采用反向域名方式表示，由包名和类名组成，如"com.example.myapplication.EntryAbility"；也可采用"."开头的类名方式表示，如".EntryAbility"。 Ability的名称，需在一个应用的范围内保证唯一。说明：在使用DevEco Studio新建项目时，默认生成首个Ability的配置，即"config.json"中"EntryAbility"的配置。如使用其他IDE工具，可自定义名称。该标签最大长度为127个字节。  字符串  不可缺省   description  标识对Ability的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。该标签最大长度为255个字节。  字符串  可缺省，缺省值为空。   icon  标识Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。 说明：应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。  字符串  可缺省，缺省值为空。   label  标识Ability对用户显示的名称。取值可以是Ability名称，也可以是对该名称的资源索引，以支持多语言。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。 说明： 应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。该标签为资源文件中定义的字符串的引用，或以"{}"包括的字符串。该标签最大长度为255个字节。  字符串  可缺省，缺省值为空。   uri  标识Ability的统一资源标识符。该标签最大长度为255个字节。  字符串  可缺省，对于data类型的Ability不可缺省。   launchType  标识Ability的启动模式，支持"multiton"和"singleton"两种模式： multiton：表示该Ability可以有多实例。该模式适用于大多数应用场景。 singleton：表示该Ability在所有任务栈中仅可以有一个实例。例如，具有全局唯一性的呼叫来电界面即采用"singleton"模式。该标签仅适用于默认设备、平板、智慧屏、车机、智能穿戴。  字符串  可缺省，缺省值为"singleton"。   visible  标识Ability是否可以被其他应用调用。 true：可以被其他应用调用。 false：不能被其他应用调用。  布尔类型  可缺省，缺省值为"false"。   permissions  标识其他应用的Ability调用此Ability时需要申请的权限集合，一个数组元素为一个权限名称。通常采用反向域名格式（最大255字节），取值为系统预定义的权限。  字符串数组  可缺省，缺省值为空。   skills  标识Ability能够接收的want的特征。  对象数组  可缺省，缺省值为空。   deviceCapability  标识Ability运行时要求设备具有的能力，采用字符串数组的格式表示。该标签为数组，支持最多配置512个元素，单个元素最大字节长度为64。  字符串数组  可缺省，缺省值为空。   metaData  元数据。  对象  可缺省，缺省值为空。   type  标识Ability的类型。取值范围如下： page：表示基于Page模板开发的FA，用于提供与用户交互的能力。 service：表示基于Service模板开发的PA，用于提供后台运行任务的能力。 data：表示基于Data模板开发的PA，用于对外部提供统一的数据访问对象。 CA：表示支持其他应用以窗口方式调起该Ability。  字符串  不可缺省。   orientation  标识该Ability的显示模式。该标签仅适用于page类型的Ability。取值范围如下： unspecified：由系统自动判断显示方向。 landscape：横屏模式。 portrait：竖屏模式。 followRecent：跟随栈中最近的应用。  字符串  可缺省，缺省值为"unspecified"。   backgroundModes  标识后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下： dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等业务。 audioPlayback：音频输出业务。 audioRecording：音频输入业务。 pictureInPicture：画中画、小窗口播放视频业务。 voip：音视频电话、VOIP业务。 location：定位、导航业务。 bluetoothInteraction：蓝牙扫描、连接、传输业务。 wifiInteraction：WLAN扫描、连接、传输业务。 screenFetch：录屏、截屏业务。 multiDeviceConnection：多设备互联业务  字符串数组  可缺省，缺省值为空。   grantPermission  指定是否可以向Ability内任何数据授予权限。  布尔值  可缺省，缺省值为空。   readPermission  标识读取Ability的数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。该标签仅适用于默认设备、平板、智慧屏、车机、智能穿戴。  字符串  可缺省，缺省为空。   writePermission  标识向Ability写数据所需的权限。该标签仅适用于data类型的Ability。取值为长度不超过255字节的字符串。  字符串  可缺省，缺省为空。   configChanges  标识Ability关注的系统配置集合。当已关注的配置发生变更后，Ability会收到onConfigurationUpdated回调。取值范围： mcc：表示IMSI移动设备国家/地区代码（MCC）发生变更。典型场景：检测到SIM并更新MCC。 mnc：IMSI移动设备网络代码（MNC）发生变更。典型场景：检测到SIM并更新MNC。 locale：表示语言区域发生变更。典型场景：用户已为设备文本的文本显示选择新的语言类型。 layout：表示屏幕布局发生变更。典型场景：当前有不同的显示形态都处于活跃状态。 fontSize：表示字号发生变更。典型场景：用户已设置新的全局字号。 orientation：表示屏幕方向发生变更。典型场景：用户旋转设备。 density：表示显示密度发生变更。典型场景：用户可能指定不同的显示比例，或当前有不同的显示形态同时处于活跃状态。 size：显示窗口大小发生变更。 smallestSize：显示窗口较短边的边长发生变更。 colorMode：颜色模式发生变更。  字符串数组  可缺省，缺省为空。   mission  标识Ability指定的任务栈。该标签仅适用于page类型的Ability。默认情况下应用中所有Ability同属一个任务栈。  字符串  可缺省，缺省为应用的包名。   targetAbility  标识当前Ability重用的目标Ability。该标签仅适用于page类型的Ability。如果配置了targetAbility属性，则当前Ability（即别名Ability）的属性中仅name、icon、label、visible、permissions、skills生效，其他属性均沿用targetAbility中的属性值。目标Ability必须与别名Ability在同一应用中，且在配置文件中目标Ability必须在别名之前进行声明。  字符串  可缺省，缺省值为空。表示当前Ability不是一个别名Ability。   formsEnabled  标识Ability是否支持卡片（forms）功能。该标签仅适用于page类型的Ability。 true：支持卡片能力。 false：不支持卡片能力。  布尔值  可缺省，缺省值为false。   forms  标识服务卡片的属性。该标签仅当formsEnabled为"true"时，才能生效。  对象数组  可缺省，缺省值为空。   srcLanguage  Ability开发语言的类型，开发者创建工程时由开发者手动选择开发语言。  字符串  可缺省，缺省值为“js”。   srcPath  该标签标识Ability对应的JS组件代码路径，该标签最大长度为127字节。  字符串  不可缺省。   uriPermission  标识该Ability有权访问的应用程序数据。此属性由模式和路径子属性组成。此属性仅对类型提供者的能力有效。  对象  可缺省，缺省值为空。   startWindowIcon  标识该Ability启动页面图标资源文件的索引。该标签仅适用于page类型的Ability。取值示例：$media:icon。  字符串  可缺省，缺省值为空。   startWindowBackground  标识该Ability启动页面背景颜色资源文件的索引。该标签仅适用于page类型的Ability。取值示例：$color:red。  字符串  可缺省，缺省值为空。   removeMissionAfterTerminate  该标签标识Ability销毁后是否从任务列表中移除任务。该标签仅适用于page类型的Ability。true表示销毁后移除任务， false表示销毁后不移除任务。  布尔值  可缺省，缺省值为false。      uriPermission对象的内部结构表9 uriPermission对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    path  uriPermission标识的路径，该标签最大字节长度为255个字节。  字符串  不可缺省。   mode  uriPermission的匹配模式。  字符串  可缺省，缺省值为default。     abilities示例： 已复制"abilities": [  {    "name": ".EntryAbility",    "description": "test main ability",    // $media:ic_launcher 为媒体类资源    "icon": "$media:ic_launcher",    // $string:example 为字符串类资源    "label": "$string:example",    "launchType": "multiton",    "orientation": "unspecified",    "permissions": [],     "visible": true,    "skills": [      {        "actions": [          "action.system.home"        ],        "entities": [          "entity.system.home"        ]      }    ],    "configChanges": [      "locale",       "layout",       "fontSize",       "orientation"    ],     "type": "page",    "startWindowIcon": "$media:icon",    "startWindowBackground": "$color:red",    "removeMissionAfterTerminate": true  },  {    "name": ".PlayService",    "description": "example play ability",    "icon": "$media:ic_launcher",    "label": "$string:example",    "launchType": "multiton",    "orientation": "unspecified",    "visible": false,    "skills": [      {        "actions": [          "action.play.music",          "action.stop.music"        ],        "entities": [          "entity.audio"        ]      }    ],    "type": "service",    "backgroundModes": [      "audioPlayback"    ]  },  {    "name": ".UserADataAbility",    "type": "data",    "uri": "dataability://com.example.world.test.UserADataAbility",    "visible": true  }]  skills对象的内部结构表10 skills对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    actions  标识能够接收的want的action值，可以包含一个或多个action。取值通常为系统预定义的action值。  字符串数组  可缺省，缺省值为空。   entities  标识能够接收的want的Ability的类别（如视频、桌面应用等），可以包含一个或多个entity。  字符串数组  可缺省，缺省值为空。   uris  该标签标识向want过滤器添加数据规范集合。该规范可以是只有数据类型（mimeType属性），可以是只有URI，也可以是既有数据类型又有URI。 URI由其各个部分的单独属性指定：<scheme>://<host>:<port>[<path>|<pathStartWith>|<pathRegex>]。该标签可缺省，缺省值为空。 其中，scheme字段配置为uri时必配；当只设置数据类型（mimeType）时，则scheme字段为非必配项。  对象数组  可缺省，缺省值为空。      uris对象的内部结构表11 uris对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    scheme  标识uri的scheme值。  字符串  不可缺省。   host  标识uri的host值。  字符串  可缺省，缺省值为空。   port  标识uri的port值。  字符串  可缺省，缺省值为空。   pathStartWith  标识uri的pathStartWith值。  字符串  可缺省，缺省值为空。   path  标识uri的path值。  字符串  可缺省，缺省值为空。   pathRegx  标识uri的pathRegx值。  字符串  可缺省，缺省值为空。   type  标识uri的type值。type为MIME-TYPE属性，为资源的媒体类型，常见的类型有"audio/aac"，"text/css"等。  字符串  可缺省，缺省值为空。     skills示例： 已复制"skills": [  {    "actions": [      "action.system.home"    ],     "entities": [      "entity.system.home"    ],    "uris": [      {        "scheme": "http",        "host": "www.example.com",        "port": "8080",        "path": "query/student/name",        "type": "text/*"      }    ]  }]  reqPermissions权限申请表12 reqPermissions权限申请字段说明 属性名称  含义  数据类型  是否可缺省    name  需要使用的权限名称。  字符串  否   reason  描述申请权限的原因。需要做多语种适配。  字符串  分情况：当申请的权限为user_grant时，必须填写此字段，否则不允许在应用市场上架；其他权限可缺省，缺省为空   usedScene  描述权限使用的场景和时机。场景类型如下两种： - ability：ability的名称，可配置多个。 - when：调用时机，可填的值有inuse（使用时）、always（始终）。  对象  可缺省，缺省值为空。 when可缺省，缺省值为"inuse"      usedScene对象内部结构表13 usedScene对象内部结构说明 属性名称  含义  数据类型  是否可缺省    ability  标识哪些Ability需要此权限，里面配置Ability的名称。  字符串数组  可以缺省，缺省表示所有Ability都需要此权限。   when  标识此权限的使用时间： inuse: 使用时需要此权限。 always: 所有时间都需要此权限。  枚举值  可缺省，缺省值为空。      js对象的内部结构表14 js对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识JS Component的名字。该标签不可缺省，默认值为default。  字符串  不可缺省。   pages  标识JS Component的页面用于列举JS Component中每个页面的路由信息，格式为“页面路径+页面名称”。其中，页面路径是以当前Ability的srcPath字段取值为基准，例如srcPath取值为EntryAbility，则JS Component页面路径需要从EntryAbility的下一层开始描述。该标签取值为数组，数组第一个元素代表JS FA首页。  字符串数组  不可缺省。   window  用于定义与显示窗口相关的配置。  对象  可缺省，缺省值见表15。   type  标识JS应用的类型。取值范围如下： normal：标识该JS Component为应用实例。 form：标识该JS Component为卡片实例。  字符串  可缺省，缺省值为"normal"。   mode  定义JS组件的开发模式。  对象  可缺省，缺省值为空。      window对象的内部结构表15 window对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    designWidth  标识页面设计基准宽度。以此为基准，根据实际设备宽度来缩放元素大小。  数值  可缺省，缺省值为720px。   autoDesignWidth  标识页面设计基准宽度是否自动计算。当配置为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。  布尔值  可缺省，缺省值为false。      mode对象的内部结构表16 mode对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    type  定义JS组件的功能类型。  字符串，取值为"pageAbility"、"form"  可缺省，缺省值为pageAbility。   syntax  定义JS组件的语法类型。  字符串，取值为"hml"，"ets"  可缺省，默认值为"hml"。     js示例： 已复制"js": [  {    "name": "default",     "pages": [            "pages/index/index",      "pages/detail/detail"    ],         "window": {      "designWidth": 720,      "autoDesignWidth": false    },    "type": "form"  }]  shortcuts对象的内部结构表17 shortcuts对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    shortcutId  标识快捷方式的ID。字符串的最大长度为63字节。  字符串  不可缺省。   label  标识快捷方式的标签信息，即快捷方式对外显示的文字描述信息。取值可以是描述性内容，也可以是标识label的资源索引。字符串最大长度为63字节。  字符串  可缺省，缺省为空。   icon  标识快捷方式的图标信息。取值为表示icon的资源索引。  字符串  可缺省，缺省为空。   intents  标识快捷方式内定义的目标intent信息集合，每个intent可配置两个子标签，targetClass, targetBundle。  对象数组  可缺省，缺省为空。      intents对象的内部结构表18 intents对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    targetClass  标识快捷方式目标类名。  字符串  可缺省，缺省值为空。   targetBundle  标识快捷方式目标Ability所在应用的包名。  字符串  可缺省，缺省值为空。     shortcuts示例： 已复制"shortcuts": [  {    "shortcutId": "id",    // $string:shortcut 为配置的字符串资源值    "label": "$string:shortcut",    "intents": [      {        "targetBundle": "com.example.world.test",        "targetClass": "com.example.world.test.entry.EntryAbility"      }    ]  }]  forms对象的内部结构表19 forms对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识卡片的类名。字符串最大长度为127字节。  字符串  不可缺省。   description  标识卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。  字符串  可缺省，缺省为空。   isDefault  标识该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。 true：默认卡片。 false：非默认卡片。  布尔值  不可缺省。   type  标识卡片的类型。取值范围如下： JS：JS卡片。  字符串  不可缺省。   colorMode  标识卡片的主题样式，取值范围如下： auto：自适应。 dark：深色主题。 light：浅色主题。  字符串  可缺省，缺省值为"auto"。   supportDimensions  标识卡片支持的外观规格，取值范围： 1 * 2：表示1行2列的二宫格。 2 * 1：表示2行1列的二宫格。 2 * 2：表示2行2列的四宫格。 2 * 4：表示2行4列的八宫格。 4 * 4：表示4行4列的十六宫格。  字符串数组  不可缺省。   defaultDimension  标识卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。  字符串  不可缺省。   updateEnabled  标识卡片是否支持周期性刷新，取值范围： true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。 false：表示不支持周期性刷新。  布尔类型  不可缺省。   scheduledUpdateTime  标识卡片的定点刷新的时刻，采用24小时制，精确到分钟。  字符串  可缺省，缺省值为"0:0"。   updateDuration  标识卡片定时刷新的更新周期，单位为30分钟，取值为自然数。 当取值为0时，表示该参数不生效。 当取值为正整数N时，表示刷新周期为30*N分钟。  数值  可缺省，缺省值为"0"。   formConfigAbility  标识用于调整卡片的设施或活动的名称。  字符串  可缺省，缺省值为空。   jsComponentName  标识JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。  字符串  不可缺省。   metaData  标识卡片的自定义信息，包含customizeData数组标签。  对象  可缺省，缺省值为空。   customizeData  标识自定义的卡片信息。  对象数组  可缺省，缺省值为空。      customizeData对象内部结构表20 customizeData对象内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识数据项的键名称。字符串最大长度为255字节。  字符串  可缺省，缺省值为空。   value  标识数据项的值。字符串最大长度为255字节。  字符串  可缺省，缺省值为空。   extra  标识当前custom数据的格式，取值为表示extra的资源值。  字符串  可缺省，缺省值为空。     forms示例： 已复制"forms": [  {    "name": "Form_Js",    "description": "It's Js Form",    "type": "JS",    "jsComponentName": "card",    "colorMode": "auto",    "isDefault": true,    "updateEnabled": true,    "scheduledUpdateTime": "11:00",    "updateDuration": 1,    "defaultDimension": "2*2",    "supportDimensions": [      "2*2",      "2*4",      "4*4"    ]  },  {    "name": "Form_Js",    "description": "It's JS Form",    "type": "Js",    "colorMode": "auto",    "isDefault": false,    "updateEnabled": true,    "scheduledUpdateTime": "21:05",    "updateDuration": 1,    "defaultDimension": "1*2",    "supportDimensions": [      "1*2"    ],    "landscapeLayouts": [      "$layout:ability_form"    ],    "portraitLayouts": [      "$layout:ability_form"    ],    "formConfigAbility": "ability://com.example.myapplication.fa/.EntryAbility",    "metaData": {      "customizeData": [        {          "name": "originWidgetName",          "value": "com.example.weather.testWidget"        }      ]    }  }]  distroFilter对象的内部结构表21 distroFilter对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    apiVersion  标识支持的apiVersion范围。  对象数组  可缺省，缺省值为空。   screenShape  标识屏幕形状的支持策略。  对象数组  可缺省，缺省值为空。   screenWindow  标识应用运行时窗口的分辨率支持策略。该字段仅支持对轻量级智能穿戴设备进行配置。  对象数组  可缺省，缺省值为空。   screenDensity  标识屏幕的像素密度（dpi：Dots Per Inch）。  对象数组  可缺省，缺省值为空。   countryCode  标识分发应用时的国家码。具体值参考ISO-3166-1的标准，支持多个国家和地区的枚举定义。  对象数组  可缺省，缺省值为空。      apiVersion对象的内部结构表22 apiVersion对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    policy  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。  字符串  不可缺省。   value  支持的取值为API Version存在的整数值，例如4、5、6。场景示例：某应用，针对相同设备型号，同时在网的为使用API 5和API 6开发的两个软件版本，则允许上架2个entry类型的安装包，分别支持到对应设备侧软件版本的分发。  数组  不可缺省。      screenShape对象的内部结构表23 screenShape对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    policy  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。  字符串  不可缺省。   value  支持的取值为API Version存在的整数值，例如4、5、6。场景示例：某应用，针对相同设备型号，同时在网的为使用API 5和API 6开发的两个软件版本，则允许上架2个entry类型的安装包，分别支持到对应设备侧软件版本的分发。  数组  不可缺省。      screenWindow对象的内部结构表24 screenWindow对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    policy  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。  字符串  不可缺省。   value  支持的取值为API Version存在的整数值，例如4、5、6。场景示例：某应用，针对相同设备型号，同时在网的为使用API 5和API 6开发的两个软件版本，则允许上架2个entry类型的安装包，分别支持到对应设备侧软件版本的分发。  数组  不可缺省。      screenDensity对象的内部结构表25 screenDensity对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    policy  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。  字符串  不可缺省。   value  取值范围如下： sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为（0,120]的设备。 mdpi：表示中规模的屏幕密度(Medium-scale Dots Per Inch)，适用于dpi取值为（120,160]的设备。 ldpi：表示大规模的屏幕密度(Large-scale Dots Per Inch)，适用于dpi取值为（160,240]的设备。 xldpi：表示特大规模的屏幕密度(Extra Large-scale Dots Per Inch)，适用于dpi取值为（240,320]的设备。 xxldpi：表示超大规模的屏幕密度(Extra Extra Large-scale Dots Per Inch)，适用于dpi取值为（320,480]的设备。 xxxldpi：表示超特大规模的屏幕密度(Extra Extra Extra Large-scale Dots Per Inch)，适用于dpi取值为（480,640]的设备。  数组  不可缺省。      countryCode对象的内部结构表26 countryCode对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    policy  标识该子属性取值规则。配置为“exclude”或“include”。 - exclude：表示需要排除的value属性。 - include：表示需要包含的value属性。  字符串  不可缺省。   value  该标签标识应用需要分发的国家码，标签为字符串数组，子串表示支持的国家或地区，由两个大写字母表示。  字符串数组  不可缺省。     distroFilter示例： 已复制"distroFilter":  {  "apiVersion": {    "policy": "include",    "value": [4,5]  },  "screenShape": {    "policy": "include",    "value": ["circle","rect"]  },  "screenWindow": {    "policy": "include",    "value": ["454*454","466*466"]  },  "screenDensity":{    "policy": "exclude",    "value": ["ldpi","xldpi"]  },  "countryCode": {    "policy":"include",    "value":["CN","HK"]  }}  commonEvents对象的内部结构表27 commonEvents对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识静态公共事件名称，该标签最大长度为127字节。  字符串  不可缺省。   permission  此标签标识实现静态公共事件所需要申请的权限，该标签最大长度为255字节。  字符串  可缺省，缺省值为空。   data  标识配置当前静态公共事件要携带的附加数据数组。  字符串数组  可缺省，缺省值为空。   type  该标签用于配置当前静态公共事件的分类数组。  字符串数组  可缺省，缺省值为空。   events  此标签标识可接收的意图的一组事件值。一般由系统预定义，也可以自定义。  字符串数组  不可缺省。     commonEvents示例： 已复制"commonEvents": [  {    "name": ".EntryAbility",    "permission": "ohos.permission.GET_BUNDLE_INFO",    "data": [      "com.example.demo",      "100"    ],    "events": [      "install",      "update"    ]  }]  testRunner对象的内部结构表28 testRunner对象的内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识测试框架对象名称，该标签最大长度为255字节。  字符串  不可缺省。   srcPath  标识测试框架代码路径，该标签最大长度为255字节。  字符串  不可缺省。     已复制"testRunner": {  "name": "myTestRunnerName",  "srcPath": "etc/test/TestRunner.ts"} definePermission仅支持系统应用配置，三方应用配置不生效。  definePermissions对象内部结构表29 definePermissions对象内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识权限的名称，该标签最大长度为255字节。  字符串  不可缺省。   grantMode  标识权限的授予方式，支持如下两种授予模式如下： - system_grant：安装后系统自动授予该权限。 - user_grant：使用时动态申请，用户授权后才可使用。  字符串  可缺省，缺省值为system_grant。   availableLevel  标识权限限制类别，可选值如下： - system_core：系统核心权限。 - system_basic：系统基础权限。 - normal：普通权限。所有应用允许申请的权限。  字符串  可缺省，缺省值为normal。   provisionEnable  标识权限是否支持证书方式申请权限，包括高级别的权限。配置为true标识开发者可以通过provision方式申请权限。  布尔值  可缺省，缺省值为true。   distributedSceneEnabled  标识权限是否支持分布式场景下使用该权限。  布尔值  可缺省，缺省值为false。   label  标识权限的简短描述，配置为对描述内容的资源索引。  字符串  可缺省，缺省值为空。   description  标识权限的详细描述，可以是字符串（最大长度为255字节），或者为对描述内容的资源索引。  字符串  可缺省，缺省值为空。       上一篇 deviceConfig内部结构 下一篇 资源分类与访问 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。多HAP构建视图 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 IDE支持在一个应用工程中进行多个HAP的开发与构建，如下图所示。 图1 多HAP构建视图   IDE开发态视图 AppScope目录app.json5：配置应用全局描述信息，例如应用包名、版本号、应用图标、应用名称和依赖的SDK版本号等。 resources目录：放置应用的图标资源和应用名称字符串资源。 说明： 该目录由IDE自动生成，名称不可更改。AppScope目录下面的文件名与Entry、Feature模块下面的文件名不能重复，否则IDE会报错。  entry或者feature目录（名称可由开发者自定义）由IDE引导开发者创建的Module，在该Module中实现应用的业务逻辑；可以创建多个Module，图中entry和feature即是创建的两个Module。resources目录：放置该Module中所使用到的资源。ets目录：开发者的业务逻辑。module.json5：配置该Module的描述信息，如：Module的名称、Module的入口代码路径、包含的组件信息等。  编译打包后的视图 从开发态到编译态，Module中的文件会发生如下变更： ets目录：ArkTS源码编译生成.abc文件。resources目录：AppScope目录下的资源文件会合入到Module下面资源目录中，如果两个目录下的存在重名文件，编译打包后只会保留AppScope目录下的资源文件。module配置文件：AppScope目录下的app.json5文件字段会合入到Module下面的module.json5文件之中，编译后生成HAP或HSP最终的module.json文件。 一个开发态的Module编译后生成一个部署态的HAP，Module和HAP一一对应。所有的HAP最终会编译到一个App Pack中（以.app为后缀的包文件），用于发布到应用市场。   上一篇 多HAP机制设计目标 下一篇 多HAP的开发调试与发布部署流程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。多HAP机制设计目标 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 方便开发者模块化的管理应用，好的应用一般都是模块化管理，模块之间属于松耦合关系。多HAP方便了开发者将业务划分成多个模块，每个模块放到独立的HAP中。例如支付类应用，有统一的主界面，主界面管理“扫一扫”、“收付款”、“消息”、“理财”等各个模块。其中主界面管理其他模块的逻辑在Entry包中实现，而“扫一扫”、“收付款”、“消息”和“理财”等模块在不同的Feature包中实现。可以同时开发多个Feature包，能够实现Feature包单独的开发测试，最终由Entry包统一集成Feature包的特性。 方便开发者将多HAP合理地组合并部署到不同的设备上。例如应用程序包含一个Entry包和两个Feature包（Feature1和Feature2）。其中Entry包可以部署到设备A和设备B，Feature1只能部署到设备A，Feature2包只部署到设备B上，那么开发者就可以方便的组合Entry和Feature1部署到设备A上，组合Entry和Feature2部署到设备B上。 方便应用资源共享，减少程序包大小。多个HAP都需要用到的资源（包括公共资源文件、公共页面等）以及so（shared object）文件可以放到单独的HAP中，其他HAP可以到该HAP中访问资源和so文件，也一定程度上可以减少应用程序包大小。   上一篇 应用程序包多HAP机制 下一篇 多HAP构建视图 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。多HAP运行机制及数据通信方式 更新时间: 2024-03-18 17:33 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
  多HAP机制主要是为方便开发者进行模块化管理。HAP和应用运行时的进程并不是一一对应的，具体运行机制如下：  默认情况下，应用中（同一包名）的所有UIAbility、ServiceExtensionAbility、DataShareExtensionAbility运行在同一个独立进程中，其他同类型ExtensionAbility分别运行在单独的进程。 HAP支持在module.json5（Stage模型）或者config.json（FA模型）中通过process标签配置单独的进程（仅系统应用支持，三方应用不支持）。配置了process的HAP，其组件运行在单独的process进程中，多个HAP可以配置相同的process，则这些HAP运行在相同进程中，process配置的详细说明请参见module.json5配置文件。 应用运行时，同一进程中的UIAbility组件被启动时，才加载对应HAP的资源和代码。  基于上述机制，多HAP数据通信方式如下：  同一进程内的数据通信，请参见线程间通信。 跨进程的数据通信，请参见进程间通信。 多HAP如果运行在同一进程，则多HAP间组件的通信方式与同一HAP内组件的通信方式相同。   上一篇 多HAP使用规则 下一篇 应用程序包安装和卸载流程 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发调试发布部署应用在终端设备上的安装多HAP的开发调试与发布部署流程 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 多HAP的开发调试与发布部署流程如下图所示。 图1 多HAP的开发调试与发布部署流程  开发开发者通过DevEco Studio工具按照业务的需要创建多个Module，在相应的Module中完成自身业务的开发。  调试通过DevEco Studio编译打包，生成单个或者多个HAP，即可基于HAP进行调试。如需根据不同的部署环境、目标人群、运行环境等，将同一个HAP定制编译为不同版本，请参见定制编译指导。 在调试前，需要先安装或更新HAP，以下介绍具体做法。 使用DevEco Studio进行调试 使用指导可参考应用程序包调试方法，其中包括了单HAP与多HAP通过DevEco Studio工具的安装调试方法。 使用hdc工具(可通过HarmonyOS SDK获取，在SDK的toolchains目录下)进行调试 在调试前，需要先安装或更新HAP，此处有两种方式。  直接使用hdc安装、更新HAP。 HAP的路径为开发平台上的文件路径，以Windows开发平台为例，命令参考如下： 已复制// 安装、更新，多HAP可以指定多个文件路径hdc install C:\entry.hap C:\feature.hap// 执行结果install bundle successfully.// 卸载hdc uninstall com.example.myapplication// 执行结果uninstall bundle successfully. 先执行hdc shell，再使用bm工具安装、更新HAP。 HAP的文件路径为真机上的文件路径，命令参考如下： 已复制// 先执行hdc shell才能使用bm工具hdc shell// 安装、更新，多HAP可以指定多个文件路径bm install -p /data/app/entry.hap /data/app/feature.hap// 执行结果install bundle successfully.// 卸载bm uninstall -n com.example.myapplication// 执行结果uninstall bundle successfully. 完成HAP安装或更新后，即可参考相关调试命令进行调试。   发布当开发的程序包满足发布要求时，可以在工具中打包编译生成App包。将该App包上架到应用市场云端，应用市场会对上架的App包校验签名，校验签名通过后会将App包中的HAP拆分出来，同时对拆分出的HAP重新添加签名，然后对HAP进行分发。  部署用户在设备上的应用市场客户端能够看到各种各样的应用，这些应用均由云端分发而来，有些是多HAP应用，有些是单HAP应用。用户选择某个应用后，应用市场将下载应用所包含的全部deliveryWithInstall设置为“true”的HAP。  应用在终端设备上的安装下载完成后，应用市场客户端再调用系统中包管理服务的安装接口安装下载的HAP，包管理服务以应用为单位将其中所有HAP部署到指定目录下，以完成应用的安装。   上一篇 多HAP构建视图 下一篇 多HAP使用规则 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。多HAP使用规则 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 App Pack包不能直接安装到设备上，只是上架应用市场的单元。 App Pack包中所有HAP的配置文件中的bundleName标签必须一致。 App Pack包中所有HAP的配置文件中的versionCode标签必须一致。 App Pack包中同一设备类型的所有HAP中必须有且只有一个entry类型的HAP，feature类型的HAP可以有一个或者多个，也可以没有。 App Pack包中的每个HAP必须配置moduleName标签，同一设备类型的所有HAP对应的moduleName标签必须唯一。 同一应用的所有HAP签名证书要保持一致。上架应用市场是以App Pack的形式上架，并对其进行了签名。应用市场分发时会将所有HAP从App Pack中拆分出来，同时对其中的所有HAP进行重签名，这样保证了所有HAP签名证书的一致性。在调试阶段，开发者通过命令行或IDE将HAP安装到设备上时要保证所有HAP签名证书一致，否则会出现安装失败的问题。   上一篇 多HAP的开发调试与发布部署流程 下一篇 多HAP运行机制及数据通信方式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介数据传输对象普通对象可转移对象可共享对象Native绑定对象TaskPool和Worker多线程并发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   简介 并发模型是用来实现不同应用场景中并发任务的编程模型，常见的并发模型分为基于内存共享的并发模型和基于消息通信的并发模型。 Actor并发模型作为基于消息通信并发模型的典型代表，不需要开发者去面对锁带来的一系列复杂偶发的问题，同时并发度也相对较高，因此得到了广泛的支持和使用，也是当前ArkTS语言选择的并发模型。 由于Actor模型的内存隔离特性，所以需要进行跨线程的数据序列化传输。   数据传输对象 目前支持传输的数据对象可以分为普通对象、可转移对象、可共享对象、Native绑定对象四种。   普通对象 普通对象传输采用标准的结构化克隆算法（Structured Clone）进行序列化，此算法可以通过递归的方式拷贝传输对象，相较于其他序列化的算法，支持的对象类型更加丰富。 序列化支持的类型包括：除Symbol之外的基础类型、Date、String、RegExp、Array、Map、Set、Object（仅限简单对象，比如通过“{}”或者“new Object”创建，普通对象仅支持传递属性，不支持传递其原型及方法）、ArrayBuffer、TypedArray。   可转移对象 可转移对象（Transferable object）传输采用地址转移进行序列化，不需要内容拷贝，会将ArrayBuffer的所有权转移给接收该ArrayBuffer的线程，转移后该ArrayBuffer在发送它的线程中变为不可用，不允许再访问。 已复制// 定义可转移对象let buffer = new ArrayBuffer(100);   可共享对象 共享对象SharedArrayBuffer，拥有固定长度，可以存储任何类型的数据，包括数字、字符串等。 共享对象传输指SharedArrayBuffer支持在多线程之间传递，传递之后的SharedArrayBuffer对象和原始的SharedArrayBuffer对象可以指向同一块内存，进而达到内存共享的目的。 SharedArrayBuffer对象存储的数据在同时被修改时，需要通过原子操作保证其同步性，即下个操作开始之前务必需要等到上个操作已经结束。 已复制// 定义可共享对象，可以使用Atomics进行操作let sharedBuffer = new SharedArrayBuffer(1024);   Native绑定对象 Native绑定对象（Native Binding Object）是系统所提供的对象，该对象与底层系统功能进行绑定，提供直接访问底层系统功能的能力。 当前支持序列化传输的Native绑定对象主要包含：Context和RemoteObject。 Context对象包含应用程序组件的上下文信息，它提供了一种访问系统服务和资源的方式，使得应用程序组件可以与系统进行交互。获取Context信息的方法可以参考获取上下文信息。 RemoteObject对象的主要作用是实现远程通信的功能，它允许在不同的进程间传递对象的引用，使得不同进程之间可以共享对象的状态和方法，服务提供者必须继承此类，RemoteObject对象的创建可以参考RemoteObject的实现。   TaskPool和Worker ArkTS提供了TaskPool和Worker两种并发能力供开发者选择，其具体的实现特点和各自的适用场景存在差异，详细请参见TaskPool和Worker的对比。   上一篇 使用多线程并发能力进行开发 下一篇 TaskPool和Worker的对比 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发流程基本功能开发建议注册建议so命名规则JS对象线程限制头文件引入限制Native API在应用工程中的使用指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在HarmonyOS中，C API中的N-API接口可以实现ArkTS/TS/JS与C/C++之间的交互。N-API提供的接口名与三方Node.js一致，目前支持部分接口，支持列表见链接。 开发流程在DevEco Studio的模板工程中包含使用N-API的默认工程，使用File->New->Create Project创建Native C++模板工程。创建后在entry/src/main目录下会包含cpp目录，可以使用N-API接口，开发C/C++代码（native侧代码）。 ArkTS/TS/JS侧通过import引入native侧的so文件，如：import hello from 'libhello.so'，意为使用libhello.so的能力，并将名为hello的ArkTS/TS/JS对象给到应用的ArkTS/TS/JS侧，开发者可通过该对象，调用到在cpp中开发的native方法。  基本功能N-API接口可以实现ArkTS/TS/JS和C/C++之间的交互，这里以HelloWorld工程的两个例子： 提供一个名为Add的native方法，ArkTS侧调用该方法并传入两个number，native方法将这两个number相加并返回到ArkTS侧。提供一个名为NativeCallArkTS的native方法，ArkTS侧调用该方法并传入一个ArkTS function，native方法中调用这个ArkTS function，并将其结果返回ArkTS侧。 以此来介绍： ArkTS侧如何调用到C++侧方法。C++侧如何调用到ArkTS侧方法。 下面给出了工程中的： entry\src\main\cpp\hello.cpp, 包含native侧逻辑。entry\src\main\ets\pages\index.ets，包含ArkTS侧逻辑。entry\src\main\cpp\types\libentry\index.d.ts，包含native侧暴露给ArkTS侧接口的声明。 同时给出了注解，工程中其余部分均与native默认工程相同。 已复制// entry\src\main\cpp\hello.cpp// 引入N-API相关头文件。#include "napi/native_api.h"
// 开发者提供的native方法，入参有且仅有如下两个，开发者不需进行变更。// napi_env 为当前运行的上下文。// napi_callback_info 记录了一些信息，包括从ArkTS侧传递过来参数等。static napi_value Add(napi_env env, napi_callback_info info){    // 期望从ArkTS侧获取的参数的数量，napi_value可理解为ArkTS value在native方法中的表现形式。    size_t argc = 2;    napi_value args[2] = {nullptr};        // 从info中，拿到从ArkTS侧传递过来的参数，此处获取了两个ArkTS参数，即arg[0]和arg[1]。    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);
    // 将获取的ArkTS参数转换为native信息，此处ArkTS侧传入了两个number，这里将其转换为native侧可以操作的double类型。    double value0;    napi_get_value_double(env, args[0], &value0);
    double value1;    napi_get_value_double(env, args[1], &value1);        // native侧的业务逻辑，这里简单以两数相加为例。    double nativeSum = value0 + value1;        // 此处将native侧业务逻辑处理结果转换为ArkTS值，并返回给ArkTS。    napi_value sum;    napi_create_double(env, nativeSum , &sum);    return sum;}
static napi_value NativeCallArkTS(napi_env env, napi_callback_info info){    // 期望从ArkTS侧获取的参数的数量，napi_value可理解为ArkTS value在native方法中的表现形式。    size_t argc = 1;    napi_value args[1] = {nullptr};        // 从info中，拿到从ArkTS侧传递过来的参数，此处获取了一个ArkTS参数，即arg[0]。    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);        // 创建一个ArkTS number作为ArkTS function的入参。    napi_value argv = nullptr;    napi_create_int32(env, 10, &argv);        napi_value result = nullptr;    // native方法中调用ArkTS function，其返回值保存到result中并返到ArkTS侧。    napi_call_function(env, nullptr, args[0], 1, &argv, &result);        return result;}
EXTERN_C_START// Init将在exports上挂上Add/NativeCallArkTS这些native方法，此处的exports就是开发者import之后获取到的ArkTS对象。static napi_value Init(napi_env env, napi_value exports){    // 函数描述结构体，以Add为例，第三个参数"Add"为上述的native方法，    // 第一个参数"add"为ArkTS侧对应方法的名称。    napi_property_descriptor desc[] = {        { "add", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr },        { "nativeCallArkTS", nullptr, NativeCallArkTS, nullptr, nullptr, nullptr, napi_default, nullptr },    };    // 在exports这个ArkTS对象上，挂载native方法。    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);    return exports;}EXTERN_C_END
// 准备模块加载相关信息，将上述Init函数与本模块名等信息记录下来。static napi_module demoModule = {    .nm_version =1,    .nm_flags = 0,    .nm_filename = nullptr,    .nm_register_func = Init,    .nm_modname = "entry",    .nm_priv = ((void*)0),    .reserved = { 0 },};
// 打开so时，该函数将自动被调用，使用上述demoModule模块信息，进行模块注册相关动作。extern "C" __attribute__((constructor)) void RegisterHelloModule(void){    napi_module_register(&demoModule);} 已复制// entry\src\main\ets\pages\index.ets
import hilog from '@ohos.hilog';// 通过import的方式，引入native能力。import entry from 'libentry.so'
@Entry@Componentstruct Index {
  build() {    Row() {      Column() {        // 第一个按钮，调用add方法，对应到native侧的Add方法，进行两数相加。        Button('ArkTS call C++')          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);            hilog.info(0x0000, 'testTag', 'Test NAPI 2 + 3 = %{public}d', entry.add(2, 3));          })        // 第二个按钮，调用nativeCallArkTS方法，对应到native的NativeCallArkTS，在native中执行ArkTS function。        Button('C++ call ArkTS')          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);            let ret = entry.nativeCallArkTS((value)=>{return value * 2;});            hilog.info(0x0000, 'testTag', 'Test NAPI nativeCallArkTS ret = %{public}d', ret);          })      }      .width('100%')    }    .height('100%')  }} 已复制// entry\src\main\cpp\types\libentry\index.d.ts// native侧暴露给ArkTS侧接口的声明。export const add: (a: number, b: number) => number;export const nativeCallArkTS: (a: object) => number;  开发建议 注册建议nm_register_func对应的函数（如上述Init函数）需要加上static，防止与其他so里的符号冲突。模块注册的入口，即使用__attribute__((constructor))修饰的函数的函数名（如上述RegisterHelloModule函数）需要确保不与其他模块重复。  so命名规则so命名必须符合以下规则： 每个模块对应一个so。如模块名为hello，则so的名字为libhello.so，napi_module中nm_modname字段应为hello，大小写与模块名保持一致，应用使用时写作：import hello from 'libhello.so'。  JS对象线程限制ArkCompiler会对JS对象线程进行保护，使用不当会引起应用crash，因此需要遵循如下原则： N-API接口只能在JS线程使用。env与线程绑定，不能跨线程使用。native侧JS对象只能在创建时的线程使用，即与线程所持有的env绑定。  头文件引入限制在引入头文件时，需引入"napi/native_api.h"，否则会出现N-API接口无法找到的编译报错。   上一篇 Native API相关指导 下一篇 Drawing开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤NativeWindow 开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 NativeWindow是HarmonyOS本地平台化窗口，表示图形队列的生产者端。开发者可以通过NativeWindow接口进行申请和提交Buffer，配置Buffer属性信息。 针对NativeWindow，常见的开发场景如下：  通过NativeWindow提供的Native API接口申请图形Buffer，并将生产图形内容写入图形Buffer，最终提交Buffer到图形队列 在适配EGL层的eglswapbuffer接口时，进行申请和提交Buffer    接口说明     接口名 描述    OH_NativeWindow_NativeWindowRequestBuffer (OHNativeWindow *window, OHNativeWindowBuffer **buffer, int *fenceFd) 通过OHNativeWindow对象申请一块OHNativeWindowBuffer，用以内容生产。   OH_NativeWindow_NativeWindowFlushBuffer (OHNativeWindow *window, OHNativeWindowBuffer *buffer, int fenceFd, Region region) 通过OHNativeWindow将生产好内容的OHNativeWindowBuffer放回到Buffer队列中，用以内容消费。   OH_NativeWindow_NativeWindowHandleOpt (OHNativeWindow *window, int code,...) 设置/获取OHNativeWindow的属性，包括设置/获取宽高、内容格式等。    详细的接口说明请参考native_window。   开发步骤 以下步骤描述了在HarmonyOS中如何使用NativeWindow提供的Native API接口，申请图形Buffer，并将生产图形内容写入图形Buffer后，最终提交Buffer到图形队列。 添加动态链接库 CMakeLists.txt中添加以下lib。 已复制libace_ndk.z.solibnative_window.so 头文件 已复制#include <ace/xcomponent/native_interface_xcomponent.h>#include <native_window/external_window.h>  获取OHNativeWindow实例。 可在OH_NativeXComponent_Callback提供的接口中获取OHNativeWindow，下面提供一份代码示例。XComponent模块的具体使用方法请参考XComponent开发指导。  在xxx.ets中添加一个XComponent组件。已复制XComponent({ id: 'xcomponentId', type: 'surface', libraryname: 'entry'})    .width(360)    .height(360) 在 native c++ 层获取 NativeXComponent。已复制napi_value exportInstance = nullptr;// 用来解析出被wrap了NativeXComponent指针的属性napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance);OH_NativeXComponent *nativeXComponent = nullptr;// 通过napi_unwrap接口，解析出NativeXComponent的实例指针napi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent));// 获取XComponentIdchar idStr[OH_XCOMPONENT_ID_LEN_MAX + 1] = {};uint64_t idSize = OH_XCOMPONENT_ID_LEN_MAX + 1;OH_NativeXComponent_GetXComponentId(nativeXComponent, idStr, &idSize); 定义 OH_NativeXComponent_Callback。已复制// 定义回调函数void OnSurfaceCreatedCB(OH_NativeXComponent* component, void* window){    // 可获取 OHNativeWindow 实例    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);    // ...}void OnSurfaceChangedCB(OH_NativeXComponent* component, void* window){    // 可获取 OHNativeWindow 实例    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);    // ...}void OnSurfaceDestroyedCB(OH_NativeXComponent* component, void* window){    // 可获取 OHNativeWindow 实例    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);    // ...}void DispatchTouchEventCB(OH_NativeXComponent* component, void* window){    // 可获取 OHNativeWindow 实例    OHNativeWindow* nativeWindow = static_cast<OHNativeWindow*>(window);    // ...} 已复制// 初始化 OH_NativeXComponent_CallbackOH_NativeXComponent_Callback callback;callback.OnSurfaceCreated = OnSurfaceCreatedCB;callback.OnSurfaceChanged = OnSurfaceChangedCB;callback.OnSurfaceDestroyed = OnSurfaceDestroyedCB;callback.DispatchTouchEvent = DispatchTouchEventCB; 将 OH_NativeXComponent_Callback 注册给 NativeXComponent。已复制// 注册回调函数OH_NativeXComponent_RegisterCallback(nativeXComponent, &callback);  设置OHNativeWindowBuffer的属性。使用OH_NativeWindow_NativeWindowHandleOpt设置OHNativeWindowBuffer的属性。 已复制// 设置 OHNativeWindowBuffer 的宽高int32_t code = SET_BUFFER_GEOMETRY;int32_t width = 0x100;int32_t height = 0x100;// 这里的nativeWindow是从上一步骤中的回调函数中获得的int32_t ret = OH_NativeWindow_NativeWindowHandleOpt(nativeWindow, code, width, height); 从图形队列申请OHNativeWindowBuffer。 已复制OHNativeWindowBuffer* buffer = nullptr;int fenceFd;// 通过 OH_NativeWindow_NativeWindowRequestBuffer 获取 OHNativeWindowBuffer 实例OH_NativeWindow_NativeWindowRequestBuffer(nativeWindow, &buffer, &fenceFd);// 通过 OH_NativeWindow_GetBufferHandleFromNative 获取 buffer 的 handleBufferHandle* bufferHandle = OH_NativeWindow_GetBufferHandleFromNative(buffer); 内存映射mmap。 已复制#include <sys/mman.h>
// 使用系统接口mmap将bufferHandle对应的共享内存映射到用户空间，可以通过映射出来的虚拟地址向bufferHandle中写入图像数据// bufferHandle->virAddr是bufferHandle在共享内存中的起始地址，bufferHandle->size是bufferHandle在共享内存中的内存占用大小void* mappedAddr = mmap(bufferHandle->virAddr, bufferHandle->size, PROT_READ | PROT_WRITE, MAP_SHARED, bufferHandle->fd, 0);if (mappedAddr == MAP_FAILED) {    // mmap failed} 将生产的内容写入OHNativeWindowBuffer。 已复制static uint32_t value = 0x00;value++;uint32_t *pixel = static_cast<uint32_t *>(mappedAddr); // 使用mmap获取到的地址来访问内存for (uint32_t x = 0; x < width; x++) {    for (uint32_t y = 0;  y < height; y++) {        *pixel++ = value;    }} 提交OHNativeWindowBuffer到图形队列。 已复制// 设置刷新区域，如果Region中的Rect为nullptr,或者rectNumber为0，则认为OHNativeWindowBuffer全部有内容更改。Region region{nullptr, 0};// 通过OH_NativeWindow_NativeWindowFlushBuffer 提交给消费者使用，例如：显示在屏幕上。OH_NativeWindow_NativeWindowFlushBuffer(nativeWindow, buffer, fenceFd, region); 取消内存映射munmap。 已复制// 内存使用完记得去掉内存映射int result = munmap(mappedAddr, bufferHandle->size);if (result == -1) {    // munmap failed}    上一篇 Rawfile开发指导 下一篇 使用MindSpore Lite引擎进行模型推理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。约束与限制网络管理开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 网络管理模块主要提供以下功能： HTTP数据请求：通过HTTP发起一个数据请求。WebSocket连接：使用WebSocket建立服务器与客户端的双向连接。Socket连接：通过Socket进行数据传输。 约束与限制使用网络管理模块的相关功能时，需要请求相应的权限。 权限名 说明   ohos.permission.GET_NETWORK_INFO 获取网络连接信息。  ohos.permission.SET_NETWORK_INFO 修改网络连接状态。  ohos.permission.INTERNET 允许程序打开网络套接字，进行网络连接。      上一篇 网络管理 下一篇 HTTP数据请求 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍环境准备环境要求环境搭建接口说明结构体模型构造相关接口模型编译相关接口执行推理相关接口设备管理相关接口开发步骤调测验证Neural Network Runtime对接AI推理框架开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 场景介绍Neural Network Runtime作为AI推理引擎和加速芯片的桥梁，为AI推理引擎提供精简的Native接口，满足推理引擎通过加速芯片执行端到端推理的需求。 本文以图1展示的Add单算子模型为例，介绍Neural Network Runtime的开发流程。Add算子包含两个输入、一个参数和一个输出，其中的activation参数用于指定Add算子中激活函数的类型。 图1 Add单算子网络示意图  环境准备 环境要求Neural Network Runtime部件的环境要求如下： 开发环境：Ubuntu 18.04及以上。接入设备：HarmonyOS定义的标准设备，并且系统中内置的硬件加速器驱动，已通过HDI接口对接Neural Network Runtime。 由于Neural Network Runtime通过Native API对外开放，需要通过Native开发套件编译Neural Network Runtime应用。  环境搭建打开Ubuntu编译服务器的终端。把下载好的Native开发套件压缩包拷贝至当前用户根目录下。执行以下命令解压Native开发套件的压缩包。已复制unzip native-linux-{版本号}.zip  解压缩后的内容如下（随版本迭代，目录下的内容可能发生变化，请以最新版本的Native API为准）： 已复制native/├── build // 交叉编译工具链├── build-tools // 编译构建工具├── docs├── llvm├── nativeapi_syscap_config.json├── ndk_system_capability.json├── NOTICE.txt├── oh-uni-package.json└── sysroot // Native API头文件和库  接口说明这里给出Neural Network Runtime开发流程中通用的接口，具体请见下列表格。  结构体 结构体名称  描述    typedef struct OH_NNModel OH_NNModel  Neural Network Runtime的模型句柄，用于构造模型。   typedef struct OH_NNCompilation OH_NNCompilation  Neural Network Runtime的编译器句柄，用于编译AI模型。   typedef struct OH_NNExecutor OH_NNExecutor  Neural Network Runtime的执行器句柄，用于在指定设备上执行推理计算。      模型构造相关接口 接口名称  描述    OH_NNModel_Construct()  创建OH_NNModel类型的模型实例。   OH_NN_ReturnCode OH_NNModel_AddTensor(OH_NNModel *model, const OH_NN_Tensor *tensor)  向模型实例中添加张量。   OH_NN_ReturnCode OH_NNModel_SetTensorData(OH_NNModel *model, uint32_t index, const void *dataBuffer, size_t length)  设置张量的数值。   OH_NN_ReturnCode OH_NNModel_AddOperation(OH_NNModel *model, OH_NN_OperationType op, const OH_NN_UInt32Array *paramIndices, const OH_NN_UInt32Array *inputIndices, const OH_NN_UInt32Array *outputIndices)  向模型实例中添加算子。   OH_NN_ReturnCode OH_NNModel_SpecifyInputsAndOutputs(OH_NNModel *model, const OH_NN_UInt32Array *inputIndices, const OH_NN_UInt32Array *outputIndices)  指定模型的输入输出。   OH_NN_ReturnCode OH_NNModel_Finish(OH_NNModel *model)  完成模型构图。   void OH_NNModel_Destroy(OH_NNModel **model)  释放模型实例。      模型编译相关接口 接口名称  描述    OH_NNCompilation *OH_NNCompilation_Construct(const OH_NNModel *model)  创建OH_NNCompilation类型的编译实例。   OH_NN_ReturnCode OH_NNCompilation_SetDevice(OH_NNCompilation *compilation, size_t deviceID)  指定模型编译和计算的硬件。   OH_NN_ReturnCode OH_NNCompilation_SetCache(OH_NNCompilation *compilation, const char *cachePath, uint32_t version)  设置编译后的模型缓存路径和缓存版本。   OH_NN_ReturnCode OH_NNCompilation_Build(OH_NNCompilation *compilation)  进行模型编译。   void OH_NNCompilation_Destroy(OH_NNCompilation **compilation)  释放OH_NNCompilation对象。      执行推理相关接口 接口名称  描述    OH_NNExecutor *OH_NNExecutor_Construct(OH_NNCompilation *compilation)  创建OH_NNExecutor类型的执行器实例。   OH_NN_ReturnCode OH_NNExecutor_SetInput(OH_NNExecutor *executor, uint32_t inputIndex, const OH_NN_Tensor *tensor, const void *dataBuffer, size_t length)  设置模型单个输入的数据。   OH_NN_ReturnCode OH_NNExecutor_SetOutput(OH_NNExecutor *executor, uint32_t outputIndex, void *dataBuffer, size_t length)  设置模型单个输出的缓冲区。   OH_NN_ReturnCode OH_NNExecutor_Run(OH_NNExecutor *executor)  执行推理。   void OH_NNExecutor_Destroy(OH_NNExecutor **executor)  销毁OH_NNExecutor实例，释放实例占用的内存。      设备管理相关接口 接口名称  描述    OH_NN_ReturnCode OH_NNDevice_GetAllDevicesID(const size_t **allDevicesID, uint32_t *deviceCount)  获取对接到 Neural Network Runtime 的硬件ID。      开发步骤Neural Network Runtime的开发流程主要包含模型构造、模型编译和推理执行三个阶段。以下开发步骤以Add单算子模型为例，介绍调用Neural Network Runtime接口，开发应用的过程。 创建应用样例文件。 首先，创建Neural Network Runtime应用样例的源文件。在项目目录下执行以下命令，创建nnrt_example/目录，在目录下创建 nnrt_example.cpp 源文件。 已复制mkdir ~/nnrt_example && cd ~/nnrt_exampletouch nnrt_example.cpp 导入Neural Network Runtime。 在 nnrt_example.cpp 文件的开头添加以下代码，引入Neural Network Runtime模块。 已复制#include <cstdint>#include <iostream>#include <vector>
#include "neural_network_runtime/neural_network_runtime.h"
// 常量，用于指定输入、输出数据的字节长度const size_t DATA_LENGTH = 4 * 12; 构造模型。 使用Neural Network Runtime接口，构造Add单算子样例模型。 已复制OH_NN_ReturnCode BuildModel(OH_NNModel** pModel){    // 创建模型实例，进行模型构造    OH_NNModel* model = OH_NNModel_Construct();    if (model == nullptr) {        std::cout << "Create model failed." << std::endl;        return OH_NN_MEMORY_ERROR;    }
    // 添加Add算子的第一个输入Tensor，类型为float32，张量形状为[1, 2, 2, 3]    int32_t inputDims[4] = {1, 2, 2, 3};    OH_NN_Tensor input1 = {OH_NN_FLOAT32, 4, inputDims, nullptr, OH_NN_TENSOR};    OH_NN_ReturnCode ret = OH_NNModel_AddTensor(model, &input1);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, add Tensor of first input failed." << std::endl;        return ret;    }
    // 添加Add算子的第二个输入Tensor，类型为float32，张量形状为[1, 2, 2, 3]    OH_NN_Tensor input2 = {OH_NN_FLOAT32, 4, inputDims, nullptr, OH_NN_TENSOR};    ret = OH_NNModel_AddTensor(model, &input2);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, add Tensor of second input failed." << std::endl;        return ret;    }
    // 添加Add算子的参数Tensor，该参数Tensor用于指定激活函数的类型，Tensor的数据类型为int8。    int32_t activationDims = 1;    int8_t activationValue = OH_NN_FUSED_NONE;    OH_NN_Tensor activation = {OH_NN_INT8, 1, &activationDims, nullptr, OH_NN_ADD_ACTIVATIONTYPE};    ret = OH_NNModel_AddTensor(model, &activation);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, add Tensor of activation failed." << std::endl;        return ret;    }
    // 将激活函数类型设置为OH_NN_FUSED_NONE，表示该算子不添加激活函数。    ret = OH_NNModel_SetTensorData(model, 2, &activationValue, sizeof(int8_t));    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, set value of activation failed." << std::endl;        return ret;    }
    // 设置Add算子的输出，类型为float32，张量形状为[1, 2, 2, 3]    OH_NN_Tensor output = {OH_NN_FLOAT32, 4, inputDims, nullptr, OH_NN_TENSOR};    ret = OH_NNModel_AddTensor(model, &output);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, add Tensor of output failed." << std::endl;        return ret;    }
    // 指定Add算子的输入、参数和输出索引    uint32_t inputIndicesValues[2] = {0, 1};    uint32_t paramIndicesValues = 2;    uint32_t outputIndicesValues = 3;    OH_NN_UInt32Array paramIndices = {&paramIndicesValues, 1};    OH_NN_UInt32Array inputIndices = {inputIndicesValues, 2};    OH_NN_UInt32Array outputIndices = {&outputIndicesValues, 1};
    // 向模型实例添加Add算子    ret = OH_NNModel_AddOperation(model, OH_NN_OPS_ADD, &paramIndices, &inputIndices, &outputIndices);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, add operation failed." << std::endl;        return ret;    }
    // 设置模型实例的输入、输出索引    ret = OH_NNModel_SpecifyInputsAndOutputs(model, &inputIndices, &outputIndices);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, specify inputs and outputs failed." << std::endl;        return ret;    }
    // 完成模型实例的构建    ret = OH_NNModel_Finish(model);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed, error happened when finishing model construction." << std::endl;        return ret;    }
    *pModel = model;    return OH_NN_SUCCESS;} 查询Neural Network Runtime已经对接的加速芯片。 Neural Network Runtime支持通过HDI接口，对接多种加速芯片。在执行模型编译前，需要查询当前设备下，Neural Network Runtime已经对接的加速芯片。每个加速芯片对应唯一的ID值，在编译阶段需要通过设备ID，指定模型编译的芯片。 已复制void GetAvailableDevices(std::vector<size_t>& availableDevice){    availableDevice.clear();
    // 获取可用的硬件ID    const size_t* devices = nullptr;    uint32_t deviceCount = 0;    OH_NN_ReturnCode ret = OH_NNDevice_GetAllDevicesID(&devices, &deviceCount);    if (ret != OH_NN_SUCCESS) {        std::cout << "GetAllDevicesID failed, get no available device." << std::endl;        return;    }
    for (uint32_t i = 0; i < deviceCount; i++) {        availableDevice.emplace_back(devices[i]);    }} 在指定的设备上编译模型。 Neural Network Runtime使用抽象的模型表达描述AI模型的拓扑结构，在加速芯片上执行前，需要通过Neural Network Runtime提供的编译模块，将抽象的模型表达下发至芯片驱动层，转换成可以直接推理计算的格式。 已复制OH_NN_ReturnCode CreateCompilation(OH_NNModel* model, const std::vector<size_t>& availableDevice, OH_NNCompilation** pCompilation){    // 创建编译实例，用于将模型传递至底层硬件编译    OH_NNCompilation* compilation = OH_NNCompilation_Construct(model);    if (compilation == nullptr) {        std::cout << "CreateCompilation failed, error happened when creating compilation." << std::endl;        return OH_NN_MEMORY_ERROR;    }
    // 设置编译的硬件、缓存路径、性能模式、计算优先级、是否开启float16低精度计算等选项
    // 选择在第一个设备上编译模型    OH_NN_ReturnCode ret = OH_NNCompilation_SetDevice(compilation, availableDevice[0]);    if (ret != OH_NN_SUCCESS) {        std::cout << "CreateCompilation failed, error happened when setting device." << std::endl;        return ret;    }
    // 将模型编译结果缓存在/data/local/tmp目录下，版本号指定为1    ret = OH_NNCompilation_SetCache(compilation, "/data/local/tmp", 1);    if (ret != OH_NN_SUCCESS) {        std::cout << "CreateCompilation failed, error happened when setting cache path." << std::endl;        return ret;    }
    // 完成编译设置，进行模型编译    ret = OH_NNCompilation_Build(compilation);    if (ret != OH_NN_SUCCESS) {        std::cout << "CreateCompilation failed, error happened when building compilation." << std::endl;        return ret;    }
    *pCompilation = compilation;    return OH_NN_SUCCESS;} 创建执行器。 完成模型编译后，需要调用Neural Network Runtime的执行模块，创建推理执行器。执行阶段，设置模型输入、获取模型输出和触发推理计算的操作均围绕执行器完成。 已复制OH_NNExecutor* CreateExecutor(OH_NNCompilation* compilation){    // 创建执行实例    OH_NNExecutor* executor = OH_NNExecutor_Construct(compilation);    return executor;} 执行推理计算，并打印计算结果。 通过执行模块提供的接口，将推理计算所需要的输入数据传递给执行器，触发执行器完成一次推理计算，获取模型的推理计算结果。 已复制OH_NN_ReturnCode Run(OH_NNExecutor* executor){    // 构造示例数据    float input1[12] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};    float input2[12] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22};
    int32_t inputDims[4] = {1, 2, 2, 3};    OH_NN_Tensor inputTensor1 = {OH_NN_FLOAT32, 4, inputDims, nullptr, OH_NN_TENSOR};    OH_NN_Tensor inputTensor2 = {OH_NN_FLOAT32, 4, inputDims, nullptr, OH_NN_TENSOR};
    // 设置执行的输入
    // 设置执行的第一个输入，输入数据由input1指定    OH_NN_ReturnCode ret = OH_NNExecutor_SetInput(executor, 0, &inputTensor1, input1, DATA_LENGTH);    if (ret != OH_NN_SUCCESS) {        std::cout << "Run failed, error happened when setting first input." << std::endl;        return ret;    }
    // 设置执行的第二个输入，输入数据由input2指定    ret = OH_NNExecutor_SetInput(executor, 1, &inputTensor2, input2, DATA_LENGTH);    if (ret != OH_NN_SUCCESS) {        std::cout << "Run failed, error happened when setting second input." << std::endl;        return ret;    }
    // 设置输出的数据缓冲区，OH_NNExecutor_Run执行计算后，输出结果将保留在output中    float output[12];    ret = OH_NNExecutor_SetOutput(executor, 0, output, DATA_LENGTH);    if (ret != OH_NN_SUCCESS) {        std::cout << "Run failed, error happened when setting output buffer." << std::endl;        return ret;    }
    // 执行计算    ret = OH_NNExecutor_Run(executor);    if (ret != OH_NN_SUCCESS) {        std::cout << "Run failed, error doing execution." << std::endl;        return ret;    }
    // 打印输出结果    for (uint32_t i = 0; i < 12; i++) {        std::cout << "Output index: " << i << ", value is: " << output[i] << "." << std::endl;    }
    return OH_NN_SUCCESS;} 构建端到端模型构造-编译-执行流程。 步骤3-步骤7实现了模型的模型构造、编译和执行流程，并封装成4个函数，便于模块化开发。以下示例代码将4个函数串联成完整的Neural Network Runtime开发流程。 已复制int main(){    OH_NNModel* model = nullptr;    OH_NNCompilation* compilation = nullptr;    OH_NNExecutor* executor = nullptr;    std::vector<size_t> availableDevices;
    // 模型构造阶段    OH_NN_ReturnCode ret = BuildModel(&model);    if (ret != OH_NN_SUCCESS) {        std::cout << "BuildModel failed." << std::endl;        OH_NNModel_Destroy(&model);        return -1;    }
    // 获取可执行的设备    GetAvailableDevices(availableDevices);    if (availableDevices.empty()) {        std::cout << "No available device." << std::endl;        OH_NNModel_Destroy(&model);        return -1;    }
    // 模型编译阶段    ret = CreateCompilation(model, availableDevices, &compilation);    if (ret != OH_NN_SUCCESS) {        std::cout << "CreateCompilation failed." << std::endl;        OH_NNModel_Destroy(&model);        OH_NNCompilation_Destroy(&compilation);        return -1;    }
    // 创建模型的推理执行器    executor = CreateExecutor(compilation);    if (executor == nullptr) {        std::cout << "CreateExecutor failed, no executor is created." << std::endl;        OH_NNModel_Destroy(&model);        OH_NNCompilation_Destroy(&compilation);        return -1;    }
    // 使用上一步创建的执行器，执行单步推理计算    ret = Run(executor);    if (ret != OH_NN_SUCCESS) {        std::cout << "Run failed." << std::endl;        OH_NNModel_Destroy(&model);        OH_NNCompilation_Destroy(&compilation);        OH_NNExecutor_Destroy(&executor);        return -1;    }
    // 释放申请的资源    OH_NNModel_Destroy(&model);    OH_NNCompilation_Destroy(&compilation);    OH_NNExecutor_Destroy(&executor);
    return 0;}   调测验证准备应用样例的编译配置文件。 新建一个 CMakeLists.txt 文件，为开发步骤中的应用样例文件 nnrt_example.cpp 添加编译配置。以下提供简单的 CMakeLists.txt 示例： 已复制cmake_minimum_required(VERSION 3.16)project(nnrt_example C CXX)
add_executable(nnrt_example    ./nnrt_example.cpp)
target_link_libraries(nnrt_example    neural_network_runtime.z) 编译应用样例。 执行以下命令，在当前目录下新建build/目录，在build/目录下编译 nnrt_example.cpp，得到二进制文件 nnrt_example。 已复制mkdir build && cd buildcmake -DCMAKE_TOOLCHAIN_FILE={交叉编译工具链的路径}/build/cmake/ohos.toolchain.cmake -DOHOS_ARCH=arm64-v8a -DOHOS_PLATFORM=OHOS -DOHOS_STL=c++_static ..make 执行以下代码，将样例推送到设备上执行。 已复制# 将编译得到的 `nnrt_example` 推送到设备上，执行样例。hdc_std file send ./nnrt_example /data/local/tmp/.# 给测试用例可执行文件加上权限。hdc_std shell "chmod +x /data/local/tmp/nnrt_example"# 执行测试用例hdc_std shell "/data/local/tmp/nnrt_example" 如果样例执行正常，应该得到以下输出。 已复制Output index: 0, value is: 11.000000.Output index: 1, value is: 13.000000.Output index: 2, value is: 15.000000.Output index: 3, value is: 17.000000.Output index: 4, value is: 19.000000.Output index: 5, value is: 21.000000.Output index: 6, value is: 23.000000.Output index: 7, value is: 25.000000.Output index: 8, value is: 27.000000.Output index: 9, value is: 29.000000.Output index: 10, value is: 31.000000.Output index: 11, value is: 33.000000. 检查模型缓存（可选）。 如果在调测环境下，Neural Network Runtime对接的HDI服务支持模型缓存功能，执行完 nnrt_example, 可以在 /data/local/tmp 目录下找到生成的缓存文件。 
说明
模型的IR需要传递到硬件驱动层，由HDI服务将统一的IR图，编译成硬件专用的计算图，编译的过程非常耗时。Neural Network Runtime支持计算图缓存的特性，可以将HDI服务编译生成的计算图，缓存到设备存储中。当下一次在同一个加速芯片上编译同一个模型时，通过指定缓存的路径，Neural Network Runtime可以直接加载缓存文件中的计算图，减少编译消耗的时间。 
 检查缓存目录下的缓存文件： 已复制ls /data/local/tmp 以下为打印结果： 已复制# 0.nncache  cache_info.nncache 如果缓存不再使用，需要手动删除缓存，可以参考以下命令，删除缓存文件。 已复制rm /data/local/tmp/*nncache    上一篇 使用MindSpore Lite引擎进行模型推理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HashMapHashSetTreeMapTreeSetLightWeightMapLightWeightSetPlainArray非线性容器的使用非线性容器 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。  HashMap HashMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。 HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容大小为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。 HashMap和TreeMap相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。 HashSet基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只对value对象进行处理。 需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。 HashMap进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过set(key: K, value: V)函数每次在HashMap增加一个键值对。   访问元素 通过get(key: K)获取key对应的value值。   通过keys()返回一个迭代器对象，包含map中的所有key值。   通过values()返回一个迭代器对象，包含map中的所有value值。   通过entries()返回一个迭代器对象，包含map中的所有键值对。   forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object)访问整个map的元素。   通过[Symbol.iterator]():IterableIterator<[K,V]>迭代器进行数据访问。   修改元素 通过replace(key: K, newValue: V)对指定key对应的value值进行修改操作。   通过forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object)对map中元素进行修改操作。   删除元素 通过remove(key: K)对map中匹配到的键值对进行删除操作。   通过clear()清空整个map集合。      HashSet HashSet可用来存储一系列值的集合，存储元素中value是唯一的。 HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容大小为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet底层数据结构基于HashTable实现，冲突策略采用链地址法。 HashSet基于HashMap实现。在HashSet中，只对value对象进行处理。 HashSet和TreeSet相比，HashSet中的数据无序存放，即存放元素的顺序和取出的顺序不一致，而TreeSet是有序存放。它们集合中的元素都不允许重复，但HashSet允许放入null值，TreeSet不建议插入空值，可能会影响排序结果。 可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。 HashSet进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(value: T)函数每次在HashSet增加一个值。   访问元素 通过values()返回一个迭代器对象，包含set中的所有value值。   通过entries()返回一个迭代器对象，包含类似键值对的数组，键值都是value。   通过forEach(callbackFn: (value?: T, key?: T, set?: HashSet<T>) => void, thisArg?: Object)访问整个set的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过forEach(callbackFn: (value?: T, key?: T, set?: HashSet<T>) => void, thisArg?: Object)对set中value进行修改操作。   删除元素 通过remove(value: T)对set中匹配到的值进行删除操作。   通过clear()清空整个set集合。      TreeMap TreeMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。 TreeMap依据泛型定义，集合中的key值是有序的，TreeMap的底层是一棵二叉树，可以通过树的二叉查找快速的找到键值对。key的类型满足ECMA标准中要求的类型。TreeMap中的键值是有序存储的。TreeMap底层基于红黑树实现，可以进行快速的插入和删除。 TreeMap和HashMap相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。 一般需要存储有序键值对的场景，可以使用TreeMap。 TreeMap进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过set(key: K,value: V)函数每次在TreeMap增加一个键值对。   访问元素 通过get(key: K)获取key对应的value值。   通过getFirstKey()获取map中排在首位的key值。   通过getLastKey()获取map中排在未位的key值。   通过keys()返回一个迭代器对象，包含map中的所有key值。   通过values()返回一个迭代器对象，包含map中的所有value值。   通过entries()返回一个迭代器对象，包含map中的所有键值对。   通过forEach(callbackFn: (value?: V, key?: K, map?: TreeMap<K, V>) => void, thisArg?: Object)访问整个map的元素。   通过[Symbol.iterator]():IterableIterator<[K,V]>迭代器进行数据访问。   修改元素 通过replace(key: K,newValue: V)对指定key对应的value值进行修改操作。   通过forEach(callbackFn: (value?: V, key?: K, map?: TreeMap<K, V>) => void, thisArg?: Object)对map中元素进行修改操作。   删除元素 通过remove(key: K)对map中匹配到的键值对进行删除操作。   通过clear()清空整个map集合。      TreeSet TreeSet可用来存储一系列值的集合，存储元素中value是唯一的。 TreeSet依据泛型定义，集合中的value值是有序的，TreeSet的底层是一棵二叉树，可以通过树的二叉查找快速的找到该value值，value的类型满足ECMA标准中要求的类型。TreeSet中的值是有序存储的。TreeSet底层基于红黑树实现，可以进行快速的插入和删除。 TreeSet基于TreeMap实现，在TreeSet中，只对value对象进行处理。TreeSet可用于存储一系列值的集合，元素中value唯一且有序。 TreeSet和HashSet相比，HashSet中的数据无序存放，而TreeSet是有序存放。它们集合中的元素都不允许重复，但HashSet允许放入null值，TreeSet不建议插入空值，可能会影响排序结果。 一般需要存储有序集合的场景，可以使用TreeSet。 TreeSet进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(value: T)函数每次在TreeSet增加一个值。   访问元素 通过values()返回一个迭代器对象，包含set中的所有value值。   通过entries()返回一个迭代器对象，包含类似键值对的数组，键值都是value。   通过getFirstValue()获取set中排在首位的value值。   通过getLastValue()获取set中排在未位的value值。   通过forEach(callbackFn: (value?: T, key?: T, set?: TreeSet<T>) => void, thisArg?: Object)访问整个set的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过forEach(callbackFn: (value?: T, key?: T, set?: TreeSet<T>) => void, thisArg?: Object)对set中value进行修改操作。   删除元素 通过remove(value: T)对set中匹配到的值进行删除操作。   通过clear()清空整个set集合。      LightWeightMap LightWeightMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用更加轻量级的结构，底层标识唯一key通过hash实现，其冲突策略为线性探测法。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准中要求的类型。 初始默认容量大小为8，每次扩容大小为原始容量的2倍。 LightWeightMap和HashMap都是用来存储键值对的集合，LightWeightMap占用内存更小。 当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。 LightWeightMap进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过set(key: K,value: V)函数每次在LightWeightMap增加一个键值对。   访问元素 通过get(key: K)获取key对应的value值。   通过getIndexOfKey(key: K)获取map中指定key的index。   通过getIndexOfValue(value: V)获取map中指定value出现的第一个的index。   通过keys()返回一个迭代器对象，包含map中的所有key值。   通过values()返回一个迭代器对象，包含map中的所有value值。   通过entries()返回一个迭代器对象，包含map中的所有键值对。   通过getKeyAt(index: number)获取指定index对应的key值。   通过getValueAt(index: number)获取指定index对应的value值。   通过forEach(callbackFn: (value?: V, key?: K, map?: LightWeightMap<K, V>) => void, thisArg?: Object)访问整个map的元素。   通过[Symbol.iterator]():IterableIterator<[K,V]>迭代器进行数据访问。   修改元素 通过setValueAt(index: number, newValue: V)对指定index对应的value值进行修改操作。   通过forEach(callbackFn: (value?: V, key?: K, map?: LightWeightMap<K, V>) => void, thisArg?: Object)对map中元素进行修改操作。   删除元素 通过remove(key: K)对map中匹配到的键值对进行删除操作。   通过removeAt(index: number)对map中指定index的位置进行删除操作。   通过clear()清空整个map集合。      LightWeightSet LightWeightSet可用来存储一系列值的集合，存储元素中value是唯一的。 LightWeightSet依据泛型定义，采用更加轻量级的结构，初始默认容量大小为8，每次扩容大小为原始容量的2倍。集合中的value值的查找依赖于hash以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的value值，value的类型满足ECMA标准中要求的类型。 LightWeightSet底层标识唯一value基于hash实现，其冲突策略为线性探测法，查找策略基于二分查找法。 LightWeightSet和HashSet都是用来存储键值的集合，LightWeightSet的占用内存更小。 当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。 LightWeightSet进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(obj: T)函数每次在LightWeightSet增加一个值。   访问元素 通过getIndexOf(key: T)获取对应的index值。   通过values()返回一个迭代器对象，包含map中的所有value值。   通过entries()返回一个迭代器对象，包含map中的所有键值对。   通过getValueAt(index: number)获取指定index对应的value值。   通过forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet<T>) => void, thisArg?: Object)访问整个set的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet<T>) => void, thisArg?: Object)对set中元素进行修改操作。   删除元素 通过remove(key: K)对set中匹配到的键值对进行删除操作。   通过removeAt(index: number)对set中指定index的位置进行删除操作。   通过clear()清空整个set集合。      PlainArray PlainArray可用来存储具有关联关系的键值对集合，存储元素中key是唯一的，并且对于PlainArray来说，其key的类型为number类型。每个key会对应一个value值，类型依据泛型的定义，PlainArray采用更加轻量级的结构，集合中的key值的查找依赖于二分查找算法，然后映射到其他数组中的value值。 初始默认容量大小为16，每次扩容大小为原始容量的2倍。 PlainArray和LightWeightMap都是用来存储键值对，且均采用轻量级结构，但PlainArray的key值类型只能为number类型。 当需要存储key值为number类型的键值对时，可以使用PlainArray。 PlainArray进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(key: number,value: T)函数每次在PlainArray增加一个键值对。   访问元素 通过get(key: number)获取key对应的value值。   通过getIndexOfKey(key: number)获取PlainArray中指定key的index。   通过getIndexOfValue(value: T)获取PlainArray中指定value的index。   通过getKeyAt(index: number)获取指定index对应的key值。   通过getValueAt(index: number)获取指定index对应的value值。   通过forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray<T>) => void, thisArg?: Object)访问整个plainarray的元素。   通过[Symbol.iterator]():IterableIterator<[number, T]>迭代器进行数据访问。   修改元素 通过setValueAt(index:number, value: T)对指定index对应的value值进行修改操作。   通过forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray<T>) => void, thisArg?: Object)对plainarray中元素进行修改操作。   删除元素 通过remove(key: number)对plainarray中匹配到的键值对进行删除操作。   通过removeAt(index: number)对plainarray中指定index的位置进行删除操作。   通过removeRangeFrom(index: number, size: number)对plainarray中指定范围内的元素进行删除操作。   通过clear()清空整个PlainArray集合。      非线性容器的使用 此处列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素及修改等操作，示例代码如下所示： 已复制// HashMapimport HashMap from '@ohos.util.HashMap'; // 导入HashMap模块
let hashMap = new HashMap();hashMap.set('a', 123);hashMap.set(4, 123); // 增加元素console.info(`result: ${hashMap.hasKey(4)}`); // 判断是否含有某元素console.info(`result: ${hashMap.get('a')}`); // 访问元素
// TreeMapimport TreeMap from '@ohos.util.TreeMap'; // 导入TreeMap模块
let treeMap = new TreeMap();treeMap.set('a', 123);treeMap.set('6', 356); // 增加元素console.info(`result: ${treeMap.get('a')}`); // 访问元素console.info(`result: ${treeMap.getFirstKey()}`); // 访问首元素console.info(`result: ${treeMap.getLastKey()}`); // 访问尾元素
// LightWeightMapimport LightWeightMap from '@ohos.util.LightWeightMap'; // 导入LightWeightMap模块
let lightWeightMap = new LightWeightMap();lightWeightMap.set('x', 123);lightWeightMap.set('8', 356); // 增加元素console.info(`result: ${lightWeightMap.get('a')}`); // 访问元素console.info(`result: ${lightWeightMap.get('x')}`); // 访问元素console.info(`result: ${lightWeightMap.getIndexOfKey('8')}`); // 访问元素
// PlainArrayimport PlainArray from '@ohos.util.PlainArray' // 导入PlainArray模块
let plainArray = new PlainArray();plainArray.add(1, 'sdd');plainArray.add(2, 'sff'); // 增加元素console.info(`result: ${plainArray.get(1)}`); // 访问元素console.info(`result: ${plainArray.getKeyAt(1)}`); // 访问元素   上一篇 线性容器 下一篇 XML生成、解析与转换 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。通知简介通知业务流程通知概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 通知简介应用可以通过通知接口发送通知消息，终端用户可以通过通知栏查看通知内容，也可以点击通知来打开应用。 通知常见的使用场景： 显示接收到的短消息、即时消息等。 显示应用的推送消息，如广告、版本更新等。 显示当前正在进行的事件，如下载等。  HarmonyOS通过ANS（Advanced Notification Service，通知系统服务）对通知类型的消息进行管理，支持多种通知类型，如基础类型通知、进度条类型通知。  通知业务流程通知业务流程由通知子系统、通知发送端、通知订阅端组成。一条通知从通知发送端产生，通过IPC通信发送到通知子系统，再由通知子系统分发给通知订阅端。 通知发送端：可以是三方应用或系统应用。开发者重点关注。 通知订阅端：只能为系统应用，比如通知中心。通知中心默认会订阅手机上所有应用对当前用户的通知。开发者无需关注。     上一篇 通知 下一篇 发布通知 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发步骤为通知添加行为意图 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  WantAgent提供了封装行为意图的能力，这里所说的行为意图主要是指拉起指定的应用组件及发布公共事件等能力。HarmonyOS支持以通知的形式，将WantAgent从发布方传递至接收方，从而在接收方触发WantAgent中指定的意图。例如，在通知消息的发布者发布通知时，通常期望用户可以通过通知栏点击拉起目标应用组件。为了达成这一目标，开发者可以将WantAgent封装至通知消息中，当系统接收到WantAgent后，在用户点击通知栏时触发WantAgent的意图，从而拉起目标应用组件。 为通知添加行为意图的实现方式如下图所示：发布通知的应用向应用组件管理服务AMS（Ability Manager Service）申请WantAgent，然后随其他通知信息一起发送给桌面，当用户在桌面通知栏上点击通知时，触发WantAgent动作。 图1 携带行为意图的通知运行机制   接口说明 具体接口描述，详见WantAgent接口文档。     接口名 描述    getWantAgent(info: WantAgentInfo, callback: AsyncCallback<WantAgent>): void 创建WantAgent。   trigger(agent: WantAgent, triggerInfo: TriggerInfo, callback?: Callback<CompleteData>): void 触发WantAgent意图。   cancel(agent: WantAgent, callback: AsyncCallback<void>): void 取消WantAgent。   getWant(agent: WantAgent, callback: AsyncCallback<Want>): void 获取WantAgent的want。   equal(agent: WantAgent, otherAgent: WantAgent, callback: AsyncCallback<boolean>): void 判断两个WantAgent实例是否相等。      开发步骤  导入模块。 已复制import NotificationManager from '@ohos.notificationManager';import wantAgent from '@ohos.app.ability.wantAgent'; 创建WantAgentInfo信息。 场景一：创建拉起Ability的WantAgent的WantAgentInfo信息。 已复制let wantAgentObj = null; // 用于保存创建成功的wantAgent对象，后续使用其完成触发的动作。
// 通过WantAgentInfo的operationType设置动作类型。let wantAgentInfo = {    wants: [        {            deviceId: '',            bundleName: 'com.example.test',            abilityName: 'com.example.test.MainAbility',            action: '',            entities: [],            uri: '',            parameters: {}        }    ],    operationType: wantAgent.OperationType.START_ABILITY,    requestCode: 0,    wantAgentFlags:[wantAgent.WantAgentFlags.CONSTANT_FLAG]} 场景二：创建发布公共事件的WantAgent的WantAgentInfo信息。 已复制let wantAgentObj = null; // 用于保存创建成功的WantAgent对象，后续使用其完成触发的动作。
// wantAgentInfolet wantAgentInfo = {    wants: [        {            action: 'event_name', // 设置事件名。            parameters: {},        }    ],    operationType: wantAgent.OperationType.SEND_COMMON_EVENT,    requestCode: 0,    wantAgentFlags: [wantAgent.WantAgentFlags.CONSTANT_FLAG],} 创建WantAgent。 已复制// 创建WantAgentwantAgent.getWantAgent(wantAgentInfo, (err, data) => {    if (err) {        console.error('[WantAgent]getWantAgent err=' + JSON.stringify(err));    } else {        console.info('[WantAgent]getWantAgent success');        wantAgentObj = data;    }}); 构造NotificationRequest对象。 已复制// 构造NotificationRequest对象let notificationRequest = {    content: {        contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,        normal: {            title: 'Test_Title',            text: 'Test_Text',            additionalText: 'Test_AdditionalText',        },    },    id: 1,    label: 'TEST',    wantAgent: wantAgentObj,} 发布WantAgent通知。 已复制// 通知发送NotificationManager.publish(notificationRequest, (err) => {    if (err) {        console.error(`[ANS] failed to publish, error[${err}]`);        return;    }    console.info(`[ANS] publish success `);}); 用户通过点击通知栏上的通知，即可触发WantAgent的动作。    上一篇 发布进度条类型通知 下一篇 窗口管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。调试流程配置签名信息调试设置设置调试代码类型设置HAP安装方式设置多HAP安装启动调试断点管理调试OpenHarmony应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 调试流程DevEco Studio提供了丰富的OpenHarmony应用/服务调试能力，帮助开发者更方便、高效的调试应用/服务。 OpenHarmony应用/服务调试支持使用真机设备调试。使用真机设备进行调试前，需要对HAP进行签名后进行调试。详细的调试流程如下图所示：    配置签名信息DevEco Studio为开发者提供了自动化签名方案，可以一键完成应用/服务签名。具体操作如下： 单击File > Project Structure > Project > Signing Configs界面勾选“Automatically generate signature”，等待自动签名完成即可，单击“OK”。如下图所示：
说明
如果您的应用/服务使用了“system_basic”和“system_core”权限，请参考修改应用APL等级修改签名模板。您使用到的应用权限，可以在自动化签名完成后，单击Show Restricted Permissions进行查看。 
    调试设置 设置调试代码类型OpenHarmony支持ArkTS、JS和C/C++代码调试，默认情况下调试器支持的调试类型为Detect Automatically。调试类型包括如下几种： 表1 调试类型配置项调试类型  调试代码    Js Only  调试ArkTS和JS代码   Native Only  仅调试C/C++代码   Dual(Js + Native)  调试C/C++工程的ArkTS/JS和C/C++代码   Detect Automatically  新建工程默认调试器选项，根据调试的工程类型，自动启动对应的调试器。     修改调试类型的方法如下。 点击Run > Edit Configurations > Debugger，在OpenHarmony App中，选择相应模块，设置Debug type即可。   设置HAP安装方式在调试阶段，HAP在设备上的安装方式有2种，可以根据实际需要进行设置。 安装方式一：先卸载应用/服务后，再重新安装，该方式会清除设备上的所有应用/服务缓存数据（默认安装方式）。安装方式二：采用覆盖安装方式，不卸载应用/服务，该方式会保留应用/服务的缓存数据。 设置方法如下： 单击Run > Edit Configurations，设置指定模块的HAP安装方式，勾选 Keep Application Data，则表示采用覆盖安装方式，保留应用/服务缓存数据。   设置多HAP安装如果工程中同时存在多个模块，且您的应用/服务存在跨模块间的调用时，在调试阶段需要同时安装多个模块的HAP到设备中。此时，需要在Deploy Multi Hap中选择多个模块，启动调试时，DevEco Studio会将所有的模块都安装到设备上。 设置方法如下： 单击Run > Edit Configurations，在Deploy Multi Hap中，勾选Deploy Multi Hap Packages，选择多个模块。  在启动调试时，请选择勾选了Deploy Multi Hap Packages的模块（如上图中的entry），然后再启动调试。   启动调试在工具栏中，选择调试的设备，并单击Debug 或Attach Debugger to Process启动调试。
说明
Debug和Attach Debugger的区别在于，Attach Debugger to Process需要先运行应用/服务，然后再启动调试，或者直接启动设备上已安装的应用/服务进行调试；而Debug是直接运行应用/服务后立即启动调试。 
  如果需要设置断点调试，则需要选定要设置断点的有效代码行，在行号（比如：第5行）的区域后，单击鼠标左键设置断点（如图示的红点）。  设置断点后，调试能够在正确的断点处中断，并高亮显示该行。 启动调试后，开发者可以通过调试器进行代码调试。调试器的功能说明如下表所示： 表2 调试器按钮按钮  名称  快捷键  功能      Resume Program  F9（macOS为Option+Command+R）  当程序执行到断点时停止执行，单击此按钮程序继续执行。     Step Over  F8（macOS为F8）  在单步调试时，直接前进到下一行（如果在函数中存在子函数时，不会进入子函数内单步执行，而是将整个子函数当作一步执行）。     Step Into  F7（macOS为F7）  在单步调试时，遇到子函数后，进入子函数并继续单步执行。     Step Out  Shift+F8（macOS为Shift+F8）  在单步调试执行到子函数内时，单击Step Out会执行完子函数剩余部分，并跳出返回到上一层函数。     Stop  Ctrl+F2（macOS为Command+F2）  停止调试任务。     Run To Cursor  Alt+F9（macOS为Option+F9）  断点执行到鼠标停留处。       断点管理在设置的程序断点红点处，单击鼠标右键，然后单击More或按快捷键Ctrl+Shift+F8（macOS为Shift+Command+F8），可以管理断点。  表3 不同代码类型的断点管理功能代码类型  断点管理    JS（JS）、ArkTS  普通行断点Exception（异常）断点   C/C++  普通行断点Exception（异常）断点Symbolic（符号）断点       上一篇 使用模拟器进行调试 下一篇 变量可视化调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。配置签名信息运行应用/服务运行OpenHarmony应用/服务运行 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 配置签名信息应用/服务在真机设备上运行，需要提前为应用/服务进行签名，DevEco Studio为开发者提供了自动化签名方案，可以一键完成应用/服务签名。具体操作如下： 单击File > Project Structure > Project > Signing Configs界面勾选Automatically generate signature，等待自动签名完成即可，单击OK。如下图所示：
说明
如果您的应用/服务使用了“system_basic”和“system_core”权限，请参考修改应用权限等级修改签名模板。您使用到的应用权限，可以在自动化签名完成后，单击Show Restricted Permissions进行查看。 
    运行应用/服务安装OpenHarmony应用可以通过DevEco Studio安装，也可以通过使用hdc_std工具（API 9工程中该工具名称为hdc）进行手动安装。 通过DevEco Studio安装：将设备连接上DevEco Studio后，单击按钮即可安装。 通过hdc_std工具安装：手动执行命令行完成应用的安装。hdc_std工具本身需要手动从开源仓中获取。然后使用工具命令将编译后的HAP安装到设备上。 相关命令如下： 安装命令install [-r/-d/-g] package 命令示例： 已复制hdc_std install E:\ohos-admin.hap 日志抓取命令hilog 命令示例： 已复制hdc_std hilog  完整的hdc_std工具使用指导及命令格式请参见hdc_std使用指导。    上一篇 使用远程真机运行应用/服务 下一篇 应用/服务调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。PageAbility组件配置 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 PageAbility的相关配置在config.json配置文件的"module"对象的"abilities"对象中，"icon"属性表示Ability图标资源文件的索引，"lable"属性表示Ability对用户显示的名称，"skills"属性表示Ability能够接收的want的特征。  表1 PageAbility部分配置项说明 属性名称 含义 数据类型 是否可缺省   icon 表示Ability图标资源文件的索引。取值示例：$media:ability_icon。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的icon将同时作为应用的icon。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon作为应用的icon。 说明：应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。  字符串 可缺省，缺省值为空。  label 表示Ability对用户显示的名称。取值可以是Ability名称，也可以是对该名称的资源索引，以支持多语言。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的label将同时作为应用的label。如果存在多个符合条件的Ability，则取位置靠前的Ability的label作为应用的label。 说明： 应用的"icon"和"label"是用户可感知配置项，需要区别于当前所有已有的应用"icon"或"label"（至少有一个不同）。该标签为资源文件中定义的字符串的引用，或以"{}"包括的字符串。该标签最大长度为255字节。  字符串 可缺省，缺省值为空。  skills 表示Ability能够接收的want的特征。 对象数组 可缺省，缺省值为空。     上一篇 PageAbility组件概述 下一篇 PageAbility的生命周期 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。PageAbility的启动模式 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 启动模式对应PageAbility被启动时的行为，支持单实例模式、标准模式两种启动模式。  表1 PageAbility的启动模式 启动模式 描述 说明   singleton 单实例模式 每次调用startAbility方法时，如果应用进程中该类型的Ability实例已经存在，则复用已有的实例，系统中只存在唯一一个实例。表现为在最近任务列表中只有一个Ability实例。 典型场景：当用户打开视频播放应用并观看视频，回到桌面后，再次打开视频播放应用，应用仍为回到桌面之前正在观看的视频。   standard 标准模式 缺省启动模式。每次调用startAbility方法时，都会在应用进程中创建一个新的Ability实例。表现为在最近任务列表中可以看到有多个该类型的Ability实例。 典型场景：当用户打开文档应用，选择新建文档的时候，每次点击新建文档，都会创建一个新的文档任务，在最近任务列表中可以看到多个新建的文档任务。     应用开发者可在config.json配置文件中通过“launchType”配置启动模式。示例如下： 已复制{  "module": {    // ...    "abilities": [      {        // singleton: 单实例模式        // standard: 标准模式        "launchType": "standard",        // ...      }    ]  }} 启动PageAbility时，对于标准启动模式（多实例启动模式）以及单实例启动模式首次启动，PageAbility生命周期回调均会被触发。单实例非首次启动时不会再触发onCreate()接口，而是触发onNewWant()，onNewWant()的说明如下表2所示。  表2 单实例启动模式特有的回调函数说明 接口名 接口描述   onNewWant(want: Want) 单实例启动模式，PageAbility非首次启动时调用onNewWant方法，开发者可以在该方法中获取want，进而根据want做进一步处理。例如，单实例PageAbility迁移场景，指定页面拉起PageAbility场景。     上一篇 PageAbility的生命周期 下一篇 创建PageAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。PageAbility的生命周期 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 PageAbility生命周期是PageAbility被调度到INACTIVE、ACTIVE、BACKGROUND等各个状态的统称。PageAbility生命周期流转及状态说明见如下图1、表1所示。  图1 PageAbility生命周期流转   表1 PageAbility生命周期状态说明 生命周期状态 生命周期状态说明   UNINITIALIZED 未初始状态，为临时状态，PageAbility被创建后会由UNINITIALIZED状态进入INITIAL状态。  INITIAL 初始化状态，也表示停止状态，表示当前PageAbility未运行，PageAbility被启动后由INITIAL态进入INACTIVE状态。  INACTIVE 失去焦点状态，表示当前窗口已显示但是无焦点状态。  ACTIVE 前台激活状态，表示当前窗口已显示，并获取焦点。  BACKGROUND 后台状态，表示当前PageAbility退到后台，PageAbility在被销毁后由BACKGROUND状态进入INITIAL状态，或者重新被激活后由BACKGROUND状态进入ACTIVE状态。    应用开发者可以在app.js/app.ets中重写生命周期相关回调函数，PageAbility生命周期相关回调函数见下表。  表2 PageAbility生命周期回调接口说明 接口名 接口描述   onCreate() Ability第一次启动创建Ability时调用onCreate方法，开发者可以在该方法里做一些应用初始化工作。  onDestroy() 应用退出，销毁Ability对象前调用onDestroy方法，开发者可以在该方法里做一些回收资源、清空缓存等应用退出前的准备工作。  onActive() Ability切换到前台，并且已经获取焦点时调用onActive方法。  onInactive() Ability失去焦点时调用onInactive方法，Ability在进入后台状态时会先失去焦点，再进入后台。  onShow() Ability由后台不可见状态切换到前台可见状态调用onShow方法，此时用户在屏幕可以看到该Ability。  onHide() Ability由前台切换到后台不可见状态时调用onHide方法，此时用户在屏幕看不到该Ability。    PageAbility生命周期回调与生命周期状态的关系如下图所示。  图2 PageAbility生命周期回调与生命周期状态的关系  
说明
 1、PageAbility的生命周期回调均为同步接口。 2、目前app.js环境中仅支持onCreate和onDestroy回调，app.ets环境支持全量生命周期回调。 
  上一篇 PageAbility组件配置 下一篇 PageAbility的启动模式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。PageAbility组件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 PageAbility是包含UI界面、提供展示UI能力的应用组件，主要用于与用户交互。 开发者通过DevEco Studio开发平台创建PageAbility时，DevEco Studio会自动创建相关模板代码。PageAbility相关能力通过单独的featureAbility实现，生命周期相关回调则通过app.js/app.ets中各个回调函数实现。  上一篇 PageAbility组件开发指导 下一篇 PageAbility组件配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ohos.permission.USE_BLUETOOTHohos.permission.DISCOVER_BLUETOOTHohos.permission.MANAGE_BLUETOOTHohos.permission.INTERNETohos.permission.MODIFY_AUDIO_SETTINGSohos.permission.ACCESS_NOTIFICATION_POLICYohos.permission.GET_TELEPHONY_STATEohos.permission.REQUIRE_FORMohos.permission.GET_NETWORK_INFOohos.permission.PLACE_CALLohos.permission.SET_NETWORK_INFOohos.permission.REMOVE_CACHE_FILESohos.permission.REBOOTohos.permission.RUNNING_LOCKohos.permission.SET_TIMEohos.permission.SET_TIME_ZONEohos.permission.DOWNLOAD_SESSION_MANAGERohos.permission.COMMONEVENT_STICKYohos.permission.SYSTEM_FLOAT_WINDOWohos.permission.PRIVACY_WINDOWohos.permission.POWER_MANAGERohos.permission.REFRESH_USER_ACTIONohos.permission.POWER_OPTIMIZATIONohos.permission.REBOOT_RECOVERYohos.permission.MANAGE_LOCAL_ACCOUNTSohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTSohos.permission.VIBRATEohos.permission.CONNECT_IME_ABILITYohos.permission.CONNECT_SCREEN_SAVER_ABILITYohos.permission.READ_SCREEN_SAVERohos.permission.WRITE_SCREEN_SAVERohos.permission.SET_WALLPAPERohos.permission.GET_WALLPAPERohos.permission.CHANGE_ABILITY_ENABLED_STATEohos.permission.ACCESS_MISSIONSohos.permission.CLEAN_BACKGROUND_PROCESSESohos.permission.KEEP_BACKGROUND_RUNNINGohos.permission.UPDATE_CONFIGURATIONohos.permission.UPDATE_SYSTEMohos.permission.FACTORY_RESETohos.permission.GRANT_SENSITIVE_PERMISSIONSohos.permission.REVOKE_SENSITIVE_PERMISSIONSohos.permission.GET_SENSITIVE_PERMISSIONSohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS_EXTENSIONohos.permission.LISTEN_BUNDLE_CHANGEohos.permission.GET_BUNDLE_INFOohos.permission.GET_BUNDLE_INFO_PRIVILEGEDohos.permission.ACCELEROMETERohos.permission.GYROSCOPEohos.permission.INSTALL_BUNDLEohos.permission.MANAGE_SHORTCUTSohos.permission.radio.ACCESS_FM_AMohos.permission.SET_TELEPHONY_STATEohos.permission.START_ABILITIES_FROM_BACKGROUNDohos.permission.BUNDLE_ACTIVE_INFOohos.permission.START_INVISIBLE_ABILITYohos.permission.sec.ACCESS_UDIDohos.permission.LAUNCH_DATA_PRIVACY_CENTERohos.permission.MANAGE_MEDIA_RESOURCESohos.permission.PUBLISH_AGENT_REMINDERohos.permission.CONTROL_TASK_SYNC_ANIMATORohos.permission.INPUT_MONITORINGohos.permission.MANAGE_MISSIONSohos.permission.NOTIFICATION_CONTROLLERohos.permission.CONNECTIVITY_INTERNALohos.permission.SET_ABILITY_CONTROLLERohos.permission.USE_USER_IDMohos.permission.MANAGE_USER_IDMohos.permission.ACCESS_BIOMETRICohos.permission.ACCESS_USER_AUTH_INTERNALohos.permission.ACCESS_PIN_AUTHohos.permission.GET_RUNNING_INFOohos.permission.CLEAN_APPLICATION_DATAohos.permission.RUNNING_STATE_OBSERVERohos.permission.CAPTURE_SCREENohos.permission.GET_WIFI_INFOohos.permission.GET_WIFI_INFO_INTERNALohos.permission.SET_WIFI_INFOohos.permission.GET_WIFI_PEERS_MACohos.permission.GET_WIFI_LOCAL_MACohos.permission.GET_WIFI_CONFIGohos.permission.SET_WIFI_CONFIGohos.permission.MANAGE_WIFI_CONNECTIONohos.permission.MANAGE_WIFI_HOTSPOTohos.permission.GET_ALL_APP_ACCOUNTSohos.permission.MANAGE_SECURE_SETTINGSohos.permission.READ_DFX_SYSEVENTohos.permission.MANAGE_ENTERPRISE_DEVICE_ADMINohos.permission.SET_ENTERPRISE_INFOohos.permission.ENTERPRISE_SUBSCRIBE_MANAGED_EVENTohos.permission.ENTERPRISE_SET_DATETIMEohos.permission.ENTERPRISE_GET_DEVICE_INFOohos.permission.NFC_TAGohos.permission.NFC_CARD_EMULATIONohos.permission.PERMISSION_USED_STATSohos.permission.NOTIFICATION_AGENT_CONTROLLERohos.permission.ANSWER_CALLohos.permission.READ_CALENDARohos.permission.READ_CALL_LOGohos.permission.READ_CELL_MESSAGESohos.permission.READ_CONTACTSohos.permission.READ_MESSAGESohos.permission.RECEIVE_MMSohos.permission.RECEIVE_SMSohos.permission.RECEIVE_WAP_MESSAGESohos.permission.MICROPHONEohos.permission.SEND_MESSAGESohos.permission.WRITE_CALENDARohos.permission.WRITE_CALL_LOGohos.permission.WRITE_CONTACTSohos.permission.DISTRIBUTED_DATASYNCohos.permission.MANAGE_VOICEMAILohos.permission.LOCATION_IN_BACKGROUNDohos.permission.LOCATIONohos.permission.APPROXIMATELY_LOCATIONohos.permission.MEDIA_LOCATIONohos.permission.CAMERAohos.permission.READ_MEDIAohos.permission.WRITE_MEDIAohos.permission.ACTIVITY_MOTIONohos.permission.READ_HEALTH_DATAohos.permission.GET_DEFAULT_APPLICATIONohos.permission.SET_DEFAULT_APPLICATIONohos.permission.MANAGE_DISPOSED_APP_STATUSohos.permission.ACCESS_IDSohos.permission.DUMPohos.permission.DISTRIBUTED_SOFTBUS_CENTERohos.permission.ACCESS_DLP_FILEohos.permission.PROVISIONING_MESSAGEohos.permission.ACCESS_SYSTEM_SETTINGSohos.permission.READ_IMAGEVIDEOohos.permission.READ_AUDIOohos.permission.READ_DOCUMENTohos.permission.WRITE_IMAGEVIDEOohos.permission.WRITE_AUDIOohos.permission.WRITE_DOCUMENTohos.permission.ABILITY_BACKGROUND_COMMUNICATIONohos.permission.securityguard.REPORT_SECURITY_INFOohos.permission.securityguard.REQUEST_SECURITY_MODEL_RESULTohos.permission.securityguard.REQUEST_SECURITY_EVENT_INFOohos.permission.READ_ACCESSIBILITY_CONFIGohos.permission.WRITE_ACCESSIBILITY_CONFIGohos.permission.ACCESS_CERT_MANAGER_INTERNALohos.permission.ACCESS_CERT_MANAGERohos.permission.ACCESS_PUSH_SERVICEohos.permission.RECEIVER_STARTUP_COMPLETEDohos.permission.MANAGE_CAMERA_CONFIGohos.permission.READ_WHOLE_CALENDARohos.permission.WRITE_WHOLE_CALENDARohos.permission.ENFORCE_USER_IAMohos.permission.ACCESS_AUTH_RESPOOLohos.permission.MOUNT_UNMOUNT_MANAGERohos.permission.MOUNT_FORMAT_MANAGERohos.permission.STORAGE_MANAGERohos.permission.BACKUPohos.permission.FILE_ACCESS_MANAGERohos.permission.MANAGE_AUDIO_CONFIGohos.permission.MANAGE_DISTRIBUTED_ACCOUNTSohos.permission.GET_DISTRIBUTED_ACCOUNTSohos.permission.GET_LOCAL_ACCOUNTS应用权限列表 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在申请目标权限前，建议开发者先阅读访问控制开发概述-权限的工作流程。对权限的工作流程有基本的了解后，再结合以下权限的具体说明，判断应用能否申请目标权限，提高开发效率。 权限的使用示例请参考访问控制开发指导。 
说明
当前仅支持部分权限通过应用市场（AGC）使用ACL的方式跨级别申请权限。这部分权限将在下述具体的权限描述中，标记“ACL使能：TRUE，可通过应用市场（AGC）申请。” 
 ohos.permission.USE_BLUETOOTH允许应用查看蓝牙的配置。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.DISCOVER_BLUETOOTH允许应用配置本地蓝牙，查找远端设备且与之配对连接。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_BLUETOOTH允许应用配对蓝牙设备，并对设备的电话簿或消息进行访问。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.INTERNET允许使用Internet网络。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.MODIFY_AUDIO_SETTINGS允许应用修改音频设置。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCESS_NOTIFICATION_POLICY在本设备上允许应用访问通知策略。 权限级别：normal 授权方式：system_grant ACL使能：FALSE  ohos.permission.GET_TELEPHONY_STATE允许应用读取电话信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.REQUIRE_FORM允许应用获取Ability Form。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_NETWORK_INFO允许应用获取数据网络信息。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.PLACE_CALL允许应用直接拨打电话。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_NETWORK_INFO允许应用配置数据网络。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.REMOVE_CACHE_FILES允许清理指定应用的缓存。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.REBOOT允许应用重启设备。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.RUNNING_LOCK允许应用获取运行锁，保证应用在后台的持续运行。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_TIME允许应用修改系统时间。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_TIME_ZONE允许应用修改系统时区。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.DOWNLOAD_SESSION_MANAGER允许应用管理下载任务会话。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.COMMONEVENT_STICKY允许应用发布粘性公共事件。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.SYSTEM_FLOAT_WINDOW允许应用使用悬浮窗的能力。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.PRIVACY_WINDOW允许应用将窗口设置为隐私窗口，禁止截屏录屏。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.POWER_MANAGER允许应用调用电源管理子系统的接口休眠或者唤醒设备。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.REFRESH_USER_ACTION允许应用在收到用户事件时，重新计算超时时间。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.POWER_OPTIMIZATION允许系统应用设置省电模式、获取省电模式的配置信息并接收配置变化的通知。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.REBOOT_RECOVERY允许系统应用重启设备并进入恢复模式。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_LOCAL_ACCOUNTS允许应用管理本地用户帐号。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS允许多个系统帐号之间相互访问。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.VIBRATE允许应用控制马达振动。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.CONNECT_IME_ABILITY允许绑定输入法Ability（InputMethodAbility）。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.CONNECT_SCREEN_SAVER_ABILITY允许绑定屏保Ability（ScreenSaverAbility）。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.READ_SCREEN_SAVER允许应用查询屏保状态信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.WRITE_SCREEN_SAVER允许应用修改屏保状态信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_WALLPAPER允许应用设置静态壁纸。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_WALLPAPER允许应用读取壁纸文件。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.CHANGE_ABILITY_ENABLED_STATE允许改变应用或者组件的使能状态。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCESS_MISSIONS允许应用访问任务栈信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.CLEAN_BACKGROUND_PROCESSES允许应用根据包名清理相关后台进程。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.KEEP_BACKGROUND_RUNNING允许Service Ability在后台持续运行。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.UPDATE_CONFIGURATION允许更新系统配置。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.UPDATE_SYSTEM允许调用升级接口。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.FACTORY_RESET允许调用恢复出厂接口。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.GRANT_SENSITIVE_PERMISSIONS允许应用为其他应用授予敏感权限。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.REVOKE_SENSITIVE_PERMISSIONS允许应用撤销给其他应用授予的敏感信息。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_SENSITIVE_PERMISSIONS允许应用读取其他应用的敏感权限的状态。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS_EXTENSION允许应用跨用户对其他应用的属性进行设置。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.LISTEN_BUNDLE_CHANGE允许应用监听其他应用安装、更新、卸载状态的变化。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_BUNDLE_INFO允许应用查询其他应用的信息。该权限仅适用于三方应用。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_BUNDLE_INFO_PRIVILEGED允许应用查询其他应用的信息。该权限仅适用于特权应用、同签名应用。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCELEROMETER允许应用读取加速度传感器的数据。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.GYROSCOPE允许应用读取陀螺仪传感器的数据。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.INSTALL_BUNDLE允许应用安装、卸载其他应用。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_SHORTCUTS允许应用查询其他应用的快捷方式信息、启动其他应用的快捷方式。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.radio.ACCESS_FM_AM允许应用获取收音机相关服务。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_TELEPHONY_STATE允许应用修改telephone的状态。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.START_ABILITIES_FROM_BACKGROUND允许应用在后台启动或者访问其他组件。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.BUNDLE_ACTIVE_INFO允许系统应用查询其他应用在前台或后台的运行时间。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.START_INVISIBLE_ABILITY无论Ability是否可见，都允许应用进行调用。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.sec.ACCESS_UDID允许系统应用获取UDID。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.LAUNCH_DATA_PRIVACY_CENTER允许应用从其隐私声明页面跳转至"数据与隐私"页面。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_MEDIA_RESOURCES允许应用程序获取当前设备正在播放的媒体资源，并对其进行管理。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.PUBLISH_AGENT_REMINDER允许该应用使用后台代理提醒。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.CONTROL_TASK_SYNC_ANIMATOR允许应用使用同步任务动画。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.INPUT_MONITORING允许应用监听输入事件，仅系统签名应用可申请此权限。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_MISSIONS允许用户管理元能力任务栈。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.NOTIFICATION_CONTROLLER允许应用管理通知和订阅通知。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.CONNECTIVITY_INTERNAL允许应用程序获取网络相关的信息或修改网络相关设置。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_ABILITY_CONTROLLER允许设置ability组件启动和停止控制权。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.USE_USER_IDM允许应用访问系统身份凭据信息。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.MANAGE_USER_IDM允许应用使用系统身份凭据管理能力进行口令、人脸、指纹等录入、修改、删除等操作。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.ACCESS_BIOMETRIC允许应用使用生物特征识别能力进行身份认证。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCESS_USER_AUTH_INTERNAL允许应用使用系统身份认证能力进行用户身份认证或身份识别。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.ACCESS_PIN_AUTH允许应用使用口令输入接口，用于系统应用完成口令输入框绘制场景。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.GET_RUNNING_INFO允许应用获取运行态信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.CLEAN_APPLICATION_DATA允许应用清理应用数据。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.RUNNING_STATE_OBSERVER允许应用观察应用状态。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.CAPTURE_SCREEN允许应用截取屏幕图像。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_WIFI_INFO允许应用获取WLAN信息。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_WIFI_INFO_INTERNAL允许应用获取WLAN信息。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_WIFI_INFO允许应用配置WLAN设备。 权限级别：normal 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_WIFI_PEERS_MAC允许应用获取对端WLAN或者蓝牙设备的MAC地址。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_WIFI_LOCAL_MAC允许应用获取本机WLAN或者蓝牙设备的MAC地址。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_WIFI_CONFIG允许应用获取WLAN配置信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_WIFI_CONFIG允许应用配置WLAN信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_WIFI_CONNECTION允许应用管理WLAN连接。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_WIFI_HOTSPOT允许应用开启或者关闭WLAN热点。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_ALL_APP_ACCOUNTS允许应用获取所有应用账户信息。 权限级别：system_core 授权方式：system_grant ACL使能：FALSE  ohos.permission.MANAGE_SECURE_SETTINGS允许应用修改安全类系统设置。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.READ_DFX_SYSEVENT允许应用访问系统事件打点数据。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.MANAGE_ENTERPRISE_DEVICE_ADMIN允许应用激活设备管理员应用。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_ENTERPRISE_INFO允许设备管理员应用设置企业信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.ENTERPRISE_SUBSCRIBE_MANAGED_EVENT允许设备管理员应用订阅管理事件。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.ENTERPRISE_SET_DATETIME允许设备管理员应用设置系统时间。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.ENTERPRISE_GET_DEVICE_INFO允许设备管理员读取设备信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.NFC_TAG允许应用读取Tag卡片。 权限级别：normal 授权方式：system_grant ACL使能：FALSE  ohos.permission.NFC_CARD_EMULATION允许应用实现卡模拟功能。 权限级别：normal 授权方式：system_grant ACL使能：FALSE  ohos.permission.PERMISSION_USED_STATS允许系统应用访问权限使用记录。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.NOTIFICATION_AGENT_CONTROLLER允许应用发送代理通知。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.ANSWER_CALL允许应用接听来电。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_CALENDAR允许应用读取日历信息。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_CALL_LOG允许应用读取通话记录。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_CELL_MESSAGES允许应用读取设备收到的小区广播信息。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_CONTACTS允许应用读取联系人数据。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE，可通过应用市场（AGC）申请。  ohos.permission.READ_MESSAGES允许应用读取短信息。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.RECEIVE_MMS允许应用接收和处理彩信。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.RECEIVE_SMS允许应用接收和处理短信。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.RECEIVE_WAP_MESSAGES允许应用接收和处理WAP消息。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.MICROPHONE允许应用使用麦克风。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.SEND_MESSAGES允许应用发送短信。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_CALENDAR允许应用添加、移除或更改日历活动。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_CALL_LOG允许应用添加、移除或更改通话记录。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_CONTACTS允许应用添加、移除或更改联系人数据。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE，可通过应用市场（AGC）申请。  ohos.permission.DISTRIBUTED_DATASYNC允许不同设备间的数据交换。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.MANAGE_VOICEMAIL允许应用在语音信箱中留言。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.LOCATION_IN_BACKGROUND允许应用在后台运行时获取设备位置信息。 权限级别：normal 授权方式：user_grant ACL使能：FALSE  ohos.permission.LOCATION允许应用获取设备位置信息。 权限级别：normal 授权方式：user_grant ACL使能：TRUE 申请条件：使用API version 9以下版本的SDK开发的应用，可以直接申请此权限。使用API version 9及API version 9以上版本的SDK开发的应用，需要先申请权限ohos.permission.APPROXIMATELY_LOCATION，才可申请此权限。  ohos.permission.APPROXIMATELY_LOCATION允许应用获取设备模糊位置信息。 权限级别：normal 授权方式：user_grant ACL使能：FALSE 申请条件：仅供使用API version 9及API version 9以上版本的SDK开发的应用申请。  ohos.permission.MEDIA_LOCATION允许应用访问用户媒体文件中的地理位置信息。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.CAMERA允许应用使用相机拍摄照片和录制视频。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_MEDIA允许应用读取用户外部存储中的媒体文件信息。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_MEDIA允许应用读写用户外部存储中的媒体文件信息。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.ACTIVITY_MOTION允许应用读取用户当前的运动状态。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_HEALTH_DATA允许应用读取用户的健康数据。 权限级别：normal 授权方式：user_grant ACL使能：TRUE  ohos.permission.GET_DEFAULT_APPLICATION允许应用查询默认应用。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.SET_DEFAULT_APPLICATION允许应用设置、重置默认应用。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_DISPOSED_APP_STATUS允许设置和查询应用的处置状态。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCESS_IDS允许应用查询设备的唯一标识符信息。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.DUMP允许导出系统基础信息和SA服务信息。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.DISTRIBUTED_SOFTBUS_CENTER允许不同设备之间进行组网处理。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.ACCESS_DLP_FILE允许对DLP文件进行权限配置和管理。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.PROVISIONING_MESSAGE允许激活超级设备管理器应用。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCESS_SYSTEM_SETTINGS允许应用接入或拉起系统设置界面。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.READ_IMAGEVIDEO允许读取用户公共目录的图片或视频文件。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_AUDIO允许读取用户公共目录的音频文件。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.READ_DOCUMENT允许读取用户公共目录的文档。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_IMAGEVIDEO允许修改用户公共目录的图片或视频文件。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_AUDIO允许修改用户公共目录的音频文件。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_DOCUMENT允许修改用户公共目录的文档。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.ABILITY_BACKGROUND_COMMUNICATION允许应用将Ability组件在后台启动并与该Ability建立通信连接。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.securityguard.REPORT_SECURITY_INFO允许应用上报风险数据至设备风险管理平台。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.securityguard.REQUEST_SECURITY_MODEL_RESULT允许应用获取设备风险状态。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.securityguard.REQUEST_SECURITY_EVENT_INFO允许应用获取风险详细数据。 权限级别：system_core 授权方式：system_grant ACL使能：FALSE  ohos.permission.READ_ACCESSIBILITY_CONFIG允许应用读取无障碍配置信息。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.WRITE_ACCESSIBILITY_CONFIG允许应用设置无障碍配置信息。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.ACCESS_CERT_MANAGER_INTERNAL允许应用进行证书及凭据的安装、卸载、启用、禁用等操作。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.ACCESS_CERT_MANAGER允许应用进行私有凭据的相关操作、查询证书状态等操作。 权限级别：normal 授权方式：system_grant ACL使能：FALSE  ohos.permission.ACCESS_PUSH_SERVICE允许应用访问推送服务的Ability。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.RECEIVER_STARTUP_COMPLETED允许应用订阅开机广播。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.MANAGE_CAMERA_CONFIG允许应用进行全局相机开关等操作。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.READ_WHOLE_CALENDAR允许应用读取所有的日历信息。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.WRITE_WHOLE_CALENDAR允许应用添加、移除或更改所有的日历活动。 权限级别：system_basic 授权方式：user_grant ACL使能：TRUE  ohos.permission.ENFORCE_USER_IAM允许SA无token删除IAM子系统用户信息。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.ACCESS_AUTH_RESPOOL允许SA注册执行器。 权限级别：system_core 授权方式：system_grant ACL使能：TRUE  ohos.permission.MOUNT_UNMOUNT_MANAGER允许应用对外卡进行挂载卸载操作。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.MOUNT_FORMAT_MANAGER允许应用对外卡进行格式化操作。 权限级别：system_basic 授权方式：system_grant ACL使能：FALSE  ohos.permission.STORAGE_MANAGER允许应用调用storage manager服务中对空间统计以及卷信息的查询接口。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.BACKUP允许应用拥有备份恢复能力。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.FILE_ACCESS_MANAGER允许文件管理类应用通过FAF框架访问公共数据文件。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_AUDIO_CONFIG允许应用进行全局麦克风静音等操作。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.MANAGE_DISTRIBUTED_ACCOUNTS允许应用管理系统分布式帐号信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_DISTRIBUTED_ACCOUNTS允许应用查询系统分布式帐号信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE  ohos.permission.GET_LOCAL_ACCOUNTS允许应用查询系统本地帐号信息。 权限级别：system_basic 授权方式：system_grant ACL使能：TRUE   上一篇 访问控制权限校验指导 下一篇 用户认证 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明完整示例访问控制权限校验指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 应用在提供对外功能服务接口时，可以根据接口涉数据的敏感程度或所涉能力的安全威胁影响，在系统定义的权限列表中权限定义列表选择合适的权限限制当前接口的开放范围，对接口访问者进行权限校验。   接口说明 以下仅列举本指导使用的接口，更多说明可以查阅API参考。 checkAccessToken(tokenID: number, permissionName: Permissions): Promise<GrantStatus>     参数名 类型 必填 说明    tokenID number 是 要校验的目标应用的身份标识。可通过应用的ApplicationInfo获得。   permissionName Permissions 是 需要校验的权限名称，合法的权限名取值可在系统权限定义列表中查询。      完整示例 进行权限校验的开发步骤为：  获取调用者的身份标识：tokenId。       
说明
 获取访问者身份标识tokenId的方法 getCallingTokenId 可参考API参考。 
 待校验的权限名：ohos.permission.ACCELEROMETER。 使用checkAccessToken接口对当前调用者进行权限校验。 根据权限校验结果采取对应的措施。  已复制  import abilityAccessCtrl from '@ohos.abilityAccessCtrl'  import rpc from '@ohos.rpc'
  class Stub extends rpc.RemoteObject {      onRemoteRequest(code, data, reply, option) {          let callerTokenId = rpc.IPCSkeleton.getCallingTokenId();          console.log("RpcServer: getCallingTokenId result: " + callerTokenId);          var atManager = abilityAccessCtrl.createAtManager();          try {              atManager.checkAccessToken(callerTokenId, "ohos.permission.ACCELEROMETER").then((data) => {                  console.log(`checkAccessToken success, data->${JSON.stringify(data)}`);              }).catch((err) => {                  console.log(`checkAccessToken fail, err->${JSON.stringify(err)}`);              });          } catch(err) {              console.log(`catch err->${JSON.stringify(err)}`);          }          return true;      }  }   上一篇 访问控制授权申请 下一篇 应用权限列表 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍导入模块接口说明设置鼠标光标隐藏开发步骤设置鼠标光标样式开发步骤鼠标光标开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 鼠标光标控制提供对鼠标光标显示隐藏、光标样式查询设置的能力。使用场景例如：用户在全屏观看视频时，开发者可以控制鼠标光标的显示隐藏；当用户执行取色时，开发者可以将鼠标光标样式切换为取色器样式。   导入模块 已复制import pointer from '@ohos.multimodalInput.pointer';   接口说明 鼠标光标控制常用接口如下表所示，接口详细介绍请参见ohos.multimodalInput.pointer 文档。     实例名 接口名 说明    pointer function isPointerVisible(callback: AsyncCallback<boolean>): void; 获取鼠标指针显示或隐藏状态。   pointer function setPointerVisible(visible: boolean, callback: AsyncCallback<void>): void; 设置鼠标指针显示或隐藏状态，改接口会影响全局鼠标光标的显示状态。   pointer function setPointerStyle(windowId: number, pointerStyle: PointerStyle, callback: AsyncCallback<void>): void; 设置鼠标光标样式，改接口会影响指定窗口鼠标光标样式。   pointer function getPointerStyle(windowId: number, callback: AsyncCallback<PointerStyle>): void; 查询鼠标光标样式。      设置鼠标光标隐藏 用户在全屏观看视频时，可以调用鼠标光标的隐藏接口设置鼠标光标不可见，提升用户体验。   开发步骤  应用切换到全屏播放。 在应用中调用鼠标光标隐藏接口隐藏光标。 应用退出全屏播放。 在应用中调用鼠标光标显示接口显示光标。  已复制import pointer from '@ohos.multimodalInput.pointer';
// 1.应用切换到全屏播放// 2.调用鼠标光标隐藏接口隐藏光标try {  pointer.setPointerVisible(false, (error) => {    if (error) {      console.log(`Set pointer visible failed, error: ${JSON.stringify(error, [`code`, `message`])}`);      return;    }    console.log(`Set pointer visible success.`);  });} catch (error) {  console.log(`The mouse pointer hide attributes is failed. ${JSON.stringify(error, [`code`, `message`])}`);}
// 3.应用退出全屏播放// 4.调用鼠标光标显示接口显示光标try {  pointer.setPointerVisible(true, (error) => {    if (error) {      console.log(`Set pointer visible failed, error: ${JSON.stringify(error, [`code`, `message`])}`);      return;    }    console.log(`Set pointer visible success.`);  });} catch (error) {  console.log(`Set pointer visible failed, ${JSON.stringify(error, [`code`, `message`])}`);}   设置鼠标光标样式 当开发者设计取色器特性时，可以将鼠标光标样式切换为取色器样式，完成取色后，设置鼠标光标样式为默认样式，该接口设置和查询当前应用内指定窗口的光标样式，总共可设置39种光标样式，具体参考鼠标样式。   开发步骤  开发者使能取色功能。 调用窗口实例获取对应的窗口id。 设置鼠标光标样式为取色器样式。 取色结束。 设置鼠标光标样式为默认样式。  已复制import pointer from '@ohos.multimodalInput.pointer';import window from '@ohos.window';
// 1.开发者使能取色功能// 2.调用窗口实例获取对应的窗口idwindow.getLastWindow(this.context, (error, windowClass) => {  if (error.code) {    console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(error));    return;  }  var windowId = windowClass.getWindowProperties().id;  if (windowId < 0) {    console.log(`Invalid windowId`);    return;  }  try {    // 3.设置鼠标光标样式为取色器样式    pointer.setPointerStyle(windowId, pointer.PointerStyle.COLOR_SUCKER).then(() => {      console.log(`Successfully set mouse pointer style`);    });  } catch (error) {    console.log(`Failed to set the pointer style, error=${JSON.stringify(error)}, msg=${JSON.stringify(`message`)}`);  }});// 4.取色结束window.getLastWindow(this.context, (error, windowClass) => {  if (error.code) {    console.error('Failed to obtain the top window. Cause: ' + JSON.stringify(error));    return;  }  var windowId = windowClass.getWindowProperties().id;  if (windowId < 0) {    console.log(`Invalid windowId`);    return;  }  try {    // 5.设置鼠标光标样式为默认样式    pointer.setPointerStyle(windowId, pointer.PointerStyle.DEFAULT).then(() => {      console.log(`Successfully set mouse pointer style`);    });  } catch (error) {    console.log(`Failed to set the pointer style, error=${JSON.stringify(error)}, msg=${JSON.stringify(`message`)}`);  }});   上一篇 输入设备开发指导 下一篇 设备状态 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看ArkTS和JS应用/服务预览效果查看ArkUI预览效果页面预览组件预览查看Java应用/服务预览效果Profile Manager查看多端设备预览效果Inspector双向预览使用预览器查看应用/服务效果 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio为开发者提供了UI界面预览功能，可以查看应用/服务的UI界面效果，方便开发者随时调整界面UI布局。预览器支持布局代码的实时预览，只需要将开发的源代码进行保存，就可以通过预览器实时查看应用/服务运行效果，方便开发者随时调整代码。 
说明
由于操作系统和真机设备的差异，在预览界面中可能出现字体、颜色等与真机设备运行的效果存在差异，预览效果仅作为应用/服务开发过程中的参考，实际最终效果请以真机设备运行效果为准。 
 为了更好的使用体验，建议先将DevEco Studio升级至最新版本，然后检测并更新SDK至最新版本。 查看ArkTS和JS应用/服务预览效果预览器支持JS和ArkTS应用/服务“实时预览”和“动态预览”。 
说明
预览Phone、Tablet、TV和Wearable设备的JS/ArkTS工程，预览器功能依赖于电脑显卡的OpenGL版本，OpenGL版本要求为3.2及以上。richtext、web、video、XComponent组件不支持预览。不支持调用C++库的预览。har在被应用和元服务使用时真机效果有区别，真机上实际效果应用不显示menubar，元服务显示menubar，但预览器都以不显示menubar为准。若开发har模块时，请注意被元服务使用时预览器效果与真机效果的不同。 
 实时预览：在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果。如果修改了组件的属性，则预览器会实时（亚秒级）刷新预览结果，达到极速预览的效果（当前版本极速预览仅支持ArkTS组件。API 8工程的极速预览仅在非数据绑定场景生效，如涉及数据绑定，仍需要在文件保存后才可以预览；API 9工程的极速预览支持部分数据绑定场景，如@State变量）。实时预览默认开启，如果不需要实时预览，请单击预览器右上角按钮，关闭实时预览功能。
说明
开发者修改resources/base/profile目录下的配置文件（如main_page.json），不支持触发实时预览，开发者需要手动刷新。 
  动态预览：在预览器界面，可以在预览器中操作应用/服务的界面交互动作，如单击、跳转、滑动等，与应用/服务运行在真机设备上的界面交互体验一致。  在使用预览器前，请根据如下项检查环境信息： 确保File > Settings > SDK > HarmonyOS/OpenHarmony中，已下载Previewer资源。如果已下载Previewer，但存在新版本的情况，建议升级到最新版本，详情请参考下载HarmonyOS SDK。建议将File > Settings > SDK > HarmonyOS/OpenHarmony中的SDK更新至最新版本。 以ArkTS为例，使用预览器的方法如下： 创建或打开一个ArkTS应用/服务工程。本示例以打开一个本地ArkTS Demo工程为例。在工程目录下，打开任意一个.ets文件（JS工程请打开.hml/.css/.js页面）。可以通过如下任意一种方式打开预览器开关，显示效果如下图所示：通过菜单栏，单击View>Tool Windows>Previewer打开预览器。在编辑窗口右上角的侧边工具栏，单击Previewer，打开预览器。    查看ArkUI预览效果ArkUI预览支持页面预览与组件预览，下图中左侧图标为页面预览，右侧图标为组件预览。   页面预览ArkTS应用/服务支持页面预览，要求compileSdkVersion为7或以上。页面预览通过在工程的ets文件头部添加注解@Entry实现。 @Entry的使用参考如下示例： 已复制@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }}  组件预览ArkTS应用/服务支持组件预览，要求compileSdkVersion为8或以上。组件预览支持实时预览，不支持动态图和动态预览。组件预览通过在组件前添加注解@Preview实现，在单个源文件中，最多可以使用10个@Preview装饰自定义组件。 @Preview的使用参考如下示例已复制@Preview({  title: 'FoodImage'})@Componentstruct FoodImageDisplayPreview {  build() {    Flex() {      FoodImageDisplay({ foodItem: getDefaultFoodData() })    }  }}  以上示例的组件预览效果如下图所示：  组件预览默认的预览设备为Phone，若您想在不同的设备，或者不同的屏幕形状，或者不同设备语言等情况下的组件预览效果，可以通过设置@Preview的参数，指定预览设备的相关属性。若不设置@Preview的参数，默认的设备属性如下所示：已复制@Preview({  title: 'Component1',  //预览组件的名称  deviceType: 'phone',  //指定当前组件预览渲染的设备类型，默认为Phone  width: 1080,  //预览设备的宽度，单位：px  height: 2340,  //预览设备的长度，单位：px  colorMode: 'light',  //显示的亮/暗模式，取值为light或dark  dpi: 480,  //预览设备的屏幕DPI值  locale: 'zh_CN',  //预览设备的语言，如zh_CN、en_US等  orientation: 'portrait',  //预览设备的横竖屏状态，取值为portrait或landscape  roundScreen: false  //设备的屏幕形状是否为圆形})  请注意，如果被预览的组件是依赖参数注入的组件，建议的预览方式是：定义一个组件片段，在该片段中声明将要预览的组件，以及该组件依赖的入参，并在组件片段上标注@Preview注解，以表明将预览该片段中的内容。例如，要预览如下组件： 已复制@Componentstruct Title {  context: string  build() {    Text(this.context)  }} 建议按如下方式预览： 已复制@Preview@Component    //定义组件片段TitlePreviewstruct TitlePreview {  build() {    Title({ context: 'MyTitle' })    //在该片段中声明将要预览的组件Title，以及该组件依赖的入参 {context: ’MyTitle’}  }}  查看Java应用/服务预览效果Java预览器支持Phone、Tablet、Car、TV和Wearable设备的Java应用/服务布局预览。Java应用/服务的布局支持Java代码布局和XML布局两种方式，其中Java代码布局（AbilitySlice.java或Ability.java文件）支持实时预览界面布局效果，同时还可以动态预览应用/服务的交互效果，如单击、跳转、滑动等互动式操作；XML布局文件可以实时预览，修改和保存了XML代码后，预览器会实时展示应用/服务的布局效果。
说明
Java文件预览是实验特性，使用中还存在以下约束。 macOS版本的Java预览器功能，只支持API Version 5及以上版本。如果xml依赖Java文件中的数据，当修改了xml布局文件后，需要通过启动Java文件预览的方式来查看布局效果。如果xml中引用了Java的自定义组件，不支持预览。只支持ohos.agp.components中的相关UI组件。只支持jpeg/jpg、png、bmp和wbmp格式的图片预览。不支持HarmonyOS Library模块的预览。不支持Ability间跳转的预览。不支持通过JNI调用C++库的预览。 
  在使用Java预览器前，请根据如下项检查环境信息： 需要确保File > Settings > SDK > HarmonyOS SDK中，已下载对应版本的Previewer资源，如果已下载Previewer，但存在新版本的情况，需要升级到最新版本。File > Settings > SDK > HarmonyOS SDK中的Java SDK需要更新至最新版本。 使用Java预览器的方法如下： 创建或打开一个Java应用/服务工程。本示例以创建一个新的Java工程为例，具体请参考创建一个新的工程。在工程目录下，根据布局方式，打开布局文件：JavaUI布局：打开一个AbilitySlice.java或Ability.java文件。
说明
JavaUI布局预览功能是实验特性： Windows系统：请通过File > Settings > Previewer下勾选“Enable java previewer”开启。macOS系统：请通过DevEco Studio > Preferences > Previewer下勾选“Enable java previewer”开启。 
 XML布局：打开一个resources > base > layout目录下的xml布局文件。 可以通过如下任意一种方式打开预览器开关，显示效果如下图所示：通过菜单栏，单击View > Tool Windows > Previewer打开预览器。在编辑窗口右上角的侧边工具栏，单击Previewer，打开预览器。    Profile Manager
说明
该特性在DevEco Studio V2.2 Beta2及更高版本中支持。 
 由于真机设备有丰富的设备型号，比如Phone设备，包括Mate30、Mate40、P40、P50等设备，不同设备型号的屏幕分辨率可能不一样。因此，在HarmonyOS应用/服务开发过程中，由于设备类型繁多，可能不能查看在不同设备上的界面显示效果。对此，DevEco Studio的预览器提供了Profile Manager功能，支持开发者自定义预览设备Profile（包含分辨率和语言），从而可以通过定义不同的预览设备Profile，查看HarmonyOS应用/服务在不同设备上的预览显示效果。当前支持自定义设备分辨率及系统语言，如果是Lite Wearable设备类型，还支持自定义屏幕形状。 定义设备后，可以在Previewer右上角，单击按钮，打开Profile管理器，切换预览设备。  同时，Profile Manager还支持多设备预览功能，具体请参考查看多端设备预览效果。 下面以自定义一款Phone设备为例，介绍设备Profile Manager的使用方法。 在预览器界面，打开Profile Manager界面。 在Profile Manager界面，单击+ New Profile按钮，添加设备。 在Create Profile界面，填写新增设备的信息，如Profile ID（设备型号）、Device type（设备类型）、Resolution（分辨率）和Language and region（语言和区域）等。其中Device type只能选择config.json（Stage工程中为module.json5）中deviceType字段已定义的设备。 设备信息填写完成后，单击OK完成创建。  查看多端设备预览效果DevEco Studio支持HarmonyOS分布式应用/服务开发，同一个应用/服务可以运行在多个设备上。在HarmonyOS分布式应用/服务的开发阶段，因不同设备的屏幕分辨率、形状、大小等不同，开发者需要在不同的设备上查看应用/服务的UI布局和交互效果，此时便可以使用多端设备预览器功能，方便开发者在应用/服务开发过程中，随时查看不同设备上的运行效果。
说明
多端设备预览最多同时支持4个设备的预览。 
  前面介绍了DevEco Studio支持ArkTS、JS和Java应用/服务的预览器功能，多端设备预览器支持ArkTS、JS与Java应用/服务在不同设备上的同时预览。如果两个设备支持的编码语言不同，就不能使用多端设备预览功能，例如，Java语言的Phone的应用/服务，是不支持在LiteWearable上运行的，因为LiteWearable不支持Java语言。 下面以ArkTS应用/服务为例，介绍多端设备预览器的使用方法，JS和Java应用/服务的多端设备预览器使用方法相同。 在工程目录中，打开任意一个ets文件（JS请打开hml/css/js文件，Java请打开AbilitySlice.java或Ability.java文件）。可以通过如下任意一种方式打开预览器开关，显示效果如下图所示：通过菜单栏，单击View>Tool Windows>Previewer，打开预览器。在编辑窗口右上角的侧边工具栏，单击Previewer，打开预览器。 在Previewer窗口中，打开Profile Manager中的Multi-profile preview开关，同时查看多设备上的应用/服务运行效果。
说明
多端设备预览不支持动画的预览，如果需要查看动画在设备上的预览效果，请关闭Multi-device preview功能后在单设备预览界面进行查看。 
  多设备预览效果如下图所示：    Inspector双向预览DevEco Studio提供HarmonyOS应用/服务的UI预览界面与源代码文件间的双向预览功能，支持ets文件、hml文件及xml文件与预览器界面的双向预览。使用双向预览功能时，需要在预览器界面单击图标打开双向预览功能。 
说明
暂不支持服务卡片的双向预览功能。 
  开启双向预览功能后，支持代码编辑器、UI界面和Component Tree 组件树三者之间的联动：选中预览器UI界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。选中布局文件中的代码块，则在UI界面会高亮显示，组件树上的组件节点也会呈现被选中的状态。  选中组件树中的组件，则对应的代码块和UI界面也会高亮显示。   在预览界面还可以通过组件的属性面板修改可修改的属性或样式，在预览界面修改后，预览器会自动同步到代码编辑器中修改源码，并实时的刷新UI界面；同样的，如果在代码编辑器中修改源码，也会实时刷新UI界面，并更新组件树信息及组件属性。
说明
如果组件有做数据绑定，则其属性不支持在属性面板修改。如果界面有使用动画效果或者带动画效果组件，则其属性不支持在属性面板修改。多设备预览时，不支持双向预览。 
     上一篇 创建服务卡片 下一篇 代码Code Linter检查 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。进程模型概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS的进程模型如下图所示： 应用中（同一包名）的所有PageAbility、ServiceAbility、DataAbility、FormAbility运行在同一个独立进程中，即图中绿色部分的“Main Process”。 WebView拥有独立的渲染进程，即图中黄色部分的“Render Process”。 图1 进程模型示意图   基于HarmonyOS的进程模型，系统提供了公共事件机制用于一对多的通信场景，公共事件发布者可能存在多个订阅者同时接收事件。  上一篇 进程模型 下一篇 公共事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。进程模型概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS的进程模型： 应用中（同一包名）的所有UIAbility运行在同一个独立进程中。 WebView拥有独立的渲染进程。  基于HarmonyOS的进程模型，系统提供了公共事件机制用于一对多的通信场景，公共事件发布者可能存在多个订阅者同时接收事件。  上一篇 进程模型 下一篇 公共事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。录制CPU活动数据查看CPU跟踪数据使用Flame Chart检查跟踪数据使用Top Down检查跟踪数据使用Bottom Up检查跟踪数据分析OpenHarmony应用/服务的CPU活动性能 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 CPU Profiler 性能分析是用来分析CPU性能瓶颈的工具，可以实时查看应用/服务的 CPU 使用率和线程活动，也可以查看记录应用跟踪数据和系统跟踪数据的详情。基于CPU性能分析，您可以了解在一段时间内执行了哪些方法，以及每个方法在其执行期间消耗的 CPU 资源，可以有针对性的优化应用/服务的 CPU 使用率，提供更快、更顺畅的用户体验，以及延长设备电池续航时间。 录制CPU活动数据录制OpenHarmony应用或服务的CPU活动数据，需要将待分析的应用或服务在设备上运行起来。 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击Profiler按钮，打开Profiler分析器。在Profiler分析器的SESSIONS窗口，单击+按钮，在弹出下拉列表中先选择设备，然后选择待分析的进程。 在实时变化视图，单击CPU区域，进入CPU详情页面。 在CPU详情页面选择CPU数据的录制模式，然后单击Record按钮，开始录制CPU活动数据。开始录制后，会在SESSIONS窗口的当前会话下生成应用/服务的数据记录。CPU数据的录制模式分为以下几种：对Perf数据采样（Sample Perf Data）：在应用/服务代码执行期间，定期捕获应用/服务的调用堆栈。分析器会比较捕获的数据集，以推导与应用/服务的代码执行有关的时间和资源使用信息。跟踪APP调用（Trace APP Calls）：在运行时检测应用/服务，在每个方法调用开始和结束时记录一个时间戳。系统会收集并比较这些时间戳，以生成方法跟踪数据，包括时间信息和 CPU 使用率。  要结束录制，单击CPU详情页面的Stop结束当前录制。CPU录制完成后，可以在SESSIONS窗口选中该数据记录，单击导出按钮将数据记录导出，方便分享和以后的查看。   查看CPU跟踪数据CPU活动数据录制后，可以在SESSIONS窗口单击要查看的数据记录，或单击+按钮，在下拉列表中选择Load from file，导入数据记录文件。   单击数据记录，可查看数据详情。 Threads：线程活动状态，可以查看线程是处于运行状态还是休眠状态，选择具体的线程，可以在右侧的Analysis窗口查看线程的详细信息。 Analysis窗口，选择All threads可以看到全部线程的信息。选择具体的某个线程，可以查看该线程或方法调用的详细数据。  使用Flame Chart检查跟踪数据Flame Chart 标签页提供一个调用图表，用来汇总完全相同的调用堆栈。   使用Top Down检查跟踪数据Top Down 标签显示一个调用列表，在该列表中展开方法或函数节点会显示它的被调用方。与 Flame chart 标签页类似，“Top Down”树也汇总了具有相同调用堆栈的完全相同的方法的跟踪信息。也就是说，Flame chart 标签页提供了 Top down 标签页的图形表示方式。 Top Down 标签提供以下信息来帮助说明在每个调用上所花的 CPU 时间（时间也可表示为在选定范围内占线程总时间的百分比）： Self：方法或函数调用在执行自己的代码（而非被调用方的代码）上所花的时间。 Children：方法或函数调用在执行它的被调用方（而非自己的代码）上所花的时间。 Total：方法的 Self 时间和 Children 时间的总和。这表示应用/服务在执行调用时所用的总时间。   使用Bottom Up检查跟踪数据Bottom Up 标签页显示一个调用列表，在该列表中展开函数或方法的节点会显示它的调用方。Bottom Up 标签页用于按照占用的 CPU 时间由多到少（或由少到多）的顺序对方法或函数排序。您可以检查每个节点以确定哪些调用方在调用这些方法或函数上所花的 CPU 时间最多。与“Top Down”树相比，“Bottom Up”树中每个方法或函数的时间信息参照的是每个树顶部的方法（顶部节点）。CPU 时间也可表示为在该记录期间占线程总时间的百分比。下表说明了如何解读顶部节点及其调用方（子节点）的时间信息。 Item  Self  Children  Total    “Bottom Up”树顶部的方法或函数（顶部节点）  表示方法或函数在执行自己的代码（而非被调用方的代码）上所花的总时间。与“Top Down”树相比，此时间信息表示在记录的持续时间内对此方法或函数的所有调用时间的总和。  表示方法或函数在执行它的被调用方（而非自己的代码）上所花的总时间。与“Top Down”树相比，此时间信息表示在记录的持续时间内对此方法或函数的被调用方的所有调用时间的总和。  Self 时间和 Children 时间的总和。   调用方（子节点）  表示被调用方在由调用方调用时的总 Self 时间。  表示被调用方在由调用方调用时的总 Children 时间。  Self 时间和 Children 时间的总和。        上一篇 Profiler性能分析器介绍 下一篇 分析OpenHarmony应用/服务的内存使用 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Profiler性能分析器介绍 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 应用或服务的性能较差时，可能表现为响应速度慢、动画播放不流畅、卡顿、崩溃或极其耗电。为了避免出现这些性能问题，需要通过一系列性能分析工具来确定应用或服务对哪方面资源（例如 CPU、内存）的使用率比较高，时间耗在什么地方。DevEco Studio集成Profiler性能分析器，通过Profiler性能分析器提供实时性能分析数据，并通过图表形式进行呈现，方便开发者及时了解应用/服务的CPU占用、内存的分配占用的具体数据。 在DevEco Studio菜单栏上单击View > Tool Windows >Profiler，或者在DevEco Studio底部工具栏单击，打开Profiler性能分析器，如下图所示：  会话窗格，单击查看会话窗格的会话。或单击+按钮，在弹出的下拉菜单中，选择一个进程创建一个新的会话。或选择导入文件，查看历史记录，请注意，导入的历史记录只能导入OpenHarmony设备的跟踪记录。 缩放按钮用于对时间轴进行缩放。 CPU、内存数据实时变化视图，单击对应的区域，可进入详情视图。  上一篇 OpenHarmony应用性能分析 下一篇 分析OpenHarmony应用/服务的CPU活动性能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看OpenHarmony应用/服务内存实时变化分析OpenHarmony应用/服务的内存使用 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 Profiler性能分析器支持内存使用分析。应用/服务运行时，Profiler的内存分析器实时显示内存使用情况，帮助开发者识别可能会导致应用卡顿、冻结的内存泄漏和内存抖动。 查看OpenHarmony应用/服务内存实时变化查看OpenHarmony应用或服务的内存使用数据，需要将待分析的应用或服务在设备上运行起来。 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击Profiler按钮，打开Profiler性能分析器。在Profiler分析器的SESSIONS窗口，单击+按钮，在弹出下拉列表中先选择设备，然后选择待分析的进程。 在实时变化视图，单击内存区域，进入内存详情页面。 内存详情页按内存类别实时显示内存变化视图，包括： Native：C或C++代码所占用的内存；Graphics：图形缓冲区队列向屏幕显示像素所使用的内存。注意这是与CPU共享的内存，不是GPU专用内存；Stack：应用/服务中的原生堆栈和Java堆栈使用的内存；Code：应用/服务用于处理代码和资源的内存；Others：系统不确定如何分类的内存；    上一篇 分析OpenHarmony应用/服务的CPU活动性能 下一篇 应用/服务测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。性能分析 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     HarmonyOS应用性能分析  OpenHarmony应用性能分析   上一篇 C/C++内存错误检测 下一篇 HarmonyOS应用性能分析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS应用性能分析 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    Profiler性能分析  HiTrace日志跟踪定位分析   上一篇 性能分析 下一篇 Profiler性能分析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。OpenHarmony应用性能分析 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    Profiler性能分析器介绍  分析OpenHarmony应用/服务的CPU活动性能  分析OpenHarmony应用/服务的内存使用   上一篇 HiTrace日志跟踪定位分析 下一篇 Profiler性能分析器介绍 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发步骤发布进度条类型通知 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  进度条通知也是常见的通知类型，主要应用于文件下载、事务处理进度显示。HarmonyOS提供了进度条模板，发布通知应用设置好进度条模板的属性值，如模板名、模板数据，通过通知子系统发送到通知栏显示。 目前系统模板仅支持进度条模板，通知模板NotificationTemplate中的data参数为用户自定义数据，用于显示与模块相关的数据，效果示意如下图所示。   接口说明 isSupportTemplate()是查询模板是否支持接口，目前仅支持进度条模板。     接口名 描述    isSupportTemplate(templateName: string, callback: AsyncCallback<boolean>): void 查询模板是否存在。      开发步骤  导入模块。 已复制import NotificationManager from '@ohos.notificationManager'; 查询系统是否支持进度条模板，查询结果为支持downloadTemplate模板类通知。 已复制NotificationManager.isSupportTemplate('downloadTemplate').then((data) => {  console.info(`[ANS] isSupportTemplate success`);  let isSupportTpl: boolean = data; // isSupportTpl的值为true表示支持支持downloadTemplate模板类通知，false表示不支持  // ...}).catch((err) => {  console.error(`[ANS] isSupportTemplate failed, error[${err}]`);}); 
说明
 查询系统支持进度条模板后，再进行后续的步骤操作。 
 构造进度条模板对象，并发布通知。 已复制let template = {  name:'downloadTemplate',  data: {    title: '标题：',    fileName: 'music.mp4',    progressValue: 30,    progressMaxValue:100,  }}//构造NotificationRequest对象let notificationRquest = {  id: 1,  slotType: notify.SlotType.OTHER_TYPES,  template: template,  content: {    contentType: notify.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,    normal: {      title: template.data.title + template.data.fileName,      text: "sendTemplate",      additionalText: "30%"    }  },  deliveryTime: new Date().getTime(),  showDeliveryTime: true}notify.publish(notificationRquest).then(() => {  console.info(`[ANS] publish success `);}).catch((err) => {  console.error(`[ANS] failed to publish, error[${err}]`);});    上一篇 发布基础类型通知 下一篇 为通知添加行为意图 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。工程管理 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    工程介绍  工程模板和开发语言介绍  创建一个新的工程  Gradle工程适配为Hvigor工程  导入Sample工程  添加/删除Module   上一篇 创建和运行Hello World 下一篇 工程介绍 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。APP包结构切换工程视图工程目录结构（API Version 8~9）ArkTS工程目录结构（Stage模型）ArkTS工程目录结构（FA模型）JS工程目录结构（FA模型）C++工程目录结构（Stage模型）C++工程目录结构（FA模型）工程目录结构（API Version 4~7）JS工程目录结构C++模板创建的工程目录结构Java工程目录结构历史工程适配OHPM包管理历史工程自动迁移历史工程手动迁移工程介绍 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 APP包结构在进行应用/服务开发前，开发者应该掌握应用/服务的逻辑结构。 应用/服务发布形态为APP Pack（Application Package，简称APP），它是由一个或多个HAP（Harmony Ability Package）包以及描述APP Pack属性的pack.info文件组成。 一个HAP在工程目录中对应一个Module，它是由代码、资源、第三方库及应用/服务配置文件组成，HAP可以分为Entry和Feature两种类型。 Entry：应用/服务的主模块，作为应用的入口，提供了应用的基础功能。Feature：应用/服务的动态特性模块，作为应用能力的扩展，可以根据用户的需求和设备类型进行选择性安装。 基于Stage模型和FA模型开发的应用，应用程序包结构并不相同。 Stage模型应用程序包结构如下图所示。更多说明请参见应用开发基础知识中的Stage模型应用程序包结构。  FA模型应用程序包结构如下图所示。更多说明请参见应用开发基础知识中的FA模型应用程序包结构。    切换工程视图DevEco Studio工程目录结构提供工程视图和Ohos视图。工程视图（Project）展示工程中实际的文件结构，Ohos视图会隐藏一些编码中不常用到的文件，并将常用到的文件进行重组展示，方便开发者查询或定位所需编辑的模块或文件。 工程创建或打开后，默认显示工程视图，如果要切换到Ohos视图，在左上角单击Project > Ohos进行切换。   工程目录结构（API Version 8~9）应用/服务支持API Version 4~9。API Version 4~7和API Version 8~9的构建工具和构建插件不同。其中，API Version 4~7构建体系是由Gradle构建工具和构建插件组成；API Version 8~9构建体系是由Hvigor构建工具和构建插件组成。所以API Version 4~7和API Version 8~9的工程目录结构存在差异。下面按照不同开发语言分别介绍API Version 4~7和API Version 8~9的工程目录结构。  ArkTS工程目录结构（Stage模型）ArkTS Stage模型支持API Version 9，其工程目录结构如下图所示：  AppScope > app.json5：应用的全局配置信息。entry：应用/服务模块，编译构建生成一个HAP。src > main > ets：用于存放ArkTS源码。src > main > ets > entryability：应用/服务的入口。src > main > ets > pages：应用/服务包含的页面。src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   rawfile  用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。     src > main > module.json5：Stage模型模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。oh_modules：用于存放三方库依赖信息。关于原npm工程适配OHPM包管理器操作，请参考历史工程适配OHPM包管理。build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。oh-package.json5：配置三方包声明文件的入口及包名。 build-profile.json5：应用级配置信息，包括签名、产品配置等。hvigorfile.ts：应用级编译构建任务脚本。  ArkTS工程目录结构（FA模型）ArkTS FA模型支持API Version 8~9，其工程目录结构如下图所示： API Version 8工程目录结构图：  API Version 9工程目录结构图:  entry：应用/服务模块，编译构建生成一个HAP。src > main > ets：用于存放ArkTS源码。src > main > ets > MainAbility：应用/服务的入口。src > main > ets > MainAbility > pages：MainAbility包含的页面。src > main > ets > MainAbility > app.ets：承载Ability生命周期。src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   rawfile  用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。     src > main > config.json：模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。 build-profile.json5：应用级配置信息，包括签名、产品配置等。hvigorfile.ts：应用级编译构建任务脚本。  JS工程目录结构（FA模型）JS工程只支持FA模型，Hvigor工程支持API Version 8~9，其工程目录结构如下图所示： API Version 8工程目录结构图：  API Version 9工程目录结构图：  entry：应用/服务模块，编译构建生成一个HAP。src > main > js：用于存放js源码。src > main > js > MainAbility：应用/服务的入口。src > main > js > MainAbility > i18n：用于配置不同语言场景资源内容，比如应用文本词条、图片路径等资源。src > main > js > MainAbility > pages：MainAbility包含的页面。src > main > js > MainAbility > app.js：承载Ability生命周期。src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   rawfile  用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。     src > main > config.json：模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。 build-profile.json5：应用级配置信息，包括签名、产品配置等。hvigorfile.ts：应用级编译构建任务脚本。  C++工程目录结构（Stage模型）C++ Stage模型支持API Version 9，支持使用ArkTS+C++进行开发，其工程目录结构如下图所示。  entry：应用/服务模块，编译构建生成一个HAP。src > main > cpp > types：用于存放C++的API接口描述文件src > main > cpp > types > libentry > index.d.ts：描述C++ API接口行为，如接口名、入参、返回参数等。src > main > cpp > types > libentry> oh-package.json5：配置.so三方包声明文件的入口及包名。src > main > cpp > CMakeLists.txt：CMake配置文件，提供CMake构建脚本。src > main > cpp > hello.cpp：定义C++ API接口的文件。src > main > ets：用于存放ArkTS源码，其详细介绍请参考ArkTS工程目录结构（Stage模型）介绍。src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值。   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   rawfile  用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。     src > main > mudule.json5：Stage模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。 build-profile.json5：应用级配置信息，包括签名、产品配置等。hvigorfile.ts：应用级编译构建任务脚本。  C++工程目录结构（FA模型）C++ FA模型，Hvigor工程支持API Version 8~9，支持使用ArkTS+C++或JS+C++进行开发，其工程目录结构相似，下面将以ArkTS+C++工程为例进行介绍，其工程目录结构如下图所示。 API Version 8工程目录结构图：  API Version 9工程目录结构图：  entry：应用/服务模块，编译构建生成一个HAP。src > main > cpp > types：用于存放C++的API接口描述文件src > main > cpp > types > libentry > index.d.ts：描述C++ API接口行为，如接口名、入参、返回参数等。src > main > cpp > types > libentry> package.json (API8)：配置.so三方包声明文件的入口及包名。src > main > cpp > types > libentry> oh-package.json5 (API9)：配置.so三方包声明文件的入口及包名。src > main > cpp > CMakeLists.txt：CMake配置文件，提供CMake构建脚本。src > main > cpp > hello.cpp：定义C++ API接口的文件。src > main > ets：用于存放ArkTS源码，其详细介绍请参考ArkTS工程目录结构（FA模型）介绍。src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值。   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   rawfile  用于存储任意格式的原始资源文件。rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。     src > main > config.json：FA模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。hvigorfile.ts：模块级编译构建任务脚本。 build-profile.json5：应用级配置信息，包括签名、产品配置等。hvigorfile.ts：应用级编译构建任务脚本。  工程目录结构（API Version 4~7） JS工程目录结构API Version 4~7的JS工程目录结构如下图所示：  java目录：作为应用/服务的启动入口。common目录：用于存放公共资源文件，如媒体资源、自定义组件和JS文档等。i18n目录：用于存放多语言的json文件，可以在该目录下定义应用/服务在不同语言系统下显示的内容，如应用/服务文本词条、图片路径等，详情请参考多语言支持。pages目录：pages文件夹下可以包含1个或多个页面，每个页面都需要创建一个文件夹。页面文件夹下主要包含3种文件类型：css、js和hml文件。pages > index > index.hml文件：hml文件定义了页面的布局结构，使用到的组件，以及这些组件的层级关系，详情请参考HML语法参考。pages > index > index.css文件：css文件定义了页面的样式与布局，包含样式选择器和各种样式属性等，详情请参考CSS语法参考。pages > index > index.js文件：js文件描述了页面的行为逻辑，此文件里定义了页面里所用到的所有的逻辑关系，比如数据、事件等，详情请参考JS语法参考。 app.js文件：全局的JS逻辑文件和应用/服务的生命周期管理。resources：用于存放资源配置文件，比如：全局样式、多分辨率加载等配置文件。resources资源引用示例请参考根据设备分辨率加载图片。entry > src > main > config.json：模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。  C++模板创建的工程目录结构C++模板创建的Java工程（API Version 4~7）目录结构如下图所示： entry > src > main > cpp：用于存放C++源码。entry > src > main > java：用于存放Java源码。entry > src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值。   base>graphic  xml类型的可绘制资源，如SVG（Scalable Vector Graphics）可缩放矢量图形文件、Shape基本的几何图形（如矩形、圆形、线等）等。   base>layout  xml格式的界面布局文件。   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   base>profile  用于存储任意格式的原始资源文件。区别在于rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。   rawfile     entry > src > main > config.json：模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。   Java工程目录结构API Version 4~7的Java工程目录结构如下图所示：  .gradle：Gradle配置文件，由系统自动生成，一般情况下不需要进行修改。entry：默认启动模块（主模块），开发者用于编写源码文件以及开发资源文件的目录。entry > libs：用于存放entry模块的依赖文件。entry > src > main > java：用于存放Java源码。entry > src > main > java >com.example.myapplication > slice > MainAbilitySlice：承载单个页面的具体逻辑实现和界面UI。entry > src > main > java > com.example.myapplication > MainAbility：应用/服务的入口。entry > src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件的详细说明请参考资源文件的分类。 资源目录  资源文件说明    base>element  包括字符串、整型数、颜色、样式等资源的json文件。每个资源均由json格式进行定义，例如： boolean.json：布尔型color.json：颜色float.json：浮点型intarray.json：整型数组integer.json：整型pattern.json：样式plural.json：复数形式strarray.json：字符串数组string.json：字符串值。   base>graphic  xml类型的可绘制资源，如SVG（Scalable Vector Graphics）可缩放矢量图形文件、Shape基本的几何图形（如矩形、圆形、线等）等。   base>layout  xml格式的界面布局文件。   base>media  多媒体文件，如图形、视频、音频等文件，支持的文件格式包括：.png、.gif、.mp3、.mp4等。   base>profile  用于存储任意格式的原始资源文件。区别在于rawfile不会根据设备的状态去匹配不同的资源，需要指定文件路径和文件名进行引用。   rawfile     entry > src > main > config.json：模块配置文件，主要包含HAP的配置信息、应用在具体设备上的配置信息以及应用的全局配置信息。   历史工程适配OHPM包管理OHPM CLI（OpenHarmony Package Manager Command-line Interface） 作为鸿蒙生态三方库的包管理工具，支持共享包的发布、安装和依赖管理。 在DevEco Studio 3.1 Beta2上新建API 9及以上版本的工程将使用ohpm作为默认包管理器。 
说明
仅API 9历史工程需进行迁移，API 8及以下版本无需迁移。 
 打开API 9的历史工程时，可选择历史工程自动迁移（需确保历史工程可运行，若自动化迁移出现报错，请参见FAQ），或根据提示选择历史工程手动迁移。 迁移流程如下： 迁移配置文件将工程和模块下npm包管理相关配置文件package.json或.npmrc，迁移为oh-package.json5或.ohpmrc文件。具体操作请参阅迁移步骤二。 
说明
若原工程中无.npmrc文件，则无需迁移为.ohpmrc文件。 
 新增编译构建相关文件在工程中新增hvigor相关的wrapper文件，包括hvigorw、hvigorw.bat、hvigor-config.json5、hvigor-wrapper.js配置文件。具体操作请参阅迁移步骤三。 删除不再使用的npm包管理文件包含package.json、package-lock.json、.npmrc、node_modules，工程和模块级别下均需进行删除处理。具体操作请参阅迁移步骤四。       迁移前文件目录  迁移后文件目录      历史工程自动迁移打开API 9历史工程，在右侧Notifications会出现Sync Failed，点击Actions，选择Start automatic configuration migration进入自动化迁移。 在弹窗中点击Migrate启动自动化迁移。 若自动化迁移失败，请参考下方历史工程手动迁移来完成迁移操作。    历史工程手动迁移如自动化迁移不成功或希望进行手动迁移，迁移前需对工程进行备份。迁移流程如下： 在工程/模块级别中，涉及package.json或.npmrc的配置文件处，创建相同目录层级的oh-package.json5或.ohpmrc文件。
说明
若历史工程为C++工程，src>main>cpp目录下包含package.json或.npmrc，需做相同处理。 
 将历史工程package.json和.npmrc文件中包含的需要迁移的字段，拷贝到对应的oh-package.json5和.ohpmrc文件中。 表1 oh-package.json5字段及迁移说明oh-package.json5包含字段  字段说明  迁移/新增字段  原package.json字段  说明    name  软件包名称  迁移字段  name  必选字段，若package.json文件中未指明，需在oh-package.json5添加补齐   version  软件包版本  迁移字段  version  必选字段，若package.json文件中未指明，需在oh-package.json5添加补齐   description  软件包简介  迁移字段  description  必选字段，若package.json文件中未指明，需在oh-package.json5添加补齐   keywords  软件包关键字  迁移字段  keywords  -   homepage  主页链接  迁移字段  homepage  -   license  开源协议  迁移字段  license  -   author  软件包作者  迁移字段  author  -   main  软件包入口  迁移字段  main  -   repository  仓库地址  迁移字段  repository  -   dependencies  生产依赖  迁移字段  dependencies  该字段处理方式请参阅下方说明内容   devDependencies  开发依赖  迁移字段  devDependencies  -   types  类型定义  迁移字段  types  -   artifactType  共享包类型  新增字段，非必选配置项  -  可选项： original：源码，即发布源码(.ts/.ets)。obfuscation：混淆代码，即源码经过混淆之后发布上传。     
说明
工程的package.json文件的dependencies字段处理方式如下：@ohos/hypium：测试框架的依赖，迁移时需要放到oh-package.json5文件的devDependencies字段下；删除@ohos/hvigor和@ohos/hvigor-ohos-plugin字段，无需迁移到oh-package.json5中；其他依赖可直接复制到oh-package.json5的dependencies字段中。 除表格中呈现的字段外，package.json中其余字段暂不支持迁移。如您在历史工程中使用到其余字段，请反馈您所使用的字段（选中文本，点击“意见反馈”）。 
  表2 .npmrc文件迁移字段对照及说明.npmrc字段  字段释义  .ohpmrc对应字段    registry  仓库地址  registry   @${scope}:registry  指定仓库  @${group}:registry   cache  缓存路径  cache   noproxy  不使用proxy代理  no_proxy   proxy  http代理  http_proxy   https-proxy  https代理  https_proxy   strict-ssl  ssl校验  strict_ssl   cafile  ca证书路径  ca_files   loglevel  日志级别  log_level      工程需要添加ohpm编译构建四件套hvigorw、hvigorw.bat、hvigor-config.json5、hvigor-wrapper.js。可新建一个API 9的新工程，拷贝新工程中hvigorw、hvigorw.bat、hvigor-config.json5、hvigor-wrapper.js四项配置文件，粘贴到历史工程文件夹对应位置。 删除工程级别和模块级别下包含的package.json、package-lock.json、.npmrc、node_modules四项配置。 点击File>Sync and Refresh Project，至此，历史工程手动迁移完成。  
说明
若安装插件时报错提示“Install failed FetchPackageInfo：hypium failed”，请参见对应FAQ。 
    上一篇 工程管理 下一篇 工程模板和开发语言介绍 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。发布流程准备签名文件生成密钥和证书请求文件申请发布证书和Profile文件配置签名信息编译构建.app文件上架.app文件到AGCHarmonyOS应用/服务发布 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS通过数字证书与Profile文件等签名信息来保证应用/服务的完整性，应用/服务上架到AppGallery Connect必须通过签名校验。因此，您需要使用发布证书和Profile文件对应用/服务进行签名后才能发布。 应用/服务发布到AppGallery Connect后，会将应用分发至应用市场，将服务分发至服务中心。消费者便可以通过终端设备上的应用市场App获取HarmonyOS应用，通过服务中心获取原子化服务。 发布流程开发者完成HarmonyOS应用/服务开发后，需要将应用/服务打包成App Pack（.app文件），用于发布到华为应用市场。发布应用/服务的流程如下图所示：   关于以上流程的详细介绍，请继续查阅本章节内容。 准备签名文件 生成密钥和证书请求文件HarmonyOS应用/服务通过数字证书（.cer文件）和Profile文件（.p7b文件）来保证应用/服务的完整性，数字证书和Profile文件可通过申请发布证书和Profile文件获取。 申请数字证书和Profile文件前，首先需要通过DevEco Studio来生成密钥（存储在格式为.p12的密钥库文件中）和证书请求文件（.csr文件）。同时，也可以使用命令行工具的方式来生成密钥文件和证书请求文件。 基本概念密钥：包含非对称加密中使用的公钥和私钥，存储在密钥库文件中，格式为.p12，公钥和私钥对用于数字签名和验证。证书请求文件：格式为.csr，全称为Certificate Signing Request，包含密钥对中的公钥和公共名称、组织名称、组织单位等信息，用于向AppGallery Connect申请数字证书。数字证书：格式为.cer，由华为AppGallery Connect颁发。Profile文件：格式为.p7b，包含HarmonyOS应用/服务的包名、数字证书信息、描述应用/服务允许申请的证书权限列表，以及允许应用/服务调试的设备列表（如果应用/服务类型为Release类型，则设备列表为空）等内容，每个应用/服务包中均必须包含一个Profile文件。  使用DevEco Studio生成密钥和证书请求文件 在主菜单栏单击Build > Generate Key and CSR。
说明
如果本地已有对应的密钥，无需新生成密钥，可以在Generate Key界面中单击下方的Skip跳过密钥生成过程，直接使用已有密钥生成证书请求文件。 
 在Key Store File中，可以单击Choose Existing选择已有的密钥库文件（存储有密钥的.p12文件）；如果没有密钥库文件，单击New进行创建。下面以新创建密钥库文件为例进行说明。 在Create Key Store窗口中，填写密钥库信息后，单击OK。Key Store File：设置密钥库文件存储路径，并填写p12文件名。Password：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。Confirm Password：再次输入密钥库密码。  在Generate Key and CSR界面中，继续填写密钥信息后，单击Next。Alias：密钥的别名信息，用于标识密钥名称。请记住该别名，后续签名配置需要使用。Password：密钥对应的密码，与密钥库密码保持一致，无需手动输入。Validity：证书有效期，建议设置为25年及以上，覆盖应用/服务的完整生命周期。Certificate：输入证书基本信息，如组织、城市或地区、国家码等。  在Generate Key and CSR界面，设置CSR文件存储路径和CSR文件名。 单击OK按钮，创建CSR文件成功，可以在存储路径下获取生成的密钥库文件（.p12）和证书请求文件（.csr）。  使用命令行工具生成证书请求文件 使用Open JDK携带的Keytool工具生成证书请求文件。 使用管理员身份运行命令行工具。 切换到keytool工具所在路径，实际路径请根据安装目录进行修改。 执行如下命令，生成公私钥文件。例如，生成的密钥库名称为ide_demo_app.p12，存储到D盘根目录下。已复制keytool -genkeypair -alias "ide_demo_app" -keyalg EC -sigalg SHA256withECDSA -dname "C=CN,O=HUAWEI,OU=HUAWEI IDE,CN=ide_demo_app"  -keystore d:\\idedemokey.p12 -storetype pkcs12 -validity 9125 -storepass 123456Abc -keypass 123456Abc 生成公私钥文件的参数说明如下： 
说明
请记录下alias、storepass和keypass的值，在后续配置签名信息操作会使用到。 
 alias：密钥的别名信息，用于标识密钥名称。sigalg：签名算法，固定为SHA256withECDSA。dname：按照操作界面提示进行输入。C：国家/地区代码，如CN。O：组织名称，如HUAWEI。OU：组织单位名称，如HUAWEI IDE。CN：名字与姓氏，建议与别名一致。 validity：证书有效期，建议设置为9125（25年）。storepass：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。keypass：设置密钥的密码，请与storepass保持一致。 执行如下命令，执行后需要输入storepass密码，生成证书请求文件，后缀格式为.csr。已复制keytool -certreq -alias "ide_demo_app" -keystore d:\\idedemokey.p12 -storetype pkcs12 -file d:\\idedemokey.csr 生成证书请求文件的参数说明如下： alias：与3中输入的alias保持一致。file：生成的证书请求文件名称，后缀为.csr。   申请发布证书和Profile文件通过生成的证书请求文件，向AppGallery Connect申请发布证书和Profile文件，操作如下。创建HarmonyOS应用/服务：在AppGallery Connect项目中，创建一个HarmonyOS应用/服务，用于发布证书和Profile文件申请，具体请参考创建HarmonyOS应用。
说明
在应用/服务分发阶段，HarmonyOS应用将被分发至应用市场，原子化服务将会被分发至服务中心。因此，如果申请原子化服务的签名证书，在“创建应用”操作时，“是否原子化服务”选项请选择“是”。 
 申请发布证书和Profile文件：在AppGallery Connect中申请、下载发布证书和Profile文件，具体请参考申请发布证书和Profile文件。  用于发布的证书和Profile文件申请完成后，请在DevEco Studio中进行签名，请参考配置签名信息。  配置签名信息使用制作的私钥（.p12）文件、在AppGallery Connect中申请的证书（.cer）文件和Profile（.p7b）文件，在DevEco Studio配置工程的签名信息，构建携带发布签名信息的APP。 在File > Project Structure > Project > Signing Configs > default界面中，取消“Automatically generate signature”勾选项，然后配置工程的签名信息。
说明
若是API Version 4至7的工程，请在Signing Configs界面，选择Release，然后配置签名信息。 
 Store File：选择密钥库文件，文件后缀为.p12。Store Password：输入密钥库密码。Key Alias：输入密钥的别名信息。Key Password：输入密钥的密码。Sign Alg：签名算法，固定为SHA256withECDSA。Profile File：选择申请的发布Profile文件，文件后缀为.p7b。Certpath File：选择申请的发布数字证书文件，文件后缀为.cer。   设置完签名信息后，单击OK进行保存，然后使用DevEco Studio生成APP，请参考编译构建.app文件。  编译构建.app文件打包APP时，DevEco Studio会将工程目录下的所有HAP模块打包到APP中，因此，如果工程目录中存在不需要打包到APP的HAP模块，请手动删除后再进行编译构建生成APP。 单击Build > Build Hap(s)/APP(s) > Build APP(s)，等待编译构建完成已签名的APP。编译构建完成后，可以在工程目录build > outputs > app > release下，获取带签名的APP。   上架.app文件到AGC将HarmonyOS应用/服务打包成.app文件后上架到AppGallery Connect，AppGallery Connect会将HarmonyOS应用至应用市场，将原子化服务分发至服务中心，上架详细操作指导请参考上架HarmonyOS应用/服务。   上一篇 原子化服务体检 下一篇 命令行工具 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。代码Quick Fix快速修复 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持Quick Fix能力，辅助开发者快速修复代码问题。 查看告警信息：使用双击Shift快捷键打开文件查询框，输入problems打开问题工具面板；单击对应告警信息，可以查看告警的具体位置及原因。 快速修复：将光标放在错误告警的位置，可在弹出的悬浮窗中查看问题描述和对应修复方式；单击more actions可查看更多修复方法。   上一篇 代码Code Linter检查 下一篇 低代码开发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。编写配置文件patch.json生成快速修复文件快速修复TS文件的代码快速修复C++中的代码生成.hqf的快速修复包快速修复包的签名安装快速修复包快速修复命令行调试开发指导 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 当前阶段，HarmonyOS为开发者提供了命令行的调试开发工具可供使用。比如，包名为com.ohos.quickfix的示例应用，版本号为1000000。该应用的当前版本运行中有某问题需要修复，此时，开发者可参考如下指导使用快速修复能力解决应用问题。 编写配置文件patch.json目前DevEco Studio中还不支持patch.json的配置，因此开发者可根据项目需要编写好该文件后，放到的项目任意目录，方便后续打包工具能够找到该文件即可。在本地新建一个patch.json文件，配置编写示例如下： 已复制{    "app" : {        "bundleName" : "com.ohos.quickfix",        "versionCode" : 1000000, // 应用版本号        "versionName" : "1.0.0.1",        "patchVersionCode" : 1000000, // 补丁版本号        "patchVersionName" : "1.0.0.1"    },    "module" : {        "name" : "entry",        "type" : "patch",        "deviceTypes" : [            "default",            "tablet"        ],        "originalModuleHash" : "11223344556677889900" // 待修复hap包的sha256值，可采用SHA256生成器自行生成    }}  生成快速修复文件 快速修复TS文件的代码在DevEco Studio中修改TS文件后，编译HAP，可以在工程目录下找到对应的abc文件，如build\default\cache\default\LegacyCompileETS\jsbundle\temporary\pages\index.abc。  快速修复C++中的代码在DevEco Studio中编译原C++的代码生成.so文件；修复原C++的代码，编译生成新的.so文件。可以在工程目录中找到该so，如build\default\intermediates\libs\default\arm64-v8a\libentry.so。在本地HarmonyOS SDK路径的toolchains文件夹下查看diff.exe。通过该工具，基于新.so文件和旧的.so文件，生成.so的快速修复文件，命令如下：已复制$ diff.exe -s Example.z.so -d Example.z.so -p Example.z.so.diff 命令行参数含义：  -s：旧so的路径-d：新so的路径-p：生成的差分文件的路径  生成.hqf的快速修复包基于上述的patch.json、.abc快速修复文件和.so快速修复文件，可以通过本地HarmonyOS SDK路径的toolchains文件夹下的app_packing_tool.jar生成.hqf包，执行打包命令如下： 已复制$ java -jar app_packing_tool.jar --mode hqf --json-path patch.json --lib-path libs --ets-patch patchs --out-path entry-default-unsigned.hqf --force true 命令行参数介绍： 命令  说明  备注    mode  模式  必选   json-path  patch.json路径  必选   lib-path  .so快速修复文件路径，该路径可参考快速修复包结构  可选   ets-path  .abc快速修复文件路径  可选      快速修复包的签名签名与hap签名相同，将上述生成的entry-default-unsigned.hqf包，通过签名工具进行签名。可以使用本地HarmonyOS SDK路径的toolchains文件夹下的hap-sign-tool.jar，命令如下： 已复制$ java -jar hap-sign-tool.jar sign-app -keyAlias "HarmonyOS Application Release" -signAlg "SHA256withECDSA" -mode "localSign" -appCertFile "HarmonyOSApplication.pem" -profileFile "ohos_provision_release.p7b" -inFile "entry-default-unsigned.hqf" -keystoreFile "HarmonyOS.p12" -outFile "entry-signed-release.hqf" -keyPwd "123456" -keystorePwd "123456"  安装快速修复包将上述entry-signed-release.hqf包推送到设备上 已复制hdc.exe file send .\entry-signed-release.hqf /data/ 在设备上通过下述命令行安装补丁包 已复制$ bm quickfix -a -f /data/entry-signed-release.hqf 快速修复相关完整命令行参考如下： 已复制$ bm quickfix -husage: bm quickfix <options>options list:-h, --help                                   list available commands-q, --query                                  indicates query quickfix, used with -b or --bundle-name-b, --bundle-name <bundle-name>              query quickfix status and information by a specified bundle name-a, --apply                                  indicates apply quickfix, used with -f or --file-path-f, --file-path <file-path>                  apply a quickfix file by a specified path-f, --file-path <file-path> <file-path> ...  apply some quickfix files of one bundle-f, --file-path <bundle-direction>           apply quickfix files by direction, under which are quickfix files   上一篇 快速修复概述 下一篇 应用配置文件（Stage模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。快速修复的使用规则快速修复包结构快速修复TS编译后的文件快速修复C++编译后的文件快速修复包的发布部署流程快速修复包的调试流程快速修复概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 快速修复是HarmonyOS系统提供给开发者的一种技术手段，支持开发者以远快于应用升级的方式对应用程序包进行缺陷修复。和全量应用升级软件版本相比，快速修复的主要优势在小、快和用户体验好。在较短的时间内不中断正在运行的应用的情况下（即不需要重启应用），修复应用的缺陷。 快速修复的使用规则仅支持修复应用的TS和C++代码，对应的文件为.abc文件（TS编译后的文件）和.so文件（C++编译后的文件），不支持对资源的修复。不支持新增.abc文件和.so文件。快速修复包部署时要确保对应应用包已安装，如果未安装，则部署失败。快速修复包中配置的包名和应用版本号必须和已安装的包名和版本号应用相同，如果不同则部署失败。如果已经部署过快速修复包，新部署的快速修复包的版本号必须大于之前快速修复包的版本号，否则部署失败。快速修复包的签名信息和待修复的应用的签名信息必须一致，否则会部署失败。新的应用版本发布安装时，会清理掉快速修复包。  快速修复包结构 上图是HarmonyOS应用程序发布的快速修复的包格式 从图中可以看出包含两种包格式：appqf（Application Quick Fix）  appqf与应用的app pack包是一一对应关系，具体可参考应用程序包结构的介绍。 appqf包是HarmonyOS应用用于发布到应用市场的单元，不能够直接安装到设备上。它是由一个或多个hqf（Harmony Ability Package Quick Fix）组成，这些hqf包在应用市场会从appqf包中拆分出来，再被分发到具体的设备上。appqf包上架到应用市场前要有开发者的签名信息。  hqf（Harmony Ability Package Quick Fix）  hqf包是修复HAP中问题的快速修复包，用于安装到设备上的快速修复单元。一个hqf可以包含.abc的快速修复文件，.so的快速修复文件和描述该包的配置文件。 .abc文件：应用中修改后的ts代码，编译后生成的字节码文件。libs目录：存放.so库文件的差分文件，以.so.diff为后缀。区分的不同的系统cpu架构，例如arm平台、x86平台。patch.json：  该文件用于描述hqf包版本信息的配置文件，由开发者填写，具体内容如下： 已复制{    "app" : {        "bundleName" : "com.ohos.quickfix",        "versionCode" : 1000000,        "versionName" : "1.0.0",        "patchVersionCode" : 1000000,        "patchVersionName" : "1.0.0"    },    "module" : {        "name" : "entry",        "type" : "patch",        "deviceTypes" : [        "default",        "tablet"        ],        "originalModuleHash" : "11223344556677889900"    }} 具体字段说明： 字段  类型  说明  备注    bundleName  string  对应应用的包名。  不可缺省   versionCode  int  对应应用版本号。  不可缺省   versionName  string  对应应用的版本名称。  patch类型不可缺省   patchVersionCode  int  补丁包的版本号。  不可缺省   patchVersionName  string  补丁包的版本名称。  patch类型不可缺省   name  string  对应应用的moduleName，用来修复该module的。  不可缺省   type  string  对应补丁包的类型，当前可选择为patch。  不可缺省   deviceTypes  array  补丁包支持的设备类型。  不可缺省   originalModuleHash  string  原始module Name对应包的哈希值，可采用SHA256生成器自行生成。  不可缺省         快速修复TS编译后的文件 上图是通过TS代码编译工具生成快速修复.abc文件的流程： 原始应用编译时，生成.abc文件和.map文件。.abc是TS代码编译后的字节码文件，应用运行时使用该文件。.map文件是通过TS代码编译工具编译TS代码时生成的中间文件，记录有代码中的函数、类等信息。修复问题后的应用编译时，根据上述的.map文件，结合当前的TS代码，得到差异部分，根据差异部分生成快速修复的.abc文件。该.abc文件也既是最终要放到hqf包中的快速修复文件。  快速修复C++编译后的文件 上图是通过差分工具生成快速修复.so文件的流程： 原始应用C++源码通过编译工具生成.so文件，该.so文件供应用在运行时使用。修复问题后的C++源码通过编译工具生成.so文件，该.so文件和原应用的.so文件通过差分工具生成.so快速修复文件，该.so快速修复文件也既是最终要放到hqf包中的快速修复文件。  快速修复包的发布部署流程 上图涉及到的模块如下： DevEco Studio：用于开发代码的项目工程的集成开发环境。在快速修复的工程中能够给予原应用的代码和修复问题后的代码生成快速修复包，并完成快速修复包的签名。应用市场服务器端：开发者将开发完成的快速修复包上架到该平台，平台会对上架的包进行签名验证、风险扫描和拆包重签名等，然后分发到客户端。应用市场客户端：用于接收应用市场服务器端分发的快速修复包，并触发安装快速修复包。包管理服务：设备上用于管理应用包及快速修复包安装和卸载的系统服务程序。快速修复引擎：设备上用于管理应用切换使用快速修复包的系统服务程序。如果应用正在运行，快速修复引擎接收到有快速修复包部署完成会通知应用切换快速修复包，进而使得应用使能快速修复包。文件系统：应用及快速修复包部署在设备上的位置。 上图是快速修复包的端到端发布部署流程： 开发者通过DevEco Studio，基于原应用的源码和修复后的源码编译打包生成快速修复包，并通过DevEco Studio完成快速修复包的签名。将生成的带有签名的快速修复包上架到应用市场，应用市场通过验证签名、风险扫描和拆包重签名后进行分发。设备侧的应用市场客户端检测到应用市场服务器端有新上架的快速修复包会下载最新版本的快速修复包，接着通过系统中的包管理服务来安装部署快速修复包。快速修复包部署完成后，再由快速修复引擎触发应用使用快速修复包，进而保证用户使用到问题修复后的功能。  快速修复包的调试流程 DevEco Studio中暂时还没有集成快速修复的能力。当前阶段，HarmonyOS为开发者提供了命令行的调试开发工具可供使用，具体的调试开发流程如下： 基于原应用的源码和修复后的源码，通过命令行工具可以编译生成快速修复包，并通过命令行签名工具完成对快速修复的包的签名。通过命令行调试开发，要对.hqf包签名，并通过命令行工具将.hqf包安装到设备上，.appqf包不能直接安装到设备上。通过快速修复的命令行工具，将.hqf包安装部署到设备上。.hqf包安装部署完成后，回调通知快速修复引擎触发应用使用快速修复包，进而保证用户使用到问题修复后的功能。   上一篇 应用程序包快速修复 下一篇 快速修复命令行调试开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤函数介绍Rawfile开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 场景介绍开发者可以通过本指导了解在HarmonyOS应用中，如何使用Native Rawfile接口操作Rawfile目录和文件。功能包括遍历、打开、搜索、读取和关闭Rawfile。  接口说明 接口名  描述    NativeResourceManager *OH_ResourceManager_InitNativeResourceManager(napi_env env, napi_value jsResMgr)  初始化native resource manager。   RawDir *OH_ResourceManager_OpenRawDir(const NativeResourceManager *mgr, const char *dirName)  打开指定rawfile目录。   int OH_ResourceManager_GetRawFileCount(RawDir *rawDir)  获取指定rawfile目录下的rawfile文件数量。   const char *OH_ResourceManager_GetRawFileName(RawDir *rawDir, int index)  获取rawfile名字。   RawFile *OH_ResourceManager_OpenRawFile(const NativeResourceManager *mgr, const char *fileName)  打开指定rawfile文件。   long OH_ResourceManager_GetRawFileSize(RawFile *rawFile)  获取rawfile文件大小。   int OH_ResourceManager_SeekRawFile(const RawFile *rawFile, long offset, int whence)  指定rawfile内偏移量。   long OH_ResourceManager_GetRawFileOffset(const RawFile *rawFile)  获取rawfile偏移量。   int OH_ResourceManager_ReadRawFile(const RawFile *rawFile, void *buf, size_t length)  读取rawfile文件内容。   void OH_ResourceManager_CloseRawFile(RawFile *rawFile)  释放rawfile文件相关资源。   void OH_ResourceManager_CloseRawDir(RawDir *rawDir)  释放rawfile目录相关资源。   bool OH_ResourceManager_GetRawFileDescriptor(const RawFile *rawFile, RawFileDescriptor &descriptor)  获取rawfile的fd。   bool OH_ResourceManager_ReleaseRawFileDescriptor(const RawFileDescriptor &descriptor)  释放rawfile的fd。   void OH_ResourceManager_ReleaseNativeResourceManager(NativeResourceManager *resMgr)  释放native resource manager相关资源。      开发步骤以Js侧获取rawfile文件列表、rawfile文件内容、rawfile描述符{fd, offset, length}三种调用方式为例。 1. 创建工程  2. 添加依赖 创建完成后，IDE会在工程生成cpp目录，目录有libentry/index.d.ts、hello.cpp、CMakeLists.txt等文件。 打开src/main/cpp/CMakeLists.txt，在target_link_libraries依赖中添加资源的librawfile.z.so以及日志依赖libhilog_ndk.z.so。已复制target_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so librawfile.z.so) 打开src/main/cpp/types/libentry/index.d.ts文件，此文件声明了应用侧函数getFileList、getRawFileContent、getRawFileDescriptor。已复制import resourceManager from '@ohos.resourceManager';export const getFileList: (resmgr: resourceManager.ResourceManager, path: string) => Array<String>;export const getRawFileContent: (resmgr: resourceManager.ResourceManager, path: string) => Uint8Array;export const getRawFileDescriptor: (resmgr: resourceManager.ResourceManager, path: string) => resourceManager.RawFileDescriptor;   3. 修改源文件 打开src/main/cpp/hello.cpp文件，文件Init会对当前方法进行初始化映射，这里定义对外接口为getFileList、getRawFileContent、getRawFileDescriptor，映射C++接口分别为GetFileList、GetRawFileContent、GetRawFileDescriptor。已复制EXTERN_C_STARTstatic napi_value Init(napi_env env, napi_value exports){        napi_property_descriptor desc[] = {                { "getFileList", nullptr, GetFileList, nullptr, nullptr, nullptr, napi_default, nullptr },        { "getRawFileContent", nullptr, GetRawFileContent, nullptr, nullptr, nullptr, napi_default, nullptr },        { "getRawFileDescriptor", nullptr, GetRawFileDescriptor, nullptr, nullptr, nullptr, napi_default, nullptr }    };     napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);    return exports;}EXTERN_C_END 把src/main/cpp/hello.cpp文件中，增加对应的三个方法，如下所示已复制static napi_value GetFileList(napi_env env, napi_callback_info info)static napi_value GetRawFileContent(napi_env env, napi_callback_info info)static napi_value GetRawFileDescriptor(napi_env env, napi_callback_info info) 在hello.cpp文件中获取Js的资源对象，并转为Native的资源对象，即可调用资源的Native接口，获取rawfile列表、rawfile文件内容以及rawfile描述符{fd, offset, length}三种调用方式示例代码如下：已复制#include <rawfile/raw_file.h>#include <rawfile/raw_dir.h>#include <rawfile/raw_file_manager.h>
// 示例一：获取rawfile文件列表 GetFileListstatic napi_value GetFileList(napi_env env, napi_callback_info info){    OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "NDKTest Begin");    size_t requireArgc = 3;    size_t argc = 2;    napi_value argv[2] = { nullptr };    // 获取参数信息    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);    // argv[0]即为函数第一个参数Js资源对象，OH_ResourceManager_InitNativeResourceManager转为Native对象。    NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]);
    // 获取函数argv[1]，此为为rawfile相对路径    size_t strSize;    char strBuf[256];    napi_get_value_string_utf8(env, argv[1], strBuf, sizeof(strBuf), &strSize);    std::string dirName(strBuf, strSize);
    // 获取对应的rawDir指针对象    RawDir* rawDir = OH_ResourceManager_OpenRawDir(mNativeResMgr, dirName.c_str());
    // 获取rawDir下文件及文件夹数量    int count = OH_ResourceManager_GetRawFileCount(rawDir);
    // 遍历获取文件名称，并保存    std::vector<std::string> tempArray;    for(int i = 0; i < count; i++) {        std::string filename = OH_ResourceManager_GetRawFileName(rawDir, i);        tempArray.emplace_back(filename);    }
    napi_value fileList;    napi_create_array(env, &fileList);    for (size_t i = 0; i < tempArray.size(); i++) {        napi_value jsString;        napi_create_string_utf8(env, tempArray[i].c_str(), NAPI_AUTO_LENGTH, &jsString);        napi_set_element(env, fileList, i, jsString);    }
    // 关闭打开的指针对象    OH_ResourceManager_CloseRawDir(rawDir);    OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr);    return fileList;}
// 示例二：获取rawfile文件内容 GetRawFileContentnapi_value CreateJsArrayValue(napi_env env, std::unique_ptr<uint8_t[]> &data, long length){    napi_value buffer;    napi_status status = napi_create_external_arraybuffer(env, data.get(), length,            [](napi_env env, void *data, void *hint) {                delete[] static_cast<char*>(data);            }, nullptr, &buffer);    if (status != napi_ok) {        OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "Failed to create external array buffer");        return nullptr;    }    napi_value result = nullptr;    status = napi_create_typedarray(env, napi_uint8_array, length, buffer, 0, &result);    if (status != napi_ok) {        OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "Failed to create media typed array");        return nullptr;    }    data.release();    return result;}
static napi_value GetRawFileContent(napi_env env, napi_callback_info info){    OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "GetFileContent Begin");    size_t requireArgc = 3;    size_t argc = 2;    napi_value argv[2] = { nullptr };    // 获取参数信息    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);
    // argv[0]即为函数第一个参数Js资源对象，OH_ResourceManager_InitNativeResourceManager转为Native对象。    NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]);    size_t strSize;    char strBuf[256];    napi_get_value_string_utf8(env, argv[1], strBuf, sizeof(strBuf), &strSize);    std::string filename(strBuf, strSize);     // 获取rawfile指针对象    RawFile *rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, filename.c_str());    if (rawFile != nullptr) {        OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "OH_ResourceManager_OpenRawFile success");    }    // 获取rawfile大小并申请内存    long len = OH_ResourceManager_GetRawFileSize(rawFile);    std::unique_ptr<uint8_t[]> data= std::make_unique<uint8_t[]>(len);    // 读取rawfile    int res = OH_ResourceManager_ReadRawFile(rawFile, data.get(), len);    // 关闭打开的指针对象    OH_ResourceManager_CloseRawFile(rawFile);    OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr);    // 转为js对象    return CreateJsArrayValue(env, data, len);}
// 示例三：获取rawfile文件描述符 GetRawFileDescriptornapi_value createJsFileDescriptor(napi_env env, RawFileDescriptor &descriptor){    napi_value result;    napi_status status = napi_create_object(env, &result);    if (status != napi_ok) {        return result;    }     napi_value fd;    status = napi_create_int32(env, descriptor.fd, &fd);    if (status != napi_ok) {        return result;    }    status = napi_set_named_property(env, result, "fd", fd);    if (status != napi_ok) {        return result;    }     napi_value offset;    status = napi_create_int64(env, descriptor.start, &offset);    if (status != napi_ok) {        return result;    }    status = napi_set_named_property(env, result, "offset", offset);    if (status != napi_ok) {        return result;    }
    napi_value length;    status = napi_create_int64(env, descriptor.length, &length);    if (status != napi_ok) {        return result;    }    status = napi_set_named_property(env, result, "length", length);    if (status != napi_ok) {        return result;    }    return result;}
static napi_value GetRawFileDescriptor(napi_env env, napi_callback_info info){    OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "NDKTest GetRawFileDescriptor Begin");    size_t requireArgc = 3;    size_t argc = 2;    napi_value argv[2] = { nullptr };    // 获取参数信息    napi_get_cb_info(env, info, &argc, argv, nullptr, nullptr);
    napi_valuetype valueType;    napi_typeof(env, argv[0], &valueType);    // 获取native的resourceManager对象    NativeResourceManager *mNativeResMgr = OH_ResourceManager_InitNativeResourceManager(env, argv[0]);    size_t strSize;    char strBuf[256];    napi_get_value_string_utf8(env, argv[1], strBuf, sizeof(strBuf), &strSize);    std::string filename(strBuf, strSize);    // 获取rawfile指针对象    RawFile *rawFile = OH_ResourceManager_OpenRawFile(mNativeResMgr, filename.c_str());    if (rawFile != nullptr) {        OH_LOG_Print(LOG_APP, LOG_ERROR, GLOBAL_RESMGR, tag, "OH_ResourceManager_OpenRawFile success");    }    // 获取rawfile的描述符RawFileDescriptor {fd, offset, length}    RawFileDescriptor descriptor;    OH_ResourceManager_GetRawFileDescriptor(rawFile, descriptor);    // 关闭打开的指针对象    OH_ResourceManager_CloseRawFile(rawFile);    OH_ResourceManager_ReleaseNativeResourceManager(mNativeResMgr);    // 转为js对象    return createJsFileDescriptor(env,descriptor);} Js侧调用打开src\main\ets\pages\index.ets, 导入"libentry.so";资源获取包括获取本应用包资源、应用内跨包资源。 获取本应用包resourceManager对象，通过.context().resourceManager方法。 获取应用内跨包resourceManager对象，通过.context().createModuleContext().resourceManager 方法。 Context的更多使用信息请参考应用上下文Context。 调用Native接口getFileList即为src/main/cpp/types/libentry/index.d.ts中声明的接口，传入js的资源对象，以及rawfile文件夹的相对路径。获取本应用包resourceManager对象的示例如下：已复制import hilog from '@ohos.hilog';import testNapi from 'libentry.so'  // 导入so@Entry@Componentstruct Index {    @State message: string = 'Hello World'    private resmgr = getContext().resourceManager;  // 获取本应用包的资源对象    build() {        Row() {        Column() {            Text(this.message)            .fontSize(50)            .fontWeight(FontWeight.Bold)            .onClick(() => {                hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO);                let rawfilelist = testNapi.getFileList(this.resmgr, ""); //传入资源对象，以及访问的rawfile文件夹名称                console.log("rawfilelist" + rawfilelist);                let rawfileContet = testNapi.getRawFileContent(this.resmgr, "rawfile1.txt");                console.log("rawfileContet" + rawfileContet);                let rawfileDescriptor = testNapi.getRawFileDescriptor(this.resmgr, "rawfile1.txt");                console.log("getRawFileDescriptor" + rawfileDescriptor.fd, rawfileDescriptor.offset, rawfileDescriptor.length);            })        }        .width('100%')        }        .height('100%')    }}     函数介绍根据NativeResourceManager实例，使用OH_ResourceManager_OpenRawDir接口获取RawDir实例。已复制RawDir* rawDir = OH_ResourceManager_OpenRawDir(nativeResourceManager, path.c_str()); 根据RawDir实例，使用OH_ResourceManager_GetRawFileCount接口获取对应目录下的rawfile文件总数 。已复制int count = OH_ResourceManager_GetRawFileCount(rawDir); 根据RawDir实例，使用OH_ResourceManager_GetRawFileName接口获取目录下对应index的rawfile文件名。已复制for (int index = 0; index < count; index++) {    std::string fileName = OH_ResourceManager_GetRawFileName(rawDir, index);} 根据NativeResourceManager实例，使用OH_ResourceManager_OpenRawFile接口获取指定文件名的RawFile实例。已复制RawFile* rawFile = OH_ResourceManager_OpenRawFile(nativeResourceManager, fileName.c_str()); 根据RawFile实例，使用OH_ResourceManager_GetRawFileSize接口获取对应rawfile文件大小。已复制long rawFileSize = OH_ResourceManager_GetRawFileSize(rawFile); 根据RawFile实例，使用OH_ResourceManager_SeekRawFile接口指定rawfile偏移量。 已复制int position = OH_ResourceManager_SeekRawFile(rawFile, 10, 0);int position = OH_ResourceManager_SeekRawFile(rawFile, 0 , 1);int position = OH_ResourceManager_SeekRawFile(rawFile, -10, 2); 根据RawFile实例，使用OH_ResourceManager_GetRawFileOffset接口获取rawfile偏移量。已复制long rawFileOffset = OH_ResourceManager_GetRawFileOffset(rawFile); 根据RawFile实例，使用OH_ResourceManager_ReadRawFile接口读取rawfile文件内容。已复制std::unique_ptr<char[]> mediaData = std::make_unique<char[]>(rawFileSize);long rawFileOffset = OH_ResourceManager_ReadRawFile(rawFile, mediaData.get(), rawFileSize); 根据RawFile实例，使用OH_ResourceManager_CloseRawFile接口释放rawfile文件相关资源。已复制OH_ResourceManager_CloseRawFile(rawFile); 根据RawDir实例，使用OH_ResourceManager_CloseRawDir接口释放rawfile目录相关资源。已复制OH_ResourceManager_CloseRawDir(rawDir); 根据RawFile实例，使用OH_ResourceManager_GetRawFileDescriptor接口获取rawfile的RawFileDescriptor。已复制RawFileDescriptor descriptor;bool result = OH_ResourceManager_GetRawFileDescriptor(rawFile, descriptor); 根据RawFileDescriptor实例，使用OH_ResourceManager_ReleaseRawFileDescriptor接口关闭rawfile的fd。已复制OH_ResourceManager_ReleaseRawFileDescriptor(descriptor); 根据NativeResourceManager实例，使用OH_ResourceManager_ReleaseNativeResourceManager接口释放native resource manager。已复制OH_ResourceManager_ReleaseNativeResourceManager(nativeResourceManager);    上一篇 Drawing开发指导 下一篇 NativeWindow 开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。跳转规则 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 一般情况下，应用中的界面跳转由用户触发，应用本身通过startAbility启动跳转其他界面。 PageAbility作为可见Ability，可以通过startAbility启动有界面的且对外可见的Ability。 应用可通过在config.json中设置"abilities"中的"visible"属性设置Ability是否可由其他应用的组件启动，"visible"属性的具体参数和意义如下表所示。  表1 visible属性说明 属性名称 描述 是否可缺省   visible 表示Ability是否可以被其他应用调用。 true：该Ability可以被任何应用调用。 false：该Ability只能被同一应用的其他组件调用。  可缺省，缺省时默认属性值为"false"。    如果需设置当前Ability可由任何应用访问，对应config.json文件的示例代码如下所示： 已复制{  "module": {    // ...    "abilities": [      {        "visible": "true",        // ...      }    ]  }} 如果应用中的Ability包含skills过滤器，建议此属性设置为"true"，以允许其他应用通过隐式调用启动该Ability。如果此属性设为"false"，其他应用尝试启动该Ability时系统会返回PERMISSION_DENIED。这种情况下系统应用可以通过申请START_INVISIBLE_ABILITY权限启动visible为false的组件，例如系统桌面、语音助手、搜索助手等。  上一篇 申请授权 下一篇 ServiceAbility组件开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Release应用堆栈解析 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 应用在Release后，经过代码混淆的堆栈信息无法定位到源码的具体文件和行位置，不易于快速解决问题。针对该场景，DevEco Studio提供了Release应用堆栈解析功能，利用Release应用堆栈中的bundle路径，通过映射规则转换为具体的源码路径，从而提升解决问题的效率。当前仅API Version 8~9支持。 Release应用堆栈解析功能操作方法如下： 单击菜单栏Code > Analyze Stack Trace。在弹出的Analyze Stack Trace对话框中，粘贴Release应用的异常堆栈信息，单击OK。 DevEco Studio将解析后的堆栈信息显示在底部的Stacktrace页签中，点击路径链接可快速定位到源码具体位置。    上一篇 堆栈可视化调试 下一篇 C/C++时光调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。申请授权 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 应用需要获取用户的隐私信息或使用系统能力时，例如获取位置信息、使用相机拍摄照片或录制视频等，需要向用户申请授权。 在开发过程中，首先需要明确涉及的敏感权限并在config.json中声明需要的权限，同时通过接口requestPermissionsFromUser以动态弹窗的方式向用户申请授权。 在config.json声明需要的权限，在module下添加"reqPermissions"，并写入对应权限。 如申请访问日历权限，需要申请ohos.permission.READ_CALENDAR权限，配置方式请参阅访问控制授权申请指导。  对应config.json文件的示例代码如下所示： 已复制{  "module": {    // ...    "reqPermissions": [      {        "name": "ohos.permission.READ_CALENDAR"        // ...      }    ]  }} 通过动态弹窗向用户申请授权： 已复制import featureAbility from '@ohos.ability.featureAbility';
let context = featureAbility.getContext();  let permissions: Array<string> = ['ohos.permission.READ_CALENDAR']context.requestPermissionsFromUser(permissions, 1).then((data) => {        console.info("Succeed to request permission from user with data: " + JSON.stringify(data))}).catch((error) => {        console.info("Failed to request permission from user with error: " + JSON.stringify(error))})  上一篇 窗口属性 下一篇 跳转规则 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。资源分类资源目录资源组目录创建资源目录和资源文件创建资源目录和资源文件创建资源目录创建资源文件资源访问应用资源系统资源资源匹配资源分类与访问 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  应用开发过程中，经常需要用到颜色、字体、间距、图片等资源，在不同的设备或配置中，这些资源的值可能不同。  应用资源：借助资源文件能力，开发者在应用中自定义资源，自行管理这些资源在不同的设备或配置中的表现。 系统资源：开发者直接使用系统预置的资源定义（即分层参数，同一资源ID在设备类型、深浅色等不同配置下有不同的取值）。   资源分类 应用开发中使用的各类资源文件，需要放入特定子目录中存储管理。资源目录的示例如下所示，base目录、限定词目录、rawfile目录称为资源目录，element、media、profile称为资源组目录。 
说明
 stage模型多工程情况下，共有的资源文件放到AppScope下的resources目录。 
 资源目录示例： 已复制resources|---base|   |---element|   |   |---string.json|   |---media|   |   |---icon.png|   |---profile|   |   |---test_profile.json|---en_US  // 默认存在的目录，设备语言环境是美式英文时，优先匹配此目录下资源|   |---element|   |   |---string.json|   |---media|   |   |---icon.png|   |---profile|   |   |---test_profile.json|---zh_CN  // 默认存在的目录，设备语言环境是简体中文时，优先匹配此目录下资源|   |---element|   |   |---string.json|   |---media|   |   |---icon.png|   |---profile|   |   |---test_profile.json|---en_GB-vertical-car-mdpi // 自定义限定词目录示例，由开发者创建|   |---element|   |   |---string.json|   |---media|   |   |---icon.png|   |---profile|   |   |---test_profile.json|---rawfile // 其他类型文件，原始文件形式保存，不会被集成到resources.index文件中。文件名可自定义。   资源目录  base目录 base目录是默认存在的目录，二级子目录element用于存放字符串、颜色、布尔值等基础元素，media、profile存放媒体、动画、布局等资源文件。 目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。通过指定资源类型（type）和资源名称（name）引用。 限定词目录 en_US和zh_CN是默认存在的两个限定词目录，其余限定词目录需要开发者根据开发需要自行创建。二级子目录element、media、profile用于存放字符串、颜色、布尔值等基础元素，以及媒体、动画、布局等资源文件。 同样，目录中的资源文件会被编译成二进制文件，并赋予资源文件ID。通过指定资源类型（type）和资源名称（name）来引用。 限定词目录的命名要求 限定词目录可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括移动国家码和移动网络码、语言、文字、国家或地区、横竖屏、设备类型、颜色模式和屏幕密度等维度，限定词之间通过下划线（_）或者中划线（-）连接。开发者在创建限定词目录时，需要遵守限定词目录的命名规则。  限定词的组合顺序：_移动国家码_移动网络码-语言_文字_国家或地区-横竖屏-设备类型-颜色模式-屏幕密度_。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称。 限定词的连接方式：语言、文字、国家或地区之间采用下划线（_）连接，移动国家码和移动网络码之间也采用下划线（_）连接，除此之外的其他限定词之间均采用中划线（-）连接。例如：zh_Hant_CN、zh_CN-car-ldpi。 限定词的取值范围：每类限定词的取值必须符合限定词取值要求表中的条件，如表2。否则，将无法匹配目录中的资源文件。  表2 限定词取值要求     限定词类型 含义与取值说明    移动国家码和移动网络码 移动国家码（MCC）和移动网络码（MNC）的值取自设备注册的网络。 MCC可与MNC合并使用，使用下划线（_）连接，也可以单独使用。例如：mcc460表示中国，mcc460_mnc00表示中国_中国移动。 详细取值范围，请查阅ITU-T E.212（国际电联相关标准）。   语言 表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。 详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。   文字 表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。 详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。   国家或地区 表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。 详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。   横竖屏 表示设备的屏幕方向，取值如下： - vertical：竖屏 - horizontal：横屏   设备类型 表示设备的类型，取值如下： - car：车机 - tablet：平板 - tv：智慧屏 - wearable：智能穿戴   颜色模式 表示设备的颜色模式，取值如下： - dark：深色模式 - light：浅色模式   屏幕密度 表示设备的屏幕密度（单位为dpi），取值如下： - sdpi：表示小规模的屏幕密度（Small-scale Dots Per Inch），适用于dpi取值为(0, 120]的设备。 - mdpi：表示中规模的屏幕密度（Medium-scale Dots Per Inch），适用于dpi取值为(120, 160]的设备。 - ldpi：表示大规模的屏幕密度（Large-scale Dots Per Inch），适用于dpi取值为(160, 240]的设备。 - xldpi：表示特大规模的屏幕密度（Extra Large-scale Dots Per Inch），适用于dpi取值为(240, 320]的设备。 - xxldpi：表示超大规模的屏幕密度（Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(320, 480]的设备。 - xxxldpi：表示超特大规模的屏幕密度（Extra Extra Extra Large-scale Dots Per Inch），适用于dpi取值为(480, 640]的设备。    rawfile目录 支持创建多层子目录，目录名称可以自定义，文件夹内可以自由放置各类资源文件。 目录中的资源文件会被直接打包进应用，不经过编译，也不会被赋予资源文件ID。通过指定文件路径和文件名引用。  资源组目录 资源组目类型包括element、media、profile，用于存放特定类型的资源文件。 表3 资源组目录说明     目录类型 说明 资源文件    element 表示元素资源，以下每一类数据都采用相应的JSON文件来表征（目录下仅支持文件类型）。 - boolean，布尔型 - color，颜色 - float，浮点型 - intarray，整型数组 - integer，整型 - pattern，样式 - plural，复数形式 - strarray，字符串数组 - string，字符串 element目录中的文件名称建议与下面的文件名保持一致。每个文件中只能包含同一类型的数据。 - boolean.json - color.json - float.json - intarray.json - integer.json - pattern.json - plural.json - strarray.json - string.json   media 表示媒体资源，包括图片、音频、视频等非文本格式的文件（目录下只支持文件类型）。 图片和音视频的类型说明见表4和表5。 文件名可自定义，例如：icon.png。   profile 表示自定义配置文件，其文件内容可通过包管理接口获取（目录下只支持文件类型）。 文件名可自定义，例如：test_profile.json。    媒体资源类型说明 表4 图片资源类型说明     格式 文件后缀名    JPEG .jpg   PNG .png   GIF .gif   SVG .svg   WEBP .webp   BMP .bmp    表5 音视频资源类型说明     格式 支持的文件类型    H.263 .3gp .mp4   H.264 AVC Baseline Profile (BP) .3gp .mp4   MPEG-4 SP .3gp   VP8 .webm .mkv    资源文件示例 color.json文件的内容如下： 已复制{    "color": [        {            "name": "color_hello",            "value": "#ffff0000"        },        {            "name": "color_world",            "value": "#ff0000ff"        }    ]} float.json文件的内容如下： 已复制{    "float":[        {            "name":"font_hello",            "value":"28.0fp"        },    {            "name":"font_world",            "value":"20.0fp"        }    ]} string.json文件的内容如下： 已复制{    "string":[        {            "name":"string_hello",            "value":"Hello"        },    {            "name":"string_world",            "value":"World"        },    {            "name":"message_arrive",            "value":"We will arrive at %s."        }    ]} plural.json文件的内容如下： 已复制{    "plural":[        {            "name":"eat_apple",            "value":[                {                    "quantity":"one",                    "value":"%d apple"                },                {                    "quantity":"other",                    "value":"%d apples"                }            ]        }    ]}   创建资源目录和资源文件 在resources目录下，可按照限定词目录命名规则，以及资源组目录支持的文件类型和说明，创建资源目录和资源组目录，添加特定类型资源。DevEco Studio支持同时创建资源目录和资源文件，也支持单独创建资源目录或资源文件。   创建资源目录和资源文件 在resources目录右键菜单选择“New > Resource File”，可同时创建资源目录和资源文件，文件默认创建在base目录的对应资源组。如果选择了限定词，则会按照命名规范自动生成限定词和资源组目录，并将文件创建在限定词目录中。 图中File name为需要创建的文件名。Resource type为资源组类型，默认是element。Root Element为资源类型。Avaliable qualifiers为供选择的限定词目录，通过右边的小箭头可添加或者删除。 创建的目录名自动生成，格式固定为“限定词.资源组”，例如：创建一个限定词为dark的element目录，自动生成的目录名称为“dark.element”。    创建资源目录 在resources目录右键菜单选择“New > Resource Directory”，可创建资源目录，默认创建的是base目录。如果选择了限定词，则会按照命名规范自动生成限定词和资源组目录。确定限定词后，选择资源组类型，当前资源组类型支持Element、Media、Profile三种，创建后生成资源目录。    创建资源文件 在资源目录（element、media、profile）的右键菜单选择“New > XXX Resource File”，即可创建对应资源组目录的资源文件。例如，在element目录下可新建Element Resource File。    资源访问   应用资源  对于应用资源，在工程中，通过"$r('app.type.name')"形式引用。其中，app为应用内resources目录中定义的资源；type为资源类型或资源的存放位置，取值包含“color”、“float”、“string”、“plural”、“media”；name为资源命名，由开发者定义资源时确定。 对于rawfile目录资源，通过"$rawfile('filename')"形式引用。其中，filename为rawfile目录下文件的相对路径，文件名需要包含后缀，路径开头不可以以"/"开头。 对于rawfile目录的descriptor，可通过资源管理的getRawFd接口引用，其返回值descriptor.fd为hap包的fd。此时，访问rawfile文件需要结合{fd, offset, length}一起使用。  
说明
 资源描述符不能拼接使用，仅支持普通字符串如'app.type.name'。 $r返回值为Resource对象，可通过getStringValue 方法获取对应的字符串。 
 资源组目录下的“资源文件示例”显示了.json文件内容，包含color.json文件、string.json文件和plural.json文件，访问应用资源时需先了解.json文件的使用规范。 资源的具体使用方法如下： 已复制Text($r('app.string.string_hello'))  .fontColor($r('app.color.color_hello'))  .fontSize($r('app.float.font_hello'))
Text($r('app.string.string_world'))  .fontColor($r('app.color.color_world'))  .fontSize($r('app.float.font_world'))
// 引用string.json资源。Text中$r的第一个参数指定string资源，第二个参数用于替换string.json文件中的%s。// 如下示例代码value为"We will arrive at five of the clock"。Text($r('app.string.message_arrive', "five of the clock"))  .fontColor($r('app.color.color_hello'))  .fontSize($r('app.float.font_hello'))
// 引用plural$资源。Text中$r的第一个指定plural资源，第二个参数用于指定单复数（在中文，单复数均使用other。在英文，one：代表单数，取值为1；other：代表复数，取值为大于等于1的整数），第三个参数用于替换%d// 如下示例代码为复数，value为"5 apples"。Text($r('app.plural.eat_apple', 5, 5))  .fontColor($r('app.color.color_world'))  .fontSize($r('app.float.font_world'))
Image($r('app.media.my_background_image'))  // media资源的$r引用
Image($rawfile('test.png'))                 // rawfile$r引用rawfile目录下图片
Image($rawfile('newDir/newTest.png'))       // rawfile$r引用rawfile目录下图片   系统资源 除了自定义资源，开发者也可以使用系统中预定义的资源，统一应用的视觉风格。可以查看应用UX设计中关于资源的介绍，获取支持的系统资源ID及其在不同配置下的取值。 在开发过程中，分层参数的用法与资源限定词基本一致。对于系统资源，可以通过“$r('sys.type.resource_id')”的形式引用。其中，sys为系统资源；type为资源类型，取值包括“color”、“float”、“string”、“media”；resource_id为资源id。 
说明
  仅声明式开发范式支持使用系统资源。 对于系统预置应用，建议使用系统资源；对于三方应用，可以根据需要选择使用系统资源或自定义应用资源。  
 已复制Text('Hello')  .fontColor($r('sys.color.ohos_id_color_emphasize'))  .fontSize($r('sys.float.ohos_id_text_size_headline1'))  .fontFamily($r('sys.string.ohos_id_text_font_family_medium'))  .backgroundColor($r('sys.color.ohos_id_color_palette_aux1'))
Image($r('sys.media.ohos_app_icon'))  .border({    color: $r('sys.color.ohos_id_color_palette_aux1'),    radius: $r('sys.float.ohos_id_corner_radius_button'), width: 2  })  .margin({    top: $r('sys.float.ohos_id_elements_margin_horizontal_m'),    bottom: $r('sys.float.ohos_id_elements_margin_horizontal_l')  })  .height(200)  .width(300)   资源匹配 应用使用某资源时，系统会根据当前设备状态优先从相匹配的限定词目录中寻找该资源。只有当resources目录中没有与设备状态匹配的限定词目录，或者在限定词目录中找不到该资源时，才会去base目录中查找。rawfile是原始文件目录，不会根据设备状态去匹配不同的资源。 限定词目录与设备状态的匹配规则  在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：移动国家码和移动网络码 > 区域（可选组合：语言、语言_文字、语言_国家或地区、语言_文字_国家或地区）> 横竖屏 > 设备类型 > 颜色模式 > 屏幕密度。 如果限定词目录中包含移动国家码和移动网络码、语言、文字、横竖屏、设备类型、颜色模式限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如，限定词目录“zh_CN-car-ldpi”不能参与“en_US”设备的资源匹配。  应用界面加载资源规则，更多请参考国际化和本地化文档。  上一篇 module对象内部结构 下一篇 学习ArkTS语言 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用/服务运行 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     运行HarmonyOS应用/服务  运行OpenHarmony应用/服务运行   上一篇 通过命令行方式构建应用或服务（API 4-7） 下一篇 运行HarmonyOS应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。在Car中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 当前暂不支持使用Car类型真机进行运行和调试。  上一篇 在Phone和Tablet中运行应用/服务 下一篇 在TV中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件操作步骤在Lite Wearable中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在Lite Wearable中安装和运行HarmonyOS应用/服务，依赖华为手机上的运动健康和应用调测助手APP辅助进行。 前提条件已将运动健康APP升级至最新版本。从华为应用市场安装应用调测助手APP。在Lite Wearable中运行应用/服务，需要根据为应用/服务进行签名章节，提前对应用/服务进行签名。
说明
因Lite Wearable设备无法与DevEco Studio进行连接，因此在对Lite Wearable应用/服务签名时，不能采用自动化签名方案，只能使用手动方式申请签名文件，然后再手动配置签名信息。 
   操作步骤使用USB连接线将手机和电脑进行连接，确保连接状态是正常的。手机与电脑使用USB连接时，在手机上选择传输文件连接方式。在工程目录中的Build > outputs >hap中选择生成的HAP，通过手工拷贝的方式将HAP拷贝至手机中的“/sdcard/haps/”目录。
说明
如果在手机存储根目录下没有“haps”文件夹，请手工创建后再拷贝HAP到该文件夹下。 
 将Lite Wearable通过蓝牙与华为手机进行连接。进入运动健康APP，在设备页签中，单击添加设备按钮。 进入手表列表中，选择对应的Lite Wearable型号。单击开始配对，按照界面指引完成Lite Wearable与华为手机之间的连接。 打开应用调测助手APP，界面会显示已经与华为手机连接的Lite Wearable。
说明
如果Lite Wearable与华为手机未连接，请单击应用调测助手APP界面的连接设备按钮，手机会自动打开运动健康APP添加Lite Wearable。 
 单击应用调测助手APP界面中的应用管理按钮，选择需要安装的HarmonyOS安装包进行安装。安装完成后，单击Lite Wearable中的应用图标，运行HarmonyOS应用。   上一篇 在Wearable中运行应用/服务 下一篇 在Smart Vision设备中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用USB连接方式前提条件操作步骤使用IP Connection连接方式前提条件操作步骤在Phone和Tablet中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在Phone和Tablet中运行HarmonyOS应用/服务的操作方法一致，可以采用USB连接方式或者IP Connection的连接方式。采用IP Connection连接方式要求Phone/Tablet和PC端在同一个网段，建议将Phone/Tablet和PC连接到同一个WLAN下。 使用USB连接方式 前提条件在Phone或者Tablet中，打开“开发者模式”，可在设置 > 关于手机/关于平板中，连续多次单击“版本号”，直到提示“您正处于开发者模式”即可。然后在设置的系统与更新 > 开发人员选项中，打开“USB调试”开关。 在Phone或者Tablet中运行应用/服务，需要根据为应用/服务进行签名章节，提前对应用/服务进行签名。  操作步骤使用USB方式，将Phone或者Tablet与PC端进行连接。在Phone或者Tablet中，USB连接方式选择“传输文件”。在Phone或者Tablet中，会弹出“是否允许USB调试”的弹框，单击确定。 在菜单栏中，单击Run>Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）运行应用/服务。 DevEco Studio启动HAP的编译构建和安装。安装成功后，Phone或者Tablet会自动运行安装的HarmonyOS应用/服务。  使用IP Connection连接方式 前提条件已将Phone/Tablet和PC连接到同一WLAN网络。已获取Phone/Tablet端的IP地址，可通过设置 > 关于手机/关于平板 > 状态信息 > IP地址进行查看。Phone/Tablet上的5555端口为打开状态，默认是关闭状态，可以通过使用USB连接方式连接上设备后，在PC中执行如下命令打开。已复制hdc tmode port 5555 更多关于命令行工具hdc的使用说明，请参见hdc使用指导。 在Phone/Tablet中运行应用/服务，需要根据为应用/服务进行签名章节，提前对应用/服务进行签名。  操作步骤在DevEco Studio菜单栏中，单击Tools>IP Connection，输入连接设备的IP地址，单击，连接正常后，设备状态为online。 在菜单栏中，单击Run>Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）运行应用/服务。 DevEco Studio启动HAP的编译构建和安装。安装成功后，Phone/Tablet会自动运行安装的HarmonyOS应用/服务。   上一篇 使用本地真机运行应用/服务 下一篇 在Car中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用Local Emulator运行应用/服务使用Remote Emulator运行应用/服务使用单设备模拟器运行应用/服务使用超级终端模拟器运行应用/服务使用Simulator运行应用/服务使用模拟器运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio提供模拟器供开发者运行和调试HarmonyOS应用/服务，对于Phone、TV和Wearable可以使用本地模拟器（Local Emulator）和远程模拟器（Remote Emulator），对于Tablet可以使用Remote Emulator运行应用/服务，对于Lite Wearable和Smart Vision可以使用Simulator运行应用/服务。 同时，DevEco Studio的Remote Emulator还提供超级终端模拟器（Super Device），开发者可以利用超级终端模拟器来调测跨设备应用/服务。 
说明
建议使用本地真机或本地模拟器，远程模拟器/超级终端模拟器因为受网络带宽限制性能弱于本地模拟器。 
 模拟器支持的设备情况如下表所示： 模拟器类型  设备类型  API 版本    本地模拟器（Local Emulator）  Phone  6、9   TV  6   Wearable  6   远程模拟器（Remote Emulator）  Phone  9（P50）、8（P50）和6（P40）   TV  6   Wearable  6   Tablet  6   超级终端模拟器（Super Device）  Phone+Phone  6   Phone+Tablet  6   Phone+TV  6     
说明
macOS(M1)从HarmonyOS 3.1 Beta2开始支持手机arm模拟器，仅支持API 9的工程。本地模拟器中，手机x86模拟器为DevEco Studio 3.1 Beta1版本新增特性，当前为早期体验版本，功能和性能正在持续优化，如有问题欢迎在线提单。 
 使用Local Emulator运行应用/服务DevEco Studio提供的Local Emulator可以运行和调试Phone、TV和Wearable设备的HarmonyOS应用/服务。在Local Emulator上运行应用/服务兼容签名与不签名两种类型的HAP。 Local Emulator相比于Remote Emulator的区别：Local Emulator是创建和运行在本地计算机上的，不需要登录授权，在运行和调试应用/服务时，由于没有网络数据的交换，因此可以保持很好的流畅性和稳定性；但是需要耗费一定的计算机磁盘资源，具体的资源要求为： Windows系统：内存推荐为16GB及以上。macOS系统：内存推荐为8GB及以上。如果是ARM版本的macOS，macOS版本需在12.2及以上，否则将无法运行本地模拟器。不支持在虚拟机系统上运行本地模拟器，例如不支持在Ubuntu系统上，通过安装Windows虚拟机，然后使用Windows系统安装和运行模拟器。 创建和运行Local Emulator的操作方法如下： 单击File > Settings > SDK（macOS系统为DevEco Studio > Preferences > SDK），下拉框选择HarmonyOS，勾选并下载Platforms下的System-image和Tools下的Emulator资源。
说明
Local Emulator支持Phone、TV和Wearable设备，下载System-image时，请选择对应设备的System-image。升级模拟器版本时，需同时勾选Platforms下的System-image和Tools下的Emulator资源，勾选后点击Apply。 
 图1 下载System-image资源 图2 下载Emulator资源 单击菜单栏的Tools > Device Manager，在Local Emulator页签，单击Edit设置本地模拟器的存储路径Local emulator location，默认存储在C:\Users\Users\AppData\Local\Huawei\HarmonyOSEmulator\deployed目录（macOS为：/Users/用户/.Huawei/HarmonyOSEmulator/deployed）。 在Local Emulator页签中，单击右下角的New Emulator按钮，创建一个本地模拟器。 在创建模拟器界面，可以选择一个默认的设备；同时也可以单击New Hardware或默认设备后的克隆图标，添加一个新设备，以便自定义设备的相关参数，如尺寸、分辨率、内存等参数。
说明
自定义新设备，当前只支持Phone设备，TV和Wearable暂不支持。 
  创建New Hardware时，可以修改设备的名称、尺寸、分辨率、内存等参数。  选择需要创建的Hardware，单击Next，可以看到模拟器的镜像信息，如API、Version、CPU/ABI等信息。 单击Next，核实确定需要创建的模拟器信息，同时也可以在该界面修改模拟器信息，然后单击Finish创建本地模拟器。 在设备管理器页面，单击启动模拟器。 单击DevEco Studio的Run > Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）。DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在Local Emulator上。
说明
使用本地模拟器过程中遇到的问题请参考本地模拟器FAQ解决。 
    本地模拟器不支持规格说明： 特性  x86模拟器  arm模拟器    中文输入  不支持  不支持   相机  支持  不支持   图库视频播放  不支持  不支持   传感器  不支持  不支持   华为帐号  不支持  不支持   分布式特性  不支持  不支持   用户认证  不支持  不支持   api6应用调试  支持  不支持   api8应用调试  不支持native应用  不支持   api9应用调试  支持  支持     使用Remote Emulator运行应用/服务
注意
尊敬的开发者，抱歉地通知您，2024年3月30日起Remote Emulator将陆续停止提供服务，并将于2024年6月30日完全下线。建议您优先使用Local Emulator运行应用/服务。感谢您的支持！ 
  使用单设备模拟器运行应用/服务Remote Emulator支持Phone、Wearable、Tablet、TV等设备类型，但不同区域（开发者帐号注册地）支持的设备类型可能不同，请以实际可申请的设备类型为准。 Remote Emulator中的单设备模拟器（Single Device）可以运行和调试Phone（P50、P40）、Tablet（MatePad Pro）、TV和Wearable设备的HarmonyOS应用/服务，可兼容签名与不签名两种类型的HAP。 Remote Emulator每次使用时长为2小时，到期前可申请延长使用时间。如果Remote Emulator到期释放后，可以重新申请资源。 在DevEco Studio菜单栏，单击Tools > Device Manager。在Remote Emulator页签中，单击Sign in，在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录。
说明
推荐使用最新版本Chrome浏览器，如果使用Safari、360等其他浏览器，要取消阻止跨站跟踪和阻止所有Cookie功能。点击Sign in之后，如果DevEco Studio一直显示进度条等待弹框，并未有浏览器弹出并打开开发者联盟登录界面，此时您可以主动切换到浏览器查看相应的界面。更多问题可以查看远程模拟器登录常见问题.。 
 登录后，请单击界面的允许按钮进行授权，授权完成后，切换回Device Manager界面。 在Single Device中，单击设备运行按钮，启动远程模拟设备（同一时间只能启动一个设备）。
说明
如果远程模拟器状态为unavailable，表示当前远程模拟器无可用资源，建议优先使用本地模拟器。 
  单击DevEco Studio的Run > Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）。DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在Remote Emulator上。   使用超级终端模拟器运行应用/服务
说明
该特性在DevEco Studio V2.1 Release及更高版本中支持。 
 目前超级终端模拟器支持“Phone+Phone”、“Phone+Tablet”和“Phone+TV”的设备组网方式，开发者可以使用该超级终端模拟器来调测具备跨设备特性的应用/服务，如应用/服务在不同设备间的流转。 在DevEco Studio菜单栏，单击Tools > Device Manager。在Remote Emulator页签中，单击Login。在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录（查看远程模拟器登录常见问题）。登录后，请单击界面的允许按钮进行授权。 在Super Device中，单击设备运行按钮，启动超级终端模拟器。 在运行应用/服务中，选择Super App，然后单击Run > Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）运行应用/服务。 选择各个模块运行的设备。 DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在超级终端模拟器上。  当前DevEco Studio提供了具备跨设备特性的工程模板，可以使用“Video Player Ability”模板。 
说明
“Video Player Ability”可通过访问Templates Market获取，Templates Market提供更多模板资源，在创建工程的Choose your ability template页面上单击Templates Market进入。 
   使用Simulator运行应用/服务DevEco Studio提供的Simulator可以运行和调试Lite Wearable和Smart Vision设备的HarmonyOS应用/服务。在Simulator上运行应用/服务兼容签名与不签名两种类型的HAP。 选择需要运行的设备，默认情况下DevEco Studio会自动匹配对应的设备模拟器。单击DevEco Studio的Run > Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）。DevEco Studio会启动应用/服务的编译构建，完成后应用/服务即可运行在Simulator上。    上一篇 在Router中运行应用/服务 下一篇 使用远程真机运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用USB连接方式前提条件操作步骤使用IP Connection连接方式前提条件操作步骤在Wearable中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在Wearable中安装和运行HarmonyOS应用/服务，可以采用USB连接方式或者IP Connection的连接方式。采用IP Connection连接方式要求Wearable和PC端在同一个网段，建议将Wearable和PC连接到同一个WLAN下。 使用USB连接方式 前提条件在Wearable中，打开“开发者模式”，可在设置 >关于中，连续单击“版本号”，直到提示“您已处于开发者模式！”即可。然后在设置 >开发人员选项中，打开“HDC调试”开关。在Wearable中运行应用/服务，需要根据为应用/服务进行签名章节，提前对应用/服务进行签名。  操作步骤使用USB方式，连接Wearable和PC端。在菜单栏中，单击Run>Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）运行应用/服务。 DevEco Studio启动HAP的编译构建和安装。安装成功后，Wearable会自动运行安装的HarmonyOS应用/服务。  使用IP Connection连接方式 前提条件已将Wearable和PC连接到同一WLAN网络。在Wearable中，打开“开发者模式”，可在设置 >关于中，连续单击“版本号”，直到提示“您已处于开发者模式！”即可。然后在设置 >开发人员选项中，打开“HDC调试”和“通过WlAN调试”开关。Wearable上的5555端口为打开状态。如果未打开，可以通过使用USB连接方式连接上设备后，执行如下命令打开。已复制hdc tmode port 5555 在Wearable中运行应用/服务，需要根据为应用/服务进行签名章节，提前对应用/服务进行签名。  操作步骤在DevEco Studio菜单栏中，单击Tools>IP Connection，输入连接设备的IP地址，单击，连接正常后，设备状态为online。 在菜单栏中，单击Run>Run'模块名称'或，或使用默认快捷键Shift+F10（macOS为Control+R）运行应用/服务。 DevEco Studio启动HAP的编译构建和安装。安装成功后，Wearable会自动运行安装的HarmonyOS应用/服务。   上一篇 在TV中运行应用/服务 下一篇 在Lite Wearable中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件操作步骤在Smart Vision设备中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在Smart Vision中安装和运行HarmonyOS应用/服务，采用手动方式将HAP拷贝到Smart Vision的sdcard中再进行安装。 前提条件在Smart Vision中运行应用/服务，需要提前完成HAP的编译打包。请注意，编译打包时，请选择打包不带签名信息的HAP。获取Smart Vision应用/服务的安装工具，可从Hi3516DV300的HarmonyOS源码编译后的out\ipcamera_hi3516dv300\dev_tools下获取。Hi3516DV300开发板已完成HarmonyOS的镜像烧录，并完成镜像的运行，具体请参考Hi3516快速入门。  操作步骤将编译生成的不带签名信息的HAP和安装工具（镜像文件生成目录中的dev_tools文件夹），拷贝到sdcard中，并将sdcard插入开发板卡槽。将PC与开发板进行连接，需要同时连接串口和电源，具体可参考Hi3516开发板介绍。使用串口工具连接开发板，串口工具请自行获取安装。连接开发板后，执行如下命令，关闭HarmonyOS应用/服务签名校验。已复制./sdcard/dev_tools/bin/bm set -s disable 执行如下命令，安装HarmonyOS应用/服务。已复制./sdcard/dev_tools/bin/bm install -p /sdcard/airquality.hap  其中，airquality.hap为应用/服务安装包，此处替换为实际工程的应用/服务安装包名称。 应用/服务安装完成后，可单击桌面应用/服务图标启动应用。   上一篇 在Lite Wearable中运行应用/服务 下一篇 在Router中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。在TV中运行应用/服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 当前暂不支持使用商用智慧屏（TV）真机进行运行和调试，如需运行和调试智慧屏应用/服务，请使用远程模拟器或远程真机。  上一篇 在Car中运行应用/服务 下一篇 在Wearable中运行应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS应用安全测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    漏洞检测  隐私测试   上一篇 常见问题 下一篇 漏洞检测 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。示例代码 更新时间: 2023-10-16 11:16 毫无帮助帮助不大一般很好非常好
分享
  目录名  名称  简介  主要编程语言    ability  自定义通知（JS）  本示例演示了如何自定义通知样式，以及通过编辑框回复自定义内容。  JS   ETSUI  健康饮食  本示例演示了一个记录饮食和查看食物信息的应用，主要用于管理饮食健康。  ArkTS   转场动画  本示例展示了转场动画的使用，包括进场动画、页面间转场、组件内转场和共享元素转场。  ArkTS   Search组件  本示例展示了Search组件的使用，使用Search组件实现一个搜索界面。  ArkTS   图案密码锁组件（ArkTS）  基于HarmonyOS的图案密码锁组件，以宫格图案的方式输入密码，用于密码验证。  ArkTS   创建简单视图（ArkTS）  本示例为构建了简单页面展示食物番茄的图片和营养信息，主要为了展示简单页面的Stack布局和Flex布局。  ArkTS   页面布局和连接（ArkTS）  本示例构建了食物分类列表页面和食物详情页，向开发者展示了List布局、Grid布局以及页面路由的基本用法。  ArkTS   绘图和动画（ArkTS）  本示例构建了健康饮食应用的闪屏动画，向开发者展示了绘制组件和显式动画的基本用法。  ArkTS   network  WebSocket（ArkTS）  本示例展示了WebSocket的使用，包括客户端与服务端的连接和断开以及客户端数据的接收和发送。  ArkTS   data  首选项  本示例主要展示了首选项在主题切换方面的功能。为应用提供key-value键值型的数据处理能力，支持应用持久化轻量级数据，并对其修改和查询。  ArkTS   media  拼图  该示例通过@ohos.multimedia.image和@ohos.multimedia.mediaLibrary接口实现获取图片，以及图片裁剪分割的功能。  ArkTS   图片  本示例使用TextArea实现多文本输入，使用@ohos.multimedia.mediaLibrary 实现在相册中获取图片，使用@ohos.multimedia.image生成pixelMap，使用pixelMap的scale()，crop()，rotate()接口实现对图片的缩放，裁剪，旋转功能。  ArkTS   图片显示  本示例展示从相册选择图片展示在商品评价页面。  ArkTS   security  加解密  本示例使用cipher相关接口实现了字符串加解密算法，包括RSA加密算法与AES加密算法。  ArkTS   DFX  Debug  本示例通过使用@ohos.hidebug接口来获取当前应用内存使用情况。  ArkTS   MultiDeviceAppDev  一多音乐专辑主页  本示例展示了音乐专辑主页，使用一次开发，多端部署中介绍的自适应布局能力和响应式布局能力进行多设备（或多窗口尺寸）适配，保证应用在不同设备或不同窗口尺寸下可以正常显示。  ArkTS   JSUI  基本动画（JS）  本示例演示了JS FA中图片组件常见的几种动画效果，例如：缩放、旋转、平移、渐变等。  JS   多设备自适应的效率型首页  本示例展示了一个列表页面，在不同尺寸的设备上，通过拉伸、缩放、均分、占比等自适应能力，使用多态控件、布局和组件的延展性以及响应式布局的运用，自适应展示为合理的布局效果。  JS   多设备自适应的FA页面  本示例构建了常见应用的信息展示页面，包含搜索栏，列表展示。在不同尺寸的设备上，通过拉伸、缩放、隐藏、均分、占比等自适应能力，使用多态控件、布局和组件的延展性以及响应式布局的运用，自适应展示为合理的布局效果。  JS   多设备自适应服务卡片  本示例分别通过沉浸式卡片、图文卡片、宫格卡片、纯文本卡片、多维度信息卡片五种类型，展示了卡片在不同尺寸设备上的自适应能力。当卡片在极宽和极高的情况下，通过拉伸、缩放、隐藏、折行、均分等自适应能力将卡片展示出来。  JS   动效示例应用  本示例演示了组件动效的基础能力，包含组件的旋转、平移、显隐切换，以及组件阴影等，其中动效负载可调节。  JS   JsApp  本示例演示了如何开发一个JS FA。  JS   JsComponents  本示例演示了如何使用JS基础组件开发一个应用界面。  JS   JS 卡片开发  本示例展示了服务卡片功能，通过服务卡片将用户应用程序的重要信息展示在桌面，用户可通过快捷手势使用卡片，以达到服务直达、减少层级跳转的目的。  JS   图库示例应用  本示例为一个仿图库的JS应用，模拟多图片场景，开发者可自行添加或者更换图片资源，构建自己的多图场景。  JS   购物示例应用  本示例为一个仿购物类的JS应用，使用了混合的布局，包含图片、视频、文本等资源。  JS   JS启动模态配置  本示例演示了方舟开发框架提供的半模态和弹窗模态的启动方式。  JS   用户注册（JS）  本示例以用户注册为例，演示JS FA基本控件的使用，包含文本输入框、日期选择控件、单选按钮、下拉菜单和普通按钮等。  JS   native  JSNativeDemo  本示例使用JS和C++开发，使用JS调用C++代码，并在UI上显示C++代码运行结果。  JS、C++   Native_layer  本示例展示了关于Native_layer的JNI接口的使用，使应用程序能够获取与Java表面对象匹配的原生层，可以获取原生层信息，也可以设置原生层大小和图层格。  C++   Native_image  本示例展示了如何声明JNI接口并通过JNI接口锁定和访问或解锁像素数据的函数。  C++     下一篇 Codelabs 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。保存图片或视频类文件保存文档类文件保存音频类文件保存用户文件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在从网络下载文件到本地、或将已有用户文件另存为新的文件路径等场景下，需要使用FilePicker提供的保存用户文件的能力。 对音频、图片、视频、文档类文件的保存操作类似，均通过调用对应picker的save()接口并传入对应的saveOptions来实现。  保存图片或视频类文件  导入选择器模块和文件管理模块。已复制import picker from '@ohos.file.picker';  创建图库保存选项实例。已复制const photoSaveOptions = new picker.PhotoSaveOptions(); // 创建文件管理器保存选项实例photoSaveOptions.newFileNames = ["PhotoViewPicker01.jpg"]; // 保存文件名（可选）  创建图库选择器实例，调用save()接口拉起FilePicker界面进行文件保存。用户选择目标文件夹，用户选择与文件类型相对应的文件夹，即可完成文件保存操作。保存成功后，返回保存文档的URI。         save返回的URI权限是读写权限，可以根据结果集中URI进行文件读写等操作。注意不能在picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI，使用类似一个按钮去触发打开文件。        已复制let URI = null;const photoViewPicker = new picker.PhotoViewPicker();photoViewPicker.save(photoSaveOptions).then((photoSaveResult) => {  URI = photoSaveResult[0];  console.info('photoViewPicker.save to file succeed and URI is:' + URI);}).catch((err) => {  console.error(`Invoke photoViewPicker.save failed, code is ${err.code}, message is ${err.message}`);})   待界面从FilePicker返回后，在其他函数中使用fs.openSync接口，通过uri打开这个文件得到fd。这里需要注意接口权限参数是fs.OpenMode.READ_WRITE。已复制let file = fs.openSync(uri, fs.OpenMode.READ_WRITE);console.info('file fd: ' + file.fd);  通过fd使用fs.writeSync接口对这个文件进行编辑修改，编辑修改完成后关闭fd。已复制let writeLen = fs.writeSync(file.fd, 'hello, world');console.info('write data to file succeed and size is:' + writeLen);fs.closeSync(file);     保存文档类文件  导入选择器模块。已复制import picker from '@ohos.file.picker';import fs from '@ohos.file.fs';  创建文档保存选项实例。已复制const documentSaveOptions = new picker.DocumentSaveOptions(); // 创建文件管理器选项实例documentSaveOptions.newFileNames = ["DocumentViewPicker01.txt"]; // 保存文件名（可选）  创建文档选择器实例。调用save()接口拉起FilePicker界面进行文件保存。用户选择目标文件夹，用户选择与文件类型相对应的文件夹，即可完成文件保存操作。保存成功后，返回保存文档的URI。 save返回的URI权限是读写权限，可以根据结果集中URI进行文件读写等操作。注意不能在picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI，使用类似一个按钮去触发打开文件。 已复制let URI = null;const documentViewPicker = new picker.DocumentViewPicker(); // 创建文件选择器实例documentViewPicker.save(documentSaveOptions).then((documentSaveResult) => {  URI = documentSaveResult[0];  console.info('documentViewPicker.save to file succeed and URI is:' + URI);}).catch((err) => {  console.error(`Invoke documentViewPicker.save failed, code is ${err.code}, message is ${err.message}`);})  待界面从FilePicker返回后，在其他函数中使用fs.openSync接口，通过uri打开这个文件得到fd。这里需要注意接口权限参数是fs.OpenMode.READ_WRITE。已复制let file = fs.openSync(uri, fs.OpenMode.READ_WRITE);console.info('file fd: ' + file.fd);  通过fd使用fs.writeSync接口对这个文件进行编辑修改，编辑修改完成后关闭fd。已复制let writeLen = fs.writeSync(file.fd, 'hello, world');console.info('write data to file succeed and size is:' + writeLen);fs.closeSync(file);     保存音频类文件  导入选择器模块和文件管理模块。已复制import picker from '@ohos.file.picker';import fs from '@ohos.file.fs';  创建音频保存选项实例。已复制const audioSaveOptions = new picker.AudioSaveOptions(); // 创建文件管理器选项实例audioSaveOptions.newFileNames = ['AudioViewPicker01.mp3']; // 保存文件名（可选）  创建音频选择器实例。调用save()接口拉起FilePicker界面进行文件保存。用户选择目标文件夹，用户选择与文件类型相对应的文件夹，即可完成文件保存操作。保存成功后，返回保存文档的URI。         save返回的URI权限是读写权限，可以根据结果集中URI进行文件读写等操作。注意不能在picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI，使用类似一个按钮去触发打开文件。        已复制let URI = null;const audioViewPicker = new picker.AudioViewPicker();audioViewPicker.save(audioSaveOptions).then((audioSelectResult) => {  URI = audioSelectResult[0];  console.info('audioViewPicker.save to file succeed and URI is:' + URI);}).catch((err) => {  console.error(`Invoke audioViewPicker.save failed, code is ${err.code}, message is ${err.message}`);})   待界面从FilePicker返回后，在其他函数中使用fs.openSync接口，通过uri打开这个文件得到fd。已复制let file = fs.openSync(uri, fs.OpenMode.READ_WRITE);console.info('file fd: ' + file.fd);  通过fd使用fs.writeSync接口对这个文件进行编辑修改，编辑修改完成后关闭fd。已复制let writeLen = fs.writeSync(file.fd, 'hello, world');console.info('write data to file succeed and size is:' + writeLen);fs.closeSync(file);     上一篇 选择用户文件 下一篇 分布式文件系统 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。证书校验配置云端环境配置SDK管理命令行工具高级配置 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 证书校验配置java启动参数-Dno_ssl_verify=false表示开启https证书校验，命令行工具默认开启证书校验。若需要暂时关闭https证书校验，可设置启动参数-Dno_ssl_verify=true关闭命令行工具的https证书校验。java启动参数-Dnpm_config_strict_ssl=true表示开启npm的https证书校验，命令行工具默认开启证书校验。若需要暂时关闭https证书校验，可设置启动参数-Dnpm_config_strict_ssl=false关闭npm的https证书校验。 
说明
关闭证书校验，可能会带来安全风险，请谨慎使用。 
  云端环境配置添加grs_url启动参数可以修改命令行工具连接的云端环境。   说明：grs_url、npm_config_strict_ssl两个参数在流水线使用构建工具构建工程时也有效。  上一篇 ohsdkmgr使用指导 下一篇 codelinter使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。选择与保存用户文件（FilePicker） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    选择用户文件  保存用户文件   上一篇 用户文件概述 下一篇 选择用户文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。选择图片或视频类文件选择文档类文件选择音频类文件选择用户文件 更新时间: 2024-04-01 19:24 毫无帮助帮助不大一般很好非常好
分享
  终端用户有时需要分享、保存一些图片、视频等用户文件，开发者需要在应用中支持此类使用场景。此时，开发者可以使用HarmonyOS系统预置的文件选择器（FilePicker），实现用户文件选择及保存能力。 根据用户文件的常见类型，文件选择器（FilePicker）分别提供以下接口：  PhotoViewPicker：适用于图片或视频类文件的选择与保存。 DocumentViewPicker：适用于文档类文件的选择与保存。 AudioViewPicker：适用于音频类文件的选择与保存。   选择图片或视频类文件  导入选择器模块和文件管理模块。已复制import picker from '@ohos.file.picker';  创建图库选择选项实例。已复制const photoSelectOptions = new picker.PhotoSelectOptions();  选择媒体文件类型和选择媒体文件的最大数目。以下示例以图片选择为例，媒体文件类型请参见PhotoViewMIMETypes。 已复制photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE; // 过滤选择媒体文件类型为IMAGEphotoSelectOptions.maxSelectNumber = 5; // 选择媒体文件的最大数目  创建图库选择器实例，调用select()接口拉起FilePicker界面进行文件选择。文件选择成功后，返回PhotoSelectResult结果集。select返回的URI权限是只读权限，可以根据结果集中URI进行读取文件数据操作。注意不能在picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI，使用类似一个按钮去触发打开文件。 已复制let URI = null;const photoViewPicker = new picker.PhotoViewPicker();photoViewPicker.select(photoSelectOptions).then((photoSelectResult) => {  URI = photoSelectResult.photoUris[0];  console.info('photoViewPicker.select to file succeed and URI is:' + URI);}).catch((err) => {  console.error(`Invoke photoViewPicker.select failed, code is ${err.code}, message is ${err.message}`);})  待界面从FilePicker返回后，再通过类似一个按钮调用其他函数，使用fs.openSync接口，通过URI打开这个文件得到fd。这里需要注意接口权限参数是fs.OpenMode.READ_ONLY。         待界面从图库返回后，可再通过类似一个按钮调用其他函数，使用fs.openSync接口，通过uri打开这个文件得到fd，通过fd使用fs.readSync接口读取这个文件内的数据，读取完成后关闭fd。这里需要注意接口权限参数是fs.OpenMode.READ_ONLY。        已复制import fs from '@ohos.file.fs';
let uri: string = '';let file = fs.openSync(uri, fs.OpenMode.READ_ONLY);console.info('file fd: ' + file.fd);let buffer = new ArrayBuffer(4096);let readLen = fs.readSync(file.fd, buffer);console.info('readSync data to file succeed and buffer size is:' + readLen);fs.closeSync(file);   从图库获取URI后，也可使用Image组件，通过URI显示图片。已复制ForEach(URI, item => {    GridItem() {        Image(item)            .width(200)    }}, item => JSON.stringify(item))     选择文档类文件  导入选择器模块和文件管理模块。已复制import picker from '@ohos.file.picker';import fs from '@ohos.file.fs';import Want from '@ohos.app.ability.Want';  创建文档选择器实例。调用select()接口拉起FilePicker应用界面进行文件选择。文件选择成功后，返回被选中文档的uri结果集。select返回的uri权限是只读权限，开发者可以根据结果集中uri做进一步的处理。注意不能在picker的回调里直接使用此uri进行打开文件操作，需要定义一个全局变量保存uri，使用类似一个按钮去触发打开文件。 如有获取元数据需求，可以通过文件管理接口和文件URI根据uri获取部分文件属性信息，比如文件大小、访问时间、修改时间、文件名、文件路径等。 已复制import picker from '@ohos.file.picker';let uris: Array<string> = [];const documentViewPicker = new picker.DocumentViewPicker(); // 创建文件选择器实例const documentSelectOptions = new picker.DocumentSelectOptions(); // 创建文件类型文件选择选项实例documentViewPicker.select(documentSelectOptions).then((documentSelectResult: Array<string>) => {  uris = documentSelectResult;  console.info('documentViewPicker.select to file succeed and uris are:' + uris);}).catch((err) => {  console.error(`Invoke documentViewPicker.select failed, code is ${err.code}, message is ${err.message}`);})  待界面从FilePicker返回后，再通过类似一个按钮调用其他函数，使用fs.openSync接口，通过uri打开这个文件得到fd。这里需要注意接口权限参数是fs.OpenMode.READ_ONLY。已复制let uri = uris[0];let file = fs.openSync(uri, fs.OpenMode.READ_ONLY);console.info('file fd: ' + file.fd);  通过fd使用fs.readSync接口对这个文件进行读取数据，读取完成后关闭fd。已复制let buffer = new ArrayBuffer(4096);let readLen = fs.readSync(file.fd, buffer);console.info('readSync data to file succeed and buffer size is:' + readLen);fs.closeSync(file);     选择音频类文件  导入选择器模块和文件管理模块。已复制import picker from '@ohos.file.picker';import fs from '@ohos.file.fs';  创建音频选择选项实例。已复制const audioSelectOptions = new picker.AudioSelectOptions();  创建音频选择器实例。调用select()接口拉起FilePicker界面进行文件选择。文件选择成功后，返回被选中音频的URI结果集。select返回的URI权限是只读权限，开发者可以根据结果集中URI做读取文件数据操作。注意不能在 picker的回调里直接使用此URI进行打开文件操作，需要定义一个全局变量保存URI，使用类似一个按钮去触发打开文件。         例如通过文件管理接口根据URI拿到音频资源的文件句柄（FD），再配合媒体服务实现音频播放的开发，具体请参考音频播放开发指导。        
说明
 目前AudioSelectOptions不支持参数配置，默认可以选择所有类型的用户文件。 
 已复制let URI = null;const audioViewPicker = new picker.AudioViewPicker();audioViewPicker.select(audioSelectOptions).then((audioSelectResult: Array<string>) => {  URI = audioSelectResult[0];  console.info('audioViewPicker.select to file succeed and URI is:' + URI);}).catch((err) => {  console.error(`Invoke audioViewPicker.select failed, code is ${err.code}, message is ${err.message}`);})   待界面从FilePicker返回后，再通过类似一个按钮调用其他函数，使用fs.openSync接口，通过URI打开这个文件得到fd。这里需要注意接口权限参数是fs.OpenMode.READ_ONLY。已复制let file = fs.openSync(URI, fs.OpenMode.READ_ONLY);console.info('file fd: ' + file.fd);  通过fd使用fs.readSync接口读取这个文件内的数据，读取完成后关闭fd。已复制let buffer = new ArrayBuffer(4096);let readLen = fs.readSync(file.fd, buffer);console.info('readSync data to file succeed and buffer size is:' + readLen);fs.closeSync(file);     上一篇 选择与保存用户文件（FilePicker） 下一篇 保存用户文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用沙箱路径和调试进程视角下的真实物理路径开发示例切换应用沙箱视角向应用沙箱推送文件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  开发者在应用开发调试时，可能需要向应用沙箱下推送一些文件以期望在应用内访问或测试，此时有两种方式：  可以通过DevEco Studio向应用安装路径中放入目标文件，详见应用安装资源访问。 在具备设备环境时，可以使用另一种更为灵活的方式，通过hdc工具来向设备中应用沙箱路径推送文件。即本文介绍的内容。  但是hdc shell看到的调试进程下的文件路径与应用视角的应用沙箱路径不同，开发者需要先了解如下路径映射关系。  应用沙箱路径和调试进程视角下的真实物理路径 在应用沙箱路径下读写文件，经过映射转换，实际读写的是在hdc进程视角下看到真实物理路径中的应用文件，其对应关系如下表所示。     表1 应用沙箱路径与真实物理路径对应关系         应用沙箱路径 调试进程（hdc）视角下的实际路径 说明    /data/storage/el1/bundle /data/app/el1/bundle/public/<PACKAGENAME> 应用安装包目录   /data/storage/el1/base /data/app/el1/<USERID>/base/<PACKAGENAME> 应用el1级别加密数据目录   /data/storage/el2/base /data/app/el2/<USERID>/base/<PACKAGENAME> 应用el2级别加密数据目录   /data/storage/el1/database /data/app/el1/<USERID>/database/<PACKAGENAME> 应用el1级别加密数据库目录   /data/storage/el2/database /data/app/el2/<USERID>/database/<PACKAGENAME> 应用el2级别加密数据库目录   /data/storage/el2/distributedfiles /mnt/hmdfs/<USERID>/account/merge_view/data/<PACKAGENAME> 应用el2加密级别有帐号分布式数据融合目录     开发示例 以应用包com.ohos.example为例，如果是在example的应用沙箱路径“/data/storage/el1/bundle”下读写文件，从上表可知，对应的真实物理路径为“/data/app/el1/bundle/public/<PACKAGENAME>”，即“/data/app/el1/bundle/public/com.ohos.example”。 推送命令示例如下： 已复制hdc file send ${待推送文件的本地路径} /data/app/el1/bundle/public/com.ohos.example/   切换应用沙箱视角 在调试过程中，如果权限不对或文件不存在，开发者需要从调试进程视角切换为应用视角，以便直观分析权限及文件目录问题。视角切换命令如下： 已复制hdc shell                         // 进入shellps -ef|grep [hapName]             // 通过ps命令找到对应应用的pidnsenter -t [hapPid] -m /bin/sh    // 通过上一步找到的应用pid进入对应应用的沙箱环境中 执行完成后，即切换到了应用视角，该视角下的目录路径为应用沙箱路径，可以去排查沙箱路径相关问题。   上一篇 应用及文件系统空间统计 下一篇 应用文件分享 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤传感器开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 当设备需要获取传感器数据时，可以使用sensor模块，例如：通过订阅方向传感器数据感知用户设备当前的朝向，通过订阅计步传感器数据统计用户的步数等。 详细的接口介绍请参考Sensor接口。   接口说明     模块 接口名 描述    ohos.sensor sensor.on(sensorId, callback:AsyncCallback<Response>): void 持续监听传感器数据变化   ohos.sensor sensor.once(sensorId, callback:AsyncCallback<Response>): void 获取一次传感器数据变化   ohos.sensor sensor.off(sensorId, callback?:AsyncCallback<void>): void 注销传感器数据的监听      开发步骤  获取设备上传感器的数据前，需要检查是否已经配置请求相应的权限。 系统提供的传感器权限有：  ohos.permission.ACCELEROMETER ohos.permission.GYROSCOPE ohos.permission.ACTIVITY_MOTION ohos.permission.READ_HEALTH_DATA  具体配置方式请参考权限申请声明。 以下场景以加速度传感器ACCELEROMETER为例。展示持续监听传感器接口的调用结果。 已复制import sensor from "@ohos.sensor";sensor.on(sensor.SensorId.ACCELEROMETER, function(data){   console.info("Data obtained successfully. x: " + data.x + "y: " + data.y + "z: " + data.z);// 获取数据成功});  注销传感器数据监听。 已复制import sensor from "@ohos.sensor";sensor.off(sensor.SensorId.ACCELEROMETER);  获取一次传感器数据变化。 已复制import sensor from "@ohos.sensor";sensor.once(sensor.SensorId.ACCELEROMETER, function(data) {   console.info("Data obtained successfully. x: " + data.x + "y: " + data.y + "z: " + data.z);// 获取数据成功});  若接口调用不成功，建议使用try/catch语句捕获代码中可能出现的错误信息。例如： 已复制import sensor from "@ohos.sensor";try {  sensor.once(sensor.SensorId.ACCELEROMETER, function(data) {      console.info("Data obtained successfully. x: " + data.x + "y: " + data.y + "z: " + data.z);// 获取数据成功  });} catch (error) {  console.error("Get sensor data error, error:" + error.data, ", msg:", error.message);}    上一篇 传感器开发概述 下一篇 振动 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。运作机制约束与限制传感器开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  HarmonyOS系统传感器是应用访问底层硬件传感器的一种设备抽象概念。开发者根据传感器提供的Sensor接口，可以查询设备上的传感器，订阅传感器数据，并根据传感器数据定制相应的算法开发各类应用，比如指南针、运动健康、游戏等。     传感器类型 描述 说明 主要用途    ACCELEROMETER 加速度传感器 测量三个物理轴（x、y 和 z）上，施加在设备上的加速度（包括重力加速度），单位 : m/s² 检测运动状态   ACCELEROMETER_UNCALIBRATED 未校准加速度传感器 测量三个物理轴（x、y 和 z）上，施加在设备上的未校准的加速度（包括重力加速度），单位 : m/s² 检测加速度偏差估值   LINEAR_ACCELERATION 线性加速度传感器 测量三个物理轴（x、y 和 z）上，施加在设备上的线性加速度（不包括重力加速度），单位 : m/s² 检测每个单轴方向上的线性加速度   GRAVITY 重力传感器 测量三个物理轴（x、y 和 z）上，施加在设备上的重力加速度，单位 : m/s² 测量重力大小   GYROSCOPE 陀螺仪传感器 测量三个物理轴（x、y 和 z）上，设备的旋转角速度，单位 : rad/s 测量旋转的角速度   GYROSCOPE_UNCALIBRATED 未校准陀螺仪传感器 测量三个物理轴（x、y 和 z）上，设备的未校准旋转角速度，单位 : rad/s 测量旋转的角速度及偏差估值   SIGNIFICANT_MOTION 大幅度动作传感器 测量三个物理轴（x、y 和 z）上，设备是否存在大幅度运动；如果取值为1则代表存在大幅度运动，取值为0则代表没有大幅度运动 用于检测设备是否存在大幅度运动   PEDOMETER_DETECTION 计步器检测传感器 检测用户的计步动作；如果取值为1则代表用户产生了计步行走的动作；取值为0则代表用户没有发生运动 用于检测用户是否有计步的动作   PEDOMETER 计步器传感器 统计用户的行走步数 用于提供用户行走的步数数据   AMBIENT_TEMPERATURE 环境温度传感器 测量环境温度，单位 : 摄氏度 (°C) 测量环境温度   MAGNETIC_FIELD 磁场传感器 测量三个物理轴向（x、y、z）上，环境地磁场，单位 : μT 创建指南针   MAGNETIC_FIELD_UNCALIBRATED 未校准磁场传感器 测量三个物理轴向（x、y、z）上，未校准环境地磁场，单位 : μT 测量地磁偏差估值   HUMIDITY 湿度传感器 测量环境的相对湿度，以百分比 (%) 表示 监测露点、绝对湿度和相对湿度   BAROMETER 气压计传感器 测量环境气压，单位 : hPa 或 mbar 测量环境气压   ORIENTATION 方向传感器 测量设备围绕所有三个物理轴（x、y、z）旋转的角度值，单位：rad 用于提供屏幕旋转的3个角度值   ROTATION_VECTOR 旋转矢量传感器 测量设备旋转矢量，复合传感器：由加速度传感器、磁场传感器、陀螺仪传感器合成 检测设备相对于东北天坐标系的方向   PROXIMITY 接近光传感器 测量可见物体相对于设备显示屏的接近或远离状态 通话中设备相对人的位置   AMBIENT_LIGHT 环境光传感器 测量设备周围光线强度，单位：lux 自动调节屏幕亮度，检测屏幕上方是否有遮挡   HEART_RATE 心率传感器 测量用户的心率数值 用于提供用户的心率健康数据   WEAR_DETECTION 佩戴检测传感器 检测用户是否佩戴 用于检测用户是否佩戴智能穿戴   HALL 霍尔传感器 测量设备周围是否存在磁力吸引 设备的皮套模式     运作机制 HarmonyOS传感器包含如下四个模块：Sensor API、Sensor Framework、Sensor Service和HDF层。 图1 HarmonyOS传感器   Sensor API：提供传感器的基础API，主要包含查询传感器列表，订阅/取消传感器的数据、执行控制命令等，简化应用开发。 Sensor Framework：主要实现传感器的订阅管理，数据通道的创建、销毁、订阅与取消订阅，实现与SensorService的通信。 Sensor Service：主要实现HD_IDL层数据接收、解析、分发，前后台的策略管控，对该设备Sensor的管理，Sensor权限管控等。 HDF层：对不同的FIFO、频率进行策略选择，以及适配不同设备。    约束与限制  针对下面所列传感器，开发者需要请求响应的权限，才能获取到相应传感器的数据。     传感器 权限名 敏感级别 权限描述    加速度传感器，加速度未校准传感器，线性加速度传感器 ohos.permission.ACCELEROMETER system_grant 允许订阅Motion组对应的加速度传感器的数据   陀螺仪传感器，陀螺仪未校准传感器 ohos.permission.GYROSCOPE system_grant 允许订阅Motion组对应的陀螺仪传感器的数据   计步器 ohos.permission.ACTIVITY_MOTION user_grant 允许订阅运动状态   心率计 ohos.permission.READ_HEALTH_DATA user_grant 允许读取健康数据    传感器数据订阅和取消订阅接口成对调用，当不再需要订阅传感器数据时，开发者需要调用取消订阅接口停止数据上报。    上一篇 传感器 下一篇 传感器开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。服务卡片开发指导（Stage模型） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    服务卡片概述  开发基于ArkTS UI的卡片  开发基于JS UI的卡片   上一篇 ExtensionAbility组件 下一篇 服务卡片概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。服务卡片架构服务卡片UI页面开发方式服务卡片概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 服务卡片（以下简称“卡片”）是一种界面展示形式，可以将应用的重要信息或操作前置到卡片，以达到服务直达、减少体验层级的目的。卡片常用于嵌入到其他应用（当前卡片使用方只支持系统应用，如桌面）中作为其界面显示的一部分，并支持拉起页面、发送消息等基础的交互功能。 服务卡片架构图1 服务卡片架构 卡片的基本概念： 卡片使用方：如上图中的桌面，显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。 应用图标：应用入口图标，点击后可拉起应用进程，图标内容不支持交互。卡片：具备不同规格大小的界面展示，卡片的内容可以进行交互，如实现按钮进行界面的刷新、应用的跳转等。 卡片提供方：包含卡片的应用，提供卡片的显示内容、控件布局以及控件点击处理逻辑。 FormExtensionAbility：卡片业务逻辑模块，提供卡片创建、销毁、刷新等生命周期回调。卡片页面：卡片UI模块，包含页面控件、布局、事件等显示和交互信息。  卡片的常见使用步骤如下。 图2 卡片常见使用步骤 长按“桌面图标”，弹出操作菜单。点击“服务卡片”选项，进入卡片预览界面。点击“添加到桌面”按钮，即可在桌面上看到新添加的卡片。  服务卡片UI页面开发方式在Stage模型下，服务卡片的UI页面支持通过ArkTS和JS两种语言进行开发： 基于声明式范式ArkTS UI开发的卡片，简称ArkTS卡片。基于类Web范式JS UI开发的卡片，简称JS卡片。 ArkTS卡片与JS卡片具备不同的实现原理及特征，在场景能力上的差异如下表所示。 类别  JS卡片  ArkTS卡片    开发范式  类Web范式  声明式范式   组件能力  支持  支持   布局能力  支持  支持   事件能力  支持  支持   自定义动效  不支持  支持   自定义绘制  不支持  支持   逻辑代码执行（不包含import能力）  不支持  支持     相比于JS卡片，ArkTS卡片在能力和场景方面更加丰富，因此无论开发何种用途的卡片，都推荐使用ArkTS卡片，因为它可以提高开发效率并实现动态化。但如果只需要做静态页面展示的卡片，可以考虑使用JS卡片。   上一篇 服务卡片开发指导（Stage模型） 下一篇 开发基于ArkTS UI的卡片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ServiceAbility组件配置 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  与PageAbility类似，ServiceAbility的相关配置在config.json配置文件的"module"对象的"abilities"对象中，与PageAbility的区别在于"type"属性及"backgroundModes"属性。 表1 ServiceAbility部分配置项说明     属性名称 含义 数据类型 是否可缺省    type 表示Ability的类型。取值为"service"时表示该Ability是基于Service模板开发的Ability。 字符串 否   backgroundModes 表示后台服务的类型，可以为一个服务配置多个后台服务类型。该标签仅适用于service类型的Ability。取值范围如下： dataTransfer：通过网络/对端设备进行数据下载、备份、分享、传输等业务。 audioPlayback：音频输出业务。 audioRecording：音频输入业务。 pictureInPicture：画中画、小窗口播放视频业务。 voip：音视频电话、VOIP业务。 location：定位、导航业务。 bluetoothInteraction：蓝牙扫描、连接、传输业务。 wifiInteraction：WLAN扫描、连接、传输业务。 screenFetch：录屏、截屏业务。 multiDeviceConnection：多设备互联业务。 字符串数组 可缺省，缺省值为空。    ServiceAbility支持的配置项及详细说明详见module对象内部结构。  上一篇 ServiceAbility组件概述 下一篇 ServiceAbility的生命周期 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ServiceAbility的生命周期 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 开发者可以根据业务场景重写生命周期相关接口。ServiceAbility生命周期接口说明见下表。  表1 ServiceAbility生命周期接口说明 接口名 描述   onStart(): void 该方法在创建ServiceAbility的时候调用，用于Service的初始化，在ServiceAbility的整个生命周期只会调用一次。  onCommand(want: Want, startId: number): void 在Service创建完成之后调用，该方法在客户端每次启动该Service时都会调用，开发者可以在该方法中做一些调用统计、初始化类的操作。  onConnect(want: Want): rpc.RemoteObject 在连接ServiceAbility时调用。  onDisconnect(want: Want): void 在与已连接的ServiceAbility断开连接时调用。  onStop(): void 在ServiceAbility销毁时调用。开发者应通过实现此方法来清理资源，如关闭线程、注册的侦听器等。     上一篇 ServiceAbility组件配置 下一篇 创建ServiceAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ServiceAbility组件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 ServiceAbility，即"基于Service模板的Ability"，主要用于后台运行任务（如执行音乐播放、文件下载等），不提供用户交互界面。ServiceAbility可由其他应用或PageAbility启动，即使用户切换到其他应用，ServiceAbility仍将在后台继续运行。  上一篇 ServiceAbility组件开发指导 下一篇 ServiceAbility组件配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ServiceAbility组件开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    ServiceAbility组件概述  ServiceAbility组件配置  ServiceAbility的生命周期  创建ServiceAbility  启动ServiceAbility  连接ServiceAbility   上一篇 跳转规则 下一篇 ServiceAbility组件概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发示例设置分布式文件数据等级 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  不同设备本身的安全能力差异较大，一些小的嵌入式设备安全能力远弱于平板等设备类型。用户或者应用不同的文件数据有不同安全诉求，例如个人的健康信息和银行卡信息等不期望被弱设备读取。因此，HarmonyOS提供一套完整的数据分级、设备分级标准，并针对不同设备制定不同的数据流转策略，具体规则请参见数据、设备安全分级。  接口说明 API详细介绍请参见ohos.file.securityLabel。    表1 设置文件数据等级          接口名 功能 接口类型 支持同步 支持异步    setSecurityLabel 设置文件安全标签 方法 √ √   getSecurityLabel 获取文件安全标签 方法 √ √     
注意
 1. 对于不满足安全等级的文件，跨设备仍然可以看到该文件，但是无权限打开访问该文件。 2. 分布式文件系统的数据等级默认为S3，应用可以主动设置文件的安全等级。 
  开发示例 获取通用文件沙箱路径，并设置数据等级标签。示例中的context的获取方式请参见获取UIAbility的上下文信息。 已复制import securityLabel from '@ohos.file.securityLabel';
// 获取需要设备数据等级的文件沙箱路径let context = ...; // 获取UIAbilityContext信息let pathDir = context.filesDir;let filePath = pathDir + '/test.txt';
// 设置文件的数据等级为s0securityLabel.setSecurityLabel(filePath, 's0').then(() => {  console.info('Succeeded in setSecurityLabeling.');}).catch((err) => {  console.error(`Failed to setSecurityLabel. Code: ${err.code}, message: ${err.message}`);});   上一篇 分布式文件系统概述 下一篇 跨设备文件访问 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。文件URI规范分享文件给其他应用使用其他应用分享的文件应用文件分享 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用文件分享是应用之间通过分享URI（Uniform Resource Identifier）或文件描述符FD（File Descriptor）的方式，进行文件共享的过程。由于FD分享的文件关闭FD后，无法再打开分享文件，因此不推荐使用，本文重点介绍URI分享方式。  基于URI分享方式，应用可分享单个文件，通过ohos.app.ability.wantConstant的wantConstant.Flags接口以只读或读写权限授权给其他应用。应用可通过ohos.file.fs的open()接口打开URI，并进行读写操作。当前OpenHarmony API 9仅支持临时授权，分享给其他应用的文件在被分享应用退出时权限被收回。 基于FD分享方式，应用可分享单个文件，通过ohos.file.fs的open接口以指定权限授权给其他应用。应用从Want中解析拿到FD后可通过ohos.file.fs的读写接口对文件进行读写。  开发者可以使用相关接口，分享文件给其他应用或使用其他应用分享的文件。  文件URI规范 文件URI的格式为：       格式为file://<bundleName>/<path>       file：文件URI的标志。 bundleName：该文件资源的属主。 path：文件资源在应用沙箱中的路径。     分享文件给其他应用 在分享文件给其他应用前，开发者需要先获取应用文件路径。  获取文件在应用沙箱中的路径，并转换为文件URI。已复制import UIAbility from '@ohos.app.ability.UIAbility';import fileuri from '@ohos.file.fileuri';import window from '@ohos.window';
export default class EntryAbility extends UIAbility {  onWindowStageCreate(windowStage: window.WindowStage) {    // 获取文件的沙箱路径    let pathInSandbox = this.context.filesDir + "/test.txt";    // 将沙箱路径转换为uri    let uri = fileuri.getUriFromPath(pathInSandbox);    // 获取的uri为"file://com.example.demo/data/storage/el2/base/files/test.txt"  }} 设置获取文件的权限以及选择要分享的应用。分享文件给其他应用需要使用startAbility()接口，将获取到的URI填充在want的参数uri中，标注URI的文件类型，type字段可参考Want属性，并通过设置want的flag来设置对应的读写权限，action字段配置为"ohos.want.action.sendData"表示进行应用文件分享，开发示例如下。 
说明
 写权限分享时，同时授予读权限。 
 已复制import fileuri from '@ohos.file.fileuri';import window from '@ohos.window';import wantConstant from '@ohos.app.ability.wantConstant';import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {  onWindowStageCreate(windowStage: window.WindowStage) {    // 获取文件沙箱路径    let filePath = this.context.filesDir + '/test.txt';    // 将沙箱路径转换为uri    let uri = fileuri.getUriFromPath(filePath);    let want = {      // 配置被分享文件的读写权限，例如对被分享应用进行读写授权      flags: wantConstant.Flags.FLAG_AUTH_WRITE_URI_PERMISSION | wantConstant.Flags.FLAG_AUTH_READ_URI_PERMISSION,      // 配置分享应用的隐式拉起规则      action: 'ohos.want.action.sendData',      uri: uri,      type: 'text/plain'    }    this.context.startAbility(want)      .then(() => {        console.info('Invoke getCurrentBundleStats succeeded.');      })      .catch((err) => {        console.error(`Invoke startAbility failed, code is ${err.code}, message is ${err.message}`);      });  }
  ...}    使用其他应用分享的文件 被分享应用需要在module.json5配置文件的actions标签的值配置为"ohos.want.action.sendData"，表示接收应用分享文件，配置uris字段，表示接收URI的类型，即只接收其他应用分享该类型的URI，如下表示本应用只接收scheme为file，类型为txt的文件，示例如下。 已复制{  "module": {    ...    "abilities": [      {        ...        "skills": [          {            ...            "actions": [              "ohos.want.action.sendData"            ],            "uris": [              {                "scheme": "file",                "type": "text/plain"              }           ]          }        ]      }    ]  }} 被分享方的UIAbility被启动后，可以在其onCreate()或者onNewWant()回调中获取传入的Want参数信息。 通过接口want的参数获取分享文件的URI，获取文件URI后通过fs.open()接口打开文件，获取对应的file对象后，可对文件进行读写操作。 已复制// xxx.etsimport fs from '@ohos.file.fs';
function getShareFile() {  try {    let want = ...; // 获取分享方传递过来的want信息
    // 从want信息中获取uri字段    let uri = want.uri;    if (uri == null || uri == undefined) {      console.info('uri is invalid');      return;    }    try {      // 根据需要对被分享文件的URI进行相应操作。例如读写的方式打开URI获取file对象      let file = fs.openSync(uri, fs.OpenMode.READ_WRITE);      console.info('open file successfully!');    } catch (error) {      console.error(`Invoke openSync failed, code is ${error.code}, message is ${error.message}`);    }  } catch (error) {    console.error(`Invoke openSync failed, code is ${error.code}, message is ${error.message}`);  }}   上一篇 向应用沙箱推送文件 下一篇 用户文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。共享包概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS提供了两种共享包，HAR（Harmony Archive）静态共享包，和HSP（Harmony Shared Package）动态共享包。 HAR与HSP都是为了实现代码和资源的共享，都可以包含代码、C++库、资源和配置文件，最大的不同之处在于：HAR中的代码和资源跟随使用方编译，如果有多个使用方，它们的编译产物中会存在多份相同拷贝；而HSP中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份。 图1 HAR和HSP在APP包中的形态示意图  HSP旨在解决HAR存在的几个问题： 多个HAP引用相同的HAR，导致的APP包大小膨胀问题。多个HAP引用相同的HAR，HAR中的一些状态变量无法共享的问题。 HSP的一些约束： HSP及其使用方都必须是Stage模型。HSP及其使用方都必须使用esmodule编译模式。HSP不支持在配置文件中声明abilities、extensionAbilities标签。 HSP按照使用场景可以分为应用内HSP和应用间HSP，应用间HSP暂不支持。  上一篇 共享包 下一篇 HAR 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自动签名手动签名生成密钥和证书请求文件申请调试证书和调试Profile文件手动配置签名信息使用ACL的签名配置指导为应用/服务进行签名 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 针对应用/服务的签名，DevEco Studio为开发者提供了自动签名方案，帮助开发者高效进行调试。也可选择手动方式对应用/服务进行签名，如果使用了需要ACL的权限，需采用手动方式进行签名。 自动签名
说明
使用自动签名前，请确保本地系统时间与北京时间（UTC/GMT +8.00）保持一致。如果不一致，将导致签名失败。 
 连接真机设备，确保DevEco Studio与真机设备已连接，真机连接成功后如下图所示：
说明
如果同时连接多个设备，则使用自动化签名时，会同时将这多个设备的信息写到证书文件中。 
  进入File > Project Structure > Project > Signing Configs界面，勾选“Automatically generate signature”（如果是API 8和9工程，需同时勾选“SupportHarmonyOS”），即可完成签名。如果未登录，请先单击Sign In进行登录，然后自动完成签名。 签名完成后，如下图所示：    手动签名 HarmonyOS应用/服务通过数字证书（.cer文件）和Profile文件（.p7b文件）来保证应用/服务的完整性。在申请数字证书和Profile文件前，首先需要通过DevEco Studio或命令行工具来生成密钥（存储在格式为.p12的密钥库文件中）和证书请求文件（.csr文件）。然后，申请调试数字证书和调试Profile文件。最后，将密钥（.p12）文件、数字证书（.cer）文件和Profile（.p7b）文件配置到工程中。 基本概念密钥：格式为.p12，包含非对称加密中使用的公钥和私钥，存储在密钥库文件中，公钥和私钥对用于数字签名和验证。证书请求文件：格式为.csr，全称为Certificate Signing Request，包含密钥对中的公钥和公共名称、组织名称、组织单位等信息，用于向AppGallery Connect申请数字证书。数字证书：格式为.cer，由华为AppGallery Connect颁发。Profile文件：格式为.p7b，包含HarmonyOS应用/服务的包名、数字证书信息、描述应用/服务允许申请的证书权限列表，以及允许应用/服务调试的设备列表（如果应用/服务类型为Release类型，则设备列表为空）等内容，每个应用/服务包中均必须包含一个Profile文件。  生成密钥和证书请求文件使用DevEco Studio生成密钥和证书请求文件 在主菜单栏单击Build > Generate Key and CSR。
说明
如果本地已有对应的密钥，无需新生成密钥，可以在Generate Key界面中单击下方的Skip跳过密钥生成过程，直接使用已有密钥生成证书请求文件。 
 在Key Store File中，可以单击Choose Existing选择已有的密钥库文件（存储有密钥的.p12文件）；如果没有密钥库文件，单击New进行创建。下面以新创建密钥库文件为例进行说明。 在Create Key Store窗口中，填写密钥库信息后，单击OK。Key Store File：设置密钥库文件存储路径，并填写p12文件名。Password：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。Confirm Password：再次输入密钥库密码。  在Generate Key and CSR界面中，继续填写密钥信息后，单击Next。Alias：密钥的别名信息，用于标识密钥名称。请记住该别名，后续签名配置需要使用。Password：密钥对应的密码，与密钥库密码保持一致，无需手动输入。Validity：证书有效期，建议设置为25年及以上，覆盖应用/服务的完整生命周期。Certificate：输入证书基本信息，如组织、城市或地区、国家码等。  在Generate Key and CSR界面，设置CSR文件存储路径和CSR文件名。 单击OK，创建CSR文件成功，可以在存储路径下获取生成的密钥库文件（.p12）和证书请求文件（.csr）。  使用命令行工具生成证书请求文件 使用Open JDK携带的Keytool工具生成证书请求文件。 使用管理员身份运行命令行工具。 切换到keytool工具所在路径，路径为DevEco Studio安装目录下的jbr\bin目录。执行如下命令，生成公私钥文件。例如，生成的密钥库名称为idedemokey.p12，存储到D盘根目录下。已复制keytool -genkeypair -alias "ide_demo_app" -keyalg EC -sigalg SHA256withECDSA -dname "C=CN,O=HUAWEI,OU=HUAWEI IDE,CN=ide_demo_app"  -keystore d:\\idedemokey.p12 -storetype pkcs12 -validity 9125 -storepass 123456Abc -keypass 123456Abc 生成公私钥文件的参数说明如下： 
说明
请记录下alias、storepass和keypass的值，在后续手动配置签名信息操作会使用到。 
 alias：密钥的别名信息，用于标识密钥名称。sigalg：签名算法，固定为SHA256withECDSA。dname：按照操作界面提示进行输入。C：国家/地区代码，如CN。O：组织名称，如HUAWEI。OU：组织单位名称，如HUAWEI IDE。CN：名字与姓氏，建议与别名一致。 validity：证书有效期，建议设置为9125（25年）。storepass：设置密钥库密码，必须由大写字母、小写字母、数字和特殊符号中的两种以上字符的组合，长度至少为8位。请记住该密码，后续签名配置需要使用。keypass：设置密钥的密码，请与storepass保持一致。 执行如下命令，执行后需要输入storepass密码，生成证书请求文件，后缀格式为.csr。已复制keytool -certreq -alias "ide_demo_app" -keystore d:\\idedemokey.p12 -storetype pkcs12 -file d:\\idedemokey.csr 生成证书请求文件的参数说明如下： alias：与上一步骤中输入的alias保持一致。file：生成的证书请求文件名称，后缀为.csr。   申请调试证书和调试Profile文件通过生成的证书请求文件，向AppGallery Connect申请调试证书和Profile文件，操作如下：创建HarmonyOS应用/服务：在AppGallery Connect项目中，创建一个HarmonyOS应用/服务，用于调试证书和Profile文件申请，具体请参考创建HarmonyOS应用。申请调试证书和Profile文件：在AppGallery Connect中申请、下载调试证书和Profile文件，具体请参考申请调试证书和Profile文件。   手动配置签名信息在DevEco Studio中配置密钥（.p12）文件、申请的调试证书（.cer）文件和调试Profile（.p7b）文件。 在File > Project Structure > Project > Signing Configs窗口中，去勾选“Automatically generate signature”（API 8和9工程请勾选“support HarmonyOS”），然后配置工程的签名信息。Store File：选择密钥库文件，文件后缀为.p12，该文件为生成密钥和证书请求文件中生成的.p12文件。Store Password：输入密钥库密码，该密码与生成密钥和证书请求文件中填写的密钥库密码保持一致。Key Alias：输入密钥的别名信息，与生成密钥和证书请求文件中填写的别名保持一致。Key Password：输入密钥的密码，与生成密钥和证书请求文件中填写的Store Password保持一致。Sign Alg：签名算法，固定为SHA256withECDSA。Profile File：选择申请调试证书和调试Profile文件中生成的Profile文件，文件后缀为.p7b。Certpath File：选择申请调试证书和调试Profile文件中生成的数字证书文件，文件后缀为.cer。    使用ACL的签名配置指导如果应用需要使用跨级别权限时，需使用ACL方式来申请对应权限。当前仅部分权限支持使用ACL方式申请，在应用权限列表中标记“ACL使能：TRUE，可通过应用市场（AGC）申请”的为支持ACL的权限。 申请进入ACL白名单。请提供APP ID发送到agconnect@huawei.com。收到邮件后，AGC运营审核通过后将进行白名单配置，审核周期一个工作日，请耐心等待。 获取密钥和证书请求文件，请参见生成密钥和证书请求文件。申请调试证书，请参见申请调试证书。申请调试Profile。登录AppGallery Connect，选择“我的项目”找到您的项目，点击您创建的HarmonyOS应用/服务。选择“HarmonyOS应用 > HAP Provision Profile管理”，进入“管理HAP Provision Profile”页面，点击右上角“添加”。 在弹出的“HarmonyAppProvision信息”窗口分别输入信息：名称：不超过100个字符。类型：选择“调试”。
说明
当前仅支持申请调试证书，类型请勿选择发布。 
 选择证书：选择上一步得到用于调试的数字证书。选择设备：选择需要调试的设备，可选择一个或多个。申请受限权限：勾选需要申请使用的受限权限（需要先完成申请进入ACL白名单，当开通ACL白名单后，才会出现配置项“申请受限ACL权限”）。   调试Profile申请成功后 ，在“管理HAP Provision Profile”页面点击“下载”，获取Profile文件。  在配置文件中添加权限信息。在需要使用权限的模块的module.json5文件中添加“requestPermissions”字段，并在字段下添加对应的权限名等信息，以权限“ohos.permission.ACCESS_IDS”为例。已复制{  "module": {    ...    "requestPermissions": [{      "name": "ohos.permission.ACCESS_IDS",    }],    ...  }}   手动配置签名信息。连接真机设备，确保DevEco Studio与真机设备已连接。 点击DevEco Studio右上角的按钮打开“Project Structure”窗口，进入“Signing Config”页签，取消勾选“Automatically generate signature”。在“Signing”下分别配置密钥(.p12文件)、Profile(.p7b文件)和数字证书(.cer文件)的路径等信息。 勾选“Show restricted permissions”，即可看到配置成功的权限。 配置完毕后，点击“Apply”。   进入工程级build-profile.json5文件，在“signingConfigs”下可查看到配置成功的签名信息，点击右上角的“Run”按钮运行应用/服务。    上一篇 调试HarmonyOS应用/服务 下一篇 使用真机进行调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。单次I/O任务开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 Promise和async/await提供异步并发能力，适用于单次I/O任务的场景开发，本文以使用异步进行单次文件写入为例来提供指导。 实现单次I/O任务逻辑。 已复制import fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
async function write(data: string, file: fs.File): Promise<void> {  fs.write(file.fd, data).then((writeLen: number) => {    console.info('write data length is: ' + writeLen)  }).catch((err) => {    console.error(`Failed to write data. Code is ${err.code}, message is ${err.message}`);  })} 采用异步能力调用单次I/O任务。示例中的filePath的获取方式请参见获取应用文件路径。 已复制async function testFunc(): Promise<void> {  let context = getContext() as common.UIAbilityContext;  let filePath: string = context.filesDir + "/test.txt"; // 应用文件路径  let file: fs.File = await fs.open(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);  write('Hello World!', file).then(() => {    console.info('Succeeded in writing data.');  }).catch((err) => {    console.error(`Failed to write data. Code is ${err.code}, message is ${err.message}`);  })  fs.close(file);}testFunc();   上一篇 异步并发概述 下一篇 使用多线程并发能力进行开发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介基本概念场景介绍接口说明应用TCP/UDP协议进行通信应用通过TLS Socket进行加密数据传输开发步骤Socket连接 更新时间: 2024-03-25 11:20 毫无帮助帮助不大一般很好非常好
分享
   简介 Socket连接主要是通过Socket进行数据传输，支持TCP/UDP/TLS协议。   基本概念  Socket：套接字，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 TCP：传输控制协议(Transmission Control Protocol)。是一种面向连接的、可靠的、基于字节流的传输层通信协议。 UDP：用户数据报协议(User Datagram Protocol)。是一个简单的面向消息的传输层，不需要连接。 TLS：安全传输层协议(Transport Layer Security)。用于在两个通信应用程序之间提供保密性和数据完整性。    场景介绍 应用通过Socket进行数据传输，支持TCP/UDP/TLS协议。主要场景有：  应用通过TCP/UDP Socket进行数据传输 应用通过TLS Socket进行加密数据传输    接口说明 完整的JS API说明以及实例代码请参考：Socket连接。 Socket连接主要由socket模块提供。具体接口说明如下表。     接口名 功能描述    constructUDPSocketInstance() 创建一个UDPSocket对象。   constructTCPSocketInstance() 创建一个TCPSocket对象。   bind() 绑定IP地址和端口。   send() 发送数据。   close() 关闭连接。   getState() 获取Socket状态。   connect() 连接到指定的IP地址和端口（仅TCP支持）   getRemoteAddress() 获取对端Socket地址（仅TCP支持，需要先调用connect方法）   on(type: 'message') 订阅Socket连接的接收消息事件。   off(type: 'message') 取消订阅Socket连接的接收消息事件。   on(type: 'close') 订阅Socket连接的关闭事件。   off(type: 'close') 取消订阅Socket连接的关闭事件。   on(type: 'error') 订阅Socket连接的Error事件。   off(type: 'error') 取消订阅Socket连接的Error事件。   on(type: 'listening') 订阅UDPSocket连接的数据包消息事件（仅UDP支持）。   off(type: 'listening') 取消订阅UDPSocket连接的数据包消息事件（仅UDP支持）。   on(type: 'connect') 订阅TCPSocket的连接事件（仅TCP支持）。   off(type: 'connect') 取消订阅TCPSocket的连接事件（仅TCP支持）。    TLS Socket连接主要由tls_socket模块提供。具体接口说明如下表。     接口名 功能描述    constructTLSSocketInstance() 创建一个TLSSocket对象。   bind() 绑定IP地址和端口号。   close(type: 'error') 关闭连接。   connect() 连接到指定的IP地址和端口。   getCertificate() 返回表示本地证书的对象。   getCipherSuite() 返回包含协商的密码套件信息的列表。   getProtocol() 返回包含当前连接协商的SSL/TLS协议版本的字符串。   getRemoteAddress() 获取TLSSocket连接的对端地址。   getRemoteCertificate() 返回表示对等证书的对象。   getSignatureAlgorithms() 在服务器和客户端之间共享的签名算法列表，按优先级降序排列。   getState() 获取TLSSocket连接的状态。   off(type: 'close') 取消订阅TLSSocket连接的关闭事件。   off(type: 'error') 取消订阅TLSSocket连接的Error事件。   off(type: 'message') 取消订阅TLSSocket连接的接收消息事件。   on(type: 'close') 订阅TLSSocket连接的关闭事件。   on(type: 'error') 订阅TLSSocket连接的Error事件。   on(type: 'message') 订阅TLSSocket连接的接收消息事件。   send() 发送数据。   setExtraOptions() 设置TLSSocket连接的其他属性。      应用TCP/UDP协议进行通信 UDP与TCP流程大体类似，下面以TCP为例：  import需要的socket模块。 创建一个TCPSocket连接，返回一个TCPSocket对象。 （可选）订阅TCPSocket相关的订阅事件。 绑定IP地址和端口，端口可以指定或由系统随机分配。 连接到指定的IP地址和端口。 发送数据。 Socket连接使用完毕后，主动关闭。 已复制import socket from '@ohos.net.socket';
// 创建一个TCPSocket连接，返回一个TCPSocket对象。let tcp = socket.constructTCPSocketInstance();
// 订阅TCPSocket相关的订阅事件tcp.on('message', value => {  console.log("on message")  let buffer = value.message  let dataView = new DataView(buffer)  let str = ""  for (let i = 0; i < dataView.byteLength; ++i) {    str += String.fromCharCode(dataView.getUint8(i))  }  console.log("on connect received:" + str)});tcp.on('connect', () => {  console.log("on connect")});tcp.on('close', () => {  console.log("on close")});
// 绑定IP地址和端口。let bindAddress = {  address: '192.168.xx.xx',  port: 1234, // 绑定端口，如1234  family: 1};tcp.bind(bindAddress, err => {  if (err) {    console.log('bind fail');    return;  }  console.log('bind success');  // 连接到指定的IP地址和端口。  let connectAddress = {    address: '192.168.xx.xx',    port: 5678, // 连接端口，如5678    family: 1  };  tcp.connect({    address: connectAddress, timeout: 6000  }, err => {    if (err) {      console.log('connect fail');      return;    }    console.log('connect success');    // 发送数据    tcp.send({      data: 'Hello, server!'    }, err => {      if (err) {        console.log('send fail');        return;      }      console.log('send success');    })  });});// 连接使用完毕后，主动关闭。取消相关事件的订阅。setTimeout(() => {  tcp.close((err) => {    console.log('close socket.')  });  tcp.off('message');  tcp.off('connect');  tcp.off('close');}, 30 * 1000);    应用通过TLS Socket进行加密数据传输   开发步骤 客户端TLS Socket流程：  import需要的socket模块。 绑定服务器IP和端口号。 双向认证上传客户端CA证书及数字证书；单向认证只上传CA证书，无需上传客户端证书。 创建一个TLSSocket连接，返回一个TLSSocket对象。 （可选）订阅TLSSocket相关的订阅事件。 发送数据。 TLSSocket连接使用完毕后，主动关闭。 已复制// 创建一个（双向认证）TLS Socket连接，返回一个TLS Socket对象。import socket from '@ohos.net.socket';
let tlsTwoWay: socket.TLSSocket = socket.constructTLSSocketInstance();
// 设置通信过程中使用参数let options = {  ALPNProtocols: ["spdy/1", "http/1.1"],
  // 连接到指定的IP地址和端口。  address: {    address: "192.168.xx.xxx",    port: xxxx, // 端口    family: 1,  },
  // 设置用于通信过程中完成校验的参数。  secureOptions: {    key: "xxxx",                            // 密钥    cert: "xxxx",                           // 数字证书    ca: ["xxxx"],                           // CA证书    passwd: "xxxx",                         // 生成密钥时的密码    protocols: [socket.Protocol.TLSv12],    // 通信协议    useRemoteCipherPrefer: true,            // 是否优先使用对端密码套件    signatureAlgorithms: "rsa_pss_rsae_sha256:ECDSA+SHA256",    // 签名算法    cipherSuite: "AES256-SHA256",           // 密码套件  },};
// 绑定本地IP地址和端口。tlsTwoWay.bind({ address: '192.168.xxx.xxx', port: xxxx, family: 1 }, err => {  if (err) {    console.log('bind fail');    return;  }  console.log('bind success');  // 订阅TLS Socket相关的订阅事件  tlsTwoWay.on('message', value => {    console.log("on message")    let buffer = value.message    let dataView = new DataView(buffer)    let str = ""    for (let i = 0; i < dataView.byteLength; ++i) {      str += String.fromCharCode(dataView.getUint8(i))    }    console.log("on connect received:" + str)  });  tlsTwoWay.on('connect', () => {    console.log("on connect")  });  tlsTwoWay.on('close', () => {    console.log("on close")  });
  // 建立连接  tlsTwoWay.connect(options).then(() => {    console.log('connect success');
    // 发送数据    let sendBuf = 'client send to server...';    tlsTwoWay.send(sendBuf).then(() => {      console.log('client send ok');    }).catch((err: Object) => {      console.error('client send err: ' + JSON.stringify(err));    })  }).catch((err: Object) => {    console.log('connect failed ' + JSON.stringify(err));  });
  // 连接使用完毕后，主动关闭。取消相关事件的订阅。  tlsTwoWay.close().then(() => {    console.log('close success');  }).catch((err: Object) => {    console.log('close failed ' + JSON.stringify(err));  });  tlsTwoWay.off('message');  tlsTwoWay.off('connect');  tlsTwoWay.off('close');});    上一篇 WebSocket连接 下一篇 IPC与RPC通信 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Windows环境运行环境要求下载和安装DevEco StudiomacOS环境运行环境要求下载和安装DevEco Studio下载与安装软件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持Windows和macOS系统，下面将针对两种操作系统的软件安装方式分别进行介绍。 Windows环境 运行环境要求为保证DevEco Studio正常运行，建议电脑配置满足如下要求： 操作系统：Windows10 64位、Windows11 64位内存：8GB及以上硬盘：100GB及以上分辨率：1280*800像素及以上  下载和安装DevEco Studio进入HUAWEI DevEco Studio产品页，单击下载列表右侧的按钮，下载DevEco Studio。下载完成后，双击下载的“deveco-studio-xxxx.exe”，进入DevEco Studio安装向导。在如下界面选择安装路径，默认安装于C:\Program Files路径下，也可以单击Browse...指定其他安装路径，然后单击Next。 在如下安装选项界面勾选DevEco Studio后，单击Next，直至安装完成。 安装完成后，单击Finish完成安装。   macOS环境 运行环境要求为保证DevEco Studio正常运行，建议电脑配置满足如下要求： macOS(X86) 10.15/11/12/13 macOS(ARM) 11/12/13内存：8GB及以上 硬盘：100GB及以上分辨率：1280*800像素及以上 
说明
ARM架构芯片系列处理器的Mac仅支持创建API 9及以上版本的工程。 
  下载和安装DevEco Studio进入HUAWEI DevEco Studio产品页，单击下载列表右侧的按钮，下载DevEco Studio。下载完成后，双击下载的“deveco-studio-xxxx.dmg”软件包。在安装界面中，将“DevEco-Studio.app”拖拽到“Applications”中，等待安装完成。 安装完成后，接下来请根据配置开发环境，检查和配置开发环境。   上一篇 搭建开发环境流程 下一篇 配置开发环境 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。堆栈可视化调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 堆栈可视化功能可以在调试过程中，将函数之间的调用关系以直观的可视化结构图呈现出来，保留了历史调用关系，克服了跨设备跨语言堆栈列表不连续的弊端。堆栈可视化可使用不同颜色表示不同设备调试的模块，点击调用关系结构图中的函数节点能自动定位到代码中的函数处。使开发者溯源代码更加轻松快捷。 堆栈可视化按如下方式操作。 
说明
该功能支持HarmonyOS API Version 4至7的工程，不支持C++工程。 
 在待调试的源代码中打上断点，并启动调试功能。在代码的任意位置单击鼠标右键，在弹出窗口中单击Call Stack。 通过调试控制器对代码进行调试，在右侧Call Stack窗口可以查看函数调用关系。 Call Stack窗口显示的函数调用关系：    上一篇 变量可视化调试 下一篇 Release应用堆栈解析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念开发流程Stage模型开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   基本概念 下图展示了Stage模型中的基本概念。 图1 Stage模型概念图   AbilityStage 每个Entry类型或者Feature类型的HAP在运行期都有一个AbilityStage类实例，当HAP中的代码首次被加载到进程中的时候，系统会先创建AbilityStage实例。   UIAbility组件和ExtensionAbility组件 Stage模型提供UIAbility和ExtensionAbility两种类型的组件，这两种组件都有具体的类承载，支持面向对象的开发方式。  UIAbility组件是一种包含UI界面的应用组件，主要用于和用户交互。例如，图库类应用可以在UIAbility组件中展示图片瀑布流，在用户选择某个图片后，在新的页面中展示图片的详细内容。同时用户可以通过返回键返回到瀑布流页面。UIAbility的生命周期只包含创建/销毁/前台/后台等状态，与显示相关的状态通过WindowStage的事件暴露给开发者。 ExtensionAbility组件是一种面向特定场景的应用组件。开发者并不直接从ExtensionAbility派生，而是需要使用ExtensionAbility的派生类。目前ExtensionAbility有用于卡片场景的FormExtensionAbility，用于闲时任务场景的WorkSchedulerExtensionAbility等多种派生类，这些派生类都是基于特定场景提供的。例如，用户在桌面创建应用的卡片，需要应用开发者从FormExtensionAbility派生，实现其中的回调函数，并在配置文件中配置该能力。ExtensionAbility派生类实例由用户触发创建，并由系统管理生命周期。在Stage模型上，普通应用开发者不能开发自定义服务，而需要根据自身的业务场景通过ExtensionAbility的派生类来实现。  WindowStage 每个UIAbility类实例都会与一个WindowStage类实例绑定，WindowStage类起到了应用进程内窗口管理器的作用，它包含一个主窗口。也就是说，UIAbility通过WindowStage持有了一个窗口，该窗口为ArkUI提供了绘制区域。 Context 在Stage模型上，Context及其派生类向开发者提供在运行期可以调用的各种能力。UIAbility组件和各种ExtensionAbility派生类都有各自不同的Context类，他们都继承自基类Context，但是各自又根据所属组件，提供不同的能力。    开发流程 基于Stage模型开发应用时，在应用模型部分，涉及如下开发过程。 表1 Stage模型开发流程     任务 简介 相关指导    应用组件开发 本章节介绍了如何使用Stage模型的UIAbility组件和ExtensionAbility组件开发应用。 - 应用/组件级配置 - UIAbility组件 - ExtensionAbility组件 - AbilityStage组件容器 - 应用上下文Context   了解进程模型 本章节介绍了Stage模型的进程模型以及几种常用的进程间通信方式。 - 公共事件   了解线程模型 本章节介绍了Stage模型的线程模型以及几种常用的线程间通信方式。 - Emitter - Worker   应用配置文件 本章节介绍Stage模型中应用配置文件的开发要求。 Stage模型应用配置文件      上一篇 Stage模型开发指导 下一篇 Stage模型应用组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。启动DataAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 启动DataAbility会获取一个工具接口类对象（DataAbilityHelper）。启动DataAbility的示例代码如下： 已复制// 作为参数传递的URI,与config中定义的URI的区别是多了一个"/",有三个"/",具体原因详见。import featureAbility from '@ohos.ability.featureAbility'
let urivar = "dataability:///com.ix.DataAbility"let DAHelper = featureAbility.acquireDataAbilityHelper(urivar);  上一篇 创建DataAbility 下一篇 访问DataAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。启动本地PageAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 PageAbility相关的能力通过featureAbility提供，启动本地Ability通过featureAbility中的startAbility接口实现。  表1 featureAbility接口说明 接口名 接口描述   startAbility(parameter: StartAbilityParameter) 启动Ability。  startAbilityForResult(parameter: StartAbilityParameter) 启动Ability，并在该Ability被销毁时返回执行结果。    如下示例通过startAbility显式启动PageAbility。启动Ability的参数包含want，关于want的说明详见对象间信息传递载体Want，相应的，隐式启动与显式启动也不在此赘述。 已复制import featureAbility from '@ohos.ability.featureAbility'(async () => {  try {    console.info('Begin to start ability')    let param = {      want: {        bundleName: "com.example.myapplication",        moduleName: "entry",        abilityName: "com.example.myapplication.MainAbility"      }    }    await featureAbility.startAbility(param)    console.info(`Start ability succeed`)  }   catch (error) {    console.error('Start ability failed with ' + error)  }})()  上一篇 创建PageAbility 下一篇 停止PageAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念UI框架应用模型工具准备开发准备 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  本文档适用于HarmonyOS应用开发的初学者。通过构建一个简单的具有页面跳转/返回功能的应用（如下图所示），快速了解工程目录的主要文件，熟悉HarmonyOS应用开发流程。  在开始之前，您需要了解有关HarmonyOS应用的一些基本概念：UI框架的简单说明、应用模型的基本概念。  基本概念   UI框架 HarmonyOS提供了一套UI开发框架，即方舟开发框架（ArkUI框架）。方舟开发框架可为开发者提供应用UI开发所必需的能力，比如多种组件、布局计算、动画能力、UI交互、绘制等。 方舟开发框架针对不同目的和技术背景的开发者提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）和兼容JS的类Web开发范式（简称“类Web开发范式”）。以下是两种开发范式的简单对比。     开发范式名称 语言生态 UI更新方式 适用场景 适用人群    声明式开发范式 ArkTS语言 数据驱动更新 复杂度较大、团队合作度较高的程序 移动系统应用开发人员、系统应用开发人员   类Web开发范式 JS语言 数据驱动更新 界面较为简单的程序应用和卡片 Web前端开发人员    更多UI框架的开发内容及指导，详见UI开发。   应用模型 应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。请见应用模型的构成要素。 随着系统的演进发展，HarmonyOS先后提供了两种应用模型：  FA（Feature Ability）模型： HarmonyOS API 7开始支持的模型，已经不再主推。FA模型开发可见FA模型开发概述。 Stage模型： HarmonyOS API 9开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。Stage模型开发可见Stage模型开发概述。  FA模型和Stage模型的整体架构和设计思想等更多区别，请见应用模型解读。 快速入门提供了一个含有两个页面的开发实例，并使用了不同的开发语言或不同的应用模型进行开发，以便开发者理解以上基本概念及应用开发流程。   工具准备  安装最新版DevEco Studio。 请参考配置开发环境，完成DevEco Studio的安装和开发环境配置。  完成上述操作及基本概念的理解后，可参照构建第一个ArkTS应用（Stage模型）、构建第一个ArkTS应用（FA模型）、构建第一个JS应用（FA模型）中的任一章节进行下一步体验和学习。   上一篇 快速入门 下一篇 构建第一个ArkTS应用（Stage模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。启动指定页面 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 当PageAbility的启动模式设置为单例时（具体设置方法和典型场景示例见PageAbility的启动模式，缺省情况下是单实例模式），若PageAbility已被拉起，再次启动PageAbility会触发onNewWant回调（即非首次拉起）。应用开发者可以通过want传递启动参数，例如开发者希望指定页面启动PageAbility，可以通过want中的parameters参数传递pages信息，具体示例代码如下： 调用方PageAbility的app.ets中或者page中，使用startAbility再次拉起PageAbility，通过want中的uri参数传递页面信息： 已复制import featureAbility from '@ohos.ability.featureAbility';
async function restartAbility() {    let wantInfo = {        bundleName: "com.sample.MyApplication",        abilityName: "MainAbility",        parameters: {            page: "pages/second"        }    };    featureAbility.startAbility({        want: wantInfo    }).then((data) => {        console.info('restartAbility success.');    });} 在目标端PageAbility的onNewWant回调中获取包含页面信息的want参数： 已复制export default {      onNewWant(want) {            globalThis.newWant = want      }} 在目标端页面的自定义组件中获取包含页面信息的want参数并根据uri做路由处理： 已复制import router from '@ohos.router'@Entry@Componentstruct Index {  @State message: string = 'Router Page'  newWant = undefined  onPageShow() {    console.info('Index onPageShow')    let newWant = globalThis.newWant    if (newWant.hasOwnProperty("page")) {      router.push({ url: newWant.page });      globalThis.newWant = undefined    }  }
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }} 当PageAbility的启动模式设置为标准模式或为首次启动单例模式的PageAbility时（具体设置方法和典型场景示例见PageAbility的启动模式），在调用方PageAbility中，通过want中的parameters参数传递要启动的指定页面的pages信息，调用startAbility()方法启动PageAbility。被调用方可以在onCreate中使用featureAbility的getWant方法获取want，再通过调用router.push实现启动指定页面。 调用方的页面中实现按钮点击触发startAbility方法启动目标端PageAbility，startAbility方法的入参want中携带指定页面信息，示例代码如下： 已复制import featureAbility from '@ohos.ability.featureAbility'@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    // ...    Button("startAbility")      .onClick(() => {        featureAbility.startAbility({          want: {            bundleName: "com.exm.myapplication",            abilityName: "com.exm.myapplication.MainAbility",            parameters: { page: "pages/page1" }          }        }).then((data) => {          console.info("startAbility finish");        }).catch((err) => {          console.info("startAbility failed errcode:" + err.code)        })      })    // ...    Button("page2")      .onClick(() => {        featureAbility.startAbility({          want: {            bundleName: "com.exm.myapplication",            abilityName: "com.exm.myapplication.MainAbility",            parameters: { page: "pages/page2" }          }        }).then((data) => {          console.info("startAbility finish");        }).catch((err) => {          console.info("startAbility failed errcode:" + err.code)        })      })    // ...  }} 目标端PageAbility的onCreate生命周期回调中通过featureAbility的getWant方法获取want，并对参数进行解析，实现指定页面拉起： 已复制import featureAbility from '@ohos.ability.featureAbility';import router from '@ohos.router';
export default {  onCreate() {    featureAbility.getWant().then((want) => {      if (want.parameters.page) {        router.push({          url: want.parameters.page        })      }    })  },  onDestroy() {    // ...  },}  上一篇 停止PageAbility 下一篇 窗口属性 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。启动ServiceAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 ServiceAbility的启动与其他Ability并无区别，应用开发者可以在PageAbility中通过featureAbility的startAbility接口拉起ServiceAbility，在ServiceAbility中通过particleAbility的startAbility接口拉起ServiceAbility。 如下示例展示了在PageAbility中通过startAbility启动bundleName为"com.example.myapplication"，abilityName为"ServiceAbility"的ServiceAbility的方法。启动FA模型的ServiceAbility时，需要在abilityName前拼接bundleName字符串。 已复制import featureAbility from '@ohos.ability.featureAbility'
async function startServiceAbility() {  try {    console.info('Begin to start ability')    let param = {      want: {        bundleName: "com.example.myapplication",        abilityName: "com.example.myapplication.ServiceAbility"      }    }    await featureAbility.startAbility(param)    console.info(`Start ability succeed`)  } catch (error) {    console.error('Start ability failed with ' + error)  }} 执行上述代码后，Ability将通过startAbility() 方法来启动ServiceAbility。 如果ServiceAbility尚未运行，则系统会先调用onStart()来初始化ServiceAbility，再回调Service的onCommand()方法来启动ServiceAbility。 如果ServiceAbility正在运行，则系统会直接回调ServiceAbility的onCommand()方法来启动ServiceAbility。   上一篇 创建ServiceAbility 下一篇 连接ServiceAbility 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建ArkTS工程ArkTS工程目录结构（FA模型）构建第一个页面构建第二个页面实现页面间的跳转使用真机运行应用构建第一个ArkTS应用（FA模型） 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
说明
 为确保运行效果，本文以使用DevEco Studio 3.1 Release版本为例，点击此处获取下载链接。 
  创建ArkTS工程  若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File > New > Create Project来创建一个新工程。 选择Application应用开发（本文以应用开发为例，Atomic Service对应为元服务开发），选择模板“Empty Ability”，点击Next进行下一步配置。  进入配置工程界面，Compile SDK选择“3.0.0(API 8)”（Compile SDK选择“3.1.0(API 9)”时注意同步选择 Model 为“FA”，此处以选择“3.0.0(API 8)”为例），Language选择“ArkTS”其他参数保持默认设置即可。 
说明
 DevEco Studio V3.0 Beta3及更高版本支持使用ArkTS低代码开发方式。 低代码开发方式具有丰富的UI界面编辑功能，通过可视化界面开发方式快速构建布局，可有效降低开发者的上手成本并提升开发者构建UI界面的效率。 如需使用低代码开发方式，请打开上图中的Enable Super Visual开关。 
  点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。    ArkTS工程目录结构（FA模型）   entry：HarmonyOS工程模块，编译构建生成一个HAP包。  src > main > ets：用于存放ets源码。 src > main > ets > MainAbility：应用/服务的入口。 src > main > ets > MainAbility > pages：MainAbility包含的页面。 src > main > ets > MainAbility > pages > index.ets：pages列表中的第一个页面，即应用的首页入口。 src > main > ets > MainAbility > app.ets：承载Ability生命周期。 src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。 src > main > config.json：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见应用配置文件（FA模型）。 build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。  build-profile.json5：应用级配置信息，包括签名、产品配置等。 hvigorfile.ts：应用级编译构建任务脚本。    构建第一个页面  使用文本组件。 工程同步完成后，在“Project”窗口，点击“entry > src > main > ets > MainAbility > pages”，打开“index.ets”文件，可以看到页面由Text组件组成。“index.ets”文件的示例如下： 已复制// index.ets@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }} 添加按钮。 在默认页面基础上，我们添加一个Button组件，作为按钮响应用户点击，从而实现跳转到另一个页面。“index.ets”文件的示例如下： 已复制// index.ets@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        // 添加按钮，以响应用户点击        Button() {          Text('Next')            .fontSize(30)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')      }      .width('100%')    }    .height('100%')  }} 在编辑窗口右上角的侧边工具栏，点击Previewer，打开预览器。第一个页面效果如下图所示：     构建第二个页面  创建第二个页面。  新建第二个页面文件。在“Project”窗口，打开“entry > src > main > ets > MainAbility”，右键点击“pages”文件夹，选择“New > ArkTS File”，命名为“second”，点击“Finish”。可以看到文件目录结构如下：  
说明
 开发者也可以在右键点击“pages”文件夹时，选择“New > Page”，则无需手动配置相关页面路由。 
 配置第二个页面的路由。在config.json文件中的“module - js - pages”下配置第二个页面的路由“pages/second”。示例如下： 已复制{  "module": {    "js": [      {        "pages": [          "pages/index",          "pages/second"        ]        }    ]  }}  添加文本及按钮。 参照第一个页面，在第二个页面添加Text组件、Button组件等，并设置其样式。“second.ets”文件的示例如下： 已复制// second.ets@Entry@Componentstruct Second {  @State message: string = 'Hi there'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button() {          Text('Back')            .fontSize(25)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')      }      .width('100%')    }    .height('100%')  }}    实现页面间的跳转 页面间的导航可以通过页面路由router来实现。页面路由router根据页面url找到目标页面，从而实现跳转。使用页面路由请导入router模块。  第一个页面跳转到第二个页面。 在第一个页面中，跳转按钮绑定onClick事件，点击按钮时跳转到第二页。“index.ets”文件的示例如下： 已复制// index.ets// 导入页面路由模块import router from '@ohos.router';
@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        // 添加按钮，以响应用户点击        Button() {          Text('Next')            .fontSize(30)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')        // 跳转按钮绑定onClick事件，点击时跳转到第二页        .onClick(() => {          router.push({ url: 'pages/second' })          // 若为API 9工程，则可使用以下接口          // router.pushUrl({ url: 'pages/second' })        })      }      .width('100%')    }    .height('100%')  }} 第二个页面返回到第一个页面。 在第二个页面中，返回按钮绑定onClick事件，点击按钮时返回到第一页。“second.ets”文件的示例如下： 已复制// second.ets// 导入页面路由模块import router from '@ohos.router';
@Entry@Componentstruct Second {  @State message: string = 'Hi there'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button() {          Text('Back')            .fontSize(25)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')        // 返回按钮绑定onClick事件，点击按钮时返回到第一页        .onClick(() => {          router.back()        })      }      .width('100%')    }    .height('100%')  }} 打开index.ets文件，点击预览器中的按钮进行刷新。效果如下图所示：     使用真机运行应用 运行HarmonyOS应用可以使用远程模拟器和物理真机设备，区别在于使用远程模拟器运行应用不需要对应用进行签名。接下来将以物理真机设备为例，介绍HarmonyOS应用的运行方法，关于模拟器的使用请参考使用Remote Emulator运行应用/服务。  将搭载HarmonyOS系统的真机与电脑连接。具体指导及要求，可查看使用本地真机运行应用/服务。 点击File > Project Structure... > Project > SigningConfigs界面勾选“Support HarmonyOS”和“Automatically generate signature”，点击界面提示的“Sign In”，使用华为帐号登录。等待自动签名完成后，点击“OK”即可。如下图所示：  在编辑窗口右上角的工具栏，点击按钮运行。效果如下图所示：   恭喜您已经使用ArkTS语言开发（FA模型）完成了第一个HarmonyOS应用，快来探索更多的HarmonyOS功能吧。   上一篇 构建第一个ArkTS应用（Stage模型） 下一篇 构建第一个JS应用（FA模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建ArkTS工程ArkTS工程目录结构（Stage模型）构建第一个页面构建第二个页面实现页面间的跳转使用真机运行应用构建第一个ArkTS应用（Stage模型） 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
说明
 为确保运行效果，本文以使用DevEco Studio 3.1 Release版本为例，点击此处获取下载链接。 
  创建ArkTS工程  若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File > New > Create Project来创建一个新工程。 选择Application应用开发（本文以应用开发为例，Atomic Service对应为元服务开发），选择模板“Empty Ability”，点击Next进行下一步配置。  进入配置工程界面，Compile SDK选择“3.1.0(API 9)”，Model 选择“Stage”，其他参数保持默认设置即可。 
说明
 支持使用ArkTS低代码开发方式。 低代码开发方式具有丰富的UI界面编辑功能，通过可视化界面开发方式快速构建布局，可有效降低开发者的上手成本并提升开发者构建UI界面的效率。 如需使用低代码开发方式，请打开上图中的Enable Super Visual开关。 
  点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。    ArkTS工程目录结构（Stage模型）   AppScope > app.json5：应用的全局配置信息。   entry：HarmonyOS工程模块，编译构建生成一个HAP包。         src > main > ets：用于存放ArkTS源码。 src > main > ets > entryability：应用/服务的入口。 src > main > ets > pages：应用/服务包含的页面。 src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。 src > main > module.json5：Stage模型模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。 build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。   oh_modules：用于存放三方库依赖信息。关于原npm工程适配ohpm操作，请参考历史工程迁移。 build-profile.json5：应用级配置信息，包括签名、产品配置等。 hvigorfile.ts：应用级编译构建任务脚本。    构建第一个页面  使用文本组件。 工程同步完成后，在“Project”窗口，点击“entry > src > main > ets > pages”，打开“Index.ets”文件，可以看到页面由Text组件组成。“Index.ets”文件的示例如下： 已复制// Index.ets@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)      }      .width('100%')    }    .height('100%')  }} 添加按钮。 在默认页面基础上，我们添加一个Button组件，作为按钮响应用户点击，从而实现跳转到另一个页面。“Index.ets”文件的示例如下： 已复制// Index.ets@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        // 添加按钮，以响应用户点击        Button() {          Text('Next')            .fontSize(30)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')      }      .width('100%')    }    .height('100%')  }} 在编辑窗口右上角的侧边工具栏，点击Previewer，打开预览器。第一个页面效果如下图所示：     构建第二个页面  创建第二个页面。  新建第二个页面文件。在“Project”窗口，打开“entry > src > main > ets ”，右键点击“pages”文件夹，选择“New > ArkTS File”，命名为“Second”，点击“Finish”。可以看到文件目录结构如下：  
说明
 开发者也可以在右键点击“pages”文件夹时，选择“New > Page”，则无需手动配置相关页面路由。 
 配置第二个页面的路由。在“Project”窗口，打开“entry > src > main > resources > base > profile”，在main_pages.json文件中的“src”下配置第二个页面的路由“pages/Second”。示例如下： 已复制{  "src": [    "pages/Index",    "pages/Second"  ]}  添加文本及按钮。 参照第一个页面，在第二个页面添加Text组件、Button组件等，并设置其样式。“Second.ets”文件的示例如下： 已复制// Second.ets@Entry@Componentstruct Second {  @State message: string = 'Hi there'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button() {          Text('Back')            .fontSize(25)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')      }      .width('100%')    }    .height('100%')  }}    实现页面间的跳转 页面间的导航可以通过页面路由router来实现。页面路由router根据页面url找到目标页面，从而实现跳转。使用页面路由请导入router模块。  第一个页面跳转到第二个页面。 在第一个页面中，跳转按钮绑定onClick事件，点击按钮时跳转到第二页。“Index.ets”文件的示例如下： 已复制// Index.ets// 导入页面路由模块import router from '@ohos.router';
@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        // 添加按钮，以响应用户点击        Button() {          Text('Next')            .fontSize(30)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')        // 跳转按钮绑定onClick事件，点击时跳转到第二页        .onClick(() => {          console.info(`Succeeded in clicking the 'Next' button.`)          // 跳转到第二页          router.pushUrl({ url: 'pages/Second' }).then(() => {            console.info('Succeeded in jumping to the second page.')          }).catch((err) => {            console.error(`Failed to jump to the second page.Code is ${err.code}, message is ${err.message}`)          })        })      }      .width('100%')    }    .height('100%')  }} 第二个页面返回到第一个页面。 在第二个页面中，返回按钮绑定onClick事件，点击按钮时返回到第一页。“Second.ets”文件的示例如下： 已复制// Second.ets// 导入页面路由模块import router from '@ohos.router';
@Entry@Componentstruct Second {  @State message: string = 'Hi there'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button() {          Text('Back')            .fontSize(25)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({          top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')        // 返回按钮绑定onClick事件，点击按钮时返回到第一页        .onClick(() => {          console.info(`Succeeded in clicking the 'Back' button.`)          try {            // 返回第一页            router.back()            console.info('Succeeded in returning to the first page.')          } catch (err) {            console.error(`Failed to return to the first page.Code is ${err.code}, message is ${err.message}`)          }        })      }      .width('100%')    }    .height('100%')  }} 打开“Index.ets”文件，点击预览器中的按钮进行刷新。效果如下图所示：     使用真机运行应用 运行HarmonyOS应用可以使用远程模拟器和物理真机设备，区别在于使用远程模拟器运行应用不需要对应用进行签名。接下来将以物理真机设备为例，介绍HarmonyOS应用的运行方法，关于模拟器的使用请参考使用Remote Emulator运行。  将搭载HarmonyOS系统的真机与电脑连接。具体指导及要求，可查看使用本地真机运行应用/服务。 点击File > Project Structure... > Project > SigningConfigs界面勾选“Support HarmonyOS”和“Automatically generate signature”，点击界面提示的“Sign In”，使用华为帐号登录。等待自动签名完成后，点击“OK”即可。如下图所示：  在编辑窗口右上角的工具栏，点击按钮运行。效果如下图所示：   恭喜您已经使用ArkTS语言开发（Stage模型）完成了第一个HarmonyOS应用，快来探索更多的HarmonyOS功能吧。   上一篇 开发准备 下一篇 构建第一个ArkTS应用（FA模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建JS工程JS工程目录结构构建第一个页面构建第二个页面实现页面间的跳转使用真机运行应用构建第一个JS应用（FA模型） 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
说明
 为确保运行效果，本文以使用DevEco Studio 3.1 Release版本为例，点击此处获取下载链接。 
  创建JS工程  若首次打开DevEco Studio，请点击Create Project创建工程。如果已经打开了一个工程，请在菜单栏选择File > New > Create Project来创建一个新工程。 选择Application应用开发（本文以应用开发为例，Atomic Service对应为元服务开发），选择模板“Empty Ability”，点击Next进行下一步配置。  进入配置工程界面，Compile SDK选择“3.0.0(API 8)”（Compile SDK选择“3.1.0(API 9)”时注意同步选择 Model 为“FA”，此处以选择“3.0.0(API 8)”为例），Language选择“JS”，其他参数保持默认设置即可。 
说明
 DevEco Studio V2.2 Beta1及更高版本支持使用JS低代码开发方式。 低代码开发方式具有丰富的UI界面编辑功能，通过可视化界面开发方式快速构建布局，可有效降低开发者的上手成本并提升开发者构建UI界面的效率。 如需使用低代码开发方式，请打开上图中的Enable Super Visual开关。 
  点击Finish，工具会自动生成示例代码和相关资源，等待工程创建完成。    JS工程目录结构   entry：HarmonyOS工程模块，编译构建生成一个HAP包。  src > main > js：用于存放js源码。 src > main > js > MainAbility：应用/服务的入口。 src > main > js > MainAbility > i18n：用于配置不同语言场景资源内容，比如应用文本词条、图片路径等资源。 src > main > js > MainAbility > pages：MainAbility包含的页面。 src > main > js > MainAbility > app.js：承载Ability生命周期。 src > main > resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源限定与访问。 src > main > config.json：模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见应用配置文件（FA模型）。 build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。  build-profile.json5：应用级配置信息，包括签名、产品配置等。 hvigorfile.ts：应用级编译构建任务脚本。    构建第一个页面  使用文本组件。 工程同步完成后，在“Project”窗口，点击“entry > src > main > js > MainAbility > pages> index”，打开“index.hml”文件，设置Text组件内容。“index.hml”文件的示例如下： 已复制<!-- index.hml --><div class="container">    <text class="title">        Hello World    </text></div> 添加按钮，并绑定onclick方法。 在默认页面基础上，我们添加一个button类型的input组件，作为按钮响应用户点击，从而实现跳转到另一个页面。“index.hml”文件的示例代码如下： 已复制<!-- index.hml --><div class="container">    <text class="title">        Hello World    </text>
<!-- 添加按钮，值为Next，并绑定onclick方法-->    <input class="btn" type="button" value="Next" onclick="onclick"></input></div> 设置页面样式。 在“Project”窗口，点击“entry > src > main > js > MainAbility > pages> index”，打开“index.css”文件，可以对页面中文本、按钮设置宽高、字体大小、间距等样式。“index.css”文件的示例如下： 已复制/* index.css */.container {    display: flex;    flex-direction: column;    justify-content: center;    align-items: center;    left: 0px;    top: 0px;    width: 100%;    height: 100%;}
.title {    font-size: 100px;    font-weight: bold;    text-align: center;    width: 100%;    margin: 10px;}
.btn {    font-size: 60px;    font-weight: bold;    text-align: center;    width: 40%;    height: 5%;    margin-top: 20px;} 在编辑窗口右上角的侧边工具栏，点击Previewer，打开预览器。第一个页面效果如下图所示：     构建第二个页面  创建第二个页面。 在“Project”窗口，打开“entry > src > main > js > MainAbility”，右键点击“pages”文件夹，选择“New > Page”，命名为“second”，点击“Finish”，即完成第二个页面的创建。可以看到文件目录结构如下：  添加文本及按钮。 参照第一个页面，在第二个页面添加文本、按钮及点击按钮绑定页面返回等。“second.hml”文件的示例如下： 已复制<!-- second.hml --><div class="container">    <text class="title">        Hi there    </text>
<!-- 添加按钮，值为Back，并绑定back方法-->    <input class="btn" type="button" value="Back" onclick="back"></input></div> 设置页面样式。“second.css”文件的示例如下： 已复制/* second.css */.container {    display: flex;    flex-direction: column;    justify-content: center;    align-items: center;    left: 0px;    top: 0px;    width: 100%;    height: 100%;}
.title {    font-size: 100px;    font-weight: bold;    text-align: center;    width: 100%;    margin: 10px;}
.btn {    font-size: 60px;    font-weight: bold;    text-align: center;    width: 40%;    height: 5%;    margin-top: 20px;}    实现页面间的跳转 页面间的导航可以通过页面路由router来实现。页面路由router根据页面url找到目标页面，从而实现跳转。使用页面路由请导入router模块。  第一个页面跳转到第二个页面。 在第一个页面中，跳转按钮绑定onclick方法，点击按钮时跳转到第二页。“index.js”示例如下： 已复制// index.js// 导入页面路由模块import router from '@ohos.router';
export default {    onclick: function () {        router.push({            url: "pages/second/second"        })    }} 第二个页面返回到第一个页面。 在第二个页面中，返回按钮绑定back方法，点击按钮时返回到第一页。“second.js”示例如下： 已复制// second.js// 导入页面路由模块import router from '@ohos.router';
export default {    back: function () {        router.back()    }} 打开index文件夹下的任意一个文件，点击预览器中的按钮进行刷新。效果如下图所示：     使用真机运行应用 运行HarmonyOS应用可以使用远程模拟器和物理真机设备，区别在于使用远程模拟器运行应用不需要对应用进行签名。接下来将以物理真机设备为例，介绍HarmonyOS应用的运行方法，关于模拟器的使用请参考使用Remote Emulator运行应用/服务。  将搭载HarmonyOS系统的真机与电脑连接。具体指导及要求，可查看使用本地真机运行应用/服务。 点击File > Project Structure... > Project > SigningConfigs界面勾选“Support HarmonyOS”和“Automatically generate signature”，点击界面提示的“Sign In”，使用华为帐号登录。等待自动签名完成后，点击“OK”即可。如下图所示：  在编辑窗口右上角的工具栏，点击按钮运行。效果如下图所示：   恭喜您已经使用JS语言开发（FA模型）完成了第一个HarmonyOS应用，快来探索更多的HarmonyOS功能吧。   上一篇 构建第一个ArkTS应用（FA模型） 下一篇 开发基础知识 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍设备状态类型参数说明订阅设备状态事件参数说明返回设备状态参数说明接口说明约束与限制开发步骤Stationary开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 当应用需要获取当前设备状态时，可以调用Stationary模块，例如：需要判断当前设备处于绝对静止状态或者相对静止状态。 详细的接口介绍请参考Stationary接口。   设备状态类型参数说明     名称 描述    still 绝对静止。   relativeStill 相对静止。      订阅设备状态事件参数说明     变量 值 说明    ENTER 1 订阅进入事件。   EXIT 2 订阅退出事件。   ENTER_EXIT 3 订阅进入和退出事件。      返回设备状态参数说明     变量 值 说明    ENTER 1 返回进入状态。   EXIT 2 返回退出状态。      接口说明     模块 接口名 描述    ohos.stationary on(activity: ActivityType, event: ActivityEvent, reportLatencyNs: number, callback: Callback<ActivityResponse>): void 订阅设备状态，结果通过callback返回。   ohos.stationary once(activity: ActivityType, callback: Callback<ActivityResponse>): void 查询设备状态，结果通过callback返回。   ohos.stationary off(activity: ActivityType, event: ActivityEvent, callback?: Callback<ActivityResponse>): void 取消订阅设备状态。      约束与限制 设备需要支持加速度传感器。   开发步骤  订阅绝对静止的进入事件，1秒上报一次。 已复制import stationary from '@ohos.stationary';var reportLatencyNs = 1000000000;try {   stationary.on('still', stationary.ActivityEvent.ENTER, reportLatencyNs, (data) => {      console.log('data='+ JSON.stringify(data));   })} catch (err) {   console.error('errCode: ' + err.code + ' ,msg: ' + err.message);} 查询绝对静止状态的进入事件。 已复制import stationary from '@ohos.stationary';try {   stationary.once('still', (data) => {      console.log('data='+ JSON.stringify(data));   })} catch (err) {   console.error('errCode: ' + err.code + ' ,msg: ' + err.message);} 取消订阅绝对静止状态的进入事件。 已复制import stationary from '@ohos.stationary';try {   stationary.off('still', stationary.ActivityEvent.ENTER, (data) => {      console.log('data='+ JSON.stringify(data));   })} catch (err) {   console.error('errCode: ' + err.code + ' ,msg: ' + err.message);}    上一篇 设备状态 下一篇 DFX 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。停止PageAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 停止PageAbility通过featureAbility中的terminateSelf接口实现。 表1 featureAbility接口说明 接口名  接口描述    terminateSelf()  停止Ability。   terminateSelfWithResult(parameter: AbilityResult)  设置该PageAbility停止时返回给调用者的结果及数据并停止Ability。     如下示例展示了停止Ability的方法。 已复制import featureAbility from '@ohos.ability.featureAbility'
(async () => {  try {    console.info('Begin to terminateSelf')    await featureAbility.terminateSelf()    console.info('terminateSelf succeed')  }   catch (error) {    console.error('terminateSelf failed with ' + error)  }})()  上一篇 启动本地PageAbility 下一篇 启动指定页面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用场景Native侧接口参考代码JS侧接口参考代码Stub感知Proxy消亡（匿名Stub的使用）参考代码远端状态订阅开发实例 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 IPC/RPC提供对远端Stub对象状态的订阅机制， 在远端Stub对象消亡时，可触发消亡通知告诉本地Proxy对象。这种状态通知订阅需要调用特定接口完成，当不再需要订阅时也需要调用特定接口取消。使用这种订阅机制的用户，需要实现消亡通知接口DeathRecipient并实现onRemoteDied方法清理资源。该方法会在远端Stub对象所在进程消亡或所在设备离开组网时被回调。值得注意的是，调用这些接口有一定的顺序。首先，需要Proxy订阅Stub消亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或者所在设备退出组网，则会自动触发Proxy自定义的后续操作。 使用场景这种订阅机制适用于本地Proxy对象需要感知远端Stub对象所在进程消亡，或所在设备离开组网的场景。当Proxy感知到Stub端消亡后，可适当清理本地资源。此外，RPC目前不提供匿名Stub对象的消亡通知，即只有向SAMgr注册过的服务才能被订阅消亡通知，IPC则支持匿名对象的消亡通知。  Native侧接口 接口名  返回值类型  功能描述    AddDeathRecipient(const sptr<DeathRecipient> &recipient);  bool  订阅远端Stub对象状态。   RemoveDeathRecipient(const sptr<DeathRecipient> &recipient);  bool  取消订阅远端Stub对象状态。   OnRemoteDied(const wptr<IRemoteObject> &object);  void  当远端Stub对象死亡时回调。      参考代码已复制#include "iremote_broker.h"#include "iremote_stub.h"
//定义消息码enum {    TRANS_ID_PING_ABILITY = 5,    TRANS_ID_REVERSED_MONITOR};
const std::string DESCRIPTOR = "test.ITestAbility";
class ITestService : public IRemoteBroker {public:    // DECLARE_INTERFACE_DESCRIPTOR是必需的，入参需使用std::u16string；    DECLARE_INTERFACE_DESCRIPTOR(to_utf16(DESCRIPTOR));    virtual int TestPingAbility(const std::u16string &dummy) = 0; // 定义业务函数};
class TestServiceProxy : public IRemoteProxy<ITestAbility> {public:    explicit TestAbilityProxy(const sptr<IRemoteObject> &impl);    virtual int TestPingAbility(const std::u16string &dummy) override;    int TestAnonymousStub();private:    static inline BrokerDelegator<TestAbilityProxy> delegator_; // 方便后续使用iface_cast宏};
TestServiceProxy::TestServiceProxy(const sptr<IRemoteObject> &impl)    : IRemoteProxy<ITestAbility>(impl){}
int TestServiceProxy::TestPingAbility(const std::u16string &dummy){    MessageOption option;    MessageParcel dataParcel, replyParcel;    dataParcel.WriteString16(dummy);    int error = PeerHolder::Remote()->SendRequest(TRANS_ID_PING_ABILITY, dataParcel, replyParcel, option);    int result = (error == ERR_NONE) ? replyParcel.ReadInt32() : -1;    return result;} 已复制#include "iremote_object.h"
class TestDeathRecipient : public IRemoteObject::DeathRecipient {public:    virtual void OnRemoteDied(const wptr<IRemoteObject>& remoteObject);}
void TestDeathRecipient::OnRemoteDied(const wptr<IRemoteObject>& remoteObject){} 已复制sptr<IPCObjectProxy> object = new IPCObjectProxy(1, to_utf16(DESCRIPTOR));sptr<IRemoteObject::DeathRecipient> deathRecipient (new TestDeathRecipient());// 构造一个消亡通知对象bool result = object->AddDeathRecipient(deathRecipient); // 注册消亡通知result = object->RemoveDeathRecipient(deathRecipient); // 移除消亡通知  JS侧接口 接口名  返回值类型  功能描述    addDeathRecipient  boolean  注册用于接收远程对象消亡通知的回调，增加proxy对象上的消亡通知。   removeDeathRecipient  boolean  注销用于接收远程对象消亡通知的回调。   onRemoteDied  void  在成功添加死亡通知订阅后，当远端对象死亡时，将自动调用本方法。      参考代码已复制import FA from "@ohos.ability.featureAbility";let proxy;let connect = {    onConnect: function(elementName, remoteProxy) {        console.log("RpcClient: js onConnect called.");        proxy = remoteProxy;    },    onDisconnect: function(elementName) {        console.log("RpcClient: onDisconnect");    },    onFailed: function() {        console.log("RpcClient: onFailed");    }};let want = {    "bundleName": "com.ohos.server",    "abilityName": "com.ohos.server.MainAbility",};FA.connectAbility(want, connect);class MyDeathRecipient {    onRemoteDied() {        console.log("server died");    }}let deathRecipient = new MyDeathRecipient();proxy.addDeathRecipient(deathRecipient, 0);proxy.removeDeathRecipient(deathRecipient, 0);  Stub感知Proxy消亡（匿名Stub的使用）正向的消亡通知是Proxy感知Stub的状态，若想达到反向的死消亡通知，即Stub感知Proxy的状态，可以巧妙的利用正向消亡通知。如两个进程A（原Stub所在进程）和B（原Proxy所在进程），进程B在获取到进程A的Proxy对象后，在B进程新建一个匿名Stub对象（匿名指未向SAMgr注册），可称之为回调Stub，再通过SendRequest接口将回调Stub传给进程A的原Stub。这样一来，进程A便获取到了进程B的回调Proxy。当进程B消亡或B所在设备离开组网时，回调Stub会消亡，回调Proxy会感知，进而通知给原Stub，便实现了反向消亡通知。 注意： 反向死亡通知仅限设备内跨进程通信使用，不可用于跨设备。 当匿名Stub对象没有被任何一个Proxy指向的时候，内核会自动回收。  参考代码已复制//Proxyint TestAbilityProxy::TestAnonymousStub(){    MessageOption option;    MessageParcel dataParcel, replyParcel;    dataParcel.UpdateDataVersion(Remote());    dataParcel.WriteRemoteObject(new TestAbilityStub());    int error = Remote()->SendRequest(TRANS_ID_REVERSED_MONITOR,dataParcel, replyParcel, option);    int result = (error == ERR_NONE) ? replyParcel.ReadInt32() : -1;    return result;}
//Stub
int TestAbilityStub::OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option){    switch (code) {        case TRANS_ID_REVERSED_MONITOR: {            sptr<IRemoteObject> obj = data.ReadRemoteObject();            if (obj == nullptr) {                reply.WriteInt32(ERR_NULL_OBJECT);                return ERR_NULL_OBJECT;            }            bool result = obj->AddDeathRecipient(new TestDeathRecipient());            result ? reply.WriteInt32(ERR_NONE) : reply.WriteInt32(-1);            break;        }        default:            break;    }    return ERR_NONE;}   上一篇 IPC与RPC通信开发指导 下一篇 电话服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用TaskPool处理同步任务使用Worker处理关联的同步任务同步任务开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  同步任务是指在多个线程之间协调执行的任务，其目的是确保多个任务按照一定的顺序和规则执行，例如使用锁来防止数据竞争。 同步任务的实现需要考虑多个线程之间的协作和同步，以确保数据的正确性和程序的正确执行。 由于TaskPool偏向于单个独立的任务，因此当各个同步任务之间相对独立时推荐使用TaskPool，例如一系列导入的静态方法，或者单例实现的方法。如果同步任务之间有关联性，则需要使用Worker，例如无法单例创建的类对象实现的方法。  使用TaskPool处理同步任务 当调度独立的同步任务，或者一系列同步任务为静态方法实现，或者可以通过单例构造唯一的句柄或类对象，可在不同任务池之间使用时，推荐使用TaskPool。  定义并发函数，内部调用同步方法。 创建任务，并通过TaskPool执行，再对异步结果进行操作。创建Task，通过execute()执行同步任务。  模拟一个包含同步调用的单实例类。 已复制// Handle.ts 代码export default class Handle {  static getInstance() {    // 返回单例对象  }
  static syncGet() {    // 同步Get方法    return;  }
  static syncSet(num: number) {    // 同步Set方法    return;  }} 业务使用TaskPool调用相关同步方法的代码。 已复制// Index.ets代码import taskpool from '@ohos.taskpool';import Handle from './Handle'; // 返回静态句柄
// 步骤1: 定义并发函数，内部调用同步方法@Concurrentfunction func(num: number) {  // 调用静态类对象中实现的同步等待调用  Handle.syncSet(num);  // 或者调用单例对象中实现的同步等待调用  Handle.getInstance().syncGet();  return true;}
// 步骤2: 创建任务并执行async function asyncGet() {  // 创建task并传入函数func  let task = new taskpool.Task(func, 1);  // 执行task任务，获取结果res  let res = await taskpool.execute(task);  // 对同步逻辑后的结果进行操作  console.info(String(res));}
@Entry@Componentstruct Index {  @State message: string = 'Hello World';
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            // 步骤3: 执行并发操作            asyncGet();          })      }      .width('100%')      .height('100%')    }  }}   使用Worker处理关联的同步任务 当一系列同步任务需要使用同一个句柄调度，或者需要依赖某个类对象调度，无法在不同任务池之间共享时，需要使用Worker。  在主线程中创建Worker对象，同时接收Worker线程发送回来的消息。 已复制import worker from '@ohos.worker';
@Entry@Componentstruct Index {  @State message: string = 'Hello World';
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            let w = new worker.ThreadWorker('entry/ets/workers/MyWorker.ts');            w.onmessage = function (d) {              // 接收Worker子线程的结果            }            w.onerror = function (d) {              // 接收Worker子线程的错误信息            }            // 向Worker子线程发送Set消息            w.postMessage({'type': 0, 'data': 'data'})            // 向Worker子线程发送Get消息            w.postMessage({'type': 1})            // ...            // 根据实际业务，选择时机以销毁线程            w.terminate()          })      }      .width('100%')    }    .height('100%')  }} 在Worker线程中绑定Worker对象，同时处理同步任务逻辑。 已复制// handle.ts代码export default class Handle {  syncGet() {    return;  }
  syncSet(num: number) {    return;  }}
// MyWorker.ts代码import worker, { ThreadWorkerGlobalScope, MessageEvents } from '@ohos.worker';import Handle from './handle.ts'  // 返回句柄
var workerPort : ThreadWorkerGlobalScope = worker.workerPort;
// 无法传输的句柄，所有操作依赖此句柄var handler = new Handle()
// Worker线程的onmessage逻辑workerPort.onmessage = function(e : MessageEvents) {  switch (e.data.type) {    case 0:      handler.syncSet(e.data.data);      workerPort.postMessage('success set');    case 1:      handler.syncGet();      workerPort.postMessage('success get');  }}    上一篇 I/O密集型任务开发指导 下一篇 容器类库 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。实现特点对比适用场景对比TaskPool运作机制Worker运作机制TaskPool注意事项Worker注意事项文件路径注意事项生命周期注意事项TaskPool和Worker的对比 更新时间: 2024-04-01 19:24 毫无帮助帮助不大一般很好非常好
分享
  TaskPool（任务池）和Worker的作用是为应用程序提供一个多线程的运行环境，用于处理耗时的计算任务或其他密集型任务。可以有效地避免这些任务阻塞主线程，从而最大化系统的利用率，降低整体资源消耗，并提高系统的整体性能。 本文将从实现特点和适用场景两个方面来进行TaskPool与Worker的比较，同时提供了各自运作机制和注意事项的相关说明。  实现特点对比 表1 TaskPool和Worker的实现特点对比     实现 TaskPool Worker    内存模型 线程间隔离，内存不共享。 线程间隔离，内存不共享。   参数传递机制 采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。 支持ArrayBuffer转移和SharedArrayBuffer共享。 采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。 支持ArrayBuffer转移和SharedArrayBuffer共享。   参数传递 直接传递，无需封装，默认进行transfer。 消息对象唯一参数，需要自己封装。   方法调用 直接将方法传入调用。 在Worker线程中进行消息解析并调用对应方法。   返回值 异步调用后默认返回。 主动发送消息，需在onmessage解析赋值。   生命周期 TaskPool自行管理生命周期，无需关心任务负载高低。 开发者自行管理Worker的数量及生命周期。   任务池个数上限 自动管理，无需配置。 同个进程下，最多支持同时开启8个Worker线程。   任务执行时长上限 无限制。 无限制。   设置任务的优先级 不支持。 不支持。   执行任务的取消 支持取消任务队列中等待的任务。 不支持。      适用场景对比 TaskPool和Worker均支持多线程并发能力。TaskPool偏向独立任务维度，该任务在线程中执行，无需关注线程的生命周期；而Worker偏向线程的维度，支持长时间占据线程执行，需要主动管理线程生命周期。 常见的一些开发场景及适用具体说明如下：  有关联的一系列同步任务。例如在一些需要创建、使用句柄的场景中，句柄创建每次都是不同的，该句柄需永久保存，保证使用该句柄进行操作，需要使用Worker。 需要频繁取消的任务。例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。 大量或者调度点较分散的任务。例如大型应用的多个模块包含多个耗时任务，不方便使用8个Worker去做负载管理，推荐采用TaskPool。    TaskPool运作机制  图1 TaskPool运作机制示意图  TaskPool支持开发者在主线程封装任务抛给任务队列，系统选择合适的工作线程，进行任务的分发及执行，再将结果返回给主线程。接口直观易用，支持任务的执行、取消。工作线程数量上限为4。   Worker运作机制 图2 Worker运作机制示意图  创建Worker的线程称为宿主线程（不一定是主线程，工作线程也支持创建Worker子线程），Worker自身的线程称为Worker子线程（或Actor线程、工作线程）。每个Worker子线程与宿主线程拥有独立的实例，包含基础设施、对象、代码段等。Worker子线程和宿主线程之间的通信是基于消息传递的，Worker通过序列化机制与宿主线程之间相互通信，完成命令及数据交互。   TaskPool注意事项  实现任务的函数需要使用装饰器@Concurrent标注，且仅支持在.ets文件中使用。 实现任务的函数入参需满足序列化支持的类型，详情请参见数据传输对象。 由于不同线程中上下文对象是不同的，因此TaskPool工作线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。 序列化传输的数据量大小限制为16MB。    Worker注意事项  创建Worker时，传入的Worker.ts路径在不同版本有不同的规则，详情请参见文件路径注意事项。 Worker创建后需要手动管理生命周期，且最多同时运行的Worker子线程数量为8个，详情请参见生命周期注意事项。 Ability类型的Module支持使用Worker，Library类型的Module不支持使用Worker。 创建Worker不支持使用其他Module的Worker.ts文件，即不支持跨模块调用Worker。 由于不同线程中上下文对象是不同的，因此Worker线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。 序列化传输的数据量大小限制为16MB。    文件路径注意事项 当使用Worker模块具体功能时，均需先构造Worker实例对象，其构造函数与API版本相关。 已复制// 导入模块import worker from '@ohos.worker';
// API 9及之后版本使用：const worker1 = new worker.ThreadWorker(scriptURL);// API 8及之前版本使用：const worker1 = new worker.Worker(scriptURL); 构造函数需要传入Worker的路径（scriptURL），Worker文件存放位置默认路径为Worker文件所在目录与pages目录属于同级。 Stage模型 构造函数中的scriptURL示例如下： 已复制// 导入模块import worker from '@ohos.worker';
// 写法一// Stage模型-目录同级（entry模块下，workers目录与pages目录同级）const worker1 = new worker.ThreadWorker('entry/ets/workers/MyWorker.ts', {name:"first worker in Stage model"});// Stage模型-目录不同级（entry模块下，workers目录是pages目录的子目录）const worker2 = new worker.ThreadWorker('entry/ets/pages/workers/MyWorker.ts');
// 写法二// Stage模型-目录同级（entry模块下，workers目录与pages目录同级），假设bundlename是com.example.workerdemoconst worker3 = new worker.ThreadWorker('@bundle:com.example.workerdemo/entry/ets/workers/worker');// Stage模型-目录不同级（entry模块下，workers目录是pages目录的子目录），假设bundlename是com.example.workerdemoconst worker4 = new worker.ThreadWorker('@bundle:com.example.workerdemo/entry/ets/pages/workers/worker');  基于Stage模型工程目录结构，写法一的路径含义：  entry：module.json5文件中module的name属性对应值。 ets：用于存放ets源码，固定目录。 workers/MyWorker.ts：worker源文件在ets目录下的路径。  基于Stage模型工程目录结构，写法二的路径含义：  @bundle：固定标签。 bundlename：当前应用包名。 entryname：module.json5文件中module的name属性对应值。 ets：用于存放ets源码，固定目录。 workerdir/workerfile：worker源文件在ets目录下的路径，可不带文件后缀名。   FA模型 构造函数中的scriptURL示例如下： 已复制// 导入模块import worker from '@ohos.worker';
// FA模型-目录同级（entry模块下，workers目录与pages目录同级）const worker1 = new worker.ThreadWorker('workers/worker.js', {name:'first worker in FA model'});// FA模型-目录不同级（entry模块下，workers目录与pages目录的父目录同级）const worker2 = new worker.ThreadWorker('../workers/worker.js');   生命周期注意事项  Worker的创建和销毁耗费性能，建议开发者合理管理已创建的Worker并重复使用。Worker空闲时也会一直运行，因此当不需要Worker时，可以调用terminate()接口或parentPort.close()方法主动销毁Worker。若Worker处于已销毁或正在销毁等非运行状态时，调用其功能接口，会抛出相应的错误。 Worker存在数量限制，支持最多同时存在8个Worker。  在API version 8及之前的版本，当Worker数量超出限制时，会抛出“Too many workers, the number of workers exceeds the maximum.”错误。 从API version 9开始，当Worker数量超出限制时，会抛出“Worker initialization failure, the number of workers exceeds the maximum.”错误。     上一篇 多线程并发概述 下一篇 @Concurrent装饰器：校验并发函数 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。约束与限制电话服务开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  电话服务系统提供了一系列的API用于拨打电话、获取无线蜂窝网络和SIM卡相关信息。 应用可以通过调用API来获取当前注册网络名称、网络服务状态、信号强度以及SIM卡的相关信息，具体可参考获取当前蜂窝网络信号信息开发指导。 直接拨打电话需要系统权限ohos.permission.PLACE_CALL，建议应用使用makeCall()，跳转到拨号界面，并显示拨号的号码，具体可参考跳转拨号界面开发指导。  约束与限制 搭载设备需要支持以下硬件： 可以进行独立蜂窝通信的Modem以及SIM卡。   上一篇 电话服务 下一篇 跳转拨号界面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发步骤发布基础类型通知 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  基础类型通知主要应用于发送短信息、提示信息、广告推送等，支持普通文本类型、长文本类型、多行文本类型和图片类型。 表1 基础类型通知中的内容分类     类型 描述    NOTIFICATION_CONTENT_BASIC_TEXT 普通文本类型。   NOTIFICATION_CONTENT_LONG_TEXT 长文本类型。   NOTIFICATION_CONTENT_MULTILINE 多行文本类型。   NOTIFICATION_CONTENT_PICTURE 图片类型。    目前系统仅通知栏订阅了通知，将通知显示在通知栏里。基础类型通知呈现效果示意图如下所示。 
说明
 根据设计样式的不同，通知的实际显示效果可能有所差异。本文中所涉及的通知效果图仅供参考，请以实际运行结果为准。 
 图1 基础类型通知呈现效果示意图   接口说明 通知发布接口如下表所示，不同发布类型通知由NotificationRequest的字段携带不同的信息。     接口名 描述    publish(request: NotificationRequest, callback: AsyncCallback<void>): void 发布通知。   cancel(id: number, label: string, callback: AsyncCallback<void>): void 取消指定的通知。   cancelAll(callback: AsyncCallback<void>): void; 取消所有该应用发布的通知。      开发步骤  导入模块。 已复制import NotificationManager from '@ohos.notificationManager'; 构造NotificationRequest对象，并发布通知。  普通文本类型通知由标题、文本内容和附加信息三个字段组成，其中标题和文本内容是必填字段。 已复制let notificationRequest = {  id: 1,  content: {    contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, // 普通文本类型通知    normal: {      title: 'test_title',      text: 'test_text',      additionalText: 'test_additionalText',    }  }}
NotificationManager.publish(notificationRequest, (err) => {    if (err) {        console.error(`[ANS] failed to publish, error[${err}]`);        return;    }    console.info(`[ANS] publish success`);}); 运行效果如下图所示。  长文本类型通知继承了普通文本类型的字段，同时新增了长文本内容、内容概要和通知展开时的标题。通知默认显示与普通文本相同，展开后，标题显示为展开后标题内容，内容为长文本内容。 已复制let notificationRequest = {  id: 1,  content: {    contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_LONG_TEXT, // 长文本类型通知    longText: {      title: 'test_title',      text: 'test_text',      additionalText: 'test_additionalText',      longText: 'test_longText',      briefText: 'test_briefText',      expandedTitle: 'test_expandedTitle',    }  }}
// 发布通知NotificationManager.publish(notificationRequest, (err) => {    if (err) {        console.error(`[ANS] failed to publish, error[${err}]`);        return;    }    console.info(`[ANS] publish success`);}); 运行效果如下图所示。  多行文本类型通知继承了普通文本类型的字段，同时新增了多行文本内容、内容概要和通知展开时的标题。通知默认显示与普通文本相同，展开后，标题显示为展开后标题内容，多行文本内容多行显示。 已复制let notificationRequest = {  id: 1,  content: {    contentType: NotificationManager.ContentType.NOTIFICATION_CONTENT_MULTILINE, // 多行文本类型通知    multiLine: {      title: 'test_title',      text: 'test_text',      briefText: 'test_briefText',      longTitle: 'test_longTitle',      lines: ['line_01', 'line_02', 'line_03', 'line_04'],    }  }}
// 发布通知NotificationManager.publish(notificationRequest, (err) => {  if (err) {    console.error(`[ANS] failed to publish, error[${err}]`);    return;  }  console.info(`[ANS] publish success`);}); 运行效果如下图所示。  图片类型通知继承了普通文本类型的字段，同时新增了图片内容、内容概要和通知展开时的标题，图片内容为PixelMap型对象，其大小不能超过2M。 已复制let imagePixelMap: PixelMap = undefined; // 需要获取图片PixelMap信息let notificationRequest: notificationManager.NotificationRequest = {  id: 1,  content: {    contentType: notificationManager.ContentType.NOTIFICATION_CONTENT_PICTURE,    picture: {      title: 'test_title',      text: 'test_text',      additionalText: 'test_additionalText',      briefText: 'test_briefText',      expandedTitle: 'test_expandedTitle',      picture: imagePixelMap    }  }};
// 发布通知notificationManager.publish(notificationRequest, (err) => {  if (err) {    console.error(`Failed to publish notification. Code is ${err.code}, message is ${err.message}`);    return;  }  console.info('Succeeded in publishing notification.');});
 运行效果如下图所示。      上一篇 发布通知 下一篇 发布进度条类型通知 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。线程模型概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 FA模型下的线程主要有如下三类： 主线程 负责管理其他线程 Ability线程 每个Ability一个线程输入事件分发UI绘制应用代码回调（事件处理，生命周期）接收Worker发送的消息 Worker线程 执行耗时操作  基于HarmonyOS的线程模型，不同的业务功能运行在不同的线程上，业务功能的交互就需要线程间通信。线程间通信目前主要有Emitter和Worker两种方式，其中Emitter主要适用于线程间的事件同步， Worker主要用于新开一个线程执行耗时任务。 
说明
FA模型每个ability都有一个独立的线程，Emiter可用于Ability线程内、Ability线程间、Ability线程与Worker线程的事件同步。 
  上一篇 线程模型 下一篇 线程间通信 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。线程模型概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS应用中每个进程都会有一个主线程，主线程有如下职责： 执行UI绘制；管理主线程的ArkTS引擎实例，使多个UIAbility组件能够运行在其之上；管理其他线程（例如Worker线程）的ArkTS引擎实例，例如启动和终止其他线程；分发交互事件；处理应用代码的回调，包括事件处理和生命周期管理；接收Worker线程发送的消息； 除主线程外，还有一类与主线程并行的独立线程Worker，主要用于执行耗时操作，但不可以直接操作UI。Worker线程在主线程中创建，与主线程相互独立。最多可以创建8个Worker：  基于HarmonyOS的线程模型，不同的业务功能运行在不同的线程上，业务功能的交互就需要线程间通信。线程间通信目前主要有Emitter和Worker两种方式，其中Emitter主要适用于线程间的事件同步， Worker主要用于新开一个线程执行耗时任务。 
说明
Stage模型只提供了主线程和Worker线程，Emitter主要用于主线程和Worker线程、Worker线程和Worker线程之间的事件同步。UIAbility组件与UI均在主线程中，他们之间的数据同步请参见UIAbility组件与UI的数据同步。执行hdc shell命令，进入设备的shell命令行。在shell命令行中，执行ps -p <pid> -T命令，可以查看指定应用进程的线程信息。其中，<pid>为需要指定的应用进程的进程ID。 
  上一篇 线程模型 下一篇 使用Emitter进行线程间通信 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件操作步骤C/C++时光调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 针对C/C++开发场景，DevEco Studio在提供基础调试能力的基础上，同时提供时光调试（历史执行模式）能力，帮助开发者更好地理解代码和更迅速定位问题。 时光调试（历史执行模式）是指在调试过程中可以回退到历史行和历史断点，查看相关变量信息。支持的调试操作为： 进入/退出时光调试模式反向Step Over回退到历史行反向Resume执行到历史断点在程序执行历史的记录点上查看全局、静态、局部变量值 前提条件在File > Settings > Build,Execution,Deployment > Debugger > C++ Debugger设置界面，勾选Enable time travel debug开启C++时光调试开关。   操作步骤设置断点，进入调试模式。在Debug页签的调试控制按钮中，操作时光调试相关按钮。 其中，操作按钮说明如下： /：进入/退出时光调试模式。：切换当前高亮行到下一个历史断点，并显示断点相关信息。：切换当前高亮行到上一个历史断点，并显示断点相关信息。：切换当前高亮行到下一个历史行，并显示历史行相关信息。：切换当前高亮行到上一个历史行，并显示历史行相关信息。    上一篇 Release应用堆栈解析 下一篇 Hot Reload 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述约束与限制接口说明开发步骤短时任务 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 应用退至后台一小段时间后，应用进程会被挂起，无法执行对应的任务。如果应用在后台仍需要执行耗时不长的任务，如状态保存等，可以通过本文申请短时任务，扩展应用在后台的运行时间。   约束与限制  申请时机：应用需要在前台或退至后台5秒内，申请短时任务，否则会申请失败。 数量限制：一个应用同一时刻最多申请3个短时任务。以图1为例，在①②③时间段内的任意时刻，应用申请了2个短时任务；在④时间段内的任意时刻，应用申请了1个短时任务。 配额机制：一个应用会有一定的短时任务配额（根据系统状态和用户习惯调整），单日（24小时内）配额默认为10分钟，单次配额最大为3分钟，低电量时单次配额默认为1分钟，配额消耗完后不允许再申请短时任务。同时，系统提供获取对应短时任务剩余时间的查询接口，用以查询本次短时任务剩余时间，以确认是否继续运行其他业务。 配额计算：仅当应用在后台时，对应用下的短时任务计时；同一个应用下的同一个时间段的短时任务，不重复计时。以下图为例：应用有两个短时任务A和B，在前台时申请短时任务A，应用退至后台后开始计时为①，应用进入前台②后不计时，再次进入后台③后开始计时，短时任务A结束后，由于阶段④仍然有短时任务B，所以该阶段继续计时。因此，在这个过程中，该应用短时任务总耗时为①+③+④。 图1 短时任务配额计算原理图  
说明
 任务完成后，应用需主动取消短时任务，否则会影响应用当日短时任务的剩余配额。 申请短时任务一小段时间后，任务还未执行完，系统电量转入低电量，已申请的时长配额不会缩短。 应用进程被销毁时，未及时调用接口取消后台任务，不会继续消耗配额。 
 超时：短时任务即将超时时，系统会回调应用，应用需要取消短时任务。如果超时不取消，系统会终止对应的应用进程。    接口说明 表1 主要接口 以下是短时任务开发使用的主要接口，更多接口及使用方式请见后台任务管理。     接口名 描述    requestSuspendDelay(reason: string, callback: Callback<void>): DelaySuspendInfo 申请短时任务。   getRemainingDelayTime(requestId: number): Promise<number> 获取对应短时任务的剩余时间。   cancelSuspendDelay(requestId: number): void 取消短时任务。      开发步骤  导入模块。 已复制import backgroundTaskManager from '@ohos.resourceschedule.backgroundTaskManager';import { BusinessError } from '@ohos.base'; 申请短时任务并实现回调。 已复制let id: number;         // 申请短时任务IDlet delayTime: number;  // 本次申请短时任务的剩余时间
// 申请短时任务function requestSuspendDelay() {  let myReason = 'test requestSuspendDelay';   // 申请原因。每调用一次申请接口就会有一个新id，短时任务的数量会增加一个    let delayInfo = backgroundTaskManager.requestSuspendDelay(myReason, () => {    // 回调函数。应用申请的短时任务即将超时，通过此函数回调应用，执行一些清理和标注工作，并取消短时任务    console.info('suspend delay task will timeout');    backgroundTaskManager.cancelSuspendDelay(id);  })  id = delayInfo.requestId;  delayTime = delayInfo.actualDelayTime;} 获取短时任务剩余时间。查询本次短时任务的剩余时间，用以判断是否继续运行其他业务，例如应用有两个小任务，在执行完第一个小任务后，可以判断本次短时任务是否还有剩余时间来决定是否执行第二个小任务。 已复制let id: number; // 申请短时任务ID
async function getRemainingDelayTime() {  backgroundTaskManager.getRemainingDelayTime(id).then((res: number) => {    console.info('Succeeded in getting remaining delay time.');  }).catch((err: BusinessError) => {    console.error(`Failed to get remaining delay time. Code: ${err.code}, message: ${err.message}`);  })} 取消短时任务。 已复制let id: number; // 申请短时任务ID
function cancelSuspendDelay() {  backgroundTaskManager.cancelSuspendDelay(id);}    上一篇 后台任务总体概述 下一篇 长时任务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基于ArkTS的声明式开发范式 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    UI开发（ArkTS声明式开发范式）概述  开发布局  添加组件  设置页面路由和组件导航  显示图形  使用动画  支持交互事件  性能提升的推荐方法   上一篇 方舟开发框架（ArkUI）概述 下一篇 UI开发（ArkTS声明式开发范式）概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用程序包多HAP机制 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    多HAP机制设计目标  多HAP构建视图  多HAP的开发调试与发布部署流程  多HAP使用规则  多HAP运行机制及数据通信方式   上一篇 FA模型应用程序包结构 下一篇 多HAP机制设计目标 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。属性样式动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在关键帧（Keyframes）中动态设置父组件的width和height，实现组件变大缩小。子组件设置scale属性使父子组件同时缩放，再设置opacity实现父子组件的显示与隐藏。 已复制<!-- xxx.hml --><div class="container">  <div class="fade">    <text>fading away</text>  </div>  <div class="bigger">    <text>getting bigger</text>  </div></div> 已复制/* xxx.css */.container {  background-color:#F1F3F5;  display: flex;  justify-content: center;  align-items: center;  flex-direction: column;  width: 100%;  height: 100%;}.fade {  width: 30%;  height: 200px;  left: 35%;  top: 25%;  position: absolute;  animation: 2s change infinite friction;}.bigger {  width: 20%;  height: 100px;  background-color: blue;  animation: 2s change1 infinite linear-out-slow-in;}text {  width: 100%;  height: 100%;  text-align: center;  color: white;  font-size: 35px;  animation: 2s change2 infinite linear-out-slow-in;}/* 颜色变化 */@keyframes change{  from {    background-color: #f76160;    opacity: 1;  }  to {    background-color: #09ba07;    opacity: 0;  }}/* 父组件大小变化 */@keyframes change1 {  0% {    width: 20%;    height: 100px;  }  100% {    width: 80%;    height: 200px;  }}/* 子组件文字缩放 */@keyframes change2 {  0% {    transform: scale(0);  }  100% {    transform: scale(1.5);  }}  
说明
 animation取值不区分先后，duration （动画执行时间）/ delay （动画延迟执行时间）按照出现的先后顺序解析。 必须设置animation-duration样式，否则时长为0则不会有动画效果。当设置animation-fill-mode属性为forwards时，组件直接展示最后一帧的样式。  
  上一篇 CSS动画 下一篇 transform样式动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。