您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。background-position样式动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 通过改变background-position属性（第一个值为X轴的位置，第二个值为Y轴的位置）移动背景图片位置，若背景图位置超出组件则超出部分的背景图不显示。 已复制<!-- xxx.hml --><div class="container">  <div class="content"></div>  <div class="content1"></div></div> 已复制/* xxx.css */.container {  height: 100%;  background-color:#F1F3F5;  display: flex;  flex-direction: column;  justify-content: center;  align-items: center;  width: 100%;}.content{  width: 400px;  height: 400px;  /* 不建议图片长宽比为1:1 */  background-image: url('common/images/bg-tv.jpg');  background-size: 100%;  background-repeat: no-repeat;  animation: change 3s infinite;  border: 1px solid black;}.content1{  margin-top:50px;  width: 400px;  height: 400px;  background-image: url('common/images/bg-tv.jpg');  background-size: 50%;  background-repeat: no-repeat;  animation: change1 5s infinite;  border: 1px solid black;}/* 背景图片移动出组件 */@keyframes change{  0%{    background-position:0px top;  }  25%{    background-position:400px top;  }  50%{    background-position:0px top;  }  75%{    background-position:0px bottom;  }  100%{    background-position:0px top;  }}/* 背景图片在组件内移动 */@keyframes change1{  0%{    background-position:left top;  }  25%{    background-position:50% 50%;  }  50%{    background-position:right bottom;  }  100%{    background-position:left top;;  }} 
说明
background-position仅支持背景图片的移动，不支持背景颜色（background-color）。 
   上一篇 transform样式动画 下一篇 svg动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。获取动画对象设置动画参数组件动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在组件上创建和运行动画的快捷方式。具体用法请参考通用方法。  获取动画对象 通过调用animate方法获得animation对象，animation对象支持动画属性、动画方法和动画事件。 已复制<!-- xxx.hml --><div class="container">  <div id="content" class="box" onclick="Show"></div></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  width: 100%;}.box{  width: 200px;  height: 200px;  background-color: #ff0000;  margin-top: 30px;} 已复制/* xxx.js */export default {  data: {    animation: '',  },  onInit() {  },  onShow() {    var options = {      duration: 1500,    };    var frames = [      {        width:200,height:200,      },      {        width:300,height:300,      }    ];    this.animation = this.$element('content').animate(frames, options);  //获取动画对象  },  Show() {       this.animation.play();  }}  
说明
  使用animate方法时必须传入Keyframes和Options参数。 多次调用animate方法时，采用replace策略，即最后一次调用时传入的参数生效。  
   设置动画参数 在获取动画对象后，通过设置参数Keyframes设置动画在组件上的样式。 已复制<!-- xxx.hml --><div class="container">   <div id="content" class="box" onclick="Show"></div></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  width: 100%;  height: 100%;}.box{  width: 200px;  height: 200px;  background-color: #ff0000;  margin-top: 30px;} 已复制/* xxx.js */export default {  data: {    animation: '',    keyframes:{},    options:{}  },  onInit() {    this.options = {      duration: 4000,    }    this.keyframes = [    {      transform: {        translate: '-120px -0px',           scale: 1,                rotate: 0        },           transformOrigin: '100px 100px',          offset: 0.0,         width: 200,          height: 200         },       {        transform: {                translate: '120px 0px',               scale: 1.5,               rotate: 90             },          transformOrigin: '100px 100px',          offset: 1.0,          width: 300,          height: 300         }        ]  },  Show() {    this.animation = this.$element('content').animate(this.keyframes, this.options)    this.animation.play()  }}  
说明
  translate、scale和rtotate的先后顺序会影响动画效果。 transformOrigin只对scale和rtotate起作用。  
 在获取动画对象后，通过设置参数Options来设置动画的属性。 已复制<!-- xxx.hml --><div class="container">   <div id="content" class="box" onclick="Show"></div></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  width: 100%;}.box{  width: 200px;  height: 200px;  background-color: #ff0000;  margin-top: 30px;} 已复制/* xxx.js */export default {  data: {    animation: '',  },  onInit() {  },  onShow() {    var options = {              duration: 1500,              easing: 'ease-in',              delay: 5,              iterations: 2,              direction: 'normal',        };    var frames = [      {        transform: {          translate: '-150px -0px'        }      },      {        transform: {          translate: '150px 0px'        }      }    ];    this.animation = this.$element('content').animate(frames, options);  },  Show() {    this.animation.play();  }}  
说明
 direction：指定动画的播放模式。 normal： 动画正向循环播放。 reverse： 动画反向循环播放。 alternate：动画交替循环播放，奇数次正向播放，偶数次反向播放。 alternate-reverse：动画反向交替循环播放，奇数次反向播放，偶数次正向播放。 
   上一篇 JS动画 下一篇 插值器动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建动画对象添加动画事件和调用接口动画动效 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  通过设置插值器来实现动画效果。 
说明
 从API Version 6 开始支持。 
  创建动画对象 通过createAnimator创建一个动画对象，通过设置参数options来设置动画的属性。 已复制<!-- xxx.hml --><div class="container">  <div style="width: 300px;height: 300px;margin-top: 100px;background: linear-gradient(pink, purple);transform: translate({{translateVal}});">  </div>  <div class="row">    <button type="capsule" value="play" onclick="playAnimation"></button>  </div></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  justify-content: center;}button{  width: 200px;}.row{  width: 65%;  height: 100px;  align-items: center;  justify-content: space-between;  margin-top: 50px;  margin-left: 260px;} 已复制// xxx.jsimport animator from '@ohos.animator';export default {  data: {    translateVal: 0,    animation: null  },  onInit() {},  onShow(){    var options = {      duration: 3000,      easing:"friction",      delay:"1000",      fill: 'forwards',      direction:'alternate',      iterations: 2,      begin: 0,      end: 180    };//设置参数    this.animation = animator.createAnimator(options)//创建动画  },  playAnimation() {    var _this = this;    this.animation.onframe = function(value) {      _this.translateVal= value    };    this.animation.play();  }}  
说明
  使用createAnimator创建动画对象时必须传入options参数。 begin插值起点，不设置时默认为0。 end插值终点，不设置时默认为1。  
   添加动画事件和调用接口 animator支持事件和接口，可以通过添加frame、cancel、repeat、finish事件和调用update、play、pause、cancel、reverse、finish接口自定义动画效果。animator支持的事件和接口具体见动画中的createAnimator。 已复制<!-- xxx.hml --><div style="flex-direction: column;align-items: center;width: 100%;height: 100%;">  <div style="width:200px;height: 200px;margin-top: 100px;background: linear-gradient(#b30d29, #dcac1b);  transform: scale({{scaleVal}});"></div>  <div style="width: {{DivWidth}};height: {{DivHeight}};margin-top: 200px;  background: linear-gradient(pink, purple);margin-top: 200px;transform:translateY({{translateVal}});">  </div>  <div class="row">    <button type="capsule" value="play" onclick="playAnimation"></button>    <button type="capsule" value="update" onclick="updateAnimation"></button>  </div>  <div class="row1">    <button type="capsule" value="pause" onclick="pauseAnimation"></button>    <button type="capsule" value="finish" onclick="finishAnimation"></button>  </div>  <div class="row2">    <button type="capsule" value="cancel" onclick="cancelAnimation"></button>    <button type="capsule" value="reverse" onclick="reverseAnimation"></button>  </div></div> 已复制/* xxx.css */button{  width: 200px;}.row{  width: 65%;  height: 100px;  align-items: center;  justify-content: space-between;  margin-top: 150px;  position: fixed;  top: 52%;  left: 120px;}.row1{  width: 65%;  height: 100px;  align-items: center;  justify-content: space-between;  margin-top: 120px;  position: fixed;  top: 65%;  left: 120px;}.row2{  width: 65%;  height: 100px;  align-items: center;  justify-content: space-between;  margin-top: 100px;  position: fixed;  top: 75%;  left: 120px;} 已复制// xxx.jsimport animator from '@ohos.animator';import promptAction from '@ohos.promptAction';export default {  data: {    scaleVal:1,    DivWidth:200,    DivHeight:200,    translateVal:0,    animation: null  },  onInit() {    var options = {      duration: 3000,      fill: 'forwards',      begin: 200,      end: 270    };    this.animation = animator.createAnimator(options);  },  onShow() {    var _this= this;    //添加动画重放事件    this.animation.onrepeat = function() {      promptAction.showToast({        message: 'repeat'      });      var repeatoptions = {        duration: 2000,        iterations: 1,         direction: 'alternate',         begin: 180,         end: 240       };        _this.animation.update(repeatoptions);        _this.animation.play();      };  },  playAnimation() {    var _this= this;    //添加动画逐帧插值回调事件    this.animation.onframe = function(value) {      _this. scaleVal= value/150,      _this.DivWidth = value,      _this.DivHeight = value,      _this.translateVal = value-180    };    this.animation.play();  },  updateAnimation() {    var newoptions = {      duration: 5000,      iterations: 2,      begin: 120,      end: 180    };    this.animation.update(newoptions);    this.animation.play();//调用动画播放接口  },  pauseAnimation() {    this.animation.pause();//调用动画暂停接口  },  finishAnimation() {    var _this= this;   //添加动画完成事件    this.animation.onfinish = function() {      promptAction.showToast({        message: 'finish'      })    };    this.animation.finish(); //调用动画完成接口  },  cancelAnimation() {    this.animation.cancel(); //调用动画取消接口  },  reverseAnimation() {    this.animation.reverse(); //调用动画倒放接口  }}  
说明
 在调用update接口的过程中可以使用这个接口更新动画参数，入参与createAnimator一致。 
   上一篇 插值器动画 下一篇 动画帧 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。请求动画帧取消动画帧动画帧 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  请求动画帧请求动画帧时通过requestAnimationFrame函数逐帧回调，在调用该函数时传入一个回调函数。 runframe在调用requestAnimationFrame时传入带有timestamp参数的回调函数step，将step中的timestamp赋予起始的startTime。当timestamp与startTime的差值小于规定的时间时将再次调用requestAnimationFrame，最终动画将会停止。 已复制<!-- xxx.hml --><div class="container">  <tabs onchange="changecontent">    <tab-content>      <div class="container">        <stack style="width: 300px;height: 300px;margin-top: 100px;margin-bottom: 100px;">          <canvas id="mycanvas" style="width: 100%;height: 100%;background-color: coral;">          </canvas>          <div style="width: 50px;height: 50px;border-radius: 25px;background-color: indigo;position: absolute;left: {{left}};top: {{top}};">          </div>        </stack>        <button type="capsule" value="play" onclick="runframe"></button>      </div>    </tab-content>  </tabs></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  width: 100%;  height: 100%;}button{  width: 300px;} 已复制// xxx.jsexport default {  data: {    timer: null,    left: 0,    top: 0,    flag: true,    animation: null,    startTime: 0,  },  onShow() {    var test = this.$element("mycanvas");    var ctx = test.getContext("2d");    ctx.beginPath();    ctx.moveTo(0, 0);    ctx.lineTo(300, 300);    ctx.lineWidth = 5;    ctx.strokeStyle = "red";    ctx.stroke();  },  runframe() {    this.left = 0;    this.top = 0;    this.flag = true;    this.animation = requestAnimationFrame(this.step);  },  step(timestamp) {    if (this.flag) {      this.left += 5;      this.top += 5;      if (this.startTime == 0) {        this.startTime = timestamp;      }      var elapsed = timestamp - this.startTime;        if (elapsed < 500) {          console.log('callback step timestamp: ' + timestamp);          this.animation = requestAnimationFrame(this.step);        }      } else {        this.left -= 5;        this.top -= 5;        this.animation = requestAnimationFrame(this.step);      }      if (this.left == 250 || this.left == 0) {        this.flag = !this.flag     }    },    onDestroy() {      cancelAnimationFrame(this.animation);    }}  
说明
 requestAnimationFrame函数在调用回调函数时在第一个参数位置传入timestamp时间戳，表示requestAnimationFrame开始去执行回调函数的时刻。 
  取消动画帧通过cancelAnimationFrame函数取消逐帧回调，在调用cancelAnimationFrame函数时取消requestAnimationFrame函数的请求。 已复制<!-- xxx.hml --><div class="container">  <tabs onchange="changecontent">    <tab-content>      <div class="container">        <stack style="width: 300px;height: 300px;margin-top: 100px;margin-bottom: 100px;">          <canvas id="mycanvas" style="width: 100%;height: 100%;background-color: coral;">          </canvas>          <div style="width: 50px;height: 50px;border-radius: 25px;background-color: indigo;position: absolute;left: {{left}};top: {{top}};">          </div>        </stack>        <button type="capsule" value="play" onclick="runframe"></button>      </div>    </tab-content>  </tabs></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  width: 100%;  height: 100%;}button{  width: 300px;} 已复制// xxx.jsexport default {  data: {    timer: null,    left: 0,    top: 0,    flag: true,    animation: null  },  onShow() {    var test = this.$element("mycanvas");    var ctx = test.getContext("2d");    ctx.beginPath();    ctx.moveTo(0, 0);    ctx.lineTo(300, 300);    ctx.lineWidth = 5;    ctx.strokeStyle = "red";    ctx.stroke();  },  runframe() {    this.left = 0;    this.top = 0;    this.flag = true;    this.animation = requestAnimationFrame(this.step);  },  step(timestamp) {    if (this.flag) {      this.left += 5;      this.top += 5;      this.animation = requestAnimationFrame(this.step);    } else {      this.left -= 5;      this.top -= 5;      this.animation = requestAnimationFrame(this.step);    }    if (this.left == 250 || this.left == 0) {      this.flag = !this.flag    }  },  onDestroy() {    cancelAnimationFrame(this.animation);  }}  
说明
 在调用该函数时需传入一个具有标识id的参数。 
   上一篇 动画动效 下一篇 自定义组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。属性样式动画路径动画animateTransform动画svg动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  为svg组件添加动画效果。  属性样式动画 在Svg的子组件animate中，通过attributeName设置需要进行动效的属性，from设置开始值，to设置结束值。 已复制<!-- xxx.hml --><div class="container">  <svg>    <text x="300" y="300" fill="blue">      Hello      <animate attributeName="font-size" from="30" to="60" dur="3s" repeatCount="indefinite">      </animate>      <animate attributeName="fill" from="red" to="blue" dur="3s" repeatCount="indefinite">      </animate>      <animate attributeName="opacity" from="1" to="0.3" dur="3s" repeatCount="indefinite">      </animate>    </text>    <text x="300" y="600" fill="blue">      World      <animate attributeName="font-size" from="30" to="60" values="30;80" dur="3s" repeatCount="indefinite">      </animate>      <animate attributeName="fill" from="red" to="blue"  dur="3s" repeatCount="indefinite">      </animate>      <animate attributeName="opacity" from="0.3" to="1" dur="3s" repeatCount="indefinite">      </animate>    </text>  </svg></div>  
说明
 在设置动画变化值时，如果已经设置了values属性，则from和to都失效。 
   路径动画 在Svg的子组件animateMotion中，通过path设置动画变化的路径。 已复制<!-- xxx.hml --><div class="container">  <svg fill="white" width="800" height="900">    <path d="M300,200 h-150 a150 150 0 1 0 150 -150 z" fill="white" stroke="blue" stroke-width="5" >    </path>    <path fill="red" d="M-5,-5 L10,0 L-5,5 L0,0 Z"  >      <animateMotion dur="2000" repeatCount="indefinite" rotate="auto-reverse"path="M300,200 h-150 a150 150 0 1 0 150 -150 z">      </animateMotion>    </path>  </svg></div>    animateTransform动画 在Svg的子组件animateTransform中，通过attributeName绑定transform属性，type设置动画类型，from设置开始值，to设置结束值。 已复制<!-- xxx.hml --><div class="container" style="">    <svg>        <line x1="90" y1="300" x2="90" y2="730" stroke-width="10" stroke="black" stroke-linecap="round">            <animateTransform attributeName="transform" attributeType="XML" type="translate"  dur="3s" values="0;30;10;30;20;30;25;30" keyTimes="0;0.3;0.5;0.7;0.8;0.9;1.0;1.1"                              fill="freeze">            </animateTransform>        </line>        <circle cx="500" cy="500" r="50" stroke-width="15" fill="red" stroke="#e70d0d">            <animateTransform attributeName="transform" attributeType="XML" type="rotate"  dur="3s" values="0;30;10;30;20;30;25;30" keyTimes="0;0.3;0.5;0.7;0.8;0.9;1.0;1.1" fill="freeze">            </animateTransform>            <animateTransform attributeName="transform" attributeType="XML" type="scale"  dur="6s" values="1;1;1.3" keyTimes="0;0.5;1" fill="freeze"></animateTransform>            <animateTransform attributeName="transform" attributeType="XML" type="translate"  dur="9s" values="0;0;300 7" keyTimes="0;0.6;0.9" fill="freeze"></animateTransform>        </circle>        <line x1="650" y1="300" x2="650" y2="600" stroke-width="20" stroke="blue" stroke-linecap="round">            <animateTransform attributeName="transform" attributeType="XML" type="translate"  dur="9s" values="0;0;0 800" keyTimes="0;0.6;1" fill="freeze"></animateTransform>        </line>    </svg></div> 已复制/* xxx.css */.container {  flex-direction: column;  align-items: center;  width: 100%;  height: 100%;  background-color: #F1F3F5;}    上一篇 background-position样式动画 下一篇 JS动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。设置静态动画设置平移动画设置旋转动画设置缩放动画设置matrix属性整合transform属性transform样式动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 设置transform属性对组件进行旋转、缩放、移动和倾斜。 设置静态动画创建一个正方形并旋转90°变成菱形，并用下方的长方形把菱形下半部分遮盖形成屋顶，设置长方形translate属性值为(150px,-150px)确定坐标位置形成门，再使用position属性使横纵线跟随父组件（正方形）移动到指定坐标位置，接着设置scale属性使父子组件一起变大形成窗户大小，最后使用skewX属性使组件倾斜后设置坐标translate(200px,-710px)得到烟囱。 已复制<!-- xxx.hml --><div class="container">  <div class="top"></div>  <div class="content"></div>  <div class="door"></div>  <!-- 窗户 -->  <div class="window">    <div class="horizontal"></div>    <div class="vertical"></div>  </div>  <div class="chimney"></div></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  background-color:#F1F3F5;  align-items: center;  flex-direction: column;}.top{  z-index: -1;  position: absolute;  width: 428px;  height: 428px;  background-color: #860303;  transform: rotate(45deg);  margin-top: 284px;  margin-left: 148px;}.content{  margin-top: 500px;  width: 600px;  height: 400px;  background-color: white;  border:  1px solid black;}.door{  width: 100px;  height: 135px;  background-color: #1033d9;  transform: translate(150px,-137px);}.window{  z-index: 1;  position: relative;     width: 100px;  height: 100px;  background-color: white;  border: 1px solid black;  transform: translate(-150px,-400px) scale(1.5);}/* 窗户的横轴 */.horizontal{  position: absolute;  top: 50%;  width: 100px;  height: 5px;  background-color: black;}/* 窗户的纵轴 */.vertical{  position: absolute;  left: 50%;  width: 5px;  height: 100px;  background-color: black;}.chimney{  z-index: -2;  width: 40px;  height: 100px;  border-radius: 15px;  background-color: #9a7404;  transform: translate(200px,-710px) skewX(-5deg);}   设置平移动画小球下降动画，改变小球的Y轴坐标实现小球下落，在下一段是时间内减小Y轴坐标实现小球回弹，让每次回弹的高度逐次减小直至回弹高度为0，就模拟出了小球下降的动画。 已复制<!-- xxx.hml --><div class="container">  <div class="circle"></div>  <div class="flower"></div></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  background-color:#F1F3F5;  display: flex;  justify-content: center;}.circle{  width: 100px;  height: 100px;  border-radius: 50px;  background-color: red;  /* forwards停在动画的最后一帧 */  animation: down 3s fast-out-linear-in forwards;}.flower{  position: fixed;  width: 80%;  margin-left: 10%;  height: 5px;  background-color: black;  top: 1000px;}@keyframes down {  0%{    transform: translate(0px,0px);  }  /* 下落 */  15%{    transform: translate(10px,900px);  }  /* 开始回弹 */  25%{    transform: translate(20px,500px);  }  /* 下落 */  35%{    transform: translate(30px,900px);  }  /* 回弹 */  45%{    transform: translate(40px,700px);  }  55%{    transform: translate(50px,900px);  }  65%{    transform: translate(60px,800px);  }  80%{    transform: translate(70px,900px);  }  90%{    transform: translate(80px,850px);  }  /* 停止 */  100%{    transform: translate(90px,900px);  }}   设置旋转动画设置不同的原点位置（transform-origin）改变元素所围绕的旋转中心。rotate3d属性前三个参数值分别为X轴、Y轴、Z轴的旋转向量，第四个值为旋转角度，旋转向角度可为负值，负值则代表旋转方向为逆时针方向。 已复制<!-- xxx.hml --><div class="container">  <div class="rotate">    <div class="rect rect1"></div>    <div class="rect rect2"></div>    <div class="rect rect3"></div>  </div>  <!-- 3d属性 -->  <div class="rotate3d">    <div class="content">        <div class="rect4"></div>        <div class="rect5"> </div>    </div>    <div class="mouse"></div>  </div></div> 已复制/* xxx.css */.container {    flex-direction: column;    background-color:#F1F3F5;    display: flex;    align-items: center;    justify-content: center;    width: 100%;    height: 100%;}.rect {    width: 100px;    height: 100px;    animation: rotate 3s infinite;    margin-left: 30px;}.rect1 {    background-color: #f76160;}.rect2 {    background-color: #60f76f;/* 改变原点位置*/    transform-origin: 10% 10px;}.rect3 {    background-color: #6081f7;/*  改变原点位置*/    transform-origin: right bottom;}@keyframes rotate {    from {        transform: rotate(0deg)    }    to {        transform: rotate(360deg);    }}/* 3d示例样式 */.rotate3d {    margin-top: 150px;    flex-direction: column;    background-color:#F1F3F5;    display: flex;    align-items: center;    width: 80%;    height: 600px;    border-radius: 300px;    border: 1px solid #ec0808;}.content {    padding-top: 150px;    display: flex;    align-items: center;    justify-content: center;}/* react4 react5 翻转形成眼睛 */.rect4 {    width: 100px;    height: 100px;    animation: rotate3d1 1000ms infinite;    background-color: darkmagenta;}.rect5 {    width: 100px;    height: 100px;    animation: rotate3d1 1000ms infinite;    margin-left: 100px;    background-color: darkmagenta;}.mouse {    margin-top: 150px;    width: 200px;    height: 100px;    border-radius: 50px;    border: 1px solid #e70303;    animation: rotate3d2 1000ms infinite;}/* 眼睛的动效 */@keyframes rotate3d1 {    0% {        transform:rotate3d(0,0,0,0deg)    }    50% {        transform:rotate3d(20,20,20,360deg);    }    100% {        transform:rotate3d(0,0,0,0deg);    }}/* 嘴的动效 */@keyframes rotate3d2 {    0% {        transform:rotate3d(0,0,0,0deg)    }    33% {        transform:rotate3d(0,0,10,30deg);    }    66% {        transform:rotate3d(0,0,10,-30deg);    }    100% {        transform:rotate3d(0,0,0,0deg);    }}  
说明
transform-origin变换对象的原点位置，如果仅设置一个值，另一个值为50%，若设置两个值第一个值表示X轴的位置，第二个值表示Y轴的位置。 
  设置缩放动画设置scale样式属性实现涟漪动画，先使用定位确定元素的位置，确定坐标后创建多个组件实现重合效果，再设置opacity属性改变组件不透明度实现组件隐藏与显示，同时设置scale值使组件可以一边放大一边隐藏，最后设置两个组件不同的动画执行时间，实现扩散的效果。 设置sacle3d中X轴、Y轴、Z轴的缩放参数实现动画。 已复制<!-- xxx.hml --><div class="container">  <div class="circle">    <text>ripple</text>  </div>  <div class="ripple"></div>  <div class="ripple ripple2"></div>  <!-- 3d -->  <div class="content">    <text>spring</text>  </div></div> 已复制/* xxx.css */.container {    flex-direction: column;    background-color:#F1F3F5;    width: 100%;    position: relative;}.circle{    margin-top: 400px;    margin-left: 40%;    width: 100px;    height: 100px;    border-radius: 50px;    background-color: mediumpurple;    z-index: 1;  position: absolute;}.ripple{    margin-top: 400px;    margin-left: 40%;    position: absolute;  z-index: 0;    width: 100px;    height: 100px;    border-radius: 50px;    background-color: blueviolet;    animation: ripple 5s infinite;}/* 设置不同的动画时间 */.ripple2{    animation-duration: 2.5s;}@keyframes ripple{    0%{        transform: scale(1);        opacity: 0.5;    }    50%{        transform: scale(3);        opacity: 0;    }    100%{        transform: scale(1);        opacity: 0.5;    }}text{    color: white;    text-align: center;    height: 100%;    width: 100%;}.content {    margin-top: 700px;    margin-left: 33%;    width: 200px;    height: 100px;    animation:rubberBand 1s infinite;    background-color: darkmagenta;    position: absolute;}@keyframes rubberBand {    0% {        transform: scale3d(1, 1, 1);    }    30% {        transform: scale3d(1.25, 0.75, 1.1);    }    40% {        transform: scale3d(0.75, 1.25, 1.2);    }    50% {        transform: scale3d(1.15, 0.85, 1.3);    }    65% {        transform: scale3d(.95, 1.05, 1.2);    }    75% {        transform: scale3d(1.05, .95, 1.1);    }    100%{        transform: scale3d(1, 1, 1);    }}  
说明
设置transform属性值后，子元素会跟着父元素一起改变，若只改变父元素其他属性值时（如：height，width），子元素不会改变。 
  设置matrix属性matrix是一个入参为六个值的矩阵，6个值分别代表：scaleX, skewY, skewX, scaleY, translateX, translateY。下面示例中设置 了matrix属性为matrix(1,0,0,1,0,200)使组件移动和倾斜。 已复制<!-- xxx.hml --><div class="container">  <div class="rect"> </div></div> 已复制/* xxx.css */.container{  background-color:#F1F3F5;  display: flex;  justify-content: center;  width: 100%;  height: 100%;}.rect{  width: 100px;  height: 100px;  background-color: red;  animation: down 3s infinite forwards;}@keyframes down{  0%{    transform: matrix(1,0,0,1,0,0);  }  10%{    transform: matrix(1,0,0,1,0,200);  }  60%{    transform: matrix(2,1.5,1.5,2,0,700);  }  100%{    transform: matrix(1,0,0,1,0,0);  }}   整合transform属性transform可以设置多个值并且多个值可同时设置，下面案例中展示同时设置缩放（scale），平移（translate），旋转（rotate）属性时的动画效果。 已复制<!-- xxx.hml --><div class="container">  <div class="rect1"></div>  <div class="rect2"></div>  <div class="rect3"></div>  <div class="rect4"></div>  <div class="rect5"></div></div> 已复制/* xxx.css */.container{    width: 100%;    height: 100%;    flex-direction:column;    background-color:#F1F3F5;    padding:50px;}.rect1{    width: 100px;    height: 100px;    background-color: red;    animation: change1 3s infinite forwards;}.rect2{    margin-top: 50px;    width: 100px;    height: 100px;    background-color: darkblue;    animation: change2 3s infinite forwards;}.rect3{    margin-top: 50px;    width: 100px;    height: 100px;    background-color: darkblue;    animation: change3 3s infinite;}.rect4{    align-self: center;    margin-left: 50px;    margin-top: 200px;    width: 100px;    height: 100px;    background-color: darkmagenta;    animation: change4 3s infinite;}.rect5{    margin-top: 300px;    width: 100px;    height: 100px;   background-color: cadetblue;    animation: change5 3s infinite;}/* change1 change2 对比 */@keyframes change1{    0%{        transform: translate(0,0);    transform: rotate(0deg)    }    100%{        transform: translate(0,500px);        transform: rotate(360deg)    }}/* change2 change3 对比属性顺序不同的动画效果 */@keyframes change2{    0%{        transform:translate(0,0) rotate(0deg) ;    }    100%{        transform: translate(300px,0) rotate(360deg);    }}@keyframes change3{    0%{        transform:rotate(0deg) translate(0,0);    }    100%{        transform:rotate(360deg)  translate(300px,0);    }}/* 属性值不对应的情况 */@keyframes change4{    0%{        transform: scale(0.5);    }    100%{        transform:scale(2) rotate(45deg);    }}/* 多属性的写法 */@keyframes change5{    0%{        transform:scale(0) translate(0,0) rotate(0);    }    100%{        transform: scale(1.5) rotate(360deg) translate(200px,0);    }}  
说明
当设置多个transform时，后续的transform值会把前面的覆盖掉。若想同时使用多个动画样式可用复合写法，例：transform: scale(1) rotate(0) translate(0,0)。 transform进行复合写法时，变化样式内多个样式值顺序的不同会呈现不一样的动画效果。 transform属性设置的样式值要一一对应，若前后不对应，则该动画不生效。若设置多个样式值则只会呈现出已对应值的动画效果。  
   上一篇 属性样式动画 下一篇 background-position样式动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。静态动画连续动画使用动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  动画分为静态动画和连续动画。  静态动画 静态动画的核心是transform样式，主要可以实现以下三种变换类型，一次样式设置只能实现一种类型变换。  translate：沿水平或垂直方向将指定组件移动所需距离。 scale：横向或纵向将指定组件缩小或放大到所需比例。 rotate：将指定组件沿横轴或纵轴或中心点旋转指定的角度。  具体的使用示例如下，更多信息请参考组件方法。 已复制<!-- xxx.hml --><div class="container">  <text class="translate">hello</text>  <text class="rotate">hello</text>  <text class="scale">hello</text></div> 已复制/* xxx.css */.container {  width: 100%;  flex-direction: column;  align-items: center;}.translate {  height: 150px;  width: 300px;  margin: 50px;  font-size: 50px;  background-color: #008000;  transform: translate(200px);}.rotate {  height: 150px;  width: 300px;  margin: 50px;  font-size: 50px;  background-color: #008000;  transform-origin: 200px 100px;  transform: rotate(45deg);}.scale {  height: 150px;  width: 300px;  margin: 50px;  font-size: 50px;  background-color: #008000;  transform: scaleX(1.5);} 图1 静态动画效果图    连续动画 静态动画只有开始状态和结束状态，没有中间状态，如果需要设置中间的过渡状态和转换效果，需要使用连续动画实现。 连续动画的核心是animation样式，它定义了动画的开始状态、结束状态以及时间和速度的变化曲线。通过animation样式可以实现的效果有：  animation-name：设置动画执行后应用到组件上的背景颜色、透明度、宽高和变换类型。 animation-delay和animation-duration：分别设置动画执行后元素延迟和持续的时间。 animation-timing-function：描述动画执行的速度曲线，使动画更加平滑。 animation-iteration-count：定义动画播放的次数。 animation-fill-mode：指定动画执行结束后是否恢复初始状态。  animation样式需要在css文件中先定义keyframe，在keyframe中设置动画的过渡效果，并通过一个样式类型在hml文件中调用。animation-name的使用示例如下： 已复制<!-- xxx.hml --><div class="item-container">    <div class="item {{colorParam}}">        <text class="txt">color</text>    </div>    <div class="item {{opacityParam}}">        <text class="txt">opacity</text>    </div>    <input class="button" type="button" name="" value="show" onclick="showAnimation"/></div> 已复制/* xxx.css */.item-container {  margin: 60px;  flex-direction: column;}.item {  width: 80%;  background-color: #f76160;}.txt {  text-align: center;  width: 200px;  height: 100px;}.button {  width: 200px;  margin: 10px;  font-size: 30px;  background-color: #09ba07;}.color {  animation-name: Color;  animation-duration: 8000ms;}.opacity {  animation-name: Opacity;  animation-duration: 8000ms;}@keyframes Color {  from {    background-color: #f76160;  }  to {    background-color: #09ba07;  }}@keyframes Opacity {  from {    opacity: 0.9;  }  to {    opacity: 0.1;  }} 已复制// xxx.jsexport default {  data: {    colorParam: '',    opacityParam: '',  },  showAnimation: function () {    this.colorParam = '';    this.opacityParam = '';    this.colorParam = 'color';    this.opacityParam = 'opacity';  }} 图2 连续动画效果图    上一篇 添加交互 下一篇 手势事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。组件分类组件介绍 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  组件（Component）是构建页面的核心，每个组件通过对数据和方法的简单封装，实现独立的可视、可交互功能单元。组件之间相互独立，随取随用，也可以在需求相同的地方重复使用。关于组件的详细参考文档请参见组件。 开发者还可以通过组件间合理的搭配定义满足业务需求的新组件，减少开发量，自定义组件的开发方法请参见自定义组件。  组件分类 根据组件的功能，可以分为以下六大类：     组件类型 主要组件    容器组件 badge、dialog、div、form、list、list-item、list-item-group、panel、popup、refresh、stack、stepper、stepper-item、swiper、tabs、tab-bar、tab-content   基础组件 button、chart、divider、image、image-animator、input、label、marquee、menu、option、picker、picker-view、piece、progress、qrcode、rating、richtext、search、select、slider、span、switch、text、textarea、toolbar、toolbar-item、toggle   媒体组件 video   画布组件 canvas   栅格组件 grid-container、grid-row、grid-col   svg组件 svg、rect、circle、ellipse、path、line、polyline、polygon、text、tspan、textPath、animate、animateMotion、animateTransform      上一篇 构建用户界面 下一篇 构建布局 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。手势事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 手势表示由单个或多个事件识别的语义动作（例如：点击、拖动和长按）。一个完整的手势也可能由多个事件组成，对应手势的生命周期。支持的事件有： 触摸 touchstart：手指触摸动作开始。 touchmove：手指触摸后移动。 touchcancel：手指触摸动作被打断，如来电提醒、弹窗。 touchend：手指触摸动作结束。  点击 click：用户快速轻敲屏幕。 长按 longpress：用户在相同位置长时间保持与屏幕接触。 具体的使用示例如下： 已复制<!-- xxx.hml --><div class="container">  <div class="text-container" onclick="click">    <text class="text-style">{{onClick}}</text>  </div>  <div class="text-container" ontouchstart="touchStart">    <text class="text-style">{{touchstart}}</text>  </div>  <div class="text-container" ontouchmove="touchMove">    <text class="text-style">{{touchmove}}</text>  </div>  <div class="text-container" ontouchend="touchEnd">    <text class="text-style">{{touchend}}</text>  </div>  <div class="text-container" ontouchcancel="touchCancel">    <text class="text-style">{{touchcancel}}</text>  </div>  <div class="text-container" onlongpress="longPress">    <text class="text-style">{{onLongPress}}</text>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;}.text-container {  margin-top: 30px;  flex-direction: column;  width: 600px;  height: 70px;  background-color: #0000FF;}.text-style {  width: 100%;  line-height: 50px;  text-align: center;  font-size: 24px;  color: #ffffff;} 已复制// xxx.jsexport default {  data: {    touchstart: 'touchstart',    touchmove: 'touchmove',    touchend: 'touchend',    touchcancel: 'touchcancel',    onClick: 'onclick',    onLongPress: 'onlongpress',  },  touchCancel: function (event) {    this.touchcancel = 'canceled';  },  touchEnd: function(event) {    this.touchend = 'ended';  },  touchMove: function(event) {    this.touchmove = 'moved';  },   touchStart: function(event) {    this.touchstart = 'touched';  },  longPress: function() {    this.onLongPress = 'longpressed';  },  click: function() {    this.onClick = 'clicked';  },}   上一篇 使用动画 下一篇 页面路由 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加交互 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 添加交互可以通过在组件上关联事件实现。本节将介绍如何用div、text、image组件关联click事件，构建一个如下图所示的点赞按钮。 图1 点赞按钮效果  点赞按钮通过一个div组件关联click事件实现。div组件包含一个image组件和一个text组件： image组件用于显示未点赞和点赞的效果。click事件函数会交替更新点赞和未点赞图片的路径。 text组件用于显示点赞数，点赞数会在click事件的函数中同步更新。  click事件作为一个函数定义在js文件中，可以更改isPressed的状态，从而更新显示的image组件。如果isPressed为真，则点赞数加1。该函数在hml文件中对应的div组件上生效，点赞按钮各子组件的样式设置在css文件当中。具体的实现示例如下： 已复制<!-- xxx.hml --><!-- 点赞按钮 --><div>  <div class="like" onclick="likeClick">    <image class="like-img" src="{{likeImage}}" focusable="true"></image>    <text class="like-num" focusable="true">{{total}}</text>  </div></div> 已复制/* xxx.css */.like {  width: 104px;  height: 54px;  border: 2px solid #bcbcbc;  justify-content: space-between;  align-items: center;  margin-left: 72px;  border-radius: 8px;}.like-img {  width: 33px;  height: 33px;  margin-left: 14px;}.like-num {  color: #bcbcbc;  font-size: 20px;  margin-right: 17px;} 已复制// xxx.jsexport default {  data: {    likeImage: '/common/unLike.png',    isPressed: false,    total: 20,  },  likeClick() {    var temp;    if (!this.isPressed) {      temp = this.total + 1;      this.likeImage = '/common/like.png';    } else {      temp = this.total - 1;      this.likeImage = '/common/unLike.png';    }    this.total = temp;    this.isPressed = !this.isPressed;  },} 除此之外，还提供了很多表单组件，例如开关、标签、滑动选择器等，以便于开发者在页面布局时灵活使用和提高交互性，详见容器组件。  上一篇 添加容器 下一篇 使用动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加留言区域 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 留言框的功能为：用户输入留言后点击完成，留言区域即显示留言内容；用户点击右侧的删除按钮可删除当前留言内容并重新输入。 留言区域由div、text、input关联click事件实现。开发者可以使用input组件实现输入留言的部分，使用text组件实现留言完成部分，使用commentText的状态标记此时显示的组件（通过if属性控制）。在包含文本完成和删除的text组件中关联click事件，更新commentText状态和inputValue的内容。具体的实现示例如下： 已复制<!-- xxx.hml --><div class="container">  <text class="comment-title">Comment</text>  <div if="{{!commentText}}">    <input class="comment" value="{{inputValue}}" onchange="updateValue()"></input>    <text class="comment-key" onclick="update" focusable="true">Done</text>  </div>  <div if="{{commentText}}">    <text class="comment-text" focusable="true">{{inputValue}}</text>    <text class="comment-key" onclick="update" focusable="true">Delete</text>  </div></div> 已复制/* xxx.css */.container {  margin-top: 24px;  background-color: #ffffff;}.comment-title {  font-size: 40px;  color: #1a1a1a;  font-weight: bold;  margin-top: 40px;  margin-bottom: 10px;}.comment {  width: 550px;  height: 100px;  background-color: lightgrey;}.comment-key {  width: 150px;  height: 100px;  margin-left: 20px;  font-size: 32px;  color: #1a1a1a;  font-weight: bold;}.comment-key:focus {  color: #007dff;}.comment-text {  width: 550px;  height: 100px;  text-align: left;  line-height: 35px;  font-size: 30px;  color: #000000;  border-bottom-color: #bcbcbc;  border-bottom-width: 0.5px;} 已复制// xxx.jsexport default {  data: {    inputValue: '',    commentText: false,  },  update() {    this.commentText = !this.commentText;  },  updateValue(e) {    this.inputValue = e.text;  },}  上一篇 添加图片区域 下一篇 添加容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。List组件Tabs组件添加容器 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 要将页面的基本元素组装在一起，需要使用容器组件。在页面布局中常用到三种容器组件，分别是div、list和tabs。在页面结构相对简单时，可以直接用div作为容器，因为div作为单纯的布局容器，可以支持多种子组件，使用起来更为方便。 List组件当页面结构较为复杂时，如果使用div循环渲染，容易出现卡顿，因此推荐使用list组件代替div组件实现长列表布局，从而实现更加流畅的列表滚动体验。需要注意的是，list仅支持list-item作为子组件，具体的使用示例如下： 已复制<!-- xxx.hml --><list class="list">  <list-item type="listItem" for="{{textList}}">    <text class="desc-text">{{$item.value}}</text>  </list-item></list> 已复制/* xxx.css */.desc-text {  width: 683.3px;  font-size: 35.4px;} 已复制// xxx.jsexport default {  data: {    textList:  [{value: 'JS FA'}],  },} 为避免示例代码过长，以上示例的list中只包含一个list-item，list-item中只有一个text组件。在实际应用中可以在list中加入多个list-item，同时list-item下可以包含多个其他子组件。  Tabs组件当页面经常需要动态加载时，推荐使用tabs组件。tabs组件支持change事件，在页签切换后触发。tabs组件仅支持一个tab-bar和一个tab-content。具体的使用示例如下： 已复制<!-- xxx.hml --><tabs>  <tab-bar>    <text>Home</text>    <text>Index</text>    <text>Detail</text>  </tab-bar>  <tab-content>    <image src="{{homeImage}}"></image>    <image src="{{indexImage}}"></image>    <image src="{{detailImage}}"></image>  </tab-content></tabs> 已复制// xxx.jsexport default {  data: {    homeImage: '/common/home.png',    indexImage: '/common/index.png',    detailImage: '/common/detail.png',  },} tab-content组件用来展示页签的内容区，高度默认充满tabs剩余空间。   上一篇 添加留言区域 下一篇 添加交互 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加图片区域 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  添加图片区域通常用image组件来实现，使用的方法和text组件类似。 图片资源建议放在js\default\common目录下，common目录需自行创建，详细的目录结构见目录结构。代码示例如下： 已复制<!-- xxx.hml --><image class="img" src="{{middleImage}}"></image> 已复制/* xxx.css */.img {    margin-top: 30px;  margin-bottom: 30px;  height: 385px;} 已复制// xxx.jsexport default {  data: {    middleImage: '/common/ice.png',  },}  上一篇 添加标题行和文本区域 下一篇 添加留言区域 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。布局说明 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 设备的基准宽度为720px（px为逻辑像素，非物理像素），实际显示效果会根据实际屏幕宽度进行缩放。 其换算关系如下： 组件的width设为100px时，在宽度为720物理像素的屏幕上，实际显示为100物理像素；在宽度为1440物理像素的屏幕上，实际显示为200物理像素。 一个页面的基本元素包含标题区域、文本区域、图片区域等，每个基本元素内还可以包含多个子元素，开发者根据需求还可以添加按钮、开关、进度条等组件。在构建页面布局时，需要对每个基本元素思考以下几个问题： 该元素的尺寸和排列位置 是否有重叠的元素 是否需要设置对齐、内间距或者边界 是否包含子元素及其排列位置 是否需要容器组件及其类型  将页面中的元素分解之后再对每个基本元素按顺序实现，可以减少多层嵌套造成的视觉混乱和逻辑混乱，提高代码的可读性，方便对页面做后续的调整。以下图为例进行分解： 图1 页面布局分解  图2 留言区布局分解   上一篇 构建布局 下一篇 添加标题行和文本区域 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加标题行和文本区域 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  实现标题和文本区域最常用的是基础组件text。text组件用于展示文本，可以设置不同的属性和样式，文本内容需要写在标签内容区，完整属性和样式信息请参考text。在页面中插入标题和文本区域的示例如下： 已复制<!-- xxx.hml --><div class="container">  <text class="title-text">{{headTitle}}</text>  <text class="paragraph-text">{{paragraphFirst}}</text>  <text class="paragraph-text">{{paragraphSecond}}</text></div> 已复制/* xxx.css */.container {  flex-direction: column;  margin-top: 20px;  margin-left: 30px;}.title-text {  color: #1a1a1a;  font-size: 50px;  margin-top: 40px;  margin-bottom: 20px;  font-weight: 700;}.paragraph-text {  width: 95%;  color: #000000;  font-size: 35px;  line-height: 60px;} 已复制// xxx.jsexport default {  data: {    headTitle: 'Capture the Beauty in Moment',    paragraphFirst: 'Capture the beauty of light during the transition and fusion of ice and water. At the instant of movement and stillness, softness and rigidity, force and beauty, condensing moving moments.',    paragraphSecond: 'Reflecting the purity of nature, the innovative design upgrades your visual entertainment and ergonomic comfort. Effortlessly capture what you see and let it speak for what you feel.',  },}   上一篇 布局说明 下一篇 添加图片区域 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。构建页面布局构建页面样式实现跳转页面路由 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 很多应用由多个页面组成，比如用户可以从音乐列表页面点击歌曲，跳转到该歌曲的播放界面。开发者需要通过页面路由将这些页面串联起来，按需实现跳转。 页面路由router根据页面的uri找到目标页面，从而实现跳转。以最基础的两个页面之间的跳转为例，具体实现步骤如下： 在“Project“窗口，打开src > main >js >MainAbility，右键点击pages文件夹，选择NewJS Page，创建一个详情页。 调用router.push()路由到详情页。 调用router.back()回到首页。  构建页面布局index和detail这两个页面均包含一个text组件和button组件：text组件用来指明当前页面，button组件用来实现两个页面之间的相互跳转。hml文件代码示例如下： 已复制<!-- index.hml --><div class="container">  <text class="title">This is the index page.</text>  <button type="capsule" value="Go to the second page" class="button" onclick="launch"></button></div> 已复制<!-- detail.hml --><div class="container">  <text class="title">This is the detail page.</text>  <button type="capsule" value="Go back" class="button" onclick="launch"></button></div>  构建页面样式构建index和detail页面的页面样式，text组件和button组件居中显示，两个组件之间间距为50px。css代码如下（两个页面样式代码一致）： 已复制/* index.css *//* detail.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;}.title {  font-size: 50px;  margin-bottom: 50px;}  实现跳转为了使button组件的launch方法生效，需要在页面的js文件中实现跳转逻辑。调用router.push()接口将uri指定的页面添加到路由栈中，即跳转到uri指定的页面。在调用router方法之前，需要导入router模块。代码示例如下： 已复制// index.jsimport router from '@ohos.router';export default {  launch() {    router.push ({      url: 'pages/detail/detail',    });  },} 已复制// detail.jsimport router from '@ohos.router';export default {  launch() {    router.back();  },} 运行效果如下图所示：    上一篇 手势事件 下一篇 常见组件开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建tabs设置样式显示页签索引场景示例tabs开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  tabs是一种常见的界面导航结构。通过页签容器，用户可以快捷地访问应用的不同模块。具体用法请参考tabs API。  创建tabs 在pages/index目录下的hml文件中创建一个tabs组件。 已复制<!-- xxx.hml --><div class="container">    <tabs>        <tab-bar>            <text>item1</text>            <text>item2</text>        </tab-bar>        <tab-content class="tabContent">            <div class="text">                <text>content1</text>            </div>            <div class="text">                <text>content2</text>            </div>        </tab-content>    </tabs></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.tabContent{  width: 100%;  height: 100%;}.text{  width: 100%;  height: 100%;  justify-content: center;  align-items: center;}    设置样式 设置tabs背景色及边框和tab-content布局。 已复制<!-- xxx.hml --><div class="container">  <tabs class="tabs">    <tab-bar class="tabBar">      <text class="tabBarItem">item1</text>      <text class="tabBarItem">item2</text>    </tab-bar>    <tab-content class="tabContent">      <div class="tabContent">        <text>content1</text>      </div>      <div class="tabContent" >        <text>content2</text>      </div>    </tab-content>  </tabs></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: flex-start;  align-items: center; background-color:#F1F3F5;}.tabs{  margin-top: 20px; border: 1px solid #2262ef;  width: 99%;  padding: 10px;}.tabBar{  width: 100%;  border: 1px solid #78abec;}.tabContent{  width: 100%;  margin-top: 10px;  height: 300px;  color: blue;     justify-content: center;    align-items: center;}    显示页签索引 开发者可以为tabs添加change事件，实现页签切换后显示当前页签索引的功能。 已复制<!-- xxx.hml --><div class="container" style="background-color:#F1F3F5;">  <tabs class="tabs" onchange="tabChange">    <tab-bar class="tabBar">      <text class="tabBarItem">item1</text>      <text class="tabBarItem">item2</text>    </tab-bar>    <tab-content class="tabContent">      <div>        <image src="common/images/bg-tv.jpg" style="object-fit: contain;"> </image>      </div>      <div>        <image src="common/images/img1.jpg" style="object-fit: contain;"> </image>      </div>    </tab-content>  </tabs></div> 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  tabChange(e){    promptAction.showToast({      message: "Tab index: " + e.index    })  }}  
说明
 tabs子组件仅支持一个<tab-bar>和一个<tab-content>。 
   场景示例 在本场景中，开发者可以点击标签切换内容，选中后标签文字颜色变红，并显示下划线。 用tabs、tab-bar和tab-content实现点击切换功能，再定义数组，设置属性。使用change事件改变数组内的属性值实现变色及下划线的显示。 已复制<!-- xxx.hml --><div class="container">  <tabs onchange="changeTabactive">    <tab-content>      <div class="item-container" for="datas.list">        <div if="{{$item.title=='List1'?true:false}}">          <image src="common/images/bg-tv.jpg" style="object-fit: contain;"> </image>        </div>        <div if="{{$item.title=='List2'?true:false}}">          <image src="common/images/img1.jpg" style="object-fit: none;"> </image>        </div>        <div if="{{$item.title=='List3'?true:false}}">          <image src="common/images/img2.jpg" style="object-fit: contain;"> </image>        </div>      </div>    </tab-content>    <tab-bar class="tab_bar mytabs" mode="scrollable">      <div class="tab_item" for="datas.list">        <text style="color: {{$item.color}};">{{$item.title}}</text>        <div class="underline-show" if="{{$item.show}}"></div>        <div class="underline-hide" if="{{!$item.show}}"></div>      </div>    </tab-bar>  </tabs></div> 已复制/* xxx.css */.container{width: 100%;height: 100%;background-color:#F1F3F5;}.tab_bar {  width: 100%;  height: 150px;}.tab_item {  height: 30%;  flex-direction: column;  align-items: center;}.tab_item text {  font-size: 32px;}.item-container {  justify-content: center;  flex-direction: column;}.underline-show {  height: 2px;  width: 160px;  background-color: #FF4500;  margin-top: 7.5px;}.underline-hide {  height: 2px;  margin-top: 7.5px;  width: 160px;} 已复制// xxx.jsexport default {  data() {    return {      datas: {        color_normal: '#878787',        color_active: '#ff4500',        show: true,        list: [{          i: 0,          color: '#ff4500',          show: true,          title: 'List1'        }, {          i: 1,          color: '#878787',          show: false,          title: 'List2'        }, {           i: 2,           color: '#878787',           show: false,           title: 'List3'        }]      }    }  },  changeTabactive (e) {    for (let i = 0; i < this.datas.list.length; i++) {      let element = this.datas.list[i];      element.show = false;      element.color = this.datas.color_normal;      if (i === e.index) {        element.show = true;        element.color = this.datas.color_active;      }    }  }}    上一篇 stepper开发指导 下一篇 swiper开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建button组件设置button类型显示下载进度场景示例button开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  button是按钮组件，其类型包括胶囊按钮、圆形按钮、文本按钮、弧形按钮、下载按钮。具体用法请参考button API。  创建button组件 在pages/index目录下的hml文件中创建一个button组件。 已复制<!-- xxx.hml --><div class="container">         <button  type="capsule" value="Capsule button"></button></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}    设置button类型 通过设置button的type属性来选择按钮类型，如定义button为圆形按钮、文本按钮等。 已复制<!-- xxx.hml --><div class="container">      <button class="circle" type="circle" >+</button>  <button class="text" type="text"> button</button></div> 已复制/* xxx.css */.container {    width: 100%;  height: 100%;  background-color: #F1F3F5;  flex-direction: column;  align-items: center;  justify-content: center;}.circle {  font-size: 120px;  background-color: blue;  radius: 72px;}.text {  margin-top: 30px;  text-color: white;  font-size: 30px;  font-style: normal;  background-color: blue;  width: 50%;  height: 100px;}  
说明
  button组件使用的icon图标如果来自云端路径，需要添加网络访问权限 ohos.permission.INTERNET。  
 如果需要添加ohos.permission.INTERNET权限，则在resources文件夹下的config.json文件里进行权限配置。 已复制<!-- config.json -->"module": {  "reqPermissions": [{    "name": "ohos.permission.INTERNET"  }],}   显示下载进度 为button组件添加progress方法，来实时显示下载进度条的进度。 已复制<!-- xxx.hml --><div class="container">  <button class="button download" type="download" id="download-btn" onclick="setProgress">{{downloadText}}</button></div> 已复制/* xxx.css */.container {   width: 100%;  height: 100%;  background-color: #F1F3F5;    flex-direction: column;  align-items: center;  justify-content: center;}.download {      width: 280px;  text-color: white;  background-color: #007dff;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data: {    percent: 0,    downloadText: "Download",    isPaused: true,    intervalId : null,  },  start(){    this.intervalId = setInterval(()=>{      if(this.percent <100){        this.percent += 1;        this.downloadText = this.percent+ "%";       } else{         promptAction.showToast({            message: "Download succeeded."         })         this.paused()         this.downloadText = "Download";         this.percent = 0;         this.isPaused = true;       }    },100)  },  paused(){    clearInterval(this.intervalId);    this.intervalId = null;  }, setProgress(e) {    if(this.isPaused){      promptAction.showToast({        message: "Started Downloading"      })      this.start();      this.isPaused = false;    }else{      promptAction.showToast({        message: "Paused."      })      this.paused();      this.isPaused = true;    }  }}  
说明
 setProgress方法只支持button的类型为download。 
   场景示例 在本场景中，开发者可根据输入的文本内容进行button类型切换。 已复制<!-- xxx.hml --><div class="container">  <div class="input-item">    <input class="input-text" id="change" type="{{mytype}}"  placeholder="{{myholder}}"       style="background-color:{{mystyle1}};      placeholder-color:{{mystyle2}};flex-grow:{{myflex}};"name="{{myname}}" value="{{myvalue}}"></input>  </div>  <div class="input-item">    <div class="doc-row">      <input type="button" class="select-button color-3" value="text" onclick="changetype3"></input>      <input type="button" class="select-button color-3" value="data" onclick="changetype4"></input>    </div>  </div></div> 已复制/* xxx.css */.container {  flex-direction: column;  align-items: center;  background-color: #F1F3F5;}.input-item {  margin-bottom: 80px;  flex-direction: column;}.doc-row {  justify-content: center;  margin-left: 30px;  margin-right: 30px;  justify-content: space-around;}.input-text {  height: 80px;  line-height: 80px;  padding-left: 30px;  padding-right: 30px;  margin-left: 30px;  margin-right: 30px;  margin-top:100px;  border: 3px solid;  border-color: #999999;  font-size: 30px;  background-color: #ffffff;  font-weight: 400;}.select-button {  width: 35%;  text-align: center;  height: 70px;  padding-top: 10px;  padding-bottom: 10px;  margin-top: 30px;  font-size: 30px;  color: #ffffff;}.color-3 {  background-color: #0598db;;} 已复制// xxx.jsexport default {  data: {    myflex: '',    myholder: 'Enter text.',    myname: '',    mystyle1: "#ffffff",    mystyle2: "#ff0000",    mytype: 'text',    myvalue: '',  },  onInit() {  },  changetype3() {    this.myflex = '';    this.myholder = 'Enter text.';    this.myname = '';    this.mystyle1 = "#ffffff";    this.mystyle2 = "#FF0000";    this.mytype = 'text';    this.myvalue = '';  },  changetype4() {    this.myflex = '';    this.myholder = 'Enter a date.';    this.myname = '';    this.mystyle1 = "#ffffff";    this.mystyle2 = "#FF0000";    this.mytype = 'date';    this.myvalue = '';  },}    上一篇 input开发指导 下一篇 picker开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建Canvas组件添加样式添加事件Canvas对象 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Canvas组件提供画布，用于自定义绘制图形。具体用法请参考CanvasRenderingContext2D对象。  创建Canvas组件 在pages/index目录下的hml文件中创建一个Canvas组件。 已复制<!-- xxx.hml --><div class="container">  <canvas></canvas></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  background-color: #00ff73;}  
说明
  Canvas组件默认背景色与父组件的背景色一致。 Canvas默认宽高为width: 300px，height: 150px。  
   添加样式 Canvas组件设置宽（width）、高（height）、背景色（background-color）及边框样式（border）。 已复制<!-- xxx.hml --><div class="container">  <canvas></canvas></div> 已复制/* xxx.css */.container{  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 500px;  height: 500px;    background-color: #fdfdfd;    border: 5px solid red;}    添加事件 Canvas添加长按事件，长按后可获取Canvas组件的dataUrl值（toDataURL方法返回的图片信息），打印在下方文本区域内。 已复制<!-- xxx.hml --><div class="container">  <canvas ref="canvas1" onlongpress="getUrl"></canvas>  <text>dataURL</text>  <text class="content">{{dataURL}}</text></div> 已复制/* xxx.css */.container{  width:100%;  height:100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;  }  canvas{      width: 500px;      height: 500px;    background-color: #fdfdfd;    border: 5px solid red;    margin-bottom: 50px;}.content{  border: 5px solid blue;  padding: 10px;  width: 90%;  height: 400px;   overflow: scroll;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data:{    dataURL:null,  },  onShow(){    let el = this.$refs.canvas1;    let ctx = el.getContext("2d");     ctx.strokeRect(100,100,300,300);  },  getUrl(){    let el = this.$refs.canvas1    let dataUrl = el.toDataURL()    this.dataURL = dataUrl;    promptAction.showToast({duration:2000,message:"long press,get dataURL"})  }}  
说明
 画布不支持在onInit和onReady中进行创建。 
   上一篇 Canvas开发指导 下一篇 CanvasRenderingContext2D对象 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。画线段画边框填充渐变色填充文字添加图片添加方法CanvasRenderingContext2D对象 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  使用CanvasRenderingContext2D在Canvas画布组件上进行绘制，绘制对象可以是图形、文本、线段、图片等。具体请参考CanvasRenderingContext2D对象。  画线段 使用moveTo和lineTo画出一条线段，当使用closePath方法时会结束当前路径形成一个封闭图形 。设置quadraticCurveTo（二次贝赛尔曲线）或bezierCurveTo（三次贝赛尔曲线）的值组成图形。 已复制<!-- xxx.hml --><div class="container">  <canvas ref="canvas1"></canvas>  <select @change="change">    <option value="value1"> line </option>    <option value="value2"> quadratic </option>    <option value="value3"> bezier </option>    <option value="value4"> arc/ellipse </option>    <option value="value5"> lineJoin/miterLimit </option>  </select></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}select{  margin-top: 50px;  width: 250px;  height: 100px;  background-color: white;} 已复制// xxx.jsexport default {  data:{    el: null,    ctx: null,  },  onShow(){    this.el = this.$refs.canvas1;    this.ctx = this.el.getContext("2d",{antialias: true});    // 清除画布上的内容    this.ctx.clearRect(0, 0, 600, 500);    // 创建一个新的绘制路径    this.ctx.beginPath();    // 线端点以方形结束    this.ctx.lineCap = 'butt';    // 描边的宽度    this.ctx.lineWidth = 15;    // 创建一个新的绘制路径    this.ctx.beginPath();    // 路径从当前点移动到指定点    this.ctx.moveTo(200, 100);    // 从当前点到指定点进行路径连接    this.ctx.lineTo(400, 100);    // 边框绘制    this.ctx.stroke();    this.ctx.beginPath();    // 线端点以圆形结束    this.ctx.lineCap = 'round';    this.ctx.moveTo(200, 200);    this.ctx.lineTo(400, 200);    this.ctx.stroke();    // 线端点以方形结束    this.ctx.beginPath();    this.ctx.lineCap = 'square';    this.ctx.moveTo(200, 300);    this.ctx.lineTo(400, 300);    this.ctx.stroke();  },  change(e){    if(e.newValue == 'value1'){      this.el = this.$refs.canvas1;      this.ctx = this.el.getContext("2d",{antialias: true});      this.ctx.clearRect(0, 0, 600, 500);      // 上      this.ctx.beginPath();      this.ctx.lineCap = 'butt';      this.ctx.moveTo(200, 100);      this.ctx.lineTo(400, 100);      this.ctx.stroke();      // 中      this.ctx.beginPath();      this.ctx.lineCap = 'round';      this.ctx.moveTo(200, 200);      this.ctx.lineTo(400, 200);      this.ctx.stroke();      // 下      this.ctx.beginPath();      this.ctx.lineCap = 'square';      this.ctx.moveTo(200, 300);      this.ctx.lineTo(400, 300);      this.ctx.stroke();    }else if(e.newValue == 'value2'){      this.ctx.clearRect(0, 0, 600, 500);      // 上      this.ctx.beginPath();      this.ctx.moveTo(100, 150);      // 二次贝赛尔曲线的路径      this.ctx.quadraticCurveTo(300, 50, 500, 150);      this.ctx.stroke();      // 左      this.ctx.beginPath();      this.ctx.moveTo(200, 150);      this.ctx.quadraticCurveTo(250, 250, 250, 400);      this.ctx.stroke();      // 右      this.ctx.beginPath();      this.ctx.moveTo(400, 150);      this.ctx.quadraticCurveTo(350, 250, 350, 400);      this.ctx.stroke();    }else if(e.newValue == 'value3'){      this.ctx.clearRect(0, 0, 600, 500);      // 下      this.ctx.beginPath();      this.ctx.moveTo(100, 200);      // 三次贝赛尔曲线的路径      this.ctx.bezierCurveTo(150, 100, 200, 100,250, 200);      this.ctx.stroke();      // 左      this.ctx.beginPath();      this.ctx.moveTo(350, 200);      this.ctx.bezierCurveTo(400, 100, 450, 100,500, 200);      this.ctx.stroke();      // 右      this.ctx.beginPath();      this.ctx.moveTo(200, 350);      this.ctx.bezierCurveTo(250, 500, 350, 500, 400, 350);      this.ctx.stroke();    }else if(e.newValue == 'value4'){      this.ctx.clearRect(0, 0, 600, 500);      this.ctx.beginPath();      this.ctx.moveTo(100, 200);      // 弧线      this.ctx.arcTo(150, 300, 350, 300, 150);      this.ctx.stroke();      this.ctx.beginPath();      // 椭圆      this.ctx.ellipse(400, 250, 50, 100, Math.PI * 0.25, Math.PI * 0.5 , Math.PI , 1);      this.ctx.stroke();    }else if(e.newValue == 'value5'){      this.ctx.clearRect(0, 0, 600, 500);      // 左上      this.ctx.beginPath();      // 在线段相连处绘制一个扇形      this.ctx.lineJoin = 'round';      this.ctx.moveTo(100, 100);      this.ctx.lineTo(200, 200);      this.ctx.lineTo(100, 250);      this.ctx.stroke();      // 左下      this.ctx.beginPath();      // 在线段相连处使用三角形为底填充      this.ctx.lineJoin = 'bevel';      this.ctx.moveTo(100, 300);      this.ctx.lineTo(200, 400);      this.ctx.lineTo(100, 450);      this.ctx.stroke();      // 右上      this.ctx.beginPath();      //线条相交处内角和外角的距离      this.ctx.lineJoin = 'miter';      this.ctx.miterLimit = 3;      this.ctx.moveTo(400, 100);      this.ctx.lineTo(450, 200);      this.ctx.lineTo(400, 250);      // 结束当前路径形成一个封闭路径      this.ctx.closePath();      this.ctx.stroke();      // 右下      this.ctx.beginPath();      this.ctx.lineJoin = 'miter';      this.ctx.miterLimit = 10;      this.ctx.moveTo(400, 300);      this.ctx.lineTo(450, 400);      this.ctx.lineTo(400, 450);      this.ctx.closePath();      this.ctx.stroke();    }  },}    画边框 全局定义画布（el）及画笔（ctx），初始化创建一个边框宽度为5的长方形。对边框的宽度（lineWidth）、颜色（strokeStyle）、虚化程度（setLineDash）进行改变，选用select组件添加change事件，下拉选择时触发change事件后画出改变后的图形。 已复制<!-- xxx.hml --><div class="container">  <canvas ref="canvas1"></canvas>  <select @change="change">    <option value="value1">strokeRect</option>    <option value="value2">arc</option>    <option value="value3">lineDashRect</option>    <option value="value4">fillRect</option>  </select></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}select{  margin-top: 50px;  width: 250px;  height: 100px;  background-color: white;} 已复制// xxx.jsexport default {  data:{    el: null,    ctx: null,  },  onShow(){    this.el = this.$refs.canvas1;    this.ctx = this.el.getContext("2d",{antialias: true});    this.ctx.lineWidth = 5;    this.ctx.strokeRect(200, 150, 200, 200);  },  change(e){    if(e.newValue == 'value1'){      // 清除画布上的内容      this.ctx.clearRect(0,0,600,500);      // 边框宽度      this.ctx.lineWidth = 5;      // 边框颜色      this.ctx.strokeStyle = '#110000';      // 边框的虚化程度      this.ctx.setLineDash([0,0]);      // 画具有边框的矩形      this.ctx.strokeRect(200, 150, 200, 200);    }else if (e.newValue == 'value2'){      this.ctx.clearRect(0,0,600,500);      this.ctx.lineWidth = 30;      this.ctx.strokeStyle = '#0000ff';      this.ctx.setLineDash([0,0]);      // 画圆      this.ctx.arc(300, 250, 150,0,6.28);      //进行边框绘制      this.ctx.stroke();    }else if (e.newValue == 'value3'){      this.ctx.clearRect(0,0,600,500);      this.ctx.lineWidth = 5;      this.ctx.setLineDash([5,5]);      this.ctx.strokeRect(200, 150, 200, 200);    }else if (e.newValue == 'value4'){      this.ctx.clearRect(0,0,600,500);      // 画一个有填充颜色的矩形      this.ctx.fillStyle = '#0000ff';      this.ctx.fillRect(200, 150, 200, 200);    }  },}    填充渐变色 添加createLinearGradient和createRadialGradient属性创建渐变容器，接着用addColorStop方法添加多个色块组成渐变色，再设置fillStyle为gradient将渐变色填充到矩形中，最后设置阴影的模糊级别（shadowBlur）、阴影颜色（shadowColor）及阴影偏移量（shadowOffset）。 已复制<!-- xxx.hml --><div class="container">  <canvas ref="canvas1"></canvas>  <select @change="change">    <option value="value1">LinearGradient</option>    <option value="value2">RadialGradient</option>    <option value="value3">shadowBlur</option>    <option value="value4">shadowOffset</option>  </select></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}select{  margin-top: 50px;  width: 250px;  height: 100px;  background-color: white;} 已复制// xxx.jsexport default {  data:{    el: null,    ctx: null,  },  onShow(){    this.el = this.$refs.canvas1;    this.ctx = this.el.getContext("2d",{antialias: true});    // 创建一个线性渐变色    let gradient = this.ctx.createLinearGradient(100,100, 400,300);    // 添加渐变颜色    gradient.addColorStop(0.0, 'red');    gradient.addColorStop(0.7, 'white');    gradient.addColorStop(1.0, 'green');    // 填充颜色为渐变色    this.ctx.fillStyle = gradient;    this.ctx.fillRect(100, 100, 400, 300);  },  change(e){    if(e.newValue == 'value1'){      // 清除画布上的内容      this.ctx.clearRect(0,0,600,500);      let gradient = this.ctx.createLinearGradient(100,100, 400,300);      gradient.addColorStop(0.0, 'red');      gradient.addColorStop(0.7, 'white');      gradient.addColorStop(1.0, 'green');      this.ctx.fillStyle = gradient;      // 设置绘制阴影时的模糊级别      this.ctx.shadowBlur = 0;      // 绘制阴影时和原有对象的垂直偏移值      this.ctx.shadowOffsetY = 0;      // 绘制阴影时和原有对象的水平偏移值      this.ctx.shadowOffsetX = 0;      this.ctx.fillRect(100, 100, 400, 300);    }else if(e.newValue == 'value2'){      this.ctx.clearRect(0,0,600,500);      // 创建一个径向渐变色      let gradient = this.ctx.createRadialGradient(300,250,20,300,250,100);      gradient.addColorStop(0.0, 'red');      gradient.addColorStop(0.7, 'white');      gradient.addColorStop(1.0, 'green');      this.ctx.shadowBlur = 0;      this.ctx.shadowOffsetY = 0;      this.ctx.shadowOffsetX = 0;      this.ctx.fillStyle = gradient;      this.ctx.fillRect(100, 100, 400, 300);    }else if(e.newValue == 'value3'){      this.ctx.clearRect(0,0,600,500);      let gradient = this.ctx.createLinearGradient(100,100, 400,400);                   gradient.addColorStop(0.0, 'red');          gradient.addColorStop(0.5, 'white');          gradient.addColorStop(1, '#17ea35');      // 设置绘制阴影时的模糊级别      this.ctx.shadowBlur = 30;      // 绘制阴影时的阴影颜色      this.ctx.shadowColor = 'rgb(229, 16, 16)';      this.ctx.fillStyle = gradient;      this.ctx.fillRect(100, 100, 400, 300);    }else if(e.newValue == 'value4'){      this.ctx.clearRect(0,0,600,500);      this.ctx.clearRect(0,0,600,500);      let gradient = this.ctx.createRadialGradient(300,250,20,300,250,200);            gradient.addColorStop(0.0, 'red');           gradient.addColorStop(0.5, 'white');           gradient.addColorStop(1, '#17ea35');      // 设置绘制阴影时的模糊级别      this.ctx.shadowBlur = 30;           this.ctx.shadowOffsetY = 30;      // 绘制阴影时的阴影颜色      this.ctx.shadowColor = 'rgb(23, 1, 1)';      this.ctx.fillStyle = gradient;      this.ctx.fillRect(100, 100, 400, 300);    }  },}    填充文字 先创建文本，再用fillText方法把文字写在画布上。通过globalAlpha属性改变基线透明度，使基线不会挡住文字，再设置textAlign和textBaseline属性确定文字基于基线的位置。 已复制<!-- xxx.hml --><div class="container">  <canvas ref="canvas1"></canvas>  <select @change="change">    <option value="value1">text</option>    <option value="value2">textBaseline</option>    <option value="value3">textAlign</option>  </select></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}select{  margin-top: 50px;  width: 250px;  height: 100px;  background-color: white;} 已复制// xxx.jsexport default {  data:{    el: null,    ctx: null,  },  onShow(){    this.el = this.$refs.canvas1;    this.ctx = this.el.getContext("2d",{antialias: true});    // 创建文本    let text = "Hello World";    // 设置字体    this.ctx.font = '30px';    this.ctx.fillText("with:"+this.ctx.measureText(text).width, 200, 300);    // 填充字体文本    this.ctx.fillText(text, 200, 250);  },  change(e){    if(e.newValue == 'value1'){      // 清除画布上的内容      this.ctx.clearRect(0,0,600,500);      // 开始新的路径      this.ctx.beginPath();      // 初始化textAlign值      this.ctx.textAlign = 'left';      // 初始化textBaseline      this.ctx.textBaseline = 'alphabetic';      // 设置字体      this.ctx.font = '30px';      let text = "Hello World";      // 获取字体width      this.ctx.fillText("with:"+this.ctx.measureText(text).width, 200, 300);      // 填充字体文本      this.ctx.fillText(text, 200, 250);    }else if(e.newValue == 'value2'){      this.ctx.clearRect(0,0,600,500);      this.ctx.beginPath();      // 设置透明度      this.ctx.globalAlpha = 0.1;      // 设置线宽度      this.ctx.lineWidth = 10;      // 设置线段颜色      this.ctx.strokeStyle = '#0000ff';      // 从当前点移动到指定点      this.ctx.moveTo(0, 240);      // 当前点到指定点进行路径连接      this.ctx.lineTo(600, 240);      this.ctx.stroke();      this.ctx.font = '35px';      this.ctx.globalAlpha = 1;      // 初始化textAlign值      this.ctx.textAlign = 'left';      // 设置textBaseline      this.ctx.textBaseline = 'top';      this.ctx.fillText('Top', 50, 240);      this.ctx.textBaseline = 'bottom';      this.ctx.fillText('Bottom', 200, 240);      this.ctx.textBaseline = 'middle';      this.ctx.fillText('Middle', 400, 240);    }else if(e.newValue == 'value3'){      // 清除画布上的内容      this.ctx.clearRect(0,0,600,500);      this.ctx.beginPath();      this.ctx.globalAlpha = 0.1;      this.ctx.lineWidth = 10;      this.ctx.strokeStyle = '#0000ff';      this.ctx.moveTo(300, 0);      this.ctx.lineTo(300, 500);      this.ctx.stroke();      this.ctx.font = '35px';      this.ctx.globalAlpha = 1;      // 初始化 textBaseline      this.ctx.textBaseline = 'alphabetic';      // 设置textAlign      this.ctx.textAlign = 'left';      this.ctx.fillText('textAlign=left',300, 100);      this.ctx.textAlign = 'center';      this.ctx.fillText('textAlign=center',300, 250);      this.ctx.textAlign = 'right';      this.ctx.fillText('textAlign=right',300, 400);    }  }}  
说明
 ltr布局模式下start和left一致，rtl布局模式下start和right一致·。 
   添加图片 创建图片对象后使用drawImage属性画出图片，给图片设置一些动画样式如scale（缩放）、translate（平移）或rotate（旋转）。 已复制<!-- xxx.hml --><div class="container">  <div class="content">    <canvas ref="canvas0"></canvas>    <text onclick="change">change</text>    <canvas ref="canvas1"></canvas>    <text onclick="rotate">rotate</text>    <canvas ref="canvas2"></canvas>    <text onclick="scale">scale</text>    <canvas ref="canvas3"></canvas>    <text onclick="translate" style="width: 300px;">translate</text>    <canvas ref="canvas4"></canvas>    <text onclick="transform" style="width: 300px;">transform</text>    <canvas ref="canvas5"></canvas>    <text onclick="setTransform" style="width: 300px;">setTransform</text>    <canvas ref="canvas6"></canvas>  </div></div> 已复制/* xxx.css */.container{  width: 100%;  flex-direction: column;  background-color: #F1F3F5;  align-items: center;}canvas{  width: 600px;  height: 300px;  margin-bottom: 100px;  background-color: #fdfdfd;  border: 5px solid red;}.content{  width: 80%;  margin-top: 50px;  margin-bottom: 50px;  display: flex;  flex-wrap: wrap;  justify-content: space-around;}text{  font-size: 35px;  width: 200px;  height: 80px;  color: white;  border-radius: 20px;  text-align: center;  background-color: #6060e7;  margin-bottom: 30px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data:{    compositeOperation: 'source-over'  },  onShow(){    let ctx = this.$refs.canvas0.getContext("2d");    // 创建图片对象    let img = new Image();    // 设置图片路径    img.src = 'common/images/2.png';    // 设置图片宽度    img.width= 150;    // 设置图片高度    img.height=150;    // 图片平铺容器    var pat = ctx.createPattern(img, 'repeat');ctx.fillStyle = pat;    ctx.fillRect(0, 0, 600, 300);  },  change(){    // 创建画布后得到画笔    let ctx = this.$refs.canvas1.getContext("2d");    ctx.clearRect(0,0,600,1000);    if(this.compositeOperation == "source-over"){      this.compositeOperation = "destination-over";    }else{      this.compositeOperation = "source-over";    }    ctx.globalCompositeOperation = this.compositeOperation;    let img = new Image();    img.src = 'common/images/2.png';    // 图片成功获取触发方法    img.onload = function() {      ctx.drawImage(img, 150, 20, 200, 200);    };    let img1 = new Image();    img1.src = 'common/images/3.png';    img1.onload = function() {      // 画上图片      ctx.drawImage(img1, 250, 80, 200, 200);    };    // 图片获取失败触发方法    img1.onerror = function() {      promptAction.showToast({message:"error",duration:2000})    };  },  rotate(){    let ctx = this.$refs.canvas2.getContext("2d");    ctx.clearRect(0,0,600,300);    // 旋转    ctx.rotate(10 * Math.PI / 180);    let img = new Image();    img.src = 'common/images/2.png';    img.onload = function() {      ctx.drawImage(img, 300, 0, 100, 100);    };  },  scale(){    let ctx = this.$refs.canvas3.getContext("2d");    ctx.clearRect(0,0,600,200);    // 缩放    ctx.scale(1.3,1.2);    let img = new Image();    img.src = 'common/images/2.png';    img.onload = function() {      ctx.drawImage(img, 0, 0, 50, 50);    };  },  translate(){    let ctx = this.$refs.canvas4.getContext("2d");    ctx.clearRect(0,0,600,300);    ctx.translate(10,0);    let img = new Image();    img.src = 'common/images/2.png';    img.onload = function() {      ctx.drawImage(img, 0, 50, 300, 200);    };  },  transform(){    let ctx = this.$refs.canvas5.getContext("2d");    ctx.clearRect(0,0,600,300);    ctx.transform(1.1, 0.1, 0.1, 1, 10, 0);    let img = new Image();    img.src = 'common/images/2.png';    img.onload = function() {      ctx.drawImage(img, 0, 50, 100, 100);     };  },  setTransform(){    let ctx = this.$refs.canvas6.getContext("2d");    ctx.clearRect(0,0,600,300);    ctx.setTransform(1.1, 0.1, 0.1, 1, 10, 0);    let img = new Image();    img.src = 'common/images/2.png';    img.onload = function() {      ctx.drawImage(img, 0, 50, 100, 100);    };  },}  
说明
  setTransfrom方法使用的参数和transform()方法相同，但setTransform()方法会重置现有的变换矩阵并创建新的变换矩阵。 变换后的坐标计算方式（x和y为变换前坐标，x'和y'为变换后坐标）： x' = scaleX * x + skewY * y + translateX y' = skewX * x + scaleY * y + translateY  
   添加方法 save方法可对画笔样式进行存储，restore可对存储的画笔进行恢复。如下面的示例，先设置画笔为红色，在保存画笔后对画布进行清除并改变画笔为蓝色，当我们直接使用画笔时会画出一个蓝色矩形，对存储的画笔进行恢复后就可画出红色矩形。 已复制<!-- xxx.hml --><div class="container">  <div class="content">    <canvas ref="canvas"></canvas>  </div>  <div class="content">    <text onclick="save">save</text>    <text onclick="clear">clear</text>    <text onclick="restore">restore</text>  </div></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;  align-items: center;}canvas{  margin-top: 300px;  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}.content{  width: 80%;  margin-top: 50px;  margin-bottom: 50px;  display: flex;  flex-wrap: wrap;  justify-content: space-around;}text{  width: 150px;  height: 80px;  color: white;  border-radius: 20px;  text-align: center;  background-color: #6060e7;  margin-bottom: 30px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data:{    ctx: '',  },  onShow(){    this.ctx = this.$refs.canvas.getContext("2d");    this.ctx.fillStyle = "red"    this.ctx.fillRect(200, 150, 200, 200);  },  save(){    // 画笔储存    this.ctx.save();    promptAction.showToast({message:"save succeed"});  },  clear(){     this.ctx.clearRect(0,0,600,500);    // 该变画笔颜色    this.ctx.fillStyle = "#2133d2";  },  restore(){    this.ctx.beginPath();    // 画笔恢复    this.ctx.restore();        this.ctx.fillRect(200, 150, 200, 200);  },}    上一篇 Canvas对象 下一篇 Path2D对象 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建chart组件设置图表类型设置图表属性添加数据场景示例chart开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  chart为图表组件，用于呈现线形图、柱状图和量规图界面。具体用法请参考chart。  创建chart组件 在pages/index目录下的hml文件中创建一个chart组件。 已复制<!-- xxx.hml --><div class="container">  <chart class="chart-data" type="line" options="{{lineOps}}" datasets="{{lineData}}"></chart></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.chart-data {  width: 700px;  height: 600px;} 已复制// xxx.jsexport default {  data: {    lineData: [      {        data: [763, 550, 551, 554, 731, 654, 525, 696, 595, 628, 791, 505, 613, 575, 475, 553, 491, 680, 657, 716]      }    ],    lineOps: {      xAxis: {        min: 0,        max: 20,        display: false,      },      yAxis: {        min: 0,        max: 1000,        display: false,      },      series: {        lineStyle: {          width: 15,        },      }    },  }}    设置图表类型 chart组件通过设置type属性定义图表t类型，如将图表设置为柱状图。 已复制<!-- xxx.hml --><div class="container">  <div class="container">    <div class="switch-block">      <text class="title">        {{ title }}      </text>    </div>    <tabs class="tabs" index="0" vertical="false" onchange="changes">      <tab-content class="tabcontent" scrollable="true">        <tabs >          <tab-bar class="tab-bar" mode="fixed"style="margin-bottom: 50px;">            <text class="tab-text">线形图</text>            <text class="tab-text">柱状图</text>            <text class="tab-text">量规图</text>          </tab-bar>          <tab-content>            <div class="bar-block" style="margin-left: 30px;">              <chart class="chart-data" type="line" ref="linechart" options="{{ lineOps }}" datasets="{{ lineData }}">              </chart>            </div>            <div class="bar-block">              <chart class="data-bar" type="bar" id="bar-chart" options="{{ barOps }}" datasets="{{ barData }}">              </chart>            </div>            <div class="chart-block">              <chart type="gauge" ></chart>            </div>          </tab-content>        </tabs>      </tab-content>    </tabs>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  background-color: #F1F3F5;}.tab-bar{  background-color: #F1F3F5;}.chart-data {  width: 700px;  height: 600px;}.title{  margin-left: 50px;  margin-top: 50px;  font-size: 50px;}.line-block{  align-items: center;  justify-content: center;}.bar-block{  align-items: center;  justify-content: center;}.chart-block{  width: 90%;  margin-left: 30px;} 已复制// xxx.jsexport default {  data: {    title: "类型展示",    barData: [      {        fillColor: '#3848e8',        data: [763, 550, 551, 554, 731, 654, 525, 696, 595],      }    ],    lineData: [      {        strokeColor: '#0081ff',        fillColor: '#cce5ff',        data: [763, 550, 551, 554, 731, 654, 525, 696, 595, 628, 791, 505, 613, 575, 475, 553, 491, 680, 657, 716],        gradient: true,      }    ],    lineOps: {      xAxis: {        min: 0,        max: 20,        display: false,      },      yAxis: {        min: 0,        max: 1000,        display: false,      },      series:{        lineStyle: {          width: "5px",          smooth: true,        },        headPoint: {          shape:"circle",          size: 20,          strokeWidth: 5,          fillColor: '#ffffff',          strokeColor: '#007aff',          display: true,        },        loop:{          margin: 2,          gradient: true        }      },    },    barOps: {      xAxis: {        min: 0,        max: 20,        display: false,        axisTick: 10,      },      yAxis: {        min: 0,        max: 1000,      },    },  },}  
说明
 chart不支持显示每个点的值。 
   设置图表属性 chart组件在options属性中设置对x轴、y轴和数据序列参数的设置，在datasets属性里添加对线条颜色、填充颜色、填充渐变颜色和绘制点集的设置。 已复制<!-- xxx.hml --><div class="container">  <chart class="chart-data" type="line" options="{{lineOps}}" datasets="{{lineData}}"></chart></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.chart-data {  width: 700px;  height: 600px;} 已复制// xxx.jsexport default {  data: {    //线形图数据    lineData: [      {        strokeColor: '#0081ff',        fillColor: '#cce5ff',  //填充色        data: [463, 250, 251, 254, 431, 354, 225, 396, 295, 328, 491, 205, 313, 275, 475, 553, 491, 380, 357, 416],        gradient: true,      }    ],    lineOps: {     //x轴参数设置      xAxis: {        min: 0,        max: 20,        display: false,      },     //y轴参数设置      yAxis: {        min: 0,        max: 1000,        display: false,      },     //数据序列参数设置      series: {        //线样式设置        lineStyle: {          width: "5px",          smooth: true,        },        //线最前端位置白点的样式和大小        headPoint: {          shape: "circle",          size: 20,          strokeWidth: 5,          fillColor: '#ffffff',          strokeColor: '#007aff',          display: true,        },        //设置屏幕显示满时，是否需要重头开始绘制        loop: {          margin: 2,          gradient: true        }      }    },  },} 
说明
  options只支持柱状图和线形图设置参数，量规图不生效。 datasets只支持柱状图和线形图设置数据集合，量规图不生效。 series只有线形图支持。  
   添加数据 通过chart组件的append方法，实现动态添加数据。 已复制<!-- xxx.hml --><div class="container">  <stack class="chart-region">    <chart class="chart-data" type="line" ref="linechart" options="{{lineOps}}" datasets="{{lineData}}"></chart>  </stack>  <button value="Add data" onclick="addData"></button></div> 已复制/* xxx.css */.container {  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.chart-region {  height: 400px;  width: 700px;}.chart-data {  width: 700px;  height: 600px;}button {  width: 100%;  height: 50px;  background-color: #F4F2F1;  text-color: #0C81F3;  margin-top: 30px;} 已复制// xxx.jsexport default {  data: {    lineData: [      {        strokeColor: '#de0b6e',        fillColor: '#bb09a3',        data: [763, 550, 551, 554, 731, 654, 525, 696, 595, 628, 791, 505, 613, 575, 475, 553, 491, 680, 657, 716],        gradient: true,      }    ],    lineOps: {      xAxis: {      min: 0,      max: 20,      display: false,      },      yAxis: {        min: 0,        max: 1000,        display: false,      },      series: {        lineStyle: {          width: "5px",          smooth: true,        },        headPoint: {          shape: "circle",          size: 20,          strokeWidth: 5,          fillColor: '#ffffff',          strokeColor: '#f8145c',          display: true,        },        loop: {          margin: 2,          gradient: true,        }      }    },  },  addData() {        this.$refs.linechart.append({          serial: 0,              data: [Math.floor(Math.random() * 400) + 200]        })    }}    场景示例 开发者可以根据开关Switch的状态来选择数据展示的状态，当Switch状态为true时，通过定时器来实现数据的动态展示。 已复制<!-- xxx.hml --><div class="container">  <div class="container">    <div class="switch-block">      <text class="title">{{ title }} </text>      <switch class="switch" showtext="{{ showText }}" allow-scale="{{ allowScale }}"onchange="change">      </switch>    </div>    <tabs class="tabs" index="0" vertical="false" onchange="changes">      <tab-content class="tabcontent" scrollable="true">        <div>          <tabs class="tabs" index="0" vertical="false" onchange="changes">            <tab-content class="tabcontent" scrollable="true">              <div class="line-class">                <div class="bar-block">                  <chart class="chart-data" type="line" ref="linechart" options="{{ lineOps }}"                     datasets="{{ lineData }}">                  </chart>                </div>                <div class="bar-block">                  <chart class="data-bar" type="bar" id="bar-chart" options="{{ barOps }}"datasets="{{ barData }}">                  </chart>                </div>             </div>           </tab-content>         </tabs>       </div>       <div>         <div class="container">           <list class="todo-wrapper">             <list-item for="{{ barData }}" class="todo-item">               <text class="todo-title">{{ $item.data }}</text>             </list-item>           </list>           <list class="todo-wrapper">             <list-item for="{{ lineData.data }}" class="todo-item">               <text class="todo-title">{{ $item.value }}</text>             </list-item>           </list>         </div>       </div>      </tab-content>    </tabs>  </div></div> 已复制/* xxx.css */.container{  display:flex;  flex-direction:column;  background-color: #F1F3F5;}.line-class{  display: flex;  flex-direction: column;}.title{  font-size: 40px;  margin-left: 40px;}.switch-block {  margin-top: 30px;  width: 98%;  height: 80px;  display: flex;  justify-content: space-between;}.switch{  font-size: 40px;}.bar-block {  margin-top: 80px;  margin-left: 40px;  position: relative;  width: 90%;  border-radius: 10px;  background-color: #25FAB27B;  height: 40%;  justify-content: center;} 已复制// xxx.jsexport default {  data: {    interval: null,    title: "数据展示",    allowScale: true,    dataLength: 30,    barGroup: 3,    lineData: null,    lineOps: {      xAxis: {        min: 0,        max: 5      },      yAxis: {        min: 0,        max: 100      },      series: {        lineStyle: {        width: '1px',      },        headPoint: {          shape: 'circle',          size: 10,          strokeWidth: 2,          fillColor: '#ffffff',          strokeColor: '#8477DF'        },        loop: {          margin: 2        }      }    },    barData: [      {        fillColor: '#97CF0A2C',        data: [20, 20,40, 56]      },      {        fillColor: '#6D0A7ACF',        data: [52, 40, 2, 67]      },      {        fillColor: '#6A0ACFA1',        data: [56, 2, 77, 40]      }    ],    barOps: {      xAxis: {        min: 0,        max: 20,        axisTick: 5      },      yAxis: {        min: 0,        max: 100      }    }  },  onInit() {    this.changeLine();  },  change(e) {    if (e.checked) {      this.interval = setInterval(() => {        this.changeLine();        this.changeBar();      }, 1000)    } else {      clearInterval(this.interval);    }  },  changeLine() {    var dataArray = [];    for (var i = 0; i < this.dataLength; i++) {      var nowValue = Math.floor(Math.random() * 99 + 1);      var obj = {        "value": nowValue,        "description": nowValue + "",        "textLocation": "top",        "textColor": "#CDCACA",        "pointStyle": {          "shape": "circle",          "size": 5,          "fillColor": "#CF0A2C",          "strokeColor": "#CF0A2C"        }      };      dataArray.push(obj);    }    this.lineData = [      {        strokeColor: '#0081ff',        fillColor: '#FF07CDC4',        data: dataArray,        gradient: true,      }    ]  },  changeBar() {    for (var i = 0;i < this.barGroup; i++) {      var dataArray = this.barData[i].data;      for (var j = 0;j < 4; j++) {        dataArray[j] = Math.floor(Math.random() * 99 + 1);      }    }    this.barData = this.barData.splice(0, this.barGroup + 1);  },  changes(e) {    console.log("Tab index: " + e.index);  },}
    上一篇 slider开发指导 下一篇 switch开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建dialog组件设置弹窗响应场景示例dialog开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  dialog组件用于创建自定义弹窗，通常用来展示用户当前需要或用户必须关注的信息或操作。具体用法请参考dialog API。  创建dialog组件 在pages/index目录下的hml文件中创建一个dialog组件，并添加Button组件来触发dialog。dialog组件仅支持width、height、margin、margin-[left|top|right|bottom]、margin-[start|end]样式。 已复制<!-- xxx.hml --><div class="doc-page">  <dialog class="dialogClass" id="dialogId" dragable="true">    <div class="content">      <text>this is a dialog</text>    </div>  </dialog>  <button value="click me" onclick="opendialog"></button></div> 已复制/* xxx.css */.doc-page {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.dialogClass{  width: 80%;  height: 250px;  margin-start: 1%;}.content{  width: 100%;  height: 250px;  justify-content: center;  background-color: #e8ebec;  border-radius: 20px;}text{  width: 100%;  height: 100%;  text-align: center;}button{  width: 70%;  height: 60px;} 已复制// xxx.jsexport default {  //Touch to open the dialog box.  opendialog(){    this.$element('dialogId').show()  },}    设置弹窗响应 开发者点击页面上非dialog的区域时，将触发cancel事件而关闭弹窗。同时也可以通过对dialog添加show和close方法来显示和关闭弹窗。 已复制<!-- xxx.hml --><div class="doc-page">  <dialog class="dialogClass" id="dialogId" oncancel="canceldialog">    <div class="dialogDiv">      <text>dialog</text>      <button value="confirm" onclick="confirmClick"></button>    </div>  </dialog>  <button value="click me" onclick="opendialog"></button></div> 已复制/* xxx.css */.doc-page {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.dialogClass{  width: 80%;  height: 300px;  margin-start: 1%;}.dialogDiv{  width: 100%;  flex-direction: column;  justify-content: center;  align-self: center;}text{  height: 100px;  align-self: center;}button{  align-self: center;  margin-top: 20px;  width: 60%;  height: 80px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  canceldialog(e){    promptAction.showToast({      message: 'dialogCancel'    })  },  opendialog(){    this.$element('dialogId').show()     promptAction.showToast({      message: 'dialogShow'    })  },  confirmClick(e) {    this.$element('dialogId').close()    promptAction.showToast({      message: 'dialogClose'    })  },}  
说明
  仅支持单个子组件。 dialog属性、样式均不支持动态更新。 dialog组件不支持focusable、click-effect属性。  
   场景示例 在本场景中，开发者可以通过dialog组件实现一个日程表。弹窗在打开状态下，利用Textarea组件输入当前日程，点击确认按钮后获取当前时间并保存输入文本。最后以列表形式将各日程进行展示。 已复制<!-- xxx.hml --><div class="doc-page">  <text style="margin-top: 60px;margin-left: 30px;">    <span>{{date}} events</span>  </text>  <div class="btndiv">    <button type="circle" class="btn" onclick="addschedule">+</button>  </div><!--  for Render events data  -->  <list style="width: 100%;">    <list-item type="item" for="schedulelist" style="width:100%;height: 200px;">      <div class="schedulediv">        <text class="text1">{{date}}  event</text>        <text class="text2">{{$item.schedule}}</text>      </div>    </list-item>  </list>  <dialog id="datedialog" oncancel="canceldialog" >    <div class="dialogdiv">      <div class="innertxt">        <text class="text3">{{date}}</text>        <text class="text4">New event</text>      </div>      <textarea placeholder="Event information" onchange="getschedule" class="area" extend="true"></textarea>      <div class="innerbtn">        <button type="text" value="Cancel" onclick="cancelschedule" class="btntxt"></button>        <button type="text" value="OK" onclick="setschedule" class="btntxt"></button>      </div>    </div>  </dialog></div> 已复制/* xxx.css */.doc-page {  flex-direction: column;  background-color: #F1F3F5;}.btndiv {  width: 100%;  height: 200px;  flex-direction: column;  align-items: center;  justify-content: center;}.btn {  radius:60px;  font-size: 100px;  background-color: #1E90FF;}.schedulediv {  width: 100%;  height: 200px;  flex-direction: column;  justify-content: space-around;  padding-left: 55px;}.text1 {  color: #000000;  font-weight: bold;  font-size: 39px;}.text2 {  color: #a9a9a9;  font-size: 30px;}.dialogdiv {  flex-direction: column;  align-items: center;}.innertxt {  width: 320px;  height: 160px;  flex-direction: column;  align-items: center;  justify-content: space-around;}.text3 {  font-family: serif;  color: #1E90FF;  font-size: 38px;}.text4 {  color: #a9a9a9;  font-size: 33px;}.area {  width: 320px;  border-bottom: 1px solid #1E90FF;}.innerbtn {  width: 320px;  height: 120px;  justify-content: space-around;}.btntxt {  text-color: #1E90FF;} 已复制// xxx.jsvar info = null;import promptAction from '@ohos.promptAction';
export default {  data: {    curYear:'',    curMonth:'',    curDay:'',    date:'',    schedule:'',    schedulelist:[]  },  onInit() {    // Obtain the current date.     var date = new Date();    this.curYear = date.getFullYear();    this.curMonth = date.getMonth() + 1;    this.curDay = date.getDate();    this.date = this.curYear + '-' + this.curMonth + '-' + this.curDay;    this.schedulelist = []  },  addschedule(e) {    this.$element('datedialog').show()  },  canceldialog(e) {    promptAction.showToast({      message: 'Event setting canceled.'    })  },  getschedule(e) {    info = e.value  },  cancelschedule(e) {    this.$element('datedialog').close()    promptAction.showToast({      message: 'Event setting canceled.'    })  },//    Touch OK to save the data.  setschedule(e) {    if (e.text === '') {      this.schedule = info    } else {      this.schedule = info      var addItem =  {schedule: this.schedule,}      this.schedulelist.push(addItem)    }    this.$element('datedialog').close()  }}    上一篇 list开发指导 下一篇 form开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建form组件实现表单缩放设置form样式添加响应事件场景示例form开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  form是一个表单容器，支持容器内Input组件内容的提交和重置。具体用法请参考form API。 
说明
 从 API Version 6 开始支持。 
  创建form组件 在pages/index目录下的hml文件中创建一个form组件。 已复制<!-- xxx.hml --><div class="container">  <form style="width: 100%; height: 20%">      <input type="text" style="width:80%"></input>  </form></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}    实现表单缩放 为form组件添加click-effect属性，实现点击表单后的缩放效果，click-effect枚举值请参考通用属性。 已复制<!-- xxx.hml --><div class="container">  <form  id="formId" class="formClass" click-effect="spring-large">    <input type="text"></input>    </form></div>   设置form样式 通过为form添加background-color和border属性，来设置表单的背景颜色和边框。 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.formClass{  width: 80%;  height: 100px;  padding: 10px;  border: 1px solid #cccccc;}    添加响应事件 为form组件添加submit和reset事件，来提交表单内容或重置表单选项。 已复制<!-- xxx.hml --><div class="container">  <form onsubmit='onSubmit' onreset='onReset' class="form">    <div style="width: 100%;justify-content: center;">      <label>Option 1</label>      <input type='radio' name='radioGroup' value='radio1'></input>      <label>Option 2</label>      <input type='radio' name='radioGroup' value='radio2'></input>    </div>    <div style="width: 100%;justify-content: center; margin-top: 20px">      <input type="submit" value="Submit" style="width:120px; margin-right:20px;" >         </input>      <input type="reset" value="Reset" style="width:120px;"></input>    </div>  </form></div> 已复制/* index.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-items: center;  align-items: center;  background-color: #F1F3F5;}.form{  width: 100%;  height: 30%;  margin-top: 40%;  flex-direction: column;  justify-items: center;  align-items: center;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default{  onSubmit(result) {    promptAction.showToast({      message: result.value.radioGroup    })  },  onReset() {    promptAction.showToast({      message: 'Reset All'    })  }}    场景示例 在本场景中，开发者可以选择相应选项并提交或重置数据。 创建Input组件，分别设置type属性为checkbox（多选框）和radio（单选框），再使用form组件的onsubmit和onreset事件实现表单数据的提交与重置。 已复制<!-- xxx.hml --><div class="container">   <form onsubmit="formSubmit" onreset="formReset"> <text style="font-size: 30px; margin-bottom: 20px; margin-top: 100px;">      <span > Form </span>  </text>    <div style="flex-direction: column;width: 90%;padding: 30px 0px;">     <text class="txt">Select 1 or more options</text>      <div style="width: 90%;height: 150px;align-items: center;justify-content: space-around;">        <label target="checkbox1">Option 1</label>        <input id="checkbox1" type="checkbox" name="checkbox1"></input>        <label target="checkbox2">Option 2</label>        <input id="checkbox2" type="checkbox" name="checkbox2"></input>       </div>       <divider style="margin: 20px 0px;color: pink;height: 5px;"></divider>       <text class="txt">Select 1 option</text>       <div style="width: 90%;height: 150px;align-items: center;justify-content: space-around;">         <label target="radio1">Option 1</label>         <input id="radio1" type="radio" name="myradio"></input>         <label target="radio2">Option 2</label>         <input id="radio2" type="radio" name="myradio"></input>       </div>       <divider style="margin: 20px 0px;color: pink;height: 5px;"></divider>       <text class="txt">Text box</text>       <input type="text" placeholder="Enter content." style="margin-top: 50px;"></input>       <div style="width: 90%;align-items: center;justify-content: space-between;margin: 40px;">         <input type="submit">Submit</input>         <input type="reset">Reset</input>       </div>    </div>  </form></div> 已复制/* index.css */.container {  width: 100%;  height: 100%;  flex-direction:column;  align-items:center;  background-color:#F1F3F5;}.txt {  font-size:33px;  font-weight:bold;  color:darkgray;}label{  font-size: 20px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  formSubmit() {    promptAction.showToast({      message: 'Submitted.'    })  },  formReset() {    promptAction.showToast({      message: 'Reset.'    })  }}    上一篇 dialog开发指导 下一篇 stepper开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建grid-container组件调用方法添加grid-col场景示例栅格布局 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  栅格布局容器根节点，使用grid-row与grid-col进行栅格布局。具体请参考Grid-container。  创建grid-container组件 在pages/index目录下的hml文件中创建一个grid-container组件，并添加Grid-row子组件。 已复制<!-- index.hml --><div class="container">  <grid-container id="mygrid" gutter="20px" style="background-color: pink;">    <grid-row style="height:100px;justify-content:space-around;width: 80%;background-color: #f67002;margin-left:       10%;"></grid-row>    <grid-row style="height:300px;justify-content:space-around;background-color: #ffcf00;width: 100%;"></grid-row>    <grid-row style="height:150px;justify-content:space-around;background-color: #032cf8;width: 100%;"></grid-row>  </grid-container></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5;  margin-top: 500px;  justify-content: center;  align-items: center;}  
说明
 grid-container仅支持grid-row为子组件。 
   调用方法 grid-container点击组件调用getColumns、getColumnWidth、getGutterWidth方法，返回栅格容器列数、column宽度及gutter宽度。长按调用getSizeType方法返回当前容器响应尺寸类型（xs|sm|md|lg）。 已复制<!-- index.hml --><div class="container">  <grid-container id="mygrid" gutter="20px" style="background-color: pink;padding-top: 100px;"     onclick="getColumns" onlongpress="getSizeType">    <grid-row style="height:100px;justify-content:space-around;background-color: #4cedf3;width: 20%;margin-left:       40%;"></grid-row>    <grid-row style="height:150px;justify-content:space-around;background-color: #4cbff3;width: 50%;margin-left:      25%;"></grid-row>    <grid-row style="height:200px;justify-content:space-around;background-color: #465ff6;width: 80%;margin-left:       10%;"></grid-row>    <grid-row style="height:200px;justify-content:space-around;background-color: #5011ec;width: 100%;"></grid-row>  </grid-container></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5;  margin-top: 400px;  justify-content: center;  align-items: center;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  data:{    gutterWidth:'',    columnWidth:'',    columns:'',  },  getColumns(){    this.$element('mygrid').getColumnWidth((result)=>{      this.columnWidth = result;    })    this.$element('mygrid').getGutterWidth((result)=>{      this.gutterWidth = result;    })    this.$element('mygrid').getColumns((result)=>{      this.columns= result;    })     setTimeout(()=>{                    promptAction.showToast({duration:5000,message:'columnWidth:'+this.columnWidth+',gutterWidth:'+      this.gutterWidth+',getColumns:'+this.columns})    })  },  getSizeType(){      this.$element('mygrid').getSizeType((result)=>{      promptAction.showToast({duration:2000,message:'get size type:'+result})    })  },}    添加grid-col 创建grid-container组件并添加grid-row，在grid-row组件内添加grid-col组件形成布局。 已复制<!-- index.hml --><div class="container">  <grid-container id="mygrid" columns="4" gutter="0" style="background-color: pink;" onclick="getColumns" onlongpress="getSizeType">    <grid-row style="height: 100px;justify-content: space-around;background-color: #4cbff3;width: 100%;">      <grid-col span="0">        <div style="align-items: center;justify-content: center;height: 100%;width: 100%;">          <text style="color: dodgerblue;" onclick="getCol">top</text>        </div>      </grid-col>    </grid-row>    <grid-row style="height:500px;justify-content:space-around;background-color: #3b55ef;width: 100%;">      <grid-col span="0" style="width: 20%;">        <div style="align-items: center;justify-content: center;height: 100%;width: 100%;">          <text style="color: dodgerblue;">left</text>        </div>      </grid-col>      <grid-col span="0" style="background-color:orange;width: 80%;">        <div style="width: 100%;height: 100%;align-items: center;justify-content: center;">          <text>right</text>        </div>      </grid-col>    </grid-row>    <grid-row style="height: 100px;justify-content: space-around;background-color: #4cbff3;width: 100%;">      <grid-col style="background-color:#c075ef;" span="0">        <div style="width: 100%;height: 100%;padding: 20px;align-items: center;justify-content: center;">          <text>bottom</text>        </div>      </grid-col>    </grid-row>  </grid-container></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5;  width: 100%;  height: 100%;  justify-content: center;  align-items: center;}text{  color: white;  font-size: 40px;}  
说明
 grid-row仅支持grid-col为子组件，只能在grid-col组件中添加填充的内容。 
   场景示例 本场景中循环输出list中的内容，创建出网格布局。进行下拉操时触发refresh（刷新页面）方法，这时会向list数组中添加一条数据并设置setTimeout（延迟触发），达到刷新请求数据的效果。 已复制<!-- index.hml --><div class="container">  <refresh refreshing="{{fresh}}" onrefresh="refresh">    <grid-container id="mygrid" gutter="20" style="margin: 10px;">      <grid-row style="height:200px;width: 100%;background-color: #e7e7e2;margin-top: 50px; padding: 0px 20px;border-radius: 15px;" for="item in list">        <grid-col span="0" style="width: 40%;">          <div style="align-items: center;justify-content: center">            <image src="{{item.src}}" style="object-fit: contain;border-radius: 30px;"></image>          </div>        </grid-col>        <grid-col span="0" style="width: 60%;">          <div style="align-items: center;justify-content: center;width: 100%;height: 100%;text-align: center;">            <text>image{{item.id}}</text>          </div>        </grid-col>      </grid-row>    </grid-container>  </refresh></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5;  width: 100%;  height: 100%;}text{  color: #0a0aef;  font-size: 60px;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  data:{    list:[      {src:'common/images/1.png',id:'1'},      {src:'common/images/2.png',id:'2'},      {src:'common/images/3.png',id:'3'}    ],    fresh:false  },  refresh(e) {    promptAction.showToast({      message: 'refreshing'    })    var that = this;    that.fresh = e.refreshing;    setTimeout(function () {      that.fresh = false;      that.list.unshift({src: 'common/images/4.png',id:'4'});      promptAction.showToast({        message: 'succeed'      })    }, 2000)  }}    上一篇 OffscreenCanvasRenderingContext2D对象 下一篇 Svg开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建image-animator组件设置image-animator组件属性绑定事件场景示例image-animator开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  image-animator组件为图片帧动画播放器。具体用法请参考image-animator。  创建image-animator组件 在pages/index目录下的hml文件中创建一个image-animator组件，css文件中编写组件样式，js文件中引用图片。 已复制<!-- xxx.hml --><div class="container">  <image-animator class="animator" images="{{frames}}" duration="3s"/></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.animator {  width: 500px;  height: 500px;} 已复制// index.jsexport default {  data: {    frames: [      {        src: "/common/landscape1.jpg",      },      {        src: "/common/landscape2.jpg",      }    ],  },};    设置image-animator组件属性 添加iteration（播放次数）、reverse（播放顺序）、fixedsize（图片大小是否固定为组件大小）、duration（播放时长）和fillmode（执行结束后的状态）属性，控制图片的播放效果。 已复制<!-- xxx.hml --><div class="container">  <image-animator class="animator" fixedsize="false" iteration='2' reverse="false" ref="animator" fillmode="none" images="{{frames}}"   duration="5s" /></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;}.animator {  width: 500px;  height: 500px;} 已复制// index.jsexport default {  data: {    frames: [      {        src: 'common/landscape1.jpg',        width: '250px',        height: '250px',        left: '150px',        top: '50px',      },      {        src: 'common/landscape2.jpg',        width: '300px',        height: '300px',        left: '150px',        top: '100px',      },      {        src: 'common/landscape1.jpg',        width: '350px',        height: '350px',        left: '150px',        top: '150px',      },      {        src: 'common/landscape2.jpg',        width: '400px',        height: '400px',        left: '150px',        top: '200px',      },      {        src: 'common/landscape3.jpg',        width: '450px',        height: '450px',        left: '150px',        top: '250px',      },      {        src: 'common/landscape4.jpg',        width: '500px',        height: '500px',        left: '150px',        top: '300px',      },    ],  },};  
说明
  如果在images属性中设置了单独的duration属性，在image-animator组件中设置的duration属性无效。 如果fixedsize属性值设置为true，图片的width 、height 、top 和left属性无效。 如果reverse属性值设置为false，表示从第1张图片播放到最后1张图片。 如果reverse属性值设置为true，表示从最后1张图片播放到第1张图片。  
   绑定事件 向image-animator组件添加start、pause、stop和resume事件。当图片播放器开始播放时触发start事件，当图片播放器被点击时触发pause事件，长按图片播放器触发resume事件，图片播放器停止播放时触发stop事件。 已复制<!-- xxx.hml --><div class="doc-page">  <image-animator class="img" id="img" images="{{imginfo}}" iteration="1" duration="10s" onstart="popstart" onpause="poppause"   onstop="popstop" onresume="popresume" onlongpress="setresume" onclick="setpause">  </image-animator></div> 已复制/* xxx.css */.doc-page {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;   background-color: #F1F3F5;}.img {  width: 600px;  height: 600px;  border: 3px solid orange;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  data: {    imginfo: [      {        src: 'common/landscape1.jpg',      },{        src: 'common/landscape2.jpg',      },{        src: 'common/landscape3.jpg',      },{        src: 'common/landscape4.jpg',      }    ],  },  onInit() {  },  setpause(e) {    this.$element('img').pause()  },  setresume(e) {    this.$element('img').resume()  },  popstart(e) {    promptAction.showToast({      message: '开始'    })  },  poppause(e) {    promptAction.showToast({      message: '暂停'    })  },  popstop(e) {    promptAction.showToast({      message: '停止'    })  },  popresume(e) {    promptAction.showToast({      message: '恢复'    })  }}    场景示例 在本场景中，开发者可通过开始播放、停止播放等按钮切换图片的播放状态。 image-animator组件通过调用start、pause、stop和resume方法控制图片的开始、暂停、停止和重新播放，通过getState方法查询图片的播放状态。 已复制<!-- xxx.hml --><div class="doc-page">  <image-animator class="img" id="img" images="{{imginfo}}" iteration="2" reverse="{{rev}}" duration="10s">  </image-animator>  <div style="width: 700px;height:450px;margin-top: 40px;flex-direction:column;justify-content:space-around;">    <div class="container">      <button type="capsule" value="开始播放" onclick="startimg"></button>      <button type="capsule" value="暂停播放" onclick="pauseimg"></button>    </div>    <div class="container">      <button type="capsule" value="停止播放" onclick="stopimg"></button>      <button type="capsule" value="重新播放" onclick="resumeimg"></button>    </div>    <div class="container">      <button type="capsule" value="获取播放状态" onclick="getimgstate"></button>      <button type="capsule" value="{{revVal}}" onclick="revimg"></button>    </div>  </div></div> 已复制/* xxx.css */.doc-page {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.img {  width: 600px;  height: 600px;  border: 3px solid orange;}button{  width: 260px}.container {  width: 100%;  height: 120px;  align-items: center;  justify-content: space-around;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  data: {    rev:false,    imginfo: [      {        src: 'common/landscape1.jpg',      },{        src: 'common/landscape2.jpg',      },{        src: 'common/landscape3.jpg',      },{        src: 'common/landscape4.jpg',      }    ],    revVal: '反向播放'  },  onInit() {  },  startimg(e) {    this.$element('img').start()  },  pauseimg(e) {    this.$element('img').pause()  },  stopimg(e) {    this.$element('img').stop()  },  resumeimg(e) {    this.$element('img').resume()  },  getimgstate(e) {    promptAction.showToast({      message: '当前状态：' + this.$element('img').getState()    })  },  revimg(e) {    this.rev = !this.rev    if (this.rev) {      this.revVal = '正向播放'    } else {      this.revVal = '反向播放'    }  }}    上一篇 image开发指导 下一篇 rating开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建image组件设置image样式加载图片场景示例image开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  image是图片组件，用来渲染展示图片。具体用法请参考image API。  创建image组件 在pages/index目录下的hml文件中创建一个image组件。 已复制<!-- index.hml --><div class="container">  <image style="height: 30%;" src="common/images/bg-tv.jpg"> </image></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}    设置image样式 通过设置width、height和object-fit属性定义图片的宽、高和缩放样式。 已复制<!-- index.hml --><div class="container">  <image src="common/images/bg-tv.jpg"> </image></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color:#F1F3F5;}image{  width: 80%;    height: 500px;  border: 5px solid saddlebrown;  border-radius: 20px;  object-fit: contain;  match-text-direction:true;}    加载图片 图片成功加载时触发complete事件，返回加载的图源尺寸。加载失败则触发error事件，打印图片加载失败。 已复制<!-- index.hml --><div class="container" >  <div>    <image src="common/images/bg-tv.jpg" oncomplete="imageComplete(1)" onerror="imageError(1)"> </image>  </div>  <div>    <image src="common/images/bg-tv1.jpg" oncomplete="imageComplete(2)" onerror="imageError(2)"> </image>  </div></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-self: center;  background-color: #F1F3F5;}.container div{  margin-left: 10%;  width: 80%;  height: 300px;  margin-bottom: 40px;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  imageComplete(i,e){    promptAction.showToast({      message: "image "+i+"'s width"+ e.width+"----image "+i+"'s height"+e.height,      duration: 3000,    })  },  imageError(i,e){    setTimeout(()=>{      promptAction.showToast({        message: "Failed to load image "+i+".",        duration: 3000,      })    },3000)  }}    场景示例 在本场景中，开发者长按图片后将慢慢隐藏图片，当完全隐藏后再重新显示原始图片。定时器setInterval每隔一段时间改变图片透明度,实现慢慢隐藏的效果，当透明度为0时清除定时器，设置透明度为1。 已复制<!-- index.hml --><div class="page-container">  <div class="content">    <div class="image-container">      <image class="testimage" src="{{testuri}}" style="opacity:{{imageopacity}};" onlongpress="changeopacity"> </image>    </div>    <div class="text-container">      <text style="font-size: 37px;font-weight:bold;color:orange;text-align: center;width: 100%;">Touch and hold the image</text>    </div>  </div></div> 已复制/* xxx.css */.page-container {  width: 100%;  height: 100%;  flex-direction:column;  align-self: center;  justify-content: center;  background-color:#F1F3F5;  background-color: #F1F3F5;}.content{  flex-direction:column;}.image-container {  width: 100%;  height: 300px;  align-items: center;  justify-content: center;}.text-container {  margin-top:50px;  width: 100%;  height: 60px;  flex-direction: row;  justify-content: space-between;}.testimage {  width: 100%;  height: 400px;     object-fit: scale-down;    border-radius: 20px;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  data: {    testuri: 'common/images/bg-tv.jpg',    imageopacity:1,    timer: null  },  changeopacity: function () {    promptAction.showToast({      message: 'Touch and hold the image.'    })    var opval = this.imageopacity * 20    clearInterval(this.timer);    this.timer = setInterval(()=>{      opval--;      this.imageopacity = opval / 20      if (opval===0) {        clearInterval(this.timer)        this.imageopacity = 1      }    },100);  }}    上一篇 picker开发指导 下一篇 image-animator开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建input组件设置input类型事件绑定设置输入提示场景示例input开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  input是交互式组件，用于接收用户数据。其类型可设置为日期、多选框和按钮等。具体用法请参考input API。  创建input组件 在pages/index目录下的hml文件中创建一个input组件。 已复制<!-- xxx.hml --><div class="container">         <input type="text">                  Please enter the content    </input></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}    设置input类型 通过设置type属性来定义input类型，如将input设置为button、date等。 已复制<!-- xxx.hml --><div class="container">  <div class="div-button">    <dialog class="dialogClass" id="dialogId">      <div class="content">        <text>this is a dialog</text>      </div>    </dialog>    <input class="button" type="button" value="click" onclick="btnclick"></input>  </div>  <div class="content">    <input onchange="checkboxOnChange" checked="true" type="checkbox"></input>  </div>  <div class="content">    <input type="date" class="flex" placeholder="Enter data"></input>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  align-items: center;  flex-direction: column;  justify-content: center;  background-color: #F1F3F5 ;}.div-button {  flex-direction: column;  align-items: center;}.dialogClass{  width:80%;  height: 200px;}.button {  margin-top: 30px;  width: 50%;}.content{  width: 90%;  height: 150px;  align-items: center;  justify-content: center;}.flex {  width: 80%;  margin-bottom:40px;} 已复制// xxx.jsexport default {  btnclick(){    this.$element('dialogId').show()  },}  
说明
 仅当input类型为checkbox和radio时，当前组件是否选中的属性checked才生效，默认值为false。 
   事件绑定 向input组件添加search和translate事件。 已复制<!-- xxx.hml --><div class="content">  <text style="margin-left: -7px;">    <span>Enter text and then touch and hold what you've entered</span>  </text>  <input class="input" type="text" onsearch="search" placeholder="search"> </input>  <input class="input" type="text" ontranslate="translate" placeholder="translate"> </input></div> 已复制/* xxx.css */.content {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.input {  margin-top: 50px;  width: 60%;  placeholder-color: gray;}text{  width:100%;  font-size:25px;  text-align:center;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction'export default {  search(e){    promptAction.showToast({      message:  e.value,      duration: 3000,    });  },  translate(e){    promptAction.showToast({      message:  e.value,      duration: 3000,    });  }}    设置输入提示 通过对input组件添加showError方法来提示输入的错误原因。 已复制<!-- xxx.hml --><div class="content">  <input id="input" class="input" type="text"  maxlength="20" placeholder="Please input text" onchange="change">  </input>  <input class="button" type="button" value="Submit" onclick="buttonClick"></input></div> 已复制/* xxx.css */.content {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.input {  width: 80%;  placeholder-color: gray;}.button {  width: 30%;  margin-top: 50px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction'  export default {    data:{      value:'',    },    change(e){      this.value = e.value;      promptAction.showToast({      message: "value: " + this.value,        duration: 3000,       });    },    buttonClick(e){      if(this.value.length > 6){        this.$element("input").showError({                 error:  'Up to 6 characters are allowed.'              });       }else if(this.value.length == 0){         this.$element("input").showError({                   error:this.value + 'This field cannot be left empty.'               });       }else{         promptAction.showToast({           message: "success "         });       }    },  }  
说明
 该方法在input类型为text、email、date、time、number和password时生效。 
   场景示例 根据场景选择不同类型的input输入框，完成信息录入。 已复制<!-- xxx.hml --><div class="container">      <div class="label-item">     <label>memorandum</label>     </div>      <div class="label-item">            <label class="lab" target="input1">content:</label>            <input class="flex" id="input1" placeholder="Enter content" />      </div>      <div class="label-item">            <label class="lab" target="input3">date:</label>            <input class="flex" id="input3" type="date" placeholder="Enter data" />      </div>      <div class="label-item">            <label class="lab" target="input4">time:</label>            <input class="flex" id="input4" type="time" placeholder="Enter time" />      </div>     <div class="label-item">            <label class="lab" target="checkbox1">Complete:</label>            <input class="flex" type="checkbox" id="checkbox1" style="width: 100px;height: 100px;" />      </div>      <div class="label-item">            <input class="flex" type="button" id="button" value="save" onclick="btnclick"/>      </div></div> 已复制/* xxx.css */.container {   flex-direction: column;  background-color: #F1F3F5;}.label-item {     align-items: center;  border-bottom-width: 1px;border-color: #dddddd;}.lab {      width: 400px;}label {      padding: 30px;  font-size: 30px;        width: 320px;  font-family: serif;  color: #9370d8;  font-weight: bold;}.flex {      flex: 1;}.textareaPadding {      padding-left: 100px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {      data: {      },      onInit() {   },     btnclick(e) {            promptAction.showToast({                  message:'Saved successfully!'            })      }}         上一篇 text开发指导 下一篇 button开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建list组件添加滚动条添加侧边索引栏实现列表折叠和展开场景示例list开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  list是用来显示列表的组件，包含一系列相同宽度的列表项，适合连续、多行地呈现同类数据。具体用法请参考list API。  创建list组件 在pages/index目录下的hml文件中创建一个list组件。 已复制<!-- xxx.hml --><div class="container">  <list>       <list-item class="listItem"></list-item>   <list-item class="listItem"></list-item>   <list-item class="listItem"></list-item>   <list-item class="listItem"></list-item> </list></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  background-color: #F1F3F5;}.listItem{  height: 20%;  background-color:#d2e0e0;  margin-top: 20px;}  
说明
  <list-item-group>是<list>的子组件，实现列表分组功能，不能再嵌套<list>，可以嵌套<list-item>。 <list-item>是<list>的子组件，展示列表的具体项。  
   添加滚动条 设置scrollbar属性为on即可在屏幕右侧生成滚动条，实现长列表或者屏幕滚动等效果。 已复制<!-- xxx.hml --><div class="container">  <list class="listCss" scrollbar="on" >    <list-item class="listItem"></list-item>    <list-item class="listItem"></list-item>    <list-item class="listItem"></list-item>    <list-item class="listItem"></list-item>    <list-item class="listItem"></list-item>    <list-item class="listItem"></list-item> </list></div>  已复制/* xxx.css */.container {  flex-direction: column;  background-color: #F1F3F5;}.listItem{  height: 20%;  background-color:#d2e0e0;  margin-top: 20px;}.listCss{  height: 100%;  scrollbar-color: #8e8b8b;  scrollbar-width: 50px;}    添加侧边索引栏 设置indexer属性为自定义索引时，索引栏会显示在列表右边界处，indexer属性设置为true,默认为字母索引表。 已复制<!-- xxx.hml --><div class="container">     <list class="listCss"  indexer="{{['#','1','2','3','4','5','6','7','8']}}" >      <list-item class="listItem"  section="#" ></list-item>     </list></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5; } .listCss{  height: 100%;      flex-direction: column;  columns: 1}  
说明
  indexer属性生效需要flex-direction属性配合设置为column，且columns属性设置为1。 indexer可以自定义索引表，自定义时"#"必须要存在。  
   实现列表折叠和展开 为list组件添加groupcollapse和groupexpand事件实现列表的折叠和展开。 已复制<!-- xxx.hml --><div class="doc-page">  <list style="width: 100%;" id="mylist">    <list-item-group for="listgroup in list" id="{{listgroup.value}}" ongroupcollapse="collapse" ongroupexpand="expand">      <list-item type="item" style="background-color:#FFF0F5;height:95px;">        <div class="item-group-child">          <text>One---{{listgroup.value}}</text>        </div>      </list-item>      <list-item type="item" style="background-color: #87CEFA;height:145px;" primary="true">        <div class="item-group-child">          <text>Primary---{{listgroup.value}}</text>        </div>      </list-item>    </list-item-group>  </list></div> 已复制/* xxx.css */.doc-page {  flex-direction: column;  background-color: #F1F3F5;}list-item{margin-top:30px;}.top-list-item {  width:100%;  background-color:#D4F2E7;}.item-group-child {  justify-content: center;  align-items: center;  width:100%;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data: {    direction: 'column',    list: []  },  onInit() {    this.list = []    this.listAdd = []    for (var i = 1; i <= 2; i++) {      var dataItem = {        value: 'GROUP' + i,      };        this.list.push(dataItem);    }  },  collapse(e) {    promptAction.showToast({      message: 'Close ' + e.groupid    })  },  expand(e) {    promptAction.showToast({    message: 'Open ' + e.groupid    })  }}  
说明
  groupcollapse和groupexpand事件仅支持list-item-group组件使用。  
   场景示例 在本场景中，开发者可以根据字母索引表查找对应联系人。 已复制<!-- xxx.hml --><div class="doc-page">   <text style="font-size: 35px; font-weight: 500; text-align: center; margin-top: 20px; margin-bottom: 20px;">       <span>Contacts</span>   </text>   <list class="list" indexer="true">     <list-item class="item" for="{{namelist}}" type="{{$item.section}}" section="{{$item.section}}">       <div class="container">         <div class="in-container">           <text class="name">{{$item.name}}</text>           <text class="number">18888888888</text>         </div>       </div>     </list-item>     <list-item type="end" class="item">       <div style="align-items:center;justify-content:center;width:750px;">         <text style="text-align: center;">Total: 10</text>       </div>     </list-item>   </list> </div> 已复制/* xxx.css */.doc-page {  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;}.list {  width: 100%;  height: 90%;  flex-grow: 1;}.item {  height: 120px;  padding-left: 10%;  border-top: 1px solid #dcdcdc;}.name {  color: #000000;  font-size: 39px;}.number {  color: black;  font-size: 25px;}.container {  flex-direction: row;  align-items: center;}.in-container {  flex-direction: column;  justify-content: space-around;} 已复制// xxx.jsexport default {    data: {      namelist:[{        name: 'Zoey',        section:'Z'      },{        name: 'Quin',        section:'Q'      },{        name:'Sam',        section:'S'      },{        name:'Leo',        section:'L'      },{        name:'Zach',        section:'Z'      },{        name:'Wade',        section:'W'      },{        name:'Zoe',        section:'Z'      },{         name:'Warren',         section:'W'      },{         name:'Kyle',         section:'K'      },{        name:'Zaneta',        section:'Z'      }]    },    onInit() {    }  }    上一篇 容器组件 下一篇 dialog开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建marquee组件设置属性和样式场景示例marquee开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  marquee为跑马灯组件，用于展示一段单行滚动的文字。具体用法请参考marquee。  创建marquee组件 在pages/index目录下的hml文件中创建一个marquee组件。 已复制<!-- xxx.hml --><div class="container">  <marquee style="width: 100%;height: 80px; color: #ffffff; background-color: #0820ef;padding-left: 200px;">It's a racing lamp.</marquee></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}    设置属性和样式 marquee通过color和font-weight属性设置跑马灯中文本的颜色、字体粗细和边框样式。 已复制<!-- xxx.hml --><div class="container"> <marquee class="custommarquee">It's a racing lamp.</marquee></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.custommarquee {  width: 100%;  height: 80px;  padding: 10px;  margin: 20px;  border: 4px solid #6712f1;  border-radius: 20px;  font-size: 40px;  color: #ffffff;  font-weight: bolder;  font-family: serif;  background-color: #1567f3;}  通过scrollamount、loop和direction属性实现跑马灯滚动时移动的最大长度、滚动次数和文字滚动方向。 已复制<!-- xxx.hml --><div class="tutorial-page">  <div class="mymarquee">    <marquee loop="{{loopval}}" scrollamount="{{scroll}}" direction="{{isleft}}" class="marqueetext" id="testmarquee" onclick="makestart">      Life is a journey, not the destination.    </marquee>  </div>  <div style="width: 600px;height: 150px;flex-direction: row;justify-content: space-around;">    <button onclick="setleft"  value="left"></button>    <button onclick="setright" value="right"></button>  </div></div> 已复制/* xxx.css */.tutorial-page {  width: 750px;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}.marqueetext {  color: #ffffff;  font-family: serif;  font-size: 37px;}.mymarquee {  margin-top: 20px;  width:100%;  height: 100px;  margin-left: 50px;  margin-right: 50px;  border: 1px solid #6712f1;  background-color: #1567f3;  border-radius: 15px;  align-items: center;}button{  width: 200px;  height: 80px;  margin-top: 100px;} 已复制// xxx.jsexport default {  private: {    loopval: -1,    scroll: 10,        isleft: "left",  },  onInit(){  },  setleft(e) {    this.isleft = "left"  },  setright(e) {    this.isleft = "right"  },  makestart(e) {    this.$element('testmarquee').start()  }} 
说明
 当loop的值小于等于零时，跑马灯marquee将连续滚动。如果loop未指定，则默认为-1。 
    场景示例 本场景可以控制跑马灯文字的滚动和暂停。 跑马灯的次数设置为1，在结束的时候触发finish事件使跑马灯的次数加1，字体颜色变为随机颜色，调用start方法使跑马灯再次开始滚动。 已复制<!-- xxx.hml --><div class="tutorial-page">  <div class="mymarquee">    <marquee  style="color: {{color1}}" loop="{{loopval}}" scrollamount="{{scroll}}" direction="{{isleft}}" class="marqueetext"     id="testmarquee" onfinish="setfinish">      Life is a journey, not the destination.    </marquee>  </div>  <div style="width: 600px;height: 150px;flex-direction: row;justify-content: space-around;">    <button onclick="makestart"  value="start"></button>    <button onclick="makestop" value="stop"></button>  </div></div> 已复制/* xxx.css */.tutorial-page {  width: 750px;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;}.marqueetext {  font-size: 37px;}.mymarquee {  margin-top: 20px;  width:100%;  height: 100px;  margin-left: 50px;  margin-right: 50px;  border: 1px solid #dc0f27;  border-radius: 15px;  align-items: center;}button{  width: 200px;  height: 80px;  margin-top: 100px;} 已复制// xxx.jsexport default {  private: {    loopval: 1,    scroll: 8,    color1: 'red'  },  onInit(){  },  setfinish(e) {    this.loopval=  this.loopval + 1,    this.r = Math.floor(Math.random()*255),    this.g = Math.floor(Math.random()*255),    this.b = Math.floor(Math.random()*255),    this.color1 = 'rgba('+ this.r +','+ this.g +','+ this.b +',0.8)',    this.$element('testmarquee').start(),    this.loopval=  this.loopval - 1  },  makestart(e) {    this.$element('testmarquee').start()  },  makestop(e) {    this.$element('testmarquee').stop()  }}    上一篇 menu开发指导 下一篇 qrcode开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建menu组件设置样式绑定事件场景示例menu开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  提供菜单组件，作为临时性弹出窗口，用于展示用户可执行的操作，具体用法请参考menu。  创建menu组件 在pages/index目录下的hml文件中创建一个menu组件，添加target、type、title属性。 已复制<!-- xxx.hml--><div class="container">  <text class="title-text" id="textId">show menu</text>  <menu target="textId" type="click" title="title">    <option value="Item 1">Item 1</option>    <option value="Item 2">Item 2</option>    <option value="Item 3">Item 3</option>  </menu></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;   flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;  width: 100%;}.title-text{  font-size: 35px;}  
说明
  menu仅支持option子组件。 menu组件不支持focusable、disabled属性。  
   设置样式 为menu组件设置样式，例如字体颜色、大小、字符间距等。 已复制<!-- xxx.hml--><div class="container">  <text class="title-text" id="textId">show menu</text>  <menu target="textId" type="click" title="title">    <option value="Item 1">Item 1</option>    <option value="Item 2">Item 2</option>    <option value="Item 3">Item 3</option>  </menu></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;   flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;  width: 100%;}.title-text{  font-size: 35px;  background-color: #5a5aee;  color: white;  width: 70%;  text-align: center;  height: 85px;  border-radius: 12px;}menu{  text-color: blue;  font-size: 35px;  letter-spacing: 2px;}option{  color: #6a6aef;  font-size: 30px;}    绑定事件 为menu组件绑定onselected事件（菜单中某个值被点击选中时触发）和oncancel事件（取消操作时触发），点击text组件调用show方法可设置menu组件的坐标。 已复制<!-- xxx.hml--><div class="container">  <text  class="title-text" id="textId" onclick="textClick">show menu</text>  <menu  title="title" onselected="select" oncancel="cancel" id="menuId">    <option value="Item 1">Item 1</option>    <option value="Item 2">Item 2</option>    <option value="Item 3">Item 3</option>  </menu></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;  width: 100%;}.title-text{  font-size: 35px;  background-color: #5a5aee;  color: white;  width: 70%;  text-align: center;  height: 85px;  border-radius: 12px;  margin-top: 500px;  margin-left: 15%;}menu{  text-color: blue;  font-size: 35px;  letter-spacing: 2px;}option{  color: #6a6aef;  font-size: 30px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  select(e) {    promptAction.showToast({      message: e.value    })  },  cancel(){    promptAction.showToast({      message: "cancel"    })  },  textClick() {    this.$element("menuId").show({x:175,y:590});  },}    场景示例 本场景中开发者可点击toggle组件修改文字颜色，选择menu组件修改渐变色块大小。 已复制<!-- xxx.hml--><div class="container">    <div class="contentToggle">        <toggle class="toggle" for="{{item in togglesList}}" onclick="toggleClick({{$idx}})" checked="{{item.checked}}">{{item.name}}</toggle>    </div>    <text class="size" style="color: {{color}};">width:{{width}},height:{{height}}</text>    <div style="width: {{width}}px;height: {{height}}px; background-color: cornflowerblue;"></div>    <text id="menuId" class="text">change size</text>    <menu onselected="select" oncancel="cancel" target="menuId">        <option value="{{item.value}}" for="item in optionList">{{item.text}}</option>    </menu></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5;  width: 100%;  justify-content: center;  align-items: center;}.contentToggle{  width: 100%;  justify-content: space-around;}.toggle{  padding: 10px;  height:80px;  font-size: 35px;  width: 200px;  height: 85px;}.size{  width: 100%;  height: 200px;  text-align: center;  font-size: 40px;  text-align: center;}.text{  width: 300px;  height: 80px;  background-color: #615def;  color: white;  font-size: 35px;  text-align: center;  margin-top: 100px;}menu{  text-color: blue;  font-size: 35px;  letter-spacing: 2px;}option{  color: #6a6aef;  font-size: 30px;} 已复制// xxx.jsexport default {  data:{    fresh: false,    width: 200,    height: 200,    color: '',    optionList:[      {text:'200 x 200',value:2},      {text:'300 x 300',value:3},      {text:'500 x 500',value:5},    ],    togglesList:[      {name:"red", checked:false},      {name:"blue", checked:false},      {name: "black", checked:false},    ],  },  toggleClick(index) {       for(let i=0;i<this.togglesList.length;i++) {           if (i == index) {              this.color = this.togglesList[index].name;              this.togglesList[i].checked = true;            }else {                this.togglesList[i].checked = false;            }        }    },  select(e) {    this.width = e.value * 100;    this.height = e.value * 100;  }}    上一篇 toolbar开发指导 下一篇 marquee开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。判断位置OffscreenCanvasRenderingContext2D对象 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  使用OffscreenCanvas在离屏Canvas画布组件上进行绘制，绘制对象可以是矩形、文本、图片等。 离屏，即GPU在当前缓冲区以外新开辟的一个缓冲区。 具体请参考OffscreenCanvasRenderingContext2D对象。 以下示例创建了一个OffscreenCanvas画布，再在画布上创建一个getContext2d对象，并设置filter属性改变图片样式。 已复制<!-- xxx.hml --><div class="container">  <canvas ref="canvas1"></canvas>  <select @change="change()">    <option value="blur(5px)">blur</option>    <option value="grayscale(50%)">grayscale</option>    <option value="hue-rotate(45deg)">hue-rotate</option>    <option value="invert(100%)">invert</option>    <option value="drop-shadow(8px 8px 10px green)">drop-shadow</option>    <option value="brightness(0.4)">brightness</option>    <option value="opacity(0.25)">opacity</option>    <option value="saturate(30%)">saturate</option>    <option value="sepia(60%)">sepia</option>    <option value="contrast(200%)">contrast</option>  </select></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}select{  margin-top: 50px;  width: 250px;  height: 100px;  background-color: white;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data:{    el: null,    ctx: null,    offscreen: null,    offCanvas: null,    img: null,  },  onShow(){    this.ctx = this.$refs.canvas1.getContext("2d");    this.offscreen = new OffscreenCanvas(600, 500);    this.offCanvas = this.offscreen.getContext("2d");    this.img = new Image();    this.img.src = 'common/images/2.png';    // 图片成功获取触发方法    let _this = this;    this.img.onload = function() {      _this.offCanvas.drawImage(_this.img, 100, 100, 400, 300);    };    this.img.onerror = function() {      promptAction.showToast({message:"error",duration:2000})    };    var bitmap = this.offscreen.transferToImageBitmap();    this.ctx.transferFromImageBitmap(bitmap);  },  change(e){    this.offCanvas.filter = e.newValue;this.offCanvas.drawImage(this.img, 100, 100, 400, 300);    var bitmap = this.offscreen.transferToImageBitmap();    this.ctx.transferFromImageBitmap(bitmap);  },}   判断位置 使用isPointInPath判断坐标点是否在路径的区域内，使用isPointInStroke判断坐标点是否在路径的边缘线上，并在页面上显示返回结果。 已复制<!-- xxx.hml --><div class="container">  <div class="content">    <text>坐标：{{X}}, {{Y}}</text>    <text>In path:{{textValue}}</text>    <text>In stroke:{{textValue1}}</text>  </div>  <canvas ref="canvas"></canvas>  <button onclick="change">Add(50)</button></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}canvas{  width: 600px;  height: 500px;  background-color: #fdfdfd;  border: 5px solid red;}.content{  flex-direction: column;  justify-content: center;  align-items: center; }text{  font-size: 30px;  width: 300px;  height: 80px;  text-align: center;}button{  width: 180px;  height: 75px;  margin-top: 50px;} 已复制// xxx.jsexport default {  data: {    textValue: 0,    textValue1: 0,    X:0,    Y:250,  },  onShow(){    let canvas = this.$refs.canvas.getContext('2d');    let offscreen = new OffscreenCanvas(500,500);    let offscreenCanvasCtx = offscreen.getContext("2d");    let offscreenCanvasCtx1 = offscreen.getContext("2d");    offscreenCanvasCtx1.arc(this.X, this.Y, 2, 0, 6.28);    offscreenCanvasCtx.lineWidth=20;    offscreenCanvasCtx.rect(200,150, 200, 200);    offscreenCanvasCtx.stroke();    this.textValue1 = offscreenCanvasCtx.isPointInStroke(this.X, this.Y)?'true':'false';    this.textValue = offscreenCanvasCtx.isPointInPath(this.X, this.Y)?'true':'false';    let bitmap = offscreen.transferToImageBitmap();    canvas.transferFromImageBitmap(bitmap);  },  change(){    if(this.X < 500){      this.X = this.X+50;    }else{      this.X = 0;    }    let canvas = this.$refs.canvas.getContext('2d');    let offscreen = new OffscreenCanvas(500,500);    let offscreenCanvasCtx = offscreen.getContext("2d");    let offscreenCanvasCtx1 = offscreen.getContext("2d");    offscreenCanvasCtx1.arc(this.X, this.Y, 1, 0, 6.28)    offscreenCanvasCtx.lineWidth=20    offscreenCanvasCtx.rect(200,150, 200, 200);    offscreenCanvasCtx.stroke();    this.textValue1 = offscreenCanvasCtx.isPointInStroke(this.X, this.Y)?'true':'false';    this.textValue = offscreenCanvasCtx.isPointInPath(this.X, this.Y)?'true':'false';    let bitmap = offscreen.transferToImageBitmap();    canvas.transferFromImageBitmap(bitmap);  }}    上一篇 Path2D对象 下一篇 栅格布局 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。画线段画图形Path2D对象 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  路径对象，支持通过对象的接口进行路径的描述，并通过Canvas的stroke接口进行绘制。具体请参考Path2D对象。  画线段 创建Path2D，使用多条线段组合图形。 已复制<!-- xxx.hml --> <div class="container">  <canvas ref="canvas"></canvas></div> 已复制/* xxx.css */.container {    flex-direction: column;    background-color: #F1F3F5;    align-items: center;    justify-content: center;    width: 100%;    height: 100%;}
canvas {    width: 600px;    height: 600px;    background-color: #fdfdfd;    border: 5px solid red;} 已复制// xxx.jsexport default {    onShow() {        let ctx = this.$refs.canvas.getContext('2d', {            antialias: true        });        let path = ctx.createPath2D();        // 房顶        path.moveTo(10, 300);        path.lineTo(210, 100);        path.lineTo(410, 300);        // 屋子        path.moveTo(10, 300);        path.lineTo(410, 300);        path.lineTo(410, 600);        path.lineTo(10, 600);        path.closePath();        // 窗子        path.moveTo(50, 450);        path.bezierCurveTo(70, 350, 130, 350, 150, 450);        path.closePath();        // 门        path.moveTo(250, 450);        path.rect(250, 450, 100, 600);        path.closePath();        // 烟囱        path.moveTo(365, 250);        path.ellipse(310, 215, 30, 130, 0, Math.PI * 0.04, Math.PI * 1.1, 1);        // 树        path.moveTo(485, 450);        path.quadraticCurveTo(510, 500, 485, 600);        path.moveTo(550, 450);        path.quadraticCurveTo(525, 500, 550, 600);        path.moveTo(600, 535);        path.arc(520, 450, 85, 0, 6);        ctx.stroke(path);    }}    画图形 先使用createPath2D创建出路径对象，只对path1路径进行描边，所以画布上就只会出现path1的路径图形。点击text组件触发addPath方法会把path2路径对象当参数传入path1中，再对path1对象进行描边（stroke）操作后画布出现path1和path2两个图形。点击change文本改变setTransform属性值为setTransform(2, 0.1, 0.1, 2, 0,0)，图形变大并向左倾斜。 已复制<!-- xxx.hml --><div class="container">    <canvas ref="canvas"></canvas>    <div class="content">        <text onclick="addPath">{{ isAdd }}</text>        <text onclick="setTransform">{{ textName }}</text>    </div></div> 已复制/* xxx.css */.container {    flex-direction: column;    background-color: #F1F3F5;    align-items: center;    justify-content: center;    width: 100%;    height: 100%;}
canvas {    width: 600px;    height: 600px;    background-color: #fdfdfd;    border: 5px solid red;}
.content {    width: 80%;    margin-top: 50px;    margin-bottom: 50px;    display: flex;    flex-wrap: wrap;    justify-content: space-around;}
text {    width: 150px;    height: 80px;    color: white;    border-radius: 20px;    text-align: center;    background-color: #6060e7;    margin-bottom: 30px;} 已复制// xxx.jsexport default {    data: {        ctx: null,        path1: null,        path2: null,        path3: null,        isAdd: "addPath2",        isChange: true,        textName: 'change'    },    onShow() {        this.ctx = this.$refs.canvas.getContext('2d', {            antialias: true        });        this.path1 = this.ctx.createPath2D();        // 正方形        this.path1.moveTo(200, 200);        this.path1.lineTo(400, 200);        this.path1.lineTo(400, 400);        this.path1.lineTo(200, 400);        this.path1.closePath();        this.path2 = this.ctx.createPath2D();        // 圆形        this.path2.arc(300, 300, 75, 0, 6.28);        this.ctx.stroke(this.path1);    },    addPath() {        if (this.isAdd == "addPath2") {            // 删除指定指定区域的绘制内容            this.ctx.clearRect(0, 0, 600, 600);            this.ctx.beginPath();            // 将另一个的路径添加到当前路径对象中            this.path2.addPath(this.path1);            this.ctx.stroke(this.path2);            this.isAdd = "clearPath2";        } else {            this.ctx.clearRect(0, 0, 600, 600);            this.ctx.stroke(this.path1);            this.isAdd = "addPath2";        }    },    setTransform() {        if (this.isChange) {            this.ctx.clearRect(0, 0, 600, 600);            this.path3 = this.ctx.createPath2D();            this.path3.arc(150, 150, 100, 0, 6.28);            // 重置现有的变换矩阵并创建新的变换矩阵            this.path3.setTransform(2, 0.1, 0.1, 2, 0, 0);            this.ctx.stroke(this.path3);            this.isChange = !this.isChange;            this.textName = "back"        } else {            this.ctx.clearRect(0, 0, 600, 600);            this.path3.setTransform(0.5, -0.1, -0.1, 0.5, 0, 0);            this.ctx.stroke(this.path3);            this.isChange = !this.isChange;            this.textName = "change";        }    }}    上一篇 CanvasRenderingContext2D对象 下一篇 OffscreenCanvasRenderingContext2D对象 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建picker组件设置picker类型设置时间展现格式添加响应事件场景示例picker开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  picker是滑动选择器组件，类型支持普通选择器、日期选择器、时间选择器、时间日期选择器和多列文本选择器。具体用法请参考picker API。  创建picker组件 在pages/index目录下的hml文件中创建一个picker组件。 已复制<!-- xxx.hml --><div class="container">  <picker>    picker  </picker></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}    设置picker类型 通过设置picker的type属性来选择滑动选择器类型，如定义picker为日期选择器。 已复制<!-- xxx.hml --><div class="container">  <picker id="picker_text" type="text" value="{{textvalue}}"range="{{rangetext}}" class="pickertext" ></picker>  <picker id="picker_date" type="date" value="{{datevalue}}" lunarswitch="true" start="2002-2-5" end="2030-6-5" class="pickerdate"></picker></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.pickertext{  margin-bottom: 30px;} 已复制// xxx.jsexport default {  data: {    rangetext:['15', "20", "25"],    textvalue:'Select text',    datevalue:'Select date',  }}  
说明
 普通选择器设置取值范围时，需要使用数据绑定的方式。 
   设置时间展现格式 picker的hours属性定义时间的展现格式，可选类型有12小时制和24小时制。 已复制<!-- xxx.hml --><div class="container">  <picker id="picker_time" type="time" value="12-hour format" hours="12" onchange="timeonchange"  class="pickertime"></picker>  <picker id="picker_time" type="time" value="24-hour format" hours="24" onchange="timeonchange"  class="pickertime"></picker></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.pickertime {  margin-bottom:50px;  width: 300px;  height: 50px;}  
说明
  hours属性为12：按照12小时制显示，用上午和下午进行区分； hours属性为24：按照24小时制显示。  
   添加响应事件 对picker添加change和cancel事件，来对选择的内容进行确定和取消。 已复制<!-- xxx.hml --><div class="container">  <picker id="picker_multi" type="multi-text" value="{{multitextvalue}}" columns="3" range="{{multitext}}" selected="     {{multitextselect}}" onchange="multitextonchange" oncancel="multitextoncancel" class="pickermuitl"></picker></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5; }.pickermuitl {  margin-bottom:20px;  width: 600px;  height: 50px;  font-size: 25px;  letter-spacing:15px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data: {    multitext:[["a", "b", "c"], ["e", "f", "g"], ["h", "i"]],    multitextvalue:'Select multi-line text',    multitextselect:[0,0,0],  },  multitextonchange(e) {    this.multitextvalue=e.newValue;    promptAction.showToast({ message:"Multi-column text changed to:" + e.newValue })  },  multitextoncancel() {    promptAction.showToast({ message:"multitextoncancel" })  },}    场景示例 在本场景中，开发者可以自定义填写当前的健康情况来进行打卡。 已复制<!-- xxx.hml --><div class="doc-page">  <text class="title">Health check-in</text>  <div class="out-container">    <text class="txt">Office:</text>    <picker class="pick" focusable="true" type="text" value="{{pos}}" range="{{posarr}}" onchange="setPos"></picker>  </div>  <divider class="dvd"></divider>  <div class="out-container">    <text class="txt">Office hours:</text>    <picker class="pick" type="date" value="{{datevalue}}"  start="2002-2-5" end="2030-6-5" selected="{{dateselect}}"      lunarswitch="true" onchange="dateonchange"></picker>  </div>  <divider class="dvd"></divider>  <div class="out-container">    <text class="txt">Having fever or cold symptoms</text>    <picker class="pick" type="text" value="{{yorn1}}" range="{{yesno}}" selected="1" onchange="isFever"></picker>  </div>  <divider class="dvd"></divider>  <div class="out-container">    <text class="txt">Close contact with someone with COVID-19</text>    <picker class="pick" type="text" value="{{yorn2}}" range="{{yesno}}" selected="1" onchange="isTouch"></picker>  </div>  <div class="out-container">    <button value="Submit" style="margin-top:100px;width:50%;font-color:#0000ff;height:80px" onclick="showtoast"></button>  </div></div> 已复制/* xxx.css */.doc-page {  flex-direction: column;  background-color: #F1F3F5;}.title {  margin-top: 30px;  margin-bottom: 30px;  margin-left: 50px;  font-weight: bold;  color: #0000ff;  font-size: 38px;}.out-container {  flex-direction: column;  align-items: center;}.pick {  width: 80%;  height: 76px;  border: 1px solid #0000ff;  border-radius: 20px;  padding-left: 12px;}.txt {  width: 80%;  font-size: 18px;  text-align: left;  margin-bottom: 12px;  margin-left: 12px;}.dvd {  margin-top: 30px;  margin-bottom: 30px;  margin-left: 80px;  margin-right: 80px;  color: #6495ED;  stroke-width: 6px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction'export default {  data: {    yorn1:'No',    yorn2:'No',    pos:'Home',    yesno:['Yes', 'No'],    posarr:['Home', 'Company'],    datevalue:'Select time',    datetimeselect:'2012-5-6-11-25',    dateselect:'2021-9-17',    showbuild:true  },  onInit() {  },  isFever(e) {    this.yorn1 = e.newValue  },  isTouch(e) {    this.yorn2 = e.newValue  },  setPos(e) {    this.pos = e.newValue    if (e.newValue === 'Non-research center') {      this.showbuild = false    } else {      this.showbuild = true    }  },  setbuild(e) {    this.build = e.newValue  },  dateonchange(e) {    e.month=e.month+1;    this.datevalue = e.year + "-" + e.month + "-" + e.day;    promptAction.showToast({ message:"date:"+e.year+"-"+e.month+"-"+e.day })   },  showtoast() {    promptAction.showToast({      message: 'Submitted.',      duration: 2000,      gravity: 'center'    })  }}    上一篇 button开发指导 下一篇 image开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建qrcode组件设置组件类型设置样式场景示例qrcode开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  生成并显示二维码，具体用法请参考qrcode。  创建qrcode组件 在pages/index目录下的hml文件中创建一个qrcode组件。 已复制<!-- xxx.hml--><div class="container">  <qrcode value="Hello"></qrcode></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}  
说明
 qrcode组件在创建的时候value的值为必填项。 
   设置组件类型 通过设置qrcode的type属性来选择按钮类型，如定义qrcode为矩形二维码、圆形二维码。 已复制<!-- xxx.hml--><div class="container">  <select onchange="settype">    <option for="{{bcol_list}}" value="{{$item}}">{{$item}}</option>  </select>  <qrcode value="Hello" type="{{qr_type}}"></qrcode></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}select{  margin-top: 50px;  margin-bottom: 50px;} 已复制// index.jsexport default {  data: {    qr_type: 'rect',    bcol_list: ['rect','circle']  },  settype(e) {    this.qr_type = e.newValue   },}    设置样式 通过color和background-color样式为二维码设置显示颜色和背景颜色。 已复制<!-- xxx.hml--><div class="container">  <qrcode value="Hello" type="rect"></qrcode></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}qrcode{  width: 300px;  height: 300px; color: blue;  background-color: #ffffff;}  
说明
  width和height不一致时，取二者较小值作为二维码的边长，且最终生成的二维码居中显示。 width和height只设置一个时，取设置的值作为二维码的边长。都不设置时，使用200px作为默认边长。  
   场景示例 在本场景中将二维码与输入框绑定，通过改变输入框的内容改变二维码。 已复制<!-- xxx.hml--><div class="container">  <input style="margin-bottom: 100px;" onchange="change"></input>  <qrcode value="{{textVal}}"></qrcode></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}qrcode{  width: 400px;  height: 400px;} 已复制// index.jsexport default{  data: {    textVal: ''  },  change(e){    this.textVal = e.value  }}    上一篇 marquee开发指导 下一篇 search 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建rating组件设置评分星级设置评分样式绑定事件场景示例rating开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  rating为评分条组件，表示用户使用感受的衡量标准条。具体用法请参考rating。  创建rating组件 在pages/index目录下的hml文件中创建一个rating组件。 已复制<!-- xxx.hml --><div class="container">  <rating></rating></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  display: flex;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}rating {  width: 80%;  height: 150px;}    设置评分星级 rating组件通过设置numstars和rating属性设置评分条的星级总数和当前评星数。 已复制<!-- xxx.hml --><div class="container">  <rating numstars="6" rating="5">  </rating></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  display: flex;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}rating {  width: 80%;  height: 150px;}    设置评分样式 rating组件通过star-background、star-foreground和star-secondary属性设置单个星级未选择、选中和选中的次级背景图片。 已复制<!-- xxx.hml --><div class="container">  <div style="width: 500px;height: 500px;align-items: center;justify-content: center;flex-direction: column;;">    <rating numstars="5" rating="1" class="myrating" style="width: {{ratewidth}}; height:{{rateheight}};    star-background: {{backstar}}; star-secondary: {{secstar}};star-foreground: {{forestar}};rtl-flip: true;">    </rating>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;} 已复制// index.jsexport default {  data: {    backstar: 'common/love.png',    secstar: 'common/love.png',    forestar: 'common/love1.png',    ratewidth: '400px',    rateheight: '150px'  },  onInit(){  }}  
说明
  star-background、star-secondary、star-foreground属性的星级图源必须全部设置，否则默认的星级颜色为灰色，提示图源设置错误。 star-background、star-secondary、star-foreground属性只支持本地路径图片，图片格式为png和jpg。  
   绑定事件 向rating组件添加change事件，打印当前评分。 已复制<!-- xxx.hml --><div class="container">  <rating numstars="5" rating="0" onchange="showrating"></rating></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  display: flex;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}rating {  width: 80%;  height: 150px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  showrating(e) {    promptAction.showToast({      message: '当前评分' + e.rating    })  }}    场景示例 开发者可以通过改变开关状态切换星级背景图，通过改变滑动条的值调整星级总数。 已复制<!-- xxx.hml --><div style="width: 100%;height:100%;flex-direction: column;align-items: center;background-color: #F1F3F5;">  <div style="width: 500px;height: 500px;align-items: center;justify-content: center;flex-direction: column;;">    <rating numstars="{{stars}}" rating="{{rate}}" stepsize="{{step}}" onchange="showrating" class="myrating"    style="width: {{ratewidth}};height:{{rateheight}};star-background: {{backstar}};star-secondary: {{secstar}};    star-foreground: {{forestar}};rtl-flip: true;"></rating>  </div>  <div style="flex-direction: column;width: 80%;align-items: center;">    <div style="width: 100%;height: 100px;align-items: center;justify-content: space-around;">      <text>替换自定义图片</text>      <switch checked="false" showtext="true" onchange="setstar"></switch>    </div>    <div style="width: 100%;height:120px;margin-top: 50px;margin-bottom: 50px;flex-direction: column;align-items: center;    justify-content: space-around;">      <text>numstars   {{stars}}</text>      <slider id="sli1" min="-1" max="10" value="5" step="1" onchange="setnumstars"></slider>    </div>    <div style="width: 100%;height:120px;flex-direction: column;align-items: center;justify-content: space-around;">      <text>rating   {{rate}}</text>      <slider id="sli2" min="-1" max="10" value="0" step="1" onchange="setrating"></slider>    </div>  </div></div> 已复制/* xxx.css */.myrating:active {  width: 500px;  height: 100px;}switch{  font-size: 40px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data: {    backstar: '',    secstar: '',    forestar: '',    stars: 5,    ratewidth: '300px',    rateheight: '60px',    step: 0.5,    rate: 0  },  onInit(){  },  setstar(e) {    if (e.checked == true) {      this.backstar = 'common/love.png'      this.secstar = 'common/love.png'      this.forestar = 'common/love1.png'    } else {      this.backstar = ''      this.secstar = ''      this.forestar = ''    }  },  setnumstars(e) {    this.stars = e.progress    this.ratewidth = 60 * parseInt(this.stars) + 'px'  },  setstep(e) {    this.step = e.progress  },  setrating(e){    this.rate = e.progress  },  showrating(e) {    promptAction.showToast({      message: '当前评分' + e.rating    })  }}    上一篇 image-animator开发指导 下一篇 slider开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建search组件设置属性添加样式绑定事件场景示例search 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  提供搜索框组件，用于提供用户搜索内容的输入区域，具体用法请参考search。  创建search组件 在pages/index目录下的hml文件中创建一个search组件。 已复制<!-- xxx.hml--><div class="container">  <search></search></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}    设置属性 通过设置hint、icon和searchbutton属性设置搜索框的提示文字、图标和末尾搜索按钮的内容。 已复制<!-- xxx.hml--><div class="container">  <search hint="Please enter the search content"  searchbutton="search" icon="/common/search1.png"></search></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}    添加样式 通过color、placeholder-color和caret-color样式来设置搜索框的文本颜色、提示文本颜色和光标颜色。 已复制<!-- xxx.hml--><div class="container">  <search hint="Please enter the search content"  searchbutton="search" ></search></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}search{  color: black;  placeholder-color: black;  caret-color: red;}    绑定事件 向search组件添加change、search、submit、share和translate事件，对输入信息进行操作。 已复制<!-- xxx.hml--><div class="container">  <text style="margin-left: -7px;">    <span>Enter text and then touch and hold what you've entered</span>  </text>  <search hint="Please enter the search content"  searchbutton="search" onsearch="search" onchange="change" ontranslate="translate" onshare="share"   onsubmit="submit">  </search></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}text{  width: 100%;  font-size: 25px;  text-align: center;  margin-bottom: 100px;} 已复制// index.jsimport promptAction from '@ohos.promptAction'export default {  search(e){    promptAction.showToast({      message:  e.value,      duration: 3000,    });  },  translate(e){    promptAction.showToast({      message:  e.value,      duration: 3000,    });  },  share(e){    promptAction.showToast({      message:  e.value,      duration: 3000,    });  },  change(e){    promptAction.showToast({      message:  e.value,      duration: 3000,    });  },  submit(e){    promptAction.showToast({      message: 'submit',      duration: 3000,    });  }}    场景示例 在本场景中通过下拉菜单选择search、Textarea和Input组件来实现搜索和输入效果。 已复制<!-- xxx.hml--><div style="flex-direction: column;align-items: center;justify-content: center; width: 100%;">  <select class="slt1" id="slt1" onchange="setfield">    <option value="search">search</option>    <option value="textarea">Textarea</option>    <option value="input">Input</option>  </select>  <div if="{{showsearch}}" style="flex-direction: column;align-items: center;margin-top: 50px;height: 400px;justify-content: space-around;">    <search class="field" id="search1" hint="search1" onsubmit="submit" onchange="change" ></search>    <search class="field" id="search2" icon="common/search1.png" hint="search2" show="{{showsec}}" onsubmit="submit" onchange="change" ></search>  </div>  <div if="{{showtextarea}}" style="flex-direction: column;align-items: center;margin-top: 50px;height: 400px;justify-content: space-around;">    <textarea class="field" id="textarea1" extend="true" placeholder="textarea1" onchange="change" ></textarea>    <textarea class="field" id="textarea2" extend="true" placeholder="textarea2" onchange="change" show="{{showsec}}"></textarea>  </div>  <div if="{{showinput}}" style="flex-direction: column;align-items: center;margin-top: 50px;height: 400px;justify-content: space-around;">    <input type="text" class="field" id="input1" placeholder="input1" onchange="change" ></input>    <input type="text" class="field" id="input2" placeholder="input2" onchange="change" show="{{showsec}}"></input>  </div></div> 已复制/* xxx.css */.field {  width: 80%;  color: mediumaquamarine;  font-weight: 600;  placeholder-color: orangered;}.slt1{  font-size: 50px;  position: absolute;  left: 50px;  top: 50px;} 已复制// index.jsimport promptAction from '@ohos.promptAction';export default {  data: {    showsearch: true,    showtextarea: false,    showinput: false,    showsec: true,  },  setfield(e) {    this.field = e.newValue    if (e.newValue == 'search') {      this.showsearch = true      this.showtextarea = false      this.showinput = false    } else if (e.newValue == 'textarea') {      this.showsearch = false      this.showtextarea = true      this.showinput = false    } else {      this.showsearch = false      this.showtextarea = false      this.showinput = true    }  },  submit(e) {    promptAction.showToast({      message: '搜索！',      duration: 2000    })  },  change(e) {    promptAction.showToast({      message: '内容:' + e.text,      duration: 2000    })  }}    上一篇 qrcode开发指导 下一篇 Canvas开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建slider组件设置样式和属性绑定事件场景示例slider开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  slider为滑动条组件，用来快速调节音量、亮度等。具体用法请参考slider。  创建slider组件 在pages/index目录下的hml文件中创建一个slider组件。 已复制<!-- xxx.hml --><div class="container">  <slider></slider></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  background-color: #F1F3F5;  flex-direction: column;  justify-content: center;  align-items: center;}    设置样式和属性 slider组件通过color、selected-color、block-color样式分别为滑动条设置背景颜色、已选择颜色和滑块颜色。 已复制<!-- xxx.hml --><div class="container">  <slider class= "sli"></slider></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.sli{  color: #fcfcfc;  scrollbar-color: aqua;  background-color: #b7e3f3;}  通过添加mix、max、value、step、mode属性分别为滑动条设置最小值、最大值、初始值、滑动步长和滑动条样式。 已复制<!-- xxx.hml --><div class="container">  <slider min="0" max="100" value="1" step="2" mode="inset" showtips="true"></slider></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}  
说明
 mode属性为滑动条样式，可选值为：  outset：滑块在滑杆上； inset：滑块在滑杆内。  
   绑定事件 向Rating组件添加change事件，添加时需要传入ChangeEvent参数。 已复制<!-- xxx.hml --><div class="container">  <text>slider start value is {{startValue}}</text>  <text>slider current value is {{currentValue}}</text>  <text>slider end value is {{endValue}}</text>  <slider min="0" max="100" value="{{value}}" onchange="setvalue"></slider></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;} 已复制// xxx.jsexport default {  data: {    value: 0,    startValue: 0,    currentValue: 0,    endValue: 0,  },  setvalue(e) {    if (e.mode == "start") {      this.value = e.value;      this.startValue = e.value;    } else if (e.mode == "move") {      this.value = e.value;      this.currentValue = e.value;    } else if (e.mode == "end") {      this.value = e.value;      this.endValue = e.value;    }  }}    场景示例 开发者可以通过调整滑动条的值来改变图片大小，并且动态打印当前图片的宽和高。 已复制<!-- xxx.hml --><div class="container">  <image src="common/landscape3.jpg" style=" width: {{WidthVal}}px;height:{{HeightVal}}px;margin-top: -150px;"></image>  <div class="txt">    <slider min="0" max="100" value="{{value}}" onchange="setvalue"></slider>    <text>The width of this picture is    {{WidthVal}}</text>    <text>The height of this picture is  {{HeightVal}}</text>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}.txt{  flex-direction: column;  justify-content: center;  align-items: center;  position: fixed;  top: 65%;}text{  margin-top: 30px;} 已复制// xxx.jsexport default{  data: {    value: 0,    WidthVal: 200,    HeightVal: 200  },  setvalue(e) {    this.WidthVal = 200 + e.value;    this.HeightVal = 200 + e.value  }}    上一篇 rating开发指导 下一篇 chart开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建stepper组件设置index属性设置样式添加事件场景示例stepper开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  当一个任务需要多个步骤时，可以使用stepper组件展示当前进展。具体用法请参考stepper API。 
说明
 从API Version 5 开始支持。 
  创建stepper组件 在pages/index目录下的hml文件中创建一个stepper组件。 已复制<!-- xxx.hml --><div class="container">  <stepper>       <stepper-item>          <text>Step 1</text>   </stepper-item>    <stepper-item>          <text>Step 2</text>   </stepper-item>  </stepper> </div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}text{  width: 100%;  height: 100%;  text-align: center;}    设置index属性 页面默认显示索引值为index的步骤。 已复制<!-- xxx.hml --><div class="container">  <stepper index="2">       <stepper-item>          <text>stepper-item1</text>   </stepper-item>    <stepper-item>          <text>stepper-item2</text>   </stepper-item>    <stepper-item>          <text>stepper-item3</text>   </stepper-item>   </stepper> </div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  background-color: #F1F3F5;}text{  width: 100%;  height: 100%;  text-align: center;}  通过设置label属性，自定义stepper-item的提示按钮。 已复制<!-- xxx.hml --><div class="container">  <stepper index="1">       <stepper-item label="{{label_1}}">          <text>stepper-item1</text>   </stepper-item>    <stepper-item label="{{label_2}}">          <text>stepper-item2</text>   </stepper-item>    <stepper-item label="{{label_3}}">          <text>stepper-item3</text>   </stepper-item>   <stepper-item>          <text>stepper-item4</text>   </stepper-item>  </stepper> </div> 已复制/* xxx.css */.container {    width:100%;  height:100%;  flex-direction: column;  background-color: #F1F3F5;}text{  width: 100%;  height: 100%;  text-align: center;} 已复制// xxx.jsexport default {   data: {    label_1:{      nextLabel: 'NEXT',            status: 'normal'        },    label_2:{      prevLabel: 'BACK',      nextLabel: 'NEXT',      status: 'normal'    },    label_3:{      prevLabel: 'BACK',      nextLabel: 'END',      status: 'disabled'    },  },}    设置样式 stepper组件默认填充父容器，通过border和background-color设置边框、背景色。 已复制<!-- xxx.hml --><div class="container" >   <div class="stepperContent">    <stepper class="stepperClass">          <stepper-item>             <text>stepper-item1</text>      </stepper-item>     </stepper>   </div></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color:#F1F3F5;}.stepperContent{  width: 300px;  height: 300px;}.stepperClass{  border:1px solid silver ;  background-color: white;}text{  width: 100%;  height: 100%;  text-align: center;}    添加事件 stepper分别添加finish，change，next，back，skip事件。  当change与next或back同时存在时，会先执行next或back事件再去执行change事件。 重新设置index属性值时要先清除index的值再重新设置，否则检测不到值的改变。  已复制<!-- xxx.hml --><div class="container"  style="background-color:#F1F3F5;">  <div >    <stepper onfinish="stepperFinish" onchange="stepperChange" onnext="stepperNext" onback="stepperBack" onskip="stepperSkip" id="stepperId" index="{{index}}">      <stepper-item>        <text>stepper-item1</text>        <button value="skip" onclick="skipClick"></button>      </stepper-item>      <stepper-item>         <text>stepper-item2</text>         <button value="skip" onclick="skipClick"></button>      </stepper-item>      <stepper-item>        <text>stepper-item3</text>      </stepper-item>    </stepper>  </div></div> 已复制/* xxx.css */.doc-page {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  justify-content: center;}stepper-item{  width: 100%;  flex-direction: column;  align-self: center;  justify-content: center;}text{  margin-top: 45%;  justify-content: center;  align-self: center;  margin-bottom: 50px;}button{  width: 80%;  height: 60px;  margin-top: 20px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data: {    index:0,  },   stepperSkip(){    this.index = null;    this.index=2;  },   skipClick(){    this.$element('stepperId').setNextButtonStatus({status: 'skip', label: 'SKIP'});  },  stepperFinish(){    promptAction.showToast({      message: 'All Finished'    })  },  stepperChange(e){    console.log("stepperChange"+e.index)    promptAction.showToast({      // index表示当前步骤的序号      message: 'Previous step: '+e.prevIndex+"-------Current step:"+e.index    })  },  stepperNext(e){    console.log("stepperNext"+e.index)    promptAction.showToast({      // pendingIndex表示将要跳转的序号      message: 'Current step:'+e.index+"-------Next step:"+e.pendingIndex    })    var index = {pendingIndex:e.pendingIndex }    return index;  },  stepperBack(e){    console.log("stepperBack"+e.index)    var index = {pendingIndex: e.pendingIndex }    return index;  }}    场景示例 在本场景中，开发者可以在界面上点击选择并实时显示选择结果，点击下一步按钮后可动态修改页面的字体颜色和字体大小。 用stepper组件实现分步，再创建Toggle组件实现选择显示功能，再使用Select组件实现改变选中值动态修改字体颜色或大小。 已复制<!-- xxx.hml --><div class="container">  <stepper id="mystep" index="0" onfinish="back" style="text-color: indigo;">    <stepper-item label="{{label1}}">      <div style="flex-direction: column;padding: 0px 10px;">        <text class="text" style="margin-top: 10%;text-align: center;width: 100%;">Select error types:</text>        <text style="margin-top: 20px;padding: 10px">          <span>{{error}}</span>        </text>        <div style="justify-content: space-around;flex-wrap: wrap;">          <toggle for="{{togglelist1}}" value="{{$item}}" class="tog" onchange="multiTog({{$item}})"></toggle>        </div>      </div>    </stepper-item>    <stepper-item label="{{label2}}">      <div style="flex-direction: column;align-items: center;">        <text class="txt" style="margin-top: 10%;">Toggle</text>        <div style="justify-content: space-around;flex-wrap: wrap;;margin-top:10%">          <toggle class="tog" for="{{togglelist1}}" value="{{$item}}" style="text-color: {{tcolor}};font-size: {{tsize}}; font-style: {{tstyle}};font-weight: {{tweight}};font-family: {{tfamily}};">          </toggle>        </div>        <div style="flex-wrap: wrap;width: 700px;margin-top:10%">          <div style="flex-direction: column;width: 350px;height: 185px;align-items: center;">            <text class="txt">text-color</text>            <select onchange="settcolor">              <option for="{{color_list}}" value="{{$item}}">{{$item}}</option>            </select>          </div>          <div style="flex-direction: column;width: 350px;height: 185px;align-items: center;">            <text class="txt">font-size</text>            <select onchange="settsize">              <option for="{{size_list}}" value="{{$item}}">{{$item}}</option>            </select>          </div>        </div>      </div>    </stepper-item>  </stepper></div> 已复制/* xxx.css */.container {  width:100%;  height:100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color:#F1F3F5;}.dvd {  stroke-width: 8px;  color: orangered;  margin: 65px;}.tog{  margin-right: 20px;  margin-top: 30px;} 已复制// xxx.jslet myset = new Set();export default {  data: {    error: '',    tcolor:'#FF4500',    color_list:['#FF4500','#5F9EA0','#0000FF'],    tsize: '12px',    size_list: ['12px', '30px', '8px', '50px'],    label1: {      prevLabel: 'The text on the left of the starting step is invalid.',      nextLabel: 'Toggle'    },    label2: {      prevLabel: 'toggle',      nextLabel: 'END'    },    togglelist1:['Program error', 'Software', 'System', 'Application'],  },  multiTog(arg, e) {    this.error = ' '    if (e.checked) {      myset.add(arg)    } else {      myset.delete(arg)    }    for (let item of myset) {      this.error += item + ' '    }  },  settcolor(e) {    this.tcolor = e.newValue  },  settsize(e) {    this.tsize = e.newValue  }}    上一篇 form开发指导 下一篇 tabs开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。绘制图形 更新时间: 2024-03-20 16:30 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
 Svg组件可以用来绘制常见图形和线段，如矩形（<rect>）、圆形（<circle>）、线条(<line>）等，具体支持图形样式还请参考svg组件。 在本场景中，绘制各种图形拼接组成一个小房子。 DOC.hasCopy<!-- xxx.hml --><div class="container">  <svg width="1000" height="1000">    <polygon points="100,400 300,200 500,400" fill="red"></polygon>     //屋顶    <polygon points="375,275 375,225 425,225 425,325" fill="orange"></polygon>   //烟囱    <rect width="300" height="300" x="150" y="400" fill="orange">      //房子    </rect>    <rect width="100" height="100" x="180" y="450" fill="white">    //窗户    </rect>    <line x1="180" x2="280" y1="500" y2="500" stroke-width="4" fill="white" stroke="black"></line>     //窗框    <line x1="230" x2="230" y1="450" y2="550" stroke-width="4" fill="white" stroke="black"></line>     //窗框    <polygon points="325,700 325,550 400,550 400,700" fill="red"></polygon>     //门    <circle cx="380" cy="625" r="20" fill="black"></circle>      //门把手  </svg></div> DOC.hasCopy/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}   上一篇 基础知识 下一篇 绘制路径 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建Svg组件设置属性基础知识 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Svg组件主要作为svg画布的根节点使用，也可以在svg中嵌套使用。具体用法请参考Svg。 
说明
  从API version 7开始支持。 svg父组件或者svg组件需要定义宽高值，否则不进行绘制。  
  创建Svg组件 在pages/index目录下的hml文件中创建一个Svg组件。 已复制<!-- xxx.hml --><div class="container">  <svg width="400" height="400">  </svg></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}svg{  background-color: blue;}    设置属性 通过设置width、height、x、y和viewBox属性为Svg设置宽度、高度、x轴坐标、y轴坐标和Svg视口。 已复制<!-- xxx.hml --><div class="container">  <svg width="200" height="200" viewBox="0 0 100 100">        <svg class="rect" width="200" height="200" x="20" y="10">        </svg>    </svg></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}svg{  background-color: yellow;}.rect{  background-color: red;}  
说明
  x和y设置的是当前Svg的x轴和y轴坐标，如果当前Svg为根节点，x轴和y轴属性无效。 viewBox的宽高和svg的宽高不一致，会以中心对齐进行缩放。  
   上一篇 Svg开发指导 下一篇 绘制图形 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。绘制路径 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 Svg组件绘制路径时，通过Path中的M（起点）、H（水平线）、a（绘制弧形到指定位置）路径控制指令，并填充颜色实现饼状图效果。 已复制<!-- xxx.hml --><div class="container">  <svg fill="#00FF00" x="100" y="400">    <path d="M300,200 h-150 a150 150 0 1 0 150 -150 z" fill="red" stroke="blue" stroke-width="5" >        </path>     <path d="M275,175 v-150 a150 150 0 0 0 -150 150 z" fill="yellow" stroke="blue" stroke-width="5">        </path>  </svg></div> 已复制/* xxx.css */.container {  flex-direction: row;  justify-content: flex-start;  align-items: flex-start;  height: 1200px;  width: 600px;  background-color: #F1F3F5;}  
说明
M/m = moveto 参数x和y表示需要移动到点的x轴和y轴的坐标。在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画。 L/l = lineto 参数x和y表示一个点的x轴和y轴坐标，L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段。 H/h = horizontal lineto 绘制平行线。 V/v = vertical lineto 绘制垂直线。 C/c = curveto 三次贝塞尔曲线 设置三组坐标参数： x1 y1, x2 y2, x y。 S/s = smooth curveto 三次贝塞尔曲线命令 设置两组坐标参数： x2 y2, x y。 Q/q = quadratic Belzier curve 二次贝塞尔曲线 设置两组坐标参数： x1 y1, x y。 T/t = smooth quadratic Belzier curveto 二次贝塞尔曲线命令 设置参数： x y。 A/a = elliptical Arc 弧形命令 设置参数： rx ry x-axis-rotation（旋转角度）large-arc-flag（角度大小） sweep-flag（弧线方向） x y。large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。 Z/z = closepath 从当前点画一条直线到路径的起点。  
  上一篇 绘制图形 下一篇 绘制文本 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。文本沿路径绘制文本绘制文本 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 Svg组件还可以绘制文本。 文本
说明
 文本的展示内容需要写在元素标签text内，可嵌套tspan子元素标签分段。 只支持被父元素标签svg嵌套。 只支持默认字体sans-serif。  
 通过设置x（x轴坐标）、y（y轴坐标）、dx（文本x轴偏移）、dy（文本y轴偏移）、fill（字体填充颜色）、stroke（文本边框颜色）、stroke-width（文本边框宽度）等属性实现文本的不同展示样式。 已复制<!-- xxx.hml --><div class="container">  <svg>    <text x="200" y="300" font-size="80px" fill="blue" >Hello World</text>    <text x="200" y="300" dx="20" dy="80" font-size="80px" fill="blue" fill-opacity="0.5" stroke="red" stroke-width="2">Hello World</text>    <text x="20" y="550" fill="#D2691E">      <tspan dx="40" fill="red" font-size="80" fill-opacity="0.4">Hello World </tspan>    </text>  </svg></div>   沿路径绘制文本textpath文本内容沿着属性path中的路径绘制文本。 已复制<!-- xxx.hml --><div class="container">  <svg fill="#00FF00" x="100" y="400">    <path d="M40,360 Q360,360 360,180 Q360,20 200,20 Q40,40 40,160 Q40,280 180,180 Q180,180 200,100" stroke="red" fill="none"></path>      <text>        <textpath fill="blue" startOffset="20%" path="M40,360 Q360,360 360,180 Q360,20 200,20 Q40,40 40,160 Q40,280 180,180 Q180,180 200,100" font-size="30px">          This is textpath test.        </textpath>      </text>  </svg></div>    上一篇 绘制路径 下一篇 动效开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建swiper组件添加属性设置样式绑定事件场景示例swiper开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  swiper为滑动容器，提供切换显示子组件的能力。具体用法请参考swiper。  创建swiper组件 在pages/index目录下的hml文件中创建一个swiper组件。 已复制<!-- xxx.hml--><div class="container">  <swiper>    <div class="item" style="background-color: #bf45ea;">      <text>item1</text>    </div>    <div class="item" style="background-color: #088684;">      <text>item2</text>    </div>    <div class="item" style="background-color: #7786ee;">      <text>item3</text>    </div>  </swiper></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;  width: 100%;}swiper{  height: 30%;}.item{  width: 100%;  height: 500px;}text{  width: 100%;  height: 100%;  text-align: center;  font-size: 50px;  color: white;}  
说明
 swiper组件支持除<list>之外的子组件。 
   添加属性 swiper组件当不开启循环播放（loop="false"）时添加自动播放属性（autoplay），设置自动播放时播放时间间隔（interval），页面会自动切换并停留在最后一个子组件页面。添加digital属性启用数字导航点，设置切换时为渐隐滑动效果（scrolleffect="fade"））。 已复制<!-- xxx.hml--><div class="container">  <swiper index="1"  autoplay="true" interval="2000" indicator="true" digital="true" duration="500"  scrolleffect="fade" loop="false">    <div class="item" style="background-color: #bf45ea;">      <text>item1</text>    </div>    <div class="item" style="background-color: #088684;">      <text>item2</text>    </div>    <div class="item" style="background-color: #7786ee;">      <text>item3</text>    </div>    <div class="item" style="background-color: #c88cee;">      <text>item4</text>    </div>  </swiper></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;}swiper{  height: 30%;}.item{  width: 100%;  height: 500px;}text{  width: 100%;  height: 100%;  text-align: center;  font-size: 50px;  color: white;}  
说明
  设置indicator（是否启用导航点指示器）属性为true时digital（是否启用数字导航点）属性才会生效。 swiper子组件的个数大于等于2时设置的loop属性才会生效。 scrolleffect属性仅在loop属性值为false时生效。  
   设置样式 设置swiper组件的宽高，导航点指示器的直径大小（indicator-size）、颜色（indicator-color）、相对位置（ndicator-top）及选中时的颜色（indicator-selected-color）。 已复制<!-- xxx.hml--><div class="container">    <swiper index="1" autoplay="true" interval="2000"  duration="500" >        <div class="item" style="background-color: bisque;">            <text>item1</text>        </div>        <div class="item" style="background-color: darkkhaki;">            <text>item2</text>        </div>        <div class="item" style="background-color: cadetblue;">            <text>item3</text>        </div>    </swiper></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;}swiper{  width:  500px;  height: 500px;  border-radius: 250px;  indicator-color: white;  indicator-selected-color: blue;  indicator-size: 40px;  indicator-top: 100px;  overflow: hidden ;}.item{  width: 100%;  height: 500px;}text{  width: 100%;  text-align: center;  margin-top: 150px;  font-size: 50px;  color: white;}    绑定事件 创建两个text组件添加点击事件，当点击后就调用showPrevious（显示上一个子组件）或showNext（显示下一个子组件）方法。添加select组件下拉选择时触发change事件后调用swiperTo方法跳转到指定轮播页面。swiper组件绑定change（当前显示的组件索引变化时触发）和finish（切换动画结束时触发）事件。 已复制<!-- xxx.hml--><div class="container">  <swiper interval="2000" onchange="change" loop="false" onanimationfinish="finish" id="swiper">    <div class="item" style="background-color: #bf45ea">      <text>item1</text>    </div>    <div class="item" style="background-color: #088684;">      <text>item2</text>    </div>    <div class="item" style="background-color: #7786ee;">      <text>item3</text>    </div>    <div class="item" style="background-color: #c88cee;">      <text>item4</text>    </div>  </swiper>  <div class="content">      <button class="pnbtn" onclick="previous">Previous</button>      <select onchange="selectChange">          <option value="0">swipeTo 1</option>          <option value="1">swipeTo 2</option>          <option value="2">swipeTo 3</option>          <option value="3">swipeTo 4</option>      </select>    <button class="pnbtn" onclick="next">Next</button>  </div></div> 已复制/* xxx.css */.container{  width: 100%;  height: 100%;  flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;}swiper{  height: 30%;}.item{  width: 100%;  height: 500px;}text{  width: 100%;  height: 100%;  text-align: center;  font-size: 50px;  color: white;}select{  background-color: white;  width: 250px;  height: 80px;}.content{  margin-top: 100px;  justify-content: space-around;}.pnbtn{  width: 200px;  height: 80px;  font-size: 30px; } 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default{  change(e){    promptAction.showToast({duration:2000,message:"current index:"+e.index});  },  finish(){    promptAction.showToast({duration:2000,message:"切换动作结束"});  },  selectChange(e){    this.$element('swiper').swipeTo({index: Number(e.newValue)});  },  previous(){    this.$element('swiper').showPrevious();  },  next(){    this.$element('swiper').showNext();  }}    场景示例 本场景中使用swiper创建一个轮播图，在轮播图底部制作一个缩略图，点击缩略图后调用swipeTo方法切换到对应的轮播图。 已复制<!-- xxx.hml--><div class="container">  <swiper duration="500" indicator="false" id="swiper" onchange="change">    <div class="item" for="item in list">      <image src="{{item.src}}"></image>    </div>  </swiper>  <div class="content">    <div class="content_item {{index == $idx?'actived':''}}" for="item in list" onclick="imageTo({{$idx}})">      <image src="{{item.src}}"></image>    </div>  </div></div> 已复制/* xxx.css */.container{  flex-direction: column;  background-color: #F1F3F5;  align-items: center;  justify-content: center;  width: 100%;}swiper{  width: 100%;  height: 500px;}.item{  width: 100%;  height: 500px;}.content{  margin-top: -120px;  width: 70%;  display: flex;  justify-content: space-around;  height: 100px;}.content_item{  padding: 5px;  transform: scale(0.5);}.actived{  transform: scale(1);  border: 1px solid #b20937ea;} 已复制// xxx.jsexport default {  data:{    index: 0,    list:[      {src: 'common/images/1.png'},      {src: 'common/images/2.png'},      {src: 'common/images/3.png'},      {src: 'common/images/4.png'},]    },  imageTo(index){    this.index = index;    this.$element('swiper').swipeTo({index: index});  },  change(e){    this.index = e.index;  }}    上一篇 tabs开发指导 下一篇 基础组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建switch组件添加属性和方法场景示例switch开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  switch为开关选择器，切换开启或关闭状态。具体用法请参考switch。  创建switch组件 在pages/index目录下的hml文件中创建一个switch组件。 已复制<!-- xxx.hml --><div class="container">    <switch checked="true"></switch></div> 已复制/* xxx.css */.container {  flex-direction: column;  background-color: #F1F3F5;}    添加属性和方法 switch组件通过textoff和showtext属性设置文本选中和未选中时的状态。设置checked属性值为true（组件为打开状态）。添加change事件，当组件状态改变时触发，触发后执行switchChange函数获取组件当前状态（关闭/打开）。 已复制<!-- xxx.hml --><div class="container">  <switch showtext="true" texton="open" textoff="close" checked="true" @change="switchChange"></switch></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   display: flex;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}switch {  texton-color: #002aff;  textoff-color: silver;  text-padding: 20px;   font-size: 50px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  switchChange(e){    if(e.checked){      promptAction.showToast({        message: "open"      });    }else{      promptAction.showToast({        message: "close"      });    }  }}  
说明
 当showtext属性值设置为true时，texton和textoff设置的文本才会生效。 
   场景示例 在下面示例中设置开关为打开状态（使用默认收货地址），关闭开关后页面显示选择地址按钮，点击按钮即可改变收货地址。 实现方法：创建switch开关，设置checked属性为true，通过数据绑定改变收货地址。设置display属性（默认为none），当关闭开关改变display属性值为flex后显示地址模块，点击按钮改变颜色。 已复制<!-- xxx.hml --><div class="container">  <div class="change">    <text>Choose default address:</text>    <switch showtext="true" texton="on" textoff="off" checked="true" @change="switchChange"></switch>  </div>  <div class="content">    <text class="address"><span>Shipping address:</span><span class="textSpan">{{address}}</span></text>  </div>  <div class="myAddress" style="display: {{addressDisplay}};">    <text style="font-size: 30px;margin-bottom: 50px;">Choose an address:</text>    <text class="addressText" style="background-color: {{item == address?'#0fabe7':''}};color: {{item == address?'white':'black'}};"     for="item in addressList"@click="changeAddress({{$idx}}})">{{item}}</text>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   background-color: #F1F3F5;  flex-direction: column;  padding: 50px;}.change{  margin-top: 20%;  width: 100%;  justify-content: center;}switch{  texton-color: #002aff;  textoff-color: silver;  text-padding: 20px;}.content{  width: 70%;  text-align: center;  flex-direction: column;  border: 1px solid #002aff;  margin-left: 15%;  text-align: center;}.address{  width: 100%;  height: 100px;  line-height: 100px;  text-align: center;  font-size: 28px;  margin-bottom: 50px;}.textSpan{  color: #0aa9f1;}.myAddress{  flex-direction: column;  margin-top: 50px;}.addressText{  margin-left: 35%;  width: 30%;  height: 75px;  text-align: center;  color: white;  margin-bottom: 30px;  border-radius: 10px;  border: 1px solid #0fabe7;} 已复制// xxx.jsexport default {  data:{    address: '',    addressDisplay: 'none',    addressList: ['family','company','commissary'],  },  onInit(){    // 初始化默认地址为地址列表中的第一个    this.address = this.addressList[0];  },  switchChange(e){    if(e.checked){        this.addressDisplay = "none";    }else{        this.addressDisplay = "flex";    }  },  changeAddress(i){    this.address= this.addressList[i];  }}    上一篇 chart开发指导 下一篇 toolbar开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建text组件设置text组件样式和属性场景示例text开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  text是文本组件，用于呈现一段文本信息。具体用法请参考text API。  创建text组件 在pages/index目录下的hml文件中创建一个text组件。 已复制<!-- xxx.hml --><div class="container" style="text-align: center;justify-content: center; align-items: center;">  <text>Hello World</text></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}    设置text组件样式和属性  添加文本样式 设置color、font-size、allow-scale、word-spacing、text-valign属性分别为文本添加颜色、大小、缩放、文本之间的间距和文本在垂直方向的对齐方式。 已复制<!-- xxx.hml --><div class="container" style="background-color:#F1F3F5;flex-direction: column;justify-content: center; align-items: center;">     <text style="color: blueviolet; font-size: 40px; allow-scale:true">     This is a passage  </text>  <text style="color: blueviolet; font-size: 40px; margin-top: 20px; allow-scale:true;word-spacing: 20px;" >    This is a passage  </text></div>  已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;  background-color: #F1F3F5;}  添加划线 设置text-decoration和text-decoration-color属性为文本添加划线和划线颜色，text-decoration枚举值请参考 text自有样式。 已复制<!-- xxx.hml --><div class="container" style="background-color:#F1F3F5;">  <text style="text-decoration:underline">    This is a passage  </text>  <text style="text-decoration:line-through;text-decoration-color: red">    This is a passage   </text></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  justify-content: center;}text{  font-size: 50px;}  隐藏文本内容 当文本内容过多而显示不全时，添加text-overflow属性将隐藏内容以省略号的形式展现。 已复制<!-- xxx.hml --><div class="container">  <text class="text">    This is a passage  </text></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  flex-direction: column;  align-items: center;  background-color: #F1F3F5;  justify-content: center; }.text{  width: 200px;  max-lines: 1;  text-overflow:ellipsis;} 
说明
  text-overflow样式需要与max-lines样式配套使用，设置了最大行数的情况下生效。 max-lines属性设置文本最多可以展示的行数。  
 ​  设置文本折行 设置word-break属性对文本内容做断行处理，word-break枚举值请参考text自有样式。 已复制<!-- xxx.hml --><div class="container">  <div class="content">    <text class="text1">      Welcome to the world    </text>      <text class="text2">        Welcome to the world      </text>  </div></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  background-color: #F1F3F5;  flex-direction: column;  align-items: center;  justify-content: center;}.content{  width: 50%;  flex-direction: column;  align-items: center;  justify-content: center;}.text1{  width: 100%;  height: 200px;  border:1px solid #1a1919;  margin-bottom: 50px;  text-align: center;  word-break: break-word;  font-size: 40px;}.text2{  width: 100%;  height: 200px;  border:1px solid #0931e8;  text-align: center;  word-break: break-all;  font-size: 40px;} ​  text组件支持Span子组件 已复制<!-- xxx.hml --><div class="container" style="justify-content: center; align-items: center;flex-direction: column;background-color: #F1F3F5;  width: 100%;height: 100%;">  <text style="font-size: 45px;">    This is a passage  </text>  <text style="font-size: 45px;">    <span style="color: aqua;">This </span><span style="color: #F1F3F5;">      1           </span>       <span style="color: blue;"> is a </span>    <span style="color: #F1F3F5;">      1    </span>        <span style="color: red;">  passage </span>  </text></div>  
说明
  当使用Span子组件组成文本段落时，如果Span属性样式异常（例如：font-weight设置为1000），将导致文本段落显示异常。 在使用Span子组件时，注意text组件内不能存在文本内容，如果存在文本内容也只会显示子组件Span里的内容。  
    场景示例 text组件通过数据绑定展示文本内容，Span组件通过设置show属性来实现文本内容的隐藏和显示。 已复制<!-- xxx.hml --><div class="container">  <div style="align-items: center;justify-content: center;">    <text class="title">      {{ content }}    </text>    <switch checked="true" onchange="test"></switch>  </div>  <text class="span-container" style="color: #ff00ff;">    <span show="{{isShow}}">  {{ content  }}  </span>    <span style="color: white;">        1    </span>    <span style="color: #f76160">Hide clip </span>  </text></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;  align-items: center;  flex-direction: column;  justify-content: center;  background-color: #F1F3F5;}.title {  font-size: 26px;  text-align:center;  width: 200px;  height: 200px;} 已复制// xxx.jsexport default {     data: {        isShow:true,        content: 'Hello World'  },     onInit(){    },    test(e) {        this.isShow = e.checked    }}    上一篇 基础组件 下一篇 input开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建toolbar组件添加子组件设置样式绑定事件场景示例toolbar开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  toolbar为页面工具栏组件，用于展示针对当前界面的操作选项，可作为页面的一级导航。具体用法请参考toolbar。  创建toolbar组件 在pages/index目录下的hml文件中创建一个toolbar组件。 已复制<!-- xxx.hml --><div class="container">  <toolbar style="background-color: #F1F3F5;">    <toolbar-item value="item1"></toolbar-item>    <toolbar-item value="item2"></toolbar-item>  </toolbar></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}toolbar-item{  font-size: 35px;}    添加子组件 toolbar组件仅支持toolbar-item为子组件，页面最多可以展示5个toolbar-item子组件，如果存在6个及以上toolbar-item，则保留前面4个，后续的将收纳到工具栏上的更多项中，通过点击更多项弹窗进行展示。并且更多项展示的组件样式采用系统默认样式，toolbar-item上设置的自定义样式不生效。 已复制<!-- xxx.hml --><div class="container">  <toolbar>    <toolbar-item value="item1"></toolbar-item>        <toolbar-item value="item2"></toolbar-item>        <toolbar-item value="item3"></toolbar-item>        <toolbar-item value="item4"></toolbar-item>        <toolbar-item value="item5"></toolbar-item>        <toolbar-item value="item6"></toolbar-item>  </toolbar></div> 已复制/* xxx.css */.container {  width: 100%;  height: 100%;   flex-direction: column;  justify-content: center;  align-items: center;  background-color: #F1F3F5;}toolbar-item{  font-size: 35px;}    设置样式 设置position样式控制toolbar组件的位置，并设置子组件toolbar-item的字体颜色、大小及背景色。 已复制<!-- xxx.hml --><div class="container">  <toolbar style="position: fixed;bottom: 5%;width: 100%;background-color: #F1F3F5;">    <toolbar-item value="item1" icon="common/images/1.png"></toolbar-item>    <toolbar-item value="item2" icon="common/images/2.png"></toolbar-item>    <toolbar-item value="item3" icon="common/images/1.png"></toolbar-item>    <toolbar-item value="item4" icon="common/images/2.png"></toolbar-item>  </toolbar></div> 已复制/* xxx.css */.container {  background-color: #F1F3F5;  flex-direction: column;  width: 100%;  height: 100%;   justify-content: center;  align-items: center;}toolbar-item{  font-size: 35px;}    绑定事件 分别给toolbar-item绑定单击事件和长按事件，单击后文本变红，长按时文本变蓝。 已复制<!-- xxx.hml --><div class="container">  <toolbar style="position: fixed;top: 50%;width: 100%;background-color: #F1F3F5;">    <toolbar-item value="item1" icon="common/images/1.png" style="color: {{itemColor}};" onclick="itemClick"></toolbar-item>    <toolbar-item value="item2" icon="common/images/2.png"  style="color: {{itemColor}}"></toolbar-item>    <toolbar-item value="item3" icon="common/images/3.png"  style="color: {{itemColor}}" onlongpress="itemLongPress"></toolbar-item>  </toolbar></div> 已复制/* xxx.css */.container {  background-color: #F1F3F5;     flex-direction: column;  width: 100%;  height: 100%;   justify-content: center;  align-items: center;}toolbar-item{  font-size: 35px;} 已复制// xxx.jsimport promptAction from '@ohos.promptAction';export default {  data:{    itemColor:'black'  },  itemClick(){    this.itemColor= "red";    promptAction.showToast({duration:2000,message:'item click'});  },  itemLongPress(){    promptAction.showToast({duration:2000,message:'item long press'});    this.itemColor= "blue";  },}  
说明
 toolbar组件不支持添加事件和方法，但其子组件toolbar-item支持。 
   场景示例 本场景中开发者可点击toolbar-item组件，改变当前组件文本颜色并更换相对应的图片内容。 使用for循环创建toolbar-item组件并添加点击事件，点击后获得索引值进行存储。设置文本颜色时，判断当前索引值是否为储存的值，若相同则设置为红色，不同则使用默认颜色。 已复制<!-- xxx.hml --><div class="container">  <image src="{{imgList[active]}}"></image>  <toolbar style="position: fixed;bottom: 5%;width: 100%;background-color: #F1F3F5;">    <toolbar-item value="{{ item.option}}" icon="{{item.icon}}" style="color: {{active == $idx?'red':'black'}};background-color: {{active== $idx?'#dbe7f1':'#F1F3F5'}};" for="{{item in itemList}}" onclick="itemClick({{$idx}})"></toolbar-item>    </toolbar></div> 已复制/* xxx.css */.container {  background-color: #F1F3F5;     flex-direction: column;  width: 100%;  justify-content: center;  align-items: center;}toolbar-item{  font-size: 35px;} 已复制// xxx.jsexport default {  data:{    active: 0,    imgList:["common/images/1.png","common/images/2.png","common/images/3.png","common/images/4.png"],    itemList:[      {option:'item1',icon:'common/images/1.png'},      {option:'item2',icon:'common/images/2.png'},      {option:'item3',icon:'common/images/3.png'},      {option:'item4',icon:'common/images/4.png'},    ]  },  itemClick(id){    this.active= id;  },}    上一篇 switch开发指导 下一篇 menu开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自定义组件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  使用兼容JS的类Web开发范式的方舟开发框架支持自定义组件，用户可根据业务需求将已有的组件进行扩展，增加自定义的私有属性和事件，封装成新的组件，方便在工程中多次调用，提高页面布局代码的可读性。具体的封装方法示例如下：  构建自定义组件 已复制<!-- comp.hml --> <div class="item">    <text class="title-style">{{title}}</text>   <text class="text-style" onclick="childClicked" focusable="true">点击这里查看隐藏文本</text>   <text class="text-style" if="{{showObj}}">hello world</text> </div> 已复制/* comp.css */ .item {    width: 700px;     flex-direction: column;     height: 300px;     align-items: center;     margin-top: 100px;  } .text-style {   width: 100%;   text-align: center;   font-weight: 500;   font-family: Courier;   font-size: 36px; } .title-style {   font-weight: 500;   font-family: Courier;   font-size: 50px;   color: #483d8b; } 已复制// comp.js export default {   props: {     title: {       default: 'title',     },     showObject: {},   },   data() {      return {       showObj: this.showObject,     };   },    childClicked () {      this.$emit('eventType1', {text: '收到子组件参数'});     this.showObj = !this.showObj;    },  } 引入自定义组件 已复制<!-- xxx.hml --> <element name='comp' src='../../common/component/comp.hml'></element>  <div class="container">    <text>父组件：{{text}}</text>   <comp title="自定义组件" show-object="{{isShow}}" @event-type1="textClicked"></comp> </div> 已复制/* xxx.css */ .container {    background-color: #f8f8ff;    flex: 1;    flex-direction: column;    align-content: center; }  已复制// xxx.js export default {    data: {     text: '开始',     isShow: false,   },   textClicked (e) {     this.text = e.detail.text;   }, }  本示例中父组件通过添加自定义属性向子组件传递了名称为title的参数，子组件在props中接收。同时子组件也通过事件绑定向上传递了参数text，接收时通过e.detail获取。要绑定子组件事件，父组件事件命名必须遵循事件绑定规则，详见自定义组件开发规范。自定义组件效果如下图所示： 图1 自定义组件的效果   上一篇 动画帧 下一篇 Web 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。整体架构概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  兼容JS的类Web开发范式的方舟开发框架，采用经典的HML、CSS、JavaScript三段式开发方式。使用HML标签文件进行布局搭建，使用CSS文件进行样式描述，使用JavaScript文件进行逻辑处理。UI组件与数据之间通过单向数据绑定的方式建立关联，当数据发生变化时，UI界面自动触发更新。此种开发方式，更接近Web前端开发者的使用习惯，快速将已有的Web应用改造成方舟开发框架应用。主要适用于界面较为简单的中小型应用开发。 请参考兼容JS的类Web开发范式API文档，全面地了解组件，更好地开发应用。  整体架构 使用兼容JS的类Web开发范式的方舟开发框架，包括应用层（Application）、前端框架层（Framework）、引擎层（Engine）和平台适配层（Porting Layer）。   Application 应用层表示开发者开发的FA应用，这里的FA应用特指JS FA应用。 Framework 前端框架层主要完成前端页面解析，以及提供MVVM（Model-View-ViewModel）开发模式、页面路由机制和自定义组件等能力。 Engine 引擎层主要提供动画解析、DOM（Document Object Model）树构建、布局计算、渲染命令构建与绘制、事件管理等能力。 Porting Layer 适配层主要完成对平台层进行抽象，提供抽象接口，可以对接到系统平台。比如：事件对接、渲染管线对接和系统生命周期对接等。    上一篇 兼容JS的类Web开发范式 下一篇 框架说明 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用数据懒加载设置List组件的宽高使用条件渲染替代显隐控制使用Column/Row替代Flex减少应用滑动白块性能提升的推荐方法 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  开发者若使用低性能的代码实现功能场景可能不会影响应用的正常运行，但却会对应用的性能造成负面影响。本章节列举出了一些可提升性能的场景供开发者参考，以避免应用实现上带来的性能劣化。  使用数据懒加载 开发者在使用长列表时，如果直接采用循环渲染方式，如下所示，会一次性加载所有的列表元素，一方面会导致页面启动时间过长，影响用户体验，另一方面也会增加服务器的压力和流量，加重系统负担。 已复制@Entry@Componentstruct MyComponent {  @State arr: number[] = Array.from(Array(100), (v,k) =>k);  //构造0-99的数组  build() {    List() {      ForEach(this.arr, (item: number) => {        ListItem() {          Text(`item value: ${item}`)        }      }, (item: number) => item.toString())    }  }} 上述代码会在页面加载时将100个列表元素全部加载，这并非我们需要的，我们希望从数据源中按需迭代加载数据并创建相应组件，因此需要使用数据懒加载，如下所示： 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = []
  public totalCount(): number {    return 0  }
  public getData(index: number): any {    return undefined  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener')      this.listeners.push(listener)    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener')      this.listeners.splice(pos, 1)    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded()    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index)    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index)    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index)    })  }
  notifyDataMove(from: number, to: number): void {    this.listeners.forEach(listener => {      listener.onDataMove(from, to)    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = ['item value: 0', 'item value: 1', 'item value: 2']
  public totalCount(): number {    return this.dataArray.length  }
  public getData(index: number): any {    return this.dataArray[index]  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data)    this.notifyDataAdd(index)  }
  public pushData(data: string): void {    this.dataArray.push(data)    this.notifyDataAdd(this.dataArray.length - 1)  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource()
  build() {    List() {      LazyForEach(this.data, (item: string) => {        ListItem() {          Row() {            Text(item).fontSize(20).margin({ left: 10 })          }        }        .onClick(() => {          this.data.pushData('item value: ' + this.data.totalCount())        })      }, item => item)    }  }}  上述代码在页面加载时仅初始化加载三个列表元素，之后每点击一次列表元素，将增加一个列表元素。   设置List组件的宽高 在使用Scroll容器组件嵌套List组件加载长列表时，若不指定List的宽高尺寸，则默认全部加载。 
说明
 Scroll嵌套List时：  List没有设置宽高，会布局List的所有子组件。 List设置宽高，会布局List显示区域内的子组件。 List使用ForEach加载子组件时，无论是否设置List的宽高，都会加载所有子组件。 List使用LazyForEach加载子组件时，没有设置List的宽高，会加载所有子组件，设置了List的宽高，会加载List显示区域内的子组件。  
 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = []
  public totalCount(): number {    return 0  }
  public getData(index: number): any {    return undefined  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener')      this.listeners.push(listener)    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener')      this.listeners.splice(pos, 1)    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded()    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index)    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index)    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index)    })  }
  notifyDataMove(from: number, to: number): void {    this.listeners.forEach(listener => {      listener.onDataMove(from, to)    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: Array<string> = new Array(100).fill('test')
  public totalCount(): number {    return this.dataArray.length  }
  public getData(index: number): any {    return this.dataArray[index]  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data)    this.notifyDataAdd(index)  }
  public pushData(data: string): void {    this.dataArray.push(data)    this.notifyDataAdd(this.dataArray.length - 1)  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource()
  build() {    Scroll() {      List() {        LazyForEach(this.data, (item: string, index: number) => {          ListItem() {            Row() {              Text('item value: ' + item + (index + 1)).fontSize(20).margin(10)            }          }        })      }    }  }} 因此，此场景下建议设置List子组件的宽高。 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = []
  public totalCount(): number {    return 0  }
  public getData(index: number): any {    return undefined  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener')      this.listeners.push(listener)    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener')      this.listeners.splice(pos, 1)    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded()    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index)    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index)    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index)    })  }
  notifyDataMove(from: number, to: number): void {    this.listeners.forEach(listener => {      listener.onDataMove(from, to)    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: Array<string> = new Array(100).fill('test')
  public totalCount(): number {    return this.dataArray.length  }
  public getData(index: number): any {    return this.dataArray[index]  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data)    this.notifyDataAdd(index)  }
  public pushData(data: string): void {    this.dataArray.push(data)    this.notifyDataAdd(this.dataArray.length - 1)  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource()
  build() {    Scroll() {      List() {        LazyForEach(this.data, (item: string, index: number) => {          ListItem() {            Text('item value: ' + item + (index + 1)).fontSize(20).margin(10)          }.width('100%')        })      }.width('100%').height(500)    }.backgroundColor(Color.Pink)  }}    使用条件渲染替代显隐控制 如下所示，开发者在使用visibility通用属性控制组件的显隐状态时，仍存在组件的重新创建过程，造成性能上的损耗。 已复制@Entry@Componentstruct MyComponent {  @State isVisible: Visibility = Visibility.Visible;
  build() {    Column() {      Button("显隐切换")        .onClick(() => {          if (this.isVisible == Visibility.Visible) {            this.isVisible = Visibility.None          } else {            this.isVisible = Visibility.Visible          }        })      Row().visibility(this.isVisible)        .width(300).height(300).backgroundColor(Color.Pink)    }.width('100%')  }} 要避免这一问题，可使用if条件渲染代替visibility属性变换，如下所示： 已复制@Entry@Componentstruct MyComponent {  @State isVisible: boolean = true;
  build() {    Column() {      Button("显隐切换")        .onClick(() => {          this.isVisible = !this.isVisible        })      if (this.isVisible) {        Row()          .width(300).height(300).backgroundColor(Color.Pink)      }    }.width('100%')  }}    使用Column/Row替代Flex 由于Flex容器组件默认情况下存在shrink导致二次布局，这会在一定程度上造成页面渲染上的性能劣化。 已复制@Entry@Componentstruct MyComponent {  build() {    Flex({ direction: FlexDirection.Column }) {      Flex().width(300).height(200).backgroundColor(Color.Pink)      Flex().width(300).height(200).backgroundColor(Color.Yellow)      Flex().width(300).height(200).backgroundColor(Color.Grey)    }  }} 上述代码可将Flex替换为Column、Row，在保证实现的页面布局效果相同的前提下避免Flex二次布局带来的负面影响。 已复制@Entry@Componentstruct MyComponent {  build() {    Column() {      Row().width(300).height(200).backgroundColor(Color.Pink)      Row().width(300).height(200).backgroundColor(Color.Yellow)      Row().width(300).height(200).backgroundColor(Color.Grey)    }  }}    减少应用滑动白块 应用通过增大List/Grid控件的cachedCount参数，调整UI的加载范围。cachedCount表示屏幕外List/Grid预加载item的个数。 如果需要请求网络图片，可以在item滑动到屏幕显示之前，提前下载好内容，从而减少滑动白块。 如下是使用cachedCount参数的例子： 已复制@Entry@Componentstruct MyComponent {  private source: MyDataSource = new MyDataSource();
  build() {    List() {      LazyForEach(this.source, item => {        ListItem() {          Text("Hello" + item)            .fontSize(50)            .onAppear(() => {              console.log("appear:" + item)            })        }      })    }.cachedCount(3) // 扩大数值appear日志范围会变大  }}
class MyDataSource implements IDataSource {  data: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  public totalCount(): number {    return this.data.length  }
  public getData(index: number): any {    return this.data[index]  }
  registerDataChangeListener(listener: DataChangeListener): void {  }
  unregisterDataChangeListener(listener: DataChangeListener): void {  }}  使用说明： cachedCount的增加会增大UI的cpu、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。   上一篇 组合手势 下一篇 兼容JS的类Web开发范式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用EventHub进行数据通信使用globalThis进行数据同步UIAbility和Page之间使用globalThisUIAbility和UIAbility之间使用globalThisglobalThis使用的注意事项使用AppStorage/LocalStorage进行数据同步UIAbility组件与UI的数据同步 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  基于HarmonyOS的应用模型，可以通过以下两种方式来实现UIAbility组件与UI之间的数据同步。  使用EventHub进行数据通信：基于发布订阅模式来实现，事件需要先订阅后发布，订阅者收到消息后进行处理。 使用globalThis进行数据同步：ArkTS引擎实例内部的一个全局对象，在ArkTS引擎实例内部都能访问。   使用AppStorage/LocalStorage进行数据同步：ArkUI提供了AppStorage和LocalStorage两种应用级别的状态管理方案，可用于实现应用级别和UIAbility级别的数据同步。   使用EventHub进行数据通信 EventHub提供了UIAbility组件/ExtensionAbility组件级别的事件机制，以UIAbility组件/ExtensionAbility组件为中心提供了订阅、取消订阅和触发事件的数据通信能力。接口说明请参见EventHub。 在使用EventHub之前，首先需要获取EventHub对象。基类Context提供了EventHub对象，本章节以使用EventHub实现UIAbility与UI之间的数据通信为例进行说明。  在UIAbility中调用eventHub.on()方法注册一个自定义事件“event1”，eventHub.on()有如下两种调用方式，使用其中一种即可。 已复制import UIAbility from '@ohos.app.ability.UIAbility';
const TAG: string = '[Example].[Entry].[EntryAbility]';
export default class EntryAbility extends UIAbility {    func1(...data) {        // 触发事件，完成相应的业务操作        console.info(TAG, '1. ' + JSON.stringify(data));    }
    onCreate(want, launch) {        // 获取eventHub        let eventhub = this.context.eventHub;        // 执行订阅操作        eventhub.on('event1', this.func1);        eventhub.on('event1', (...data) => {            // 触发事件，完成相应的业务操作            console.info(TAG, '2. ' + JSON.stringify(data));        });    }} 在UI界面中通过eventHub.emit()方法触发该事件，在触发事件的同时，根据需要传入参数信息。 已复制import common from '@ohos.app.ability.common';
@Entry@Componentstruct Index {  private context = getContext(this) as common.UIAbilityContext;
  eventHubFunc() {    // 不带参数触发自定义“event1”事件    this.context.eventHub.emit('event1');    // 带1个参数触发自定义“event1”事件    this.context.eventHub.emit('event1', 1);    // 带2个参数触发自定义“event1”事件    this.context.eventHub.emit('event1', 2, 'test');    // 开发者可以根据实际的业务场景设计事件传递的参数  }
  // 页面展示  build() {    // ...  }} 在UIAbility的注册事件回调中可以得到对应的触发事件结果，运行日志结果如下所示。 已复制[]
[1]
[2,'test'] 在自定义事件“event1”使用完成后，可以根据需要调用eventHub.off()方法取消该事件的订阅。 已复制// context为UIAbility实例的AbilityContextthis.context.eventHub.off('event1');    使用globalThis进行数据同步 globalThis是ArkTS引擎实例内部的一个全局对象，引擎内部的UIAbility/ExtensionAbility/Page都可以使用，因此可以使用globalThis全局对象进行数据同步。 图1 使用globalThis进行数据同步  如上图所示，下面来具体介绍globalThis的使用：  UIAbility和Page之间使用globalThis UIAbility和UIAbility之间使用globalThis globalThis使用的注意事项    UIAbility和Page之间使用globalThis globalThis为ArkTS引擎实例下的全局对象，可以通过globalThis绑定属性/方法来进行UIAbility组件与UI的数据同步。例如在UIAbility组件中绑定want参数，即可在UIAbility对应的UI界面上使用want参数信息。  调用startAbility()方法启动一个UIAbility实例时，被启动的UIAbility创建完成后会进入onCreate()生命周期回调，且在onCreate()生命周期回调中能够接受到传递过来的want参数，可以将want参数绑定到globalThis上。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class EntryAbility extends UIAbility {    onCreate(want, launch) {        globalThis.entryAbilityWant = want;        // ...    }
    // ...} 在UI界面中即可通过globalThis获取到want参数信息。 已复制let entryAbilityWant;
@Entry@Componentstruct Index {  aboutToAppear() {    entryAbilityWant = globalThis.entryAbilityWant;  }
  // 页面展示  build() {    // ...  }}    UIAbility和UIAbility之间使用globalThis 同一个应用中UIAbility和UIAbility之间的数据传递，可以通过将数据绑定到全局变量globalThis上进行同步，如在AbilityA中将数据保存在globalThis，然后跳转到AbilityB中取得该数据：  AbilityA中保存数据一个字符串数据并挂载到globalThis上。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class AbilityA extends UIAbility {    onCreate(want, launch) {        globalThis.entryAbilityStr = 'AbilityA'; // AbilityA存放字符串“AbilityA”到globalThis        // ...    }} AbilityB中获取对应的数据。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class AbilityB extends UIAbility {    onCreate(want, launch) {        // AbilityB从globalThis读取name并输出        console.info('name from entryAbilityStr: ' + globalThis.entryAbilityStr);        // ...    }}    globalThis使用的注意事项 图2 globalThis注意事项   Stage模型下进程内的UIAbility组件共享ArkTS引擎实例，使用globalThis时需要避免存放相同名称的对象。例如AbilityA和AbilityB可以使用globalThis共享数据，在存放相同名称的对象时，先存放的对象会被后存放的对象覆盖。 FA模型因为每个UIAbility组件之间引擎隔离，不会存在该问题。 对于绑定在globalThis上的对象，其生命周期与ArkTS虚拟机实例相同，建议在使用完成之后将其赋值为null，以减少对应用内存的占用。  Stage模型上同名对象覆盖导致问题的场景举例说明。  在AbilityA文件中使用globalThis存放了UIAbilityContext。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class AbilityA extends UIAbility {    onCreate(want, launch) {        globalThis.context = this.context; // AbilityA存放context到globalThis        // ...    }} 在AbilityA的页面中获取该UIAbilityContext并进行使用。使用完成后将AbilityA实例切换至后台。 已复制@Entry@Componentstruct Index {  onPageShow() {    let ctx = globalThis.context; // 页面中从globalThis中取出context并使用    let permissions = ['com.example.permission']    ctx.requestPermissionsFromUser(permissions,(result) => {       // ...    });  }  // 页面展示  build() {    // ...  }} 在AbilityB文件中使用globalThis存放了UIAbilityContext，并且命名为相同的名称。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class AbilityB extends UIAbility {    onCreate(want, launch) {        // AbilityB覆盖了AbilityA在globalThis中存放的context        globalThis.context = this.context;        // ...    }} 在AbilityB的页面中获取该UIAbilityContext并进行使用。此时获取到的globalThis.context已经表示为AbilityB中赋值的UIAbilityContext内容。 已复制@Entry@Componentstruct Index {  onPageShow() {    let ctx = globalThis.context; // Page中从globalThis中取出context并使用    let permissions = ['com.example.permission']    ctx.requestPermissionsFromUser(permissions,(result) => {      console.info('requestPermissionsFromUser result:' + JSON.stringify(result));    });  }  // 页面展示  build() {    // ...  }} 在AbilityB实例切换至后台，将AbilityA实例从后台切换回到前台。此时AbilityA的onCreate生命周期不会再次进入。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class AbilityA extends UIAbility {    onCreate(want, launch) { // AbilityA从后台进入前台，不会再走这个生命周期        globalThis.context = this.context;        // ...    }} 在AbilityA的页面再次回到前台时，其获取到的globalThis.context表示的为AbilityB的UIAbilityContext，而不是AbilityA的UIAbilityContext，在AbilityA的页面中使用则会出错。 已复制@Entry@Componentstruct Index {  onPageShow() {    let ctx = globalThis.context; // 这时候globalThis中的context是AbilityB的context    let permissions=['com.example.permission'];    ctx.requestPermissionsFromUser(permissions,(result) => { // 使用这个对象就会导致进程崩溃       console.info('requestPermissionsFromUser result:' + JSON.stringify(result));    });  }  // 页面展示  build() {    // ...  }}     使用AppStorage/LocalStorage进行数据同步 ArkUI提供了AppStorage和LocalStorage两种应用级别的状态管理方案，可用于实现应用级别和UIAbility级别的数据同步。使用这些方案可以方便地管理应用状态，提高应用性能和用户体验。其中，AppStorage是一个全局的状态管理器，适用于多个UIAbility共享同一状态数据的情况；而LocalStorage则是一个局部的状态管理器，适用于单个UIAbility内部使用的状态数据。通过这两种方案，开发者可以更加灵活地控制应用状态，提高应用的可维护性和可扩展性。详细请参见应用级变量的状态管理。   上一篇 UIAbility组件基本用法 下一篇 UIAbility组件间交互（设备内） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。启动应用内的UIAbility启动应用内的UIAbility并获取返回结果启动其他应用的UIAbility启动其他应用的UIAbility并获取返回结果启动UIAbility的指定页面调用方UIAbility指定启动页面目标UIAbility首次启动目标UIAbility非首次启动UIAbility组件间交互（设备内） 更新时间: 2024-03-25 11:20 毫无帮助帮助不大一般很好非常好
分享
  UIAbility是系统调度的最小单元。在设备内的功能模块之间跳转时，会涉及到启动特定的UIAbility，该UIAbility可以是应用内的其他UIAbility，也可以是其他应用的UIAbility（例如启动三方支付UIAbility）。 本章节将从如下场景分别介绍设备内UIAbility间的交互方式。  启动应用内的UIAbility 启动应用内的UIAbility并获取返回结果 启动其他应用的UIAbility 启动其他应用的UIAbility并获取返回结果 启动UIAbility的指定页面   启动应用内的UIAbility 当一个应用内包含多个UIAbility时，存在应用内启动UIAbility的场景。例如在支付应用中从入口UIAbility启动收付款UIAbility。 假设应用中有两个UIAbility：EntryAbility和FuncAbility（可以在同一个Module中，也可以在不同的Module中），需要从EntryAbility的页面中启动FuncAbility。  在EntryAbility中，通过调用startAbility()方法启动UIAbility，want为UIAbility实例启动的入口参数，其中bundleName为待启动应用的Bundle名称，abilityName为待启动的UIAbility名称，moduleName在待启动的UIAbility属于不同的Module时添加，parameters为自定义信息参数。示例中的context的获取方式参见获取UIAbility的Context属性。 已复制let wantInfo = {    deviceId: '', // deviceId为空表示本设备    bundleName: 'com.example.myapplication',    abilityName: 'FuncAbility',    moduleName: 'module1', // moduleName非必选    parameters: { // 自定义信息        info: '来自EntryAbility Index页面',    },}// context为调用方UIAbility的AbilityContextthis.context.startAbility(wantInfo).then(() => {    // ...}).catch((err) => {    // ...}) 在FuncAbility的生命周期回调函数中接收EntryAbility传递过来的参数。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
export default class FuncAbility extends UIAbility {    onCreate(want, launchParam) {    // 接收调用方UIAbility传过来的参数        let funcAbilityWant = want;        let info = funcAbilityWant?.parameters?.info;        // ...    }} 在FuncAbility业务完成之后，如需要停止当前UIAbility实例，在FuncAbility中通过调用terminateSelf()方法实现。 已复制// context为需要停止的UIAbility实例的AbilityContextthis.context.terminateSelf((err) => {    // ...});    启动应用内的UIAbility并获取返回结果 在一个EntryAbility启动另外一个FuncAbility时，希望在被启动的FuncAbility完成相关业务后，能将结果返回给调用方。例如在应用中将入口功能和帐号登录功能分别设计为两个独立的UIAbility，在帐号登录UIAbility中完成登录操作后，需要将登录的结果返回给入口UIAbility。  在EntryAbility中，调用startAbilityForResult()接口启动FuncAbility，异步回调中的data用于接收FuncAbility停止自身后返回给EntryAbility的信息。示例中的context的获取方式参见获取UIAbility的Context属性。 已复制let wantInfo = {    deviceId: '', // deviceId为空表示本设备    bundleName: 'com.example.myapplication',    abilityName: 'FuncAbility',    moduleName: 'module1', // moduleName非必选    parameters: { // 自定义信息        info: '来自EntryAbility Index页面',    },}// context为调用方UIAbility的AbilityContextthis.context.startAbilityForResult(wantInfo).then((data) => {    // ...}).catch((err) => {    // ...}) 在FuncAbility停止自身时，需要调用terminateSelfWithResult()方法，入参abilityResult为FuncAbility需要返回给EntryAbility的信息。 已复制const RESULT_CODE: number = 1001;let abilityResult = {    resultCode: RESULT_CODE,    want: {        bundleName: 'com.example.myapplication',        abilityName: 'FuncAbility',        moduleName: 'module1',        parameters: {            info: '来自FuncAbility Index页面',        },    },}// context为被调用方UIAbility的AbilityContextthis.context.terminateSelfWithResult(abilityResult, (err) => {    // ...}); FuncAbility停止自身后，EntryAbility通过startAbilityForResult()方法回调接收被FuncAbility返回的信息，RESULT_CODE需要与前面的数值保持一致。 已复制const RESULT_CODE: number = 1001;
// ...
// context为调用方UIAbility的AbilityContextthis.context.startAbilityForResult(want).then((data) => {    if (data?.resultCode === RESULT_CODE) {        // 解析被调用方UIAbility返回的信息        let info = data.want?.parameters?.info;        // ...    }}).catch((err) => {    // ...})    启动其他应用的UIAbility 启动其他应用的UIAbility，通常用户只需要完成一个通用的操作（例如需要选择一个文档应用来查看某个文档的内容信息），推荐使用隐式Want启动。系统会根据调用方的want参数来识别和启动匹配到的应用UIAbility。 启动UIAbility有显式Want启动和隐式Want启动两种方式。  显式Want启动：启动一个确定应用的UIAbility，在want参数中需要设置该应用bundleName和abilityName，当需要拉起某个明确的UIAbility时，通常使用显式Want启动方式。 隐式Want启动：根据匹配条件由用户选择启动哪一个UIAbility，即不明确指出要启动哪一个UIAbility（abilityName参数未设置），在调用startAbility()方法时，其入参want中指定了一系列的entities字段（表示目标UIAbility额外的类别信息，如浏览器、视频播放器）和actions字段（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析want，并帮助找到合适的UIAbility来启动。当需要拉起其他应用的UIAbility时，开发者通常不知道用户设备中应用的安装情况，也无法确定目标应用的bundleName和abilityName，通常使用隐式Want启动方式。  本章节主要讲解如何通过隐式Want启动其他应用的UIAbility。  将多个待匹配的文档应用安装到设备，在其对应UIAbility的module.json5配置文件中，配置skills的entities字段和actions字段。 已复制{  "module": {    "abilities": [      {        // ...        "skills": [          {            "entities": [              // ...              "entity.system.default"            ],            "actions": [              // ...              "ohos.want.action.viewData"            ]          }        ]      }    ]  }} 在调用方want参数中的entities和action需要被包含在待匹配UIAbility的skills配置的entities和actions中。系统匹配到符合entities和actions参数条件的UIAbility后，会弹出选择框展示匹配到的UIAbility实例列表供用户选择使用。示例中的context的获取方式参见获取UIAbility的Context属性。 已复制let wantInfo = {    deviceId: '', // deviceId为空表示本设备    // 如果希望隐式仅在特定的捆绑包中进行查询，请取消下面的注释。    // bundleName: 'com.example.myapplication',    action: 'ohos.want.action.viewData',    // entities可以被省略。    entities: ['entity.system.default'],}
// context为调用方UIAbility的AbilityContextthis.context.startAbility(wantInfo).then(() => {    // ...}).catch((err) => {    // ...}) 效果示意如下图所示，点击“打开PDF文档”时，会弹出选择框供用户选择。  在文档应用使用完成之后，如需要停止当前UIAbility实例，通过调用terminateSelf()方法实现。 已复制// context为需要停止的UIAbility实例的AbilityContextthis.context.terminateSelf((err) => {    // ...});    启动其他应用的UIAbility并获取返回结果 当使用隐式Want启动其他应用的UIAbility并希望获取返回结果时，调用方需要使用startAbilityForResult()方法启动目标UIAbility。例如主应用中需要启动三方支付并获取支付结果。  在支付应用对应UIAbility的module.json5配置文件中，配置skills的entities字段和actions字段。 已复制{  "module": {    "abilities": [      {        // ...        "skills": [          {            "entities": [              // ...              "entity.system.default"            ],            "actions": [              // ...              "ohos.want.action.editData"            ]          }        ]      }    ]  }} 调用方使用startAbilityForResult()方法启动支付应用的UIAbility，在调用方want参数中的entities和action需要被包含在待匹配UIAbility的skills配置的entities和actions中。异步回调中的data用于后续接收支付UIAbility停止自身后返回给调用方的信息。系统匹配到符合entities和actions参数条件的UIAbility后，会弹出选择框展示匹配到的UIAbility实例列表供用户选择使用。 已复制let wantInfo = {    deviceId: '', // deviceId为空表示本设备    // uncomment line below if wish to implicitly query only in the specific bundle.    // bundleName: 'com.example.myapplication',    action: 'ohos.want.action.editData',    // entities can be omitted.    entities: ['entity.system.default'],}
// context为调用方UIAbility的AbilityContextthis.context.startAbilityForResult(wantInfo).then((data) => {    // ...}).catch((err) => {    // ...}) 在支付UIAbility完成支付之后，需要调用terminateSelfWithResult()方法实现停止自身，并将abilityResult参数信息返回给调用方。 已复制const RESULT_CODE: number = 1001;let abilityResult = {    resultCode: RESULT_CODE,    want: {        bundleName: 'com.example.myapplication',        abilityName: 'EntryAbility',        moduleName: 'entry',        parameters: {            payResult: 'OKay',        },    },}// context为被调用方UIAbility的AbilityContextthis.context.terminateSelfWithResult(abilityResult, (err) => {    // ...}); 在调用方startAbilityForResult()方法回调中接收支付应用返回的信息，RESULT_CODE需要与前面terminateSelfWithResult()返回的数值保持一致。 已复制const RESULT_CODE: number = 1001;
let want = {  // Want参数信息};
// context为调用方UIAbility的AbilityContextthis.context.startAbilityForResult(want).then((data) => {    if (data?.resultCode === RESULT_CODE) {        // 解析被调用方UIAbility返回的信息        let payResult = data.want?.parameters?.payResult;        // ...    }}).catch((err) => {    // ...})    启动UIAbility的指定页面 一个UIAbility可以对应多个页面，在不同的场景下启动该UIAbility时需要展示不同的页面，例如从一个UIAbility的页面中跳转到另外一个UIAbility时，希望启动目标UIAbility的指定页面。本文主要讲解目标UIAbility首次启动和目标UIAbility非首次启动两种启动指定页面的场景，以及在讲解启动指定页面之前会讲解到在调用方如何指定启动页面。   调用方UIAbility指定启动页面 调用方UIAbility启动另外一个UIAbility时，通常需要跳转到指定的页面。例如FuncAbility包含两个页面（Index对应首页，Second对应功能A页面），此时需要在传入的want参数中配置指定的页面路径信息，可以通过want中的parameters参数增加一个自定义参数传递页面跳转信息。示例中的context的获取方式参见获取UIAbility的Context属性。 已复制let wantInfo = {    deviceId: '', // deviceId为空表示本设备    bundleName: 'com.example.myapplication',    abilityName: 'FuncAbility',    moduleName: 'module1', // moduleName非必选    parameters: { // 自定义参数传递页面信息        router: 'funcA',    },}// context为调用方UIAbility的AbilityContextthis.context.startAbility(wantInfo).then(() => {    // ...}).catch((err) => {    // ...})   目标UIAbility首次启动 目标UIAbility首次启动时，在目标UIAbility的onWindowStageCreate()生命周期回调中，解析EntryAbility传递过来的want参数，获取到需要加载的页面信息url，传入windowStage.loadContent()方法。 已复制import UIAbility from '@ohos.app.ability.UIAbility'import Window from '@ohos.window'
export default class FuncAbility extends UIAbility {    funcAbilityWant;
    onCreate(want, launchParam) {        // 接收调用方UIAbility传过来的参数        this.funcAbilityWant = want;    }
    onWindowStageCreate(windowStage: Window.WindowStage) {        // Main window is created, set main page for this ability        let url = 'pages/Index';        if (this.funcAbilityWant?.parameters?.router) {            if (this.funcAbilityWant.parameters.router === 'funcA') {                url = 'pages/Second';            }        }        windowStage.loadContent(url, (err, data) => {            // ...        });    }}   目标UIAbility非首次启动 经常还会遇到一类场景，当应用A已经启动且处于主页面时，回到桌面，打开应用B，并从应用B再次启动应用A，且需要跳转到应用A的指定页面。例如联系人应用和短信应用配合使用的场景。打开短信应用主页，回到桌面，此时短信应用处于已打开状态且当前处于短信应用的主页。再打开联系人应用主页，进入联系人用户A查看详情，点击短信图标，准备给用户A发送短信，此时会再次拉起短信应用且当前处于短信应用的发送页面。  针对以上场景，即当应用A的UIAbility实例已创建，并且处于该UIAbility实例对应的主页面中，此时，从应用B中需要再次启动应用A的该UIAbility，并且需要跳转到不同的页面，这种情况下要如何实现呢？  在目标UIAbility中，默认加载的是Index页面。由于当前UIAbility实例之前已经创建完成，此时会进入UIAbility的onNewWant()回调中且不会进入onCreate()和onWindowStageCreate()生命周期回调，在onNewWant()回调中解析调用方传递过来的want参数，并挂载到全局变量globalThis中，以便于后续在页面中获取。 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class FuncAbility extends UIAbility {    onNewWant(want, launchParam) {        // 接收调用方UIAbility传过来的参数        globalThis.funcAbilityWant = want;        // ...    }} 在FuncAbility中，此时需要在Index页面中通过页面路由Router模块实现指定页面的跳转，由于此时FuncAbility对应的Index页面是处于激活状态，不会重新变量声明以及进入aboutToAppear()生命周期回调中。因此可以在Index页面的onPageShow()生命周期回调中实现页面路由跳转的功能。 已复制import router from '@ohos.router';
@Entry@Componentstruct Index {  onPageShow() {    let funcAbilityWant = globalThis.funcAbilityWant;    let url2 = funcAbilityWant?.parameters?.router;    if (url2 && url2 === 'funcA') {      router.replaceUrl({        url: 'pages/Second',      })    }  }
  // 页面展示  build() {    // ...  }}  
说明
 当被调用方Ability的启动模式设置为multiton启动模式时，每次启动都会创建一个新的实例，那么onNewWant()回调就不会被用到。 
   上一篇 UIAbility组件与UI的数据同步 下一篇 ExtensionAbility组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。singleton启动模式multiton启动模式specified启动模式UIAbility组件启动模式 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  UIAbility的启动模式是指UIAbility实例在启动时的不同呈现状态。针对不同的业务场景，系统提供了三种启动模式：  singleton（单实例模式） multiton（多实例模式） specified（指定实例模式）   singleton启动模式 singleton启动模式为单实例模式，也是默认情况下的启动模式。 每次调用startAbility()方法时，如果应用进程中该类型的UIAbility实例已经存在，则复用系统中的UIAbility实例。系统中只存在唯一一个该UIAbility实例，即在最近任务列表中只存在一个该类型的UIAbility实例。 图1 单实例模式演示效果  
说明
 应用的UIAbility实例已创建，该UIAbility配置为单实例模式，再次调用startAbility()方法启动该UIAbility实例，此时只会进入该UIAbility的onNewWant()回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。 
 如果需要使用singleton启动模式，在module.json5配置文件中的"launchType"字段配置为"singleton"即可。 已复制{  "module": {    // ...    "abilities": [      {        "launchType": "singleton",        // ...      }    ]  }}   multiton启动模式 multiton启动模式为多实例模式，每次调用startAbility()方法时，都会在应用进程中创建一个新的该类型UIAbility实例。即在最近任务列表中可以看到有多个该类型的UIAbility实例。这种情况下可以将UIAbility配置为multiton（多实例模式）。 图2 多实例模式演示效果  multiton启动模式的开发使用，在module.json5配置文件中的"launchType"字段配置为"multiton"即可。 已复制{  "module": {    // ...    "abilities": [      {        "launchType": "multiton",        // ...      }    ]  }}   specified启动模式 specified启动模式为指定实例模式，针对一些特殊场景使用（例如文档应用中每次新建文档希望都能新建一个文档实例，重复打开一个已保存的文档希望打开的都是同一个文档实例）。 在UIAbility实例创建之前，允许开发者为该实例创建一个唯一的字符串Key，创建的UIAbility实例绑定Key之后，后续每次调用startAbility()方法时，都会询问应用使用哪个Key对应的UIAbility实例来响应startAbility()请求。运行时由UIAbility内部业务决定是否创建多实例，如果匹配有该UIAbility实例的Key，则直接拉起与之绑定的UIAbility实例，否则创建一个新的UIAbility实例。 图3 指定实例模式演示效果  
说明
 应用的UIAbility实例已创建，该UIAbility配置为指定实例模式，再次调用startAbility()方法启动该UIAbility实例，且AbilityStage的onAcceptWant()回调匹配到一个已创建的UIAbility实例。此时，再次启动该UIAbility时，只会进入该UIAbility的onNewWant()回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。 
 例如有两个UIAbility：EntryAbility和FuncAbility，FuncAbility配置为specified启动模式，需要从EntryAbility的页面中启动FuncAbility。  在FuncAbility中，将module.json5配置文件的"launchType"字段配置为"specified"。 已复制{  "module": {    // ...    "abilities": [      {        "launchType": "specified",        // ...      }    ]  }} 在EntryAbility中，调用startAbility()方法时，在want参数中，增加一个自定义参数来区别UIAbility实例，例如增加一个"instanceKey"自定义参数。 已复制// 在启动指定实例模式的UIAbility时，给每一个UIAbility实例配置一个独立的Key标识// 例如在文档使用场景中，可以用文档路径作为Key标识function getInstance() {    // ...}
let want = {    deviceId: '', // deviceId为空表示本设备    bundleName: 'com.example.myapplication',    abilityName: 'FuncAbility',    moduleName: 'module1', // moduleName非必选    parameters: { // 自定义信息        instanceKey: getInstance(),    },}// context为调用方UIAbility的AbilityContextthis.context.startAbility(want).then(() => {    // ...}).catch((err) => {    // ...}) 由于FuncAbility的启动模式配置为了指定实例启动模式，在FuncAbility启动之前，会先进入其对应的AbilityStage的onAcceptWant()生命周期回调中，解析传入的want参数，获取"instanceKey"自定义参数。根据业务需要通过AbilityStage的onAcceptWant()生命周期回调返回一个字符串Key标识。如果返回的Key对应一个已启动的UIAbility，则会将之前的UIAbility拉回前台并获焦，而不创建新的实例，否则创建新的实例并启动。 已复制import AbilityStage from '@ohos.app.ability.AbilityStage';
export default class MyAbilityStage extends AbilityStage {    onAcceptWant(want): string {        // 在被调用方的AbilityStage中，针对启动模式为specified的UIAbility返回一个UIAbility实例对应的一个Key值        // 当前示例指的是module1 Module的FuncAbility        if (want.abilityName === 'FuncAbility') {            // 返回的字符串Key标识为自定义拼接的字符串内容            return `ControlModule_EntryAbilityInstance_${want.parameters.instanceKey}`;        }
        return '';    }} 例如在文档应用中，可以对不同的文档实例内容绑定不同的Key值。当每次新建文档的时候，可以传入不同的新Key值（如可以将文件的路径作为一个Key标识），此时AbilityStage中启动UIAbility时都会创建一个新的UIAbility实例；当新建的文档保存之后，回到桌面，或者新打开一个已保存的文档，回到桌面，此时再次打开该已保存的文档，此时AbilityStage中再次启动该UIAbility时，打开的仍然是之前原来已保存的文档界面。 以如下步骤所示进行举例说明。  打开文件A，对应启动一个新的UIAbility实例，例如启动“UIAbility实例1”。 在最近任务列表中关闭文件A的进程，此时UIAbility实例1被销毁，回到桌面，再次打开文件A，此时对应启动一个新的UIAbility实例，例如启动“UIAbility实例2”。 回到桌面，打开文件B，此时对应启动一个新的UIAbility实例，例如启动“UIAbility实例3”。 回到桌面，再次打开文件A，此时对应启动的还是之前的“UIAbility实例2”。     上一篇 UIAbility组件生命周期 下一篇 UIAbility组件基本用法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述生命周期状态说明Create状态WindowStageCreate和WindowStageDestroy状态Foreground和Background状态Destroy状态UIAbility组件生命周期 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 当用户打开、切换和返回到对应应用时，应用中的UIAbility实例会在其生命周期的不同状态之间转换。UIAbility类提供了一系列回调，通过这些回调可以知道当前UIAbility实例的某个状态发生改变，会经过UIAbility实例的创建和销毁，或者UIAbility实例发生了前后台的状态切换。 UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，如下图所示。 图1 UIAbility生命周期状态    生命周期状态说明   Create状态 Create状态为在应用加载过程中，UIAbility实例创建完成时触发，系统会调用onCreate()回调。可以在该回调中进行页面初始化操作，例如变量定义资源加载等，用于后续的UI界面展示。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        // 页面初始化    }    // ...}   WindowStageCreate和WindowStageDestroy状态 UIAbility实例创建完成之后，在进入Foreground之前，系统会创建一个WindowStage。WindowStage创建完成后会进入onWindowStageCreate()回调，可以在该回调中设置UI界面加载、设置WindowStage的事件订阅。 图2 WindowStageCreate和WindowStageDestroy状态  在onWindowStageCreate()回调中通过loadContent()方法设置应用要加载的页面并根据需要订阅WindowStage的事件（获焦/失焦、可见/不可见）。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
export default class EntryAbility extends UIAbility {    onWindowStageCreate(windowStage: Window.WindowStage) {        // 设置WindowStage的事件订阅（获焦/失焦、可见/不可见）
        // 设置UI界面加载        windowStage.loadContent('pages/Index', (err, data) => {            // ...        });    }} 
说明
 WindowStage的相关使用请参见窗口开发指导。 
 对应于onWindowStageCreate()回调。在UIAbility实例销毁之前，则会先进入onWindowStageDestroy()回调，可以在该回调中释放UI界面资源。例如在onWindowStageDestroy()中注销获焦/失焦等WindowStage事件。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
export default class EntryAbility extends UIAbility {    // ...
    onWindowStageDestroy() {        // 释放UI界面资源    }}   Foreground和Background状态 Foreground和Background状态分别在UIAbility实例切换至前台和切换至后台时触发，对应于onForeground()回调和onBackground()回调。 onForeground()回调，在UIAbility的UI界面可见之前，如UIAbility切换至前台时触发。可以在onForeground()回调中申请系统需要的资源，或者重新申请在onBackground()中释放的资源。 onBackground()回调，在UIAbility的UI界面完全不可见之后，如UIAbility切换至后台时候触发。可以在onBackground()回调中释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。 例如应用在使用过程中需要使用用户定位时，假设应用已获得用户的定位权限授权。在UI界面显示之前，可以在onForeground()回调中开启定位功能，从而获取到当前的位置信息。 当应用切换到后台状态，可以在onBackground()回调中停止定位功能，以节省系统的资源消耗。 已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onForeground() {        // 申请系统需要的资源，或者重新申请在onBackground中释放的资源    }
    onBackground() {        // 释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作        // 例如状态保存等    }}   Destroy状态 Destroy状态在UIAbility实例销毁时触发。可以在onDestroy()回调中进行系统资源的释放、数据的保存等操作。 例如调用terminateSelf()方法停止当前UIAbility实例，从而完成UIAbility实例的销毁；或者用户使用最近任务列表关闭该UIAbility实例，完成UIAbility的销毁。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
export default class EntryAbility extends UIAbility {    onDestroy() {        // 系统资源的释放、数据的保存等    }}   上一篇 UIAbility组件概述 下一篇 UIAbility组件启动模式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述声明配置UIAbility组件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 UIAbility组件是一种包含UI界面的应用组件，主要用于和用户交互。 UIAbility组件是系统调度的基本单元，为应用提供绘制界面的窗口；一个UIAbility组件中可以通过多个页面来实现一个功能模块。每一个UIAbility组件实例，都对应于一个最近任务列表中的任务。   声明配置 为使应用能够正常使用UIAbility，需要在module.json5配置文件的abilities标签中声明UIAbility的名称、入口、标签等相关信息。 已复制{  "module": {    // ...    "abilities": [      {        "name": "EntryAbility", // UIAbility组件的名称        "srcEntry": "./ets/entryability/EntryAbility.ts", // UIAbility组件的代码路径        "description": "$string:EntryAbility_desc", // UIAbility组件的描述信息        "icon": "$media:icon", // UIAbility组件的图标        "label": "$string:EntryAbility_label", // UIAbility组件的标签        "startWindowIcon": "$media:icon", // UIAbility组件启动页面图标资源文件的索引        "startWindowBackground": "$color:start_window_background", // UIAbility组件启动页面背景颜色资源文件的索引        // ...      }    ]  }}   上一篇 UIAbility组件 下一篇 UIAbility组件生命周期 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。指定UIAbility的启动页面获取UIAbility的上下文信息UIAbility组件基本用法 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  UIAbility组件的基本用法包括：指定UIAbility的启动页面以及获取UIAbility的上下文UIAbilityContext。  指定UIAbility的启动页面 应用中的UIAbility在启动过程中，需要指定启动页面，否则应用启动后会因为没有默认加载页面而导致白屏。可以在UIAbility的onWindowStageCreate()生命周期回调中，通过WindowStage对象的loadContent()方法设置启动页面。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
export default class EntryAbility extends UIAbility {    onWindowStageCreate(windowStage: Window.WindowStage) {        // Main window is created, set main page for this ability        windowStage.loadContent('pages/Index', (err, data) => {            // ...        });    }
    // ...} 
说明
 在DevEco Studio中创建的UIAbility中，该UIAbility实例默认会加载Index页面，根据需要将Index页面路径替换为需要的页面路径即可。 
   获取UIAbility的上下文信息 UIAbility类拥有自身的上下文信息，该信息为UIAbilityContext类的实例，UIAbilityContext类拥有abilityInfo、currentHapModuleInfo等属性。通过UIAbilityContext可以获取UIAbility的相关配置信息，如包代码路径、Bundle名称、Ability名称和应用程序需要的环境状态等属性信息，以及可以获取操作UIAbility实例的方法（如startAbility()、connectServiceExtensionAbility()、terminateSelf()等）。  在UIAbility中可以通过this.context获取UIAbility实例的上下文信息。 已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        // 获取UIAbility实例的上下文        let context = this.context;
        // ...    }} 在页面中获取UIAbility实例的上下文信息，包括导入依赖资源context模块和在组件中定义一个context变量两个部分。 已复制import common from '@ohos.app.ability.common';
@Entry@Componentstruct Index {  private context = getContext(this) as common.UIAbilityContext;
  startAbilityTest() {    let want = {      // Want参数信息    };    this.context.startAbility(want);  }
  // 页面展示  build() {    // ...  }} 也可以在导入依赖资源context模块后，在具体使用UIAbilityContext前进行变量定义。 已复制import common from '@ohos.app.ability.common';
@Entry@Componentstruct Index {
  startAbilityTest() {    let context = getContext(this) as common.UIAbilityContext;    let want = {      // Want参数信息    };    context.startAbility(want);  }
  // 页面展示  build() {    // ...  }}    上一篇 UIAbility组件启动模式 下一篇 UIAbility组件与UI的数据同步 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件编译打包并上传元服务对应的模板包编译打包并上传HarmonyOS应用/服务对应的软件包通过DevEco Studio编译和上传软件包 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 开发者完成HarmonyOS应用/服务开发后，DevEco Studio工具支持直接在工具里实现编译打包，并上传软件包的功能。 具体支持如下场景的编译和上传功能。 场景一普通开发者完成HarmonyOS应用/服务开发后，编译打包并上传对应的应用包到AGC平台的软件包管理中。 具体请参见编译打包并上传HarmonyOS应用/服务对应的软件包。 场景二服务商完成元服务开发后，编译打包并上传对应的应用包到AGC平台的软件包管理中。 具体请参见编译打包并上传HarmonyOS应用/服务对应的软件包。 场景三服务商完成元服务对应的模板开发后，编译打包并上传对应的模板包到第三方管理平台草稿箱中。 具体请参见编译打包并上传元服务对应的模板包。   前提条件使用此功能前，需要在AGC控制台创建对应的HarmonyOS应用/服务。具体请参见创建项目和创建应用。 如果需要使用此功能上传模板包到第三方管理平台草稿箱中，需要在第三方管理平台已完成模板绑定元服务的操作。具体请参见在第三方管理平台将模板绑定元服务。  如果不满足以上前提条件，则DevEco Studio界面将提示如下图所示。   编译打包并上传元服务对应的模板包完成元服务对应的模板开发后，DevEco Studio支持通过工具实现模板对应工程的编译打包，以及上传模板包到第三方管理平台草稿箱中。 完成开发模板后，选择“Tools > Upload Project”，上传对应的模板包。
说明
如果DevEco Studio未登录华为帐号，请先登录华为帐号。 
  在上传窗口中，DevEco Studio会自动获取当前项目的包名，并自动匹配对应的已注册应用信息。 如果DevEco Studio匹配应用成功，并且匹配已绑定元服务成功，工具会显示相关“AGC Registered Application”和“Third-party Platform”相关信息。 选择“Package the project and upload it to the third-part platform as template.”，再点击“OK”，上传模板包。之后DevEco Studio会将当前工程目录编译打包成zip包，并上传到第三方管理平台的草稿箱中。 如果上传模板成功，则DevEco Studio提示如下图信息。  也可以在第三方管理平台的草稿箱查看到已上传的模板包。    编译打包并上传HarmonyOS应用/服务对应的软件包完成开发HarmonyOS应用或元服务后，DevEco Studio支持通过工具实现编译并上传HarmonyOS应用或元服务对应的应用包到AGC平台的软件包管理中。 选择“Tools > Upload Project”，上传HarmonyOS应用或元服务对应的应用包。
说明
如果DevEco Studio未登录华为帐号，请先登录华为帐号。 
  在上传窗口中，DevEco Studio会自动获取当前项目的包名，并自动匹配对应的已注册应用信息。 如果DevEco Studio匹配应用成功，并且匹配到未绑定元服务，工具会仅显示相关“AGC Registered Application”相关信息。 选择“Compile the project, generate app package and upload it to AGC.”，再点击“OK”，进行编译打包并上传HarmonyOS应用或元服务对应的应用包。之后DevEco Studio会自动构建编译当前工程和打包，并上传到对应的应用包到AGC平台的软件包管理中。 如果上传应用包成功，则DevEco Studio提示如下图信息。  也可以在AGC平台的软件包管理中查看到已上传的应用包。     上一篇 代码检查规则表 下一篇 DevEco Studio配置参数列表 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤USB服务开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 Host模式下，可以获取到已经连接的USB设备列表，并根据需要打开和关闭设备、控制设备权限、进行数据传输等。   接口说明 USB服务主要提供的功能有：查询USB设备列表、批量数据传输、控制命令传输、权限控制等。 USB类开放能力如下，具体请查阅API参考文档。 表1 USB类的开放能力接口     接口名 描述    hasRight(deviceName: string): boolean 判断是否有权访问该设备。   requestRight(deviceName: string): Promise<boolean> 请求软件包的临时权限以访问设备。使用Promise异步回调。   removeRight(deviceName: string): boolean 移除软件包对设备的访问权限。   connectDevice(device: USBDevice): Readonly<USBDevicePipe> 根据getDevices()返回的设备信息打开USB设备。   getDevices(): Array<Readonly<USBDevice>> 获取接入主设备的USB设备列表。如果没有设备接入，那么将会返回一个空的列表。   setConfiguration(pipe: USBDevicePipe, config: USBConfiguration): number 设置设备的配置。   setInterface(pipe: USBDevicePipe, iface: USBInterface): number 设置设备的接口。   claimInterface(pipe: USBDevicePipe, iface: USBInterface, force ?: boolean): number 注册通信接口。   bulkTransfer(pipe: USBDevicePipe, endpoint: USBEndpoint, buffer: Uint8Array, timeout ?: number): Promise<number> 批量传输。   closePipe(pipe: USBDevicePipe): number 关闭设备消息控制通道。   releaseInterface(pipe: USBDevicePipe, iface: USBInterface): number 释放注册过的通信接口。   getFileDescriptor(pipe: USBDevicePipe): number 获取文件描述符。   getRawDescriptor(pipe: USBDevicePipe): Uint8Array 获取原始的USB描述符。   controlTransfer(pipe: USBDevicePipe, controlparam: USBControlParams, timeout ?: number): Promise<number> 控制传输。      开发步骤 USB设备可作为Host设备连接Device设备进行数据传输。开发示例如下：  获取设备列表。 已复制// 导入USB接口api包。import usb from '@ohos.usbManager';// 获取设备列表。let deviceList : Array<usb.USBDevice> = usb.getDevices();/*deviceList结构示例[  {    name: "1-1",    serial: "",    manufacturerName: "",    productName: "",    version: "",    vendorId: 7531,    productId: 2,    clazz: 9,    subClass: 0,    protocol: 1,    devAddress: 1,    busNum: 1,    configs: [      {        id: 1,        attributes: 224,        isRemoteWakeup: true,        isSelfPowered: true,        maxPower: 0,        name: "1-1",        interfaces: [          {            id: 0,            protocol: 0,            clazz: 9,            subClass: 0,            alternateSetting: 0,            name: "1-1",            endpoints: [              {                address: 129,                attributes: 3,                interval: 12,                maxPacketSize: 4,                direction: 128,                number: 1,                type: 3,                interfaceId: 0,              }            ]          }        ]      }    ]  }]*/ 获取设备操作权限。 已复制import usb from '@ohos.usbManager'; import { BusinessError } from '@ohos.base'; 
let deviceName : string = deviceList[0].name;// 申请操作指定的device的操作权限。usb.requestRight(deviceName).then((hasRight : boolean) => {  console.info("usb device request right result: " + hasRight);}).catch((error : BusinessError)=> {  console.info("usb device request right failed : " + error);}); 打开Device设备。 已复制// 打开设备，获取数据传输通道let pipe : USBDevicePipe = usb.connectDevice(deviceList[0]);let interface1 : number = deviceList[0].configs[0].interfaces[0];/* 打开对应接口，在设备信息（deviceList）中选取对应的interface。interface1为设备配置中的一个接口。*/usb.claimInterface(pipe, interface1, true);  数据传输。 已复制import usb from '@ohos.usbManager'; import { BusinessError } from '@ohos.base';/* 读取数据，在device信息中选取对应数据接收的endpoint来做数据传输（endpoint.direction == 0x80）；dataUint8Array是要读取的数据，类型为Uint8Array。*/let inEndpoint : USBEndpoint = interface1.endpoints[2];let outEndpoint : USBEndpoint = interface1.endpoints[1];let dataUint8Array : Array<number> = new Uint8Array(1024);usb.bulkTransfer(pipe, inEndpoint, dataUint8Array, 15000).then((dataLength : number) => {if (dataLength >= 0) {  console.info("usb readData result Length : " + dataLength);} else {  console.info("usb readData failed : " + dataLength);}}).catch((error : BusinessError) => {console.info("usb readData error : " + JSON.stringify(error));});// 发送数据，在device信息中选取对应数据发送的endpoint来做数据传输。（endpoint.direction == 0）usb.bulkTransfer(pipe, outEndpoint, dataUint8Array, 15000).then((dataLength : number) => {  if (dataLength >= 0) {    console.info("usb writeData result write length : " + dataLength);  } else {    console.info("writeData failed");  }}).catch((error : BusinessError) => {  console.info("usb writeData error : " + JSON.stringify(error));});  释放接口，关闭设备。 已复制usb.releaseInterface(pipe, interface1);usb.closePipe(pipe);    上一篇 USB服务开发概述 下一篇 位置服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念运作机制USB服务开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 基本概念USB服务是应用访问底层的一种设备抽象概念。开发者根据提供的USB API，可以获取设备列表、控制设备访问权限、以及与连接的设备进行数据传输、控制命令传输等。  运作机制USB服务系统包含USB API、USB Service、USB HAL。 图1 USB服务运作机制  USB API：提供USB的基础API，主要包含查询USB设备列表、批量数据传输、控制命令传输、权限控制等。 USB Service：主要实现HAL层数据的接收、解析、分发以及对设备的管理等。 USB HAL层：提供给用户态可直接调用的驱动能力接口。    上一篇 USB服务 下一篇 USB服务开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。用户文件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    用户文件概述  选择与保存用户文件（FilePicker）   上一篇 应用文件分享 下一篇 用户文件概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。用户文件存储位置内置存储外置存储用户文件访问框架用户文件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 用户文件：文件所有者为登录到该终端设备的用户，包括用户私有的图片、视频、音频、文档等。 用户文件存放在用户目录下，归属于该设备上登录的用户。用户文件存储位置主要分为内置存储、外置存储。应用对用户文件的创建、访问、删除等行为，需要提前获取用户授权，或由用户操作完成。 HarmonyOS提供用户文件访问框架，用于开发者访问和管理用户文件，将在下文详细介绍。 用户文件存储位置 内置存储内置存储，是指用户文件存储在终端设备的内部存储设备（空间）上。内置存储设备无法被移除。内置存储的用户文件主要有： 用户特有的文件：这部分文件归属于登录该设备的用户，不同用户登录后，仅可看到该用户自己的文件。按照这些文件的特征/属性，以及用户/应用的使用习惯，可分为：图片/视频类媒体文件所具有的特征包括拍摄时间、地点、旋转角度、文件宽高等信息，以媒体文件的形式存储在系统中，通常是以所有文件、相册的形式对外呈现，不会展示其在系统中存储的具体位置。 音频类媒体文件所具有的特征包括所属专辑、音频创作者、持续时间等信息，以媒体文件的形式存储在系统中，通常会以所有文件、专辑、作家等形式对外部呈现，不会展示其在系统中存储的具体位置。 其他文件（统称为文档类文件）以普通文件的形式存储在系统中，该类文件既包括普通的文本文件、压缩文件等，又包括以普通文件形式存储的图片/视频、音频文件，该类文件通常是以目录树的形式对外展示。   多用户共享的文件：用户可以通过将文件放在共享文件区，实现多个用户之间文件的共享访问。共享文件区的文件，也是以普通文件的形式存储在系统中，以目录树的形式对外展示。   外置存储外置存储，是指用户文件存储在外置可插拔设备上（如SD卡、U盘等）。外置存储设备上的文件，和内置存储设备共享区文件一样，可以被所有登录到系统中的用户看到。 外置存储设备具备可插拔属性，因此系统提供了设备插拔事件的监听及挂载功能，用于管理外置存储设备，当前仅对系统应用开放。 外置存储设备上的文件，全部以普通文件的形式呈现，和内置存储设备上的文档类文件一样，采用目录树的形式对外展示。  用户文件访问框架用户文件访问框架（File Access Framework）是一套提供给开发者访问和管理用户文件的基础框架。该框架依托于HarmonyOS的ExtensionAbility组件机制，提供了一套统一访问用户文件的方法和接口。 图1 用户文件访问框架示意图 应用（即图中的文件访问客户端）若需访问用户文件，如选择一张照片或保存多个文档等，可以通过拉起“文件选择器应用”来实现。HarmonyOS系统预置了文件选择器应用FilePicker和文件管理器应用FileManager。FilePicker：系统预置应用，提供文件访问客户端选择和保存文件的能力，且不需要配置任何权限。FilePicker的使用指导请参见选择用户文件。FileManager：系统预置应用，终端用户可通过系统文件管理器实现查看文件、修改文件、删除文件（目录）、重命名文件（目录）、移动文件（目录）、创建文件（目录）等操作。 File Access Framework（用户文件访问框架）的主要功能模块如下：File Access Helper：提供给文件管理器和文件选择器访问用户文件的API接口，应用不可直接调用。File Access ExtensionAbility：提供文件访问框架能力，由内卡文件管理服务UserFileManager和外卡文件管理服务ExternalFileManager组成，实现对应的文件访问功能。    上一篇 用户文件 下一篇 选择与保存用户文件（FilePicker） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明查询当前设备是否支持相应的认证能力开发步骤执行认证操作并订阅认证结果开发步骤执行认证操作并订阅认证过程中的提示信息开发步骤认证过程中取消认证开发步骤用户认证开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
说明
 该开发指导需配合API version 9版本的SDK使用。 
  场景介绍 当前用户认证支持人脸识别和指纹识别，可应用于设备解锁、应用登录、支付等身份认证场景。   接口说明 userIAM_userAuth模块提供了用户认证的相关方法，包括查询认证能力、发起认证和取消认证等，用户可以使用人脸、指纹等生物特征信息进行认证操作。具体接口说明可以查阅API参考文档。 在执行认证前，需要指定认证类型和认证等级，查询设备是否支持该认证能力。 表1 用户认证开放能力列表     接口名称 功能描述    getAvailableStatus(authType : UserAuthType, authTrustLevel : AuthTrustLevel): void 根据指定的认证类型、认证等级，检测当前设备是否支持相应的认证能力。   getAuthInstance(challenge : Uint8Array, authType : UserAuthType, authTrustLevel : AuthTrustLevel): AuthInstance 获取AuthInstance对象，用于执行用户身份认证。   on(name : AuthEventKey, callback : AuthEvent) : void 订阅指定类型的用户认证事件。   off(name : AuthEventKey) : void 取消订阅特定类型的认证事件。   start: void 执行用户认证。   cancel: void 取消本次认证操作。      查询当前设备是否支持相应的认证能力   开发步骤  申请权限。调用getAvailableStatus接口，需要在module.json5文件的requestPermissions对象中配置ohos.permission.ACCESS_BIOMETRIC权限。更多配置信息请参考Stage模型应用程序包结构。 指定认证类型和认证等级，调用getAvailableStatus接口查询当前的设备是否支持相应的认证能力。 已复制import userIAM_userAuth from '@ohos.userIAM.userAuth';
// 查询认证能力是否支持try {    userIAM_userAuth.getAvailableStatus(userIAM_userAuth.UserAuthType.FACE, userIAM_userAuth.AuthTrustLevel.ATL1);    console.info("current auth trust level is supported");} catch (error) {    console.info("current auth trust level is not supported, error = " + error);}    执行认证操作并订阅认证结果   开发步骤  申请权限。调用start接口，需要在module.json5文件的requestPermissions对象中配置ohos.permission.ACCESS_BIOMETRIC权限。更多配置信息请参考Stage模型应用程序包结构。 指定challenge、认证类型和认证等级，获取认证对象。 调用on接口订阅认证结果。 调用start接口发起认证，通过callback回调返回认证结果。 调用off接口取消订阅认证结果。 已复制import userIAM_userAuth from '@ohos.userIAM.userAuth';
let challenge = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);let authType = userIAM_userAuth.UserAuthType.FACE;let authTrustLevel = userIAM_userAuth.AuthTrustLevel.ATL1;
// 获取认证对象let auth;try {    auth = userIAM_userAuth.getAuthInstance(challenge, authType, authTrustLevel);    console.log("get auth instance success");} catch (error) {    console.log("get auth instance failed" + error);}
// 订阅认证结果try {    auth.on("result", {        callback: (result: userIAM_userAuth.AuthResultInfo) => {            console.log("authV9 result " + result.result);            console.log("authV9 token " + result.token);            console.log("authV9 remainAttempts " + result.remainAttempts);            console.log("authV9 lockoutDuration " + result.lockoutDuration);        }    });    console.log("subscribe authentication event success");} catch (error) {    console.log("subscribe authentication event failed " + error);}
// 开始认证try {    auth.start();    console.info("authV9 start auth success");} catch (error) {    console.info("authV9 start auth failed, error = " + error);}
// 取消订阅认证结果try {    auth.off("result");    console.info("cancel subscribe authentication event success");} catch (error) {    console.info("cancel subscribe authentication event failed, error = " + error);}    执行认证操作并订阅认证过程中的提示信息   开发步骤  申请权限。调用start接口，需要在module.json5文件的requestPermissions对象中配置ohos.permission.ACCESS_BIOMETRIC权限。更多配置信息请参考Stage模型应用程序包结构。 指定challenge、认证类型和认证等级，获取认证对象。 调用on接口订阅认证过程中的提示信息。 调用start接口发起认证，通过callback回调返回认证过程中的提示信息。 调用off接口取消订阅认证过程中的提示信息。 已复制import userIAM_userAuth from '@ohos.userIAM.userAuth';
let challenge = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);let authType = userIAM_userAuth.UserAuthType.FACE;let authTrustLevel = userIAM_userAuth.AuthTrustLevel.ATL1;
// 获取认证对象let auth;try {    auth = userIAM_userAuth.getAuthInstance(challenge, authType, authTrustLevel);    console.log("get auth instance success");} catch (error) {    console.log("get auth instance failed" + error);}
// 订阅认证过程中的提示信息try {    auth.on("tip", {        callback : (result : userIAM_userAuth.TipInfo) => {            switch (result.tip) {                case userIAM_userAuth.FaceTips.FACE_AUTH_TIP_TOO_BRIGHT:                // do something;                case userIAM_userAuth.FaceTips.FACE_AUTH_TIP_TOO_DARK:                // do something;                default:                // do others            }        }    });    console.log("subscribe authentication event success");} catch (error) {    console.log("subscribe authentication event failed " + error);}
// 开始认证try {    auth.start();    console.info("authV9 start auth success");} catch (error) {    console.info("authV9 start auth failed, error = " + error);}
// 取消订阅认证过程中的提示信息try {    auth.off("tip");    console.info("cancel subscribe tip information success");} catch (error) {    console.info("cancel subscribe tip information failed, error = " + error);}    认证过程中取消认证   开发步骤  申请权限。调用cancel接口，需要在module.json5文件的requestPermissions对象中配置ohos.permission.ACCESS_BIOMETRIC权限。更多配置信息请参考Stage模型应用程序包结构。 指定challenge、认证类型和认证等级，获取认证对象。 调用start接口发起认证。 通过调用cancel接口取消本次认证。 已复制import userIAM_userAuth from '@ohos.userIAM.userAuth';
let challenge = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);let authType = userIAM_userAuth.UserAuthType.FACE;let authTrustLevel = userIAM_userAuth.AuthTrustLevel.ATL1;
// 获取认证对象let auth;try {    auth = userIAM_userAuth.getAuthInstance(challenge, authType, authTrustLevel);    console.log("get auth instance success");} catch (error) {    console.log("get auth instance failed" + error);}
// 开始认证try {    auth.start();    console.info("authV9 start auth success");} catch (error) {    console.info("authV9 start auth failed, error = " + error);}
// 取消认证try {    auth.cancel();    console.info("cancel auth success");} catch (error) {    console.info("cancel auth failed, error = " + error);}    上一篇 用户认证开发概述 下一篇 密钥管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。用户认证模块的定义基本概念运作机制约束与限制用户认证开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  用户认证模块的定义用户认证模块提供用户认证能力，对应用开发者而言，可使用该模块进行用户身份认证，用于设备解锁、支付、应用登录等身份认证场景。 当前用户认证提供人脸识别和指纹识别能力，设备具备哪种识别能力，取决于当前设备的硬件能力和技术实现。  基本概念人脸识别：基于人的脸部特征信息进行身份识别的一种生物特征识别技术，用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别，通常也叫做人像识别、面部识别、人脸认证。 指纹识别：基于人的指尖皮肤纹路进行身份识别的一种生物特征识别技术。当用户触摸指纹采集器件时，器件感知并获取到用户的指纹图像，然后传输到指纹识别模块进行一定的处理后与用户预先注册的指纹信息进行比对，从而识别出用户身份。   运作机制人脸或指纹识别过程中，特征采集器件和TEE（Trusted Execution Environment）之间会建立安全通道，将采集的生物特征信息直接通过安全通道传递到TEE中，从而避免了恶意软件从REE（Rich Execution Environment）侧进行攻击。传输到TEE中的生物特征数据从活体检测、特征提取、特征存储、特征比对到特征销毁等处理都完全在TEE中完成，基于TrustZone进行安全隔离，提供API的服务框架只负责管理认证请求和处理认证结果等数据，不涉及生物特征数据本身。 用户注册的生物特征数据在TEE的安全存储区进行存储，采用高强度的密码算法进行加密和完整性保护，外部无法获取到加密生物特征数据的密钥，保证了用户生物特征数据的安全性。本能力采集和存储的生物特征数据不会在用户未授权的情况下被传出TEE。这意味着，用户未授权时，无论是系统应用还是三方应用都无法获得人脸和指纹等特征数据，也无法将这些特征数据传送或备份到任何外部存储介质。  约束与限制当前版本提供的用户认证能力包含人脸识别和指纹识别，且只支持本地认证，不提供认证界面。要求设备上具备相应的生物特征采集器，且对于人脸识别要求人脸图像分辨率大于100*100。要求设备上具有TEE安全环境，人脸和指纹等生物特征信息高强度加密保存在TEE中。对于面部特征相似的人、面部特征不断发育的儿童，人脸特征匹配率有所不同。如果对此担忧，可考虑其他认证方式。   上一篇 用户认证 下一篇 用户认证开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发指导开发步骤及注意事项完整示例使用AudioCapturer开发音频录制功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  AudioCapturer是音频采集器，用于录制PCM（Pulse Code Modulation）音频数据，适合有音频开发经验的开发者实现更灵活的录制功能。  开发指导 使用AudioCapturer录制音频涉及到AudioCapturer实例的创建、音频采集参数的配置、采集的开始与停止、资源的释放等。本开发指导将以一次录制音频数据的过程为例，向开发者讲解如何使用AudioCapturer进行音频录制，建议搭配AudioCapturer的API说明阅读。 下图展示了AudioCapturer的状态变化，在创建实例后，调用对应的方法可以进入指定的状态实现对应的行为。需要注意的是在确定的状态执行不合适的方法可能导致AudioCapturer发生错误，建议开发者在调用状态转换的方法前进行状态检查，避免程序运行产生预期以外的结果。  图1 AudioCapturer状态变化示意图    使用on('stateChange')方法可以监听AudioCapturer的状态变化，每个状态对应值与说明见AudioState。  开发步骤及注意事项  配置音频采集参数并创建AudioCapturer实例，音频采集参数的详细信息可以查看AudioCapturerOptions。已复制import audio from '@ohos.multimedia.audio';
let audioStreamInfo = {  samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_44100,  channels: audio.AudioChannel.CHANNEL_2,  sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE,  encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW};
let audioCapturerInfo = {  source: audio.SourceType.SOURCE_TYPE_MIC,  capturerFlags: 0};
let audioCapturerOptions = {  streamInfo: audioStreamInfo,  capturerInfo: audioCapturerInfo};
audio.createAudioCapturer(audioCapturerOptions, (err, data) => {  if (err) {    console.error(`Invoke createAudioCapturer failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('Invoke createAudioCapturer succeeded.');    let audioCapturer = data;  }}); 调用start()方法进入running状态，开始录制音频。已复制audioCapturer.start((err) => {  if (err) {    console.error(`Capturer start failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('Capturer start success.');  }}); 指定录制文件地址，调用read()方法读取缓冲区的数据。已复制let file = fs.openSync(path, 0o2 | 0o100);let bufferSize = await audioCapturer.getBufferSize();let buffer = await audioCapturer.read(bufferSize, true);fs.writeSync(file.fd, buffer); 调用stop()方法停止录制。已复制audioCapturer.stop((err) => {  if (err) {    console.error(`Capturer stop failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('Capturer stopped.');  }}); 调用release()方法销毁实例，释放资源。已复制audioCapturer.release((err) => {  if (err) {    console.error(`capturer release failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('capturer released.');  }});    完整示例       下面展示了使用AudioCapturer录制音频的完整示例代码。      已复制import audio from '@ohos.multimedia.audio';import fs from '@ohos.file.fs';
const TAG = 'AudioCapturerDemo';
export default class AudioCapturerDemo {  private audioCapturer = undefined;  private audioStreamInfo = {    samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_44100,    channels: audio.AudioChannel.CHANNEL_1,    sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE,    encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW  }  private audioCapturerInfo = {    source: audio.SourceType.SOURCE_TYPE_MIC, // 音源类型    capturerFlags: 0 // 音频采集器标志  }  private audioCapturerOptions = {    streamInfo: this.audioStreamInfo,    capturerInfo: this.audioCapturerInfo  }
  // 初始化，创建实例，设置监听事件  init() {    audio.createAudioCapturer(this.audioCapturerOptions, (err, capturer) => { // 创建AudioCapturer实例      if (err) {        console.error(`Invoke createAudioCapturer failed, code is ${err.code}, message is ${err.message}`);        return;      }
      console.info(`${TAG}: create AudioCapturer success`);      this.audioCapturer = capturer;      this.audioCapturer.on('markReach', 1000, (position) => { // 订阅markReach事件，当采集的帧数达到1000时触发回调        if (position === 1000) {          console.info('ON Triggered successfully');        }      });      this.audioCapturer.on('periodReach', 2000, (position) => { // 订阅periodReach事件，当采集的帧数达到2000时触发回调        if (position === 2000) {          console.info('ON Triggered successfully');        }      });
    });  }
  // 开始一次音频采集  async start() {    let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];    if (stateGroup.indexOf(this.audioCapturer.state) === -1) { // 当且仅当状态为STATE_PREPARED、STATE_PAUSED和STATE_STOPPED之一时才能启动采集      console.error(`${TAG}: start failed`);      return;    }    await this.audioCapturer.start(); // 启动采集
    let context = getContext(this);    const path = context.filesDir + '/test.wav'; // 采集到的音频文件存储路径
    let file = fs.openSync(path, 0o2 | 0o100); // 如果文件不存在则创建文件    let fd = file.fd;    let numBuffersToCapture = 150; // 循环写入150次    let count = 0;    while (numBuffersToCapture) {      let bufferSize = await this.audioCapturer.getBufferSize();      let buffer = await this.audioCapturer.read(bufferSize, true);      let options = {        offset: count * bufferSize,        length: bufferSize      };      if (buffer === undefined) {        console.error(`${TAG}: read buffer failed`);      } else {        let number = fs.writeSync(fd, buffer, options);        console.info(`${TAG}: write date: ${number}`);      }      numBuffersToCapture--;      count++;    }  }
  // 停止采集  async stop() {    // 只有采集器状态为STATE_RUNNING或STATE_PAUSED的时候才可以停止    if (this.audioCapturer.state !== audio.AudioState.STATE_RUNNING && this.audioCapturer.state !== audio.AudioState.STATE_PAUSED) {      console.info('Capturer is not running or paused');      return;    }    await this.audioCapturer.stop(); // 停止采集    if (this.audioCapturer.state === audio.AudioState.STATE_STOPPED) {      console.info('Capturer stopped');    } else {      console.error('Capturer stop failed');    }  }
  // 销毁实例，释放资源  async release() {    // 采集器状态不是STATE_RELEASED或STATE_NEW状态，才能release    if (this.audioCapturer.state === audio.AudioState.STATE_RELEASED || this.audioCapturer.state === audio.AudioState.STATE_NEW) {      console.info('Capturer already released');      return;    }    await this.audioCapturer.release(); // 释放资源    if (this.audioCapturer.state == audio.AudioState.STATE_RELEASED) {      console.info('Capturer released');    } else {      console.error('Capturer release failed');    }  }}    上一篇 使用AVRecorder开发音频录制功能 下一篇 使用OpenSL ES开发音频录制功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发指导开发步骤及注意事项完整示例使用AudioRenderer开发音频播放功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  AudioRenderer是音频渲染器，用于播放PCM（Pulse Code Modulation）音频数据，相比AVPlayer而言，可以在输入前添加数据预处理，更适合有音频开发经验的开发者，以实现更灵活的播放功能。  开发指导 使用AudioRenderer播放音频涉及到AudioRenderer实例的创建、音频渲染参数的配置、渲染的开始与停止、资源的释放等。本开发指导将以一次渲染音频数据的过程为例，向开发者讲解如何使用AudioRenderer进行音频渲染，建议搭配AudioRenderer的API说明阅读。 下图展示了AudioRenderer的状态变化，在创建实例后，调用对应的方法可以进入指定的状态实现对应的行为。需要注意的是在确定的状态执行不合适的方法可能导致AudioRenderer发生错误，建议开发者在调用状态转换的方法前进行状态检查，避免程序运行产生预期以外的结果。 为保证UI线程不被阻塞，大部分AudioRenderer调用都是异步的。对于每个API均提供了callback函数和Promise函数，以下示例均采用callback函数。  图1 AudioRenderer状态变化示意图   在进行应用开发的过程中，建议开发者通过on('stateChange')方法订阅AudioRenderer的状态变更。因为针对AudioRenderer的某些操作，仅在音频播放器在固定状态时才能执行。如果应用在音频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。  prepared状态： 通过调用createAudioRenderer()方法进入到该状态。 running状态： 正在进行音频数据播放，可以在prepared状态通过调用start()方法进入此状态，也可以在paused状态和stopped状态通过调用start()方法进入此状态。 paused状态： 在running状态可以通过调用pause()方法暂停音频数据的播放并进入paused状态，暂停播放之后可以通过调用start()方法继续音频数据播放。 stopped状态： 在paused/running状态可以通过stop()方法停止音频数据的播放。 released状态： 在prepared、paused、stopped等状态，用户均可通过release()方法释放掉所有占用的硬件和软件资源，并且不会再进入到其他的任何一种状态了。    开发步骤及注意事项  配置音频渲染参数并创建AudioRenderer实例，音频渲染参数的详细信息可以查看AudioRendererOptions。已复制import audio from '@ohos.multimedia.audio';
let audioStreamInfo = {  samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_44100,  channels: audio.AudioChannel.CHANNEL_1,  sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE,  encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW};
let audioRendererInfo = {  content: audio.ContentType.CONTENT_TYPE_SPEECH,  usage: audio.StreamUsage.STREAM_USAGE_VOICE_COMMUNICATION,  rendererFlags: 0};
let audioRendererOptions = {  streamInfo: audioStreamInfo,  rendererInfo: audioRendererInfo};
audio.createAudioRenderer(audioRendererOptions, (err, data) => {  if (err) {    console.error(`Invoke createAudioRenderer failed, code is ${err.code}, message is ${err.message}`);    return;  } else {    console.info('Invoke createAudioRenderer succeeded.');    let audioRenderer = data;  }}); 调用start()方法进入running状态，开始渲染音频。已复制audioRenderer.start((err) => {  if (err) {    console.error(`Renderer start failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('Renderer start success.');  }}); 指定待渲染文件地址，打开文件调用write()方法向缓冲区持续写入音频数据进行渲染播放。如果需要对音频数据进行处理以实现个性化的播放，在写入之前操作即可。已复制const bufferSize = await audioRenderer.getBufferSize();let file = fs.openSync(filePath, fs.OpenMode.READ_ONLY);let buf = new ArrayBuffer(bufferSize);let readsize = await fs.read(file.fd, buf);let writeSize = await new Promise((resolve, reject) => {  audioRenderer.write(buf, (err, writeSize) => {    if (err) {      reject(err);    } else {      resolve(writeSize);    }  });}); 调用stop()方法停止渲染。已复制audioRenderer.stop((err) => {  if (err) {    console.error(`Renderer stop failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('Renderer stopped.');  }}); 调用release()方法销毁实例，释放资源。已复制audioRenderer.release((err) => {  if (err) {    console.error(`Renderer release failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info('Renderer released.');  }});    完整示例       下面展示了使用AudioRenderer渲染音频文件的示例代码。      已复制import audio from '@ohos.multimedia.audio';import fs from '@ohos.file.fs';
const TAG = 'AudioRendererDemo';
export default class AudioRendererDemo {  private renderModel = undefined;  private audioStreamInfo = {    samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率    channels: audio.AudioChannel.CHANNEL_2, // 通道    sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式    encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式  }  private audioRendererInfo = {    content: audio.ContentType.CONTENT_TYPE_MUSIC, // 媒体类型    usage: audio.StreamUsage.STREAM_USAGE_MEDIA, // 音频流使用类型    rendererFlags: 0 // 音频渲染器标志  }  private audioRendererOptions = {    streamInfo: this.audioStreamInfo,    rendererInfo: this.audioRendererInfo  }
  // 初始化，创建实例，设置监听事件  init() {    audio.createAudioRenderer(this.audioRendererOptions, (err, renderer) => { // 创建AudioRenderer实例      if (!err) {        console.info(`${TAG}: creating AudioRenderer success`);        this.renderModel = renderer;        this.renderModel.on('stateChange', (state) => { // 设置监听事件，当转换到指定的状态时触发回调          if (state == 2) {            console.info('audio renderer state is: STATE_RUNNING');          }        });        this.renderModel.on('markReach', 1000, (position) => { // 订阅markReach事件，当渲染的帧数达到1000帧时触发回调          if (position == 1000) {            console.info('ON Triggered successfully');          }        });      } else {        console.info(`${TAG}: creating AudioRenderer failed, error: ${err.message}`);      }    });  }
  // 开始一次音频渲染  async start() {    let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];    if (stateGroup.indexOf(this.renderModel.state) === -1) { // 当且仅当状态为prepared、paused和stopped之一时才能启动渲染      console.error(TAG + 'start failed');      return;    }    await this.renderModel.start(); // 启动渲染
    const bufferSize = await this.renderModel.getBufferSize();    let context = getContext(this);    let path = context.filesDir;    const filePath = path + '/test.wav'; // 使用沙箱路径获取文件，实际路径为/data/storage/el2/base/haps/entry/files/test.wav
    let file = fs.openSync(filePath, fs.OpenMode.READ_ONLY);    let stat = await fs.stat(filePath);    let buf = new ArrayBuffer(bufferSize);    let len = stat.size % bufferSize === 0 ? Math.floor(stat.size / bufferSize) : Math.floor(stat.size / bufferSize + 1);    for (let i = 0; i < len; i++) {      let options = {        offset: i * bufferSize,        length: bufferSize      };      let readsize = await fs.read(file.fd, buf, options);
      // buf是要写入缓冲区的音频数据，在调用AudioRenderer.write()方法前可以进行音频数据的预处理，实现个性化的音频播放功能，AudioRenderer会读出写入缓冲区的音频数据进行渲染
      let writeSize = await new Promise((resolve, reject) => {        this.renderModel.write(buf, (err, writeSize) => {          if (err) {            reject(err);          } else {            resolve(writeSize);          }        });      });      if (this.renderModel.state === audio.AudioState.STATE_RELEASED) { // 如果渲染器状态为released，停止渲染        fs.close(file);        await this.renderModel.stop();      }      if (this.renderModel.state === audio.AudioState.STATE_RUNNING) {        if (i === len - 1) { // 如果音频文件已经被读取完，停止渲染          fs.close(file);          await this.renderModel.stop();        }      }    }  }
  // 暂停渲染  async pause() {    // 只有渲染器状态为running的时候才能暂停    if (this.renderModel.state !== audio.AudioState.STATE_RUNNING) {      console.info('Renderer is not running');      return;    }    await this.renderModel.pause(); // 暂停渲染    if (this.renderModel.state === audio.AudioState.STATE_PAUSED) {      console.info('Renderer is paused.');    } else {      console.error('Pausing renderer failed.');    }  }
  // 停止渲染  async stop() {    // 只有渲染器状态为running或paused的时候才可以停止    if (this.renderModel.state !== audio.AudioState.STATE_RUNNING && this.renderModel.state !== audio.AudioState.STATE_PAUSED) {      console.info('Renderer is not running or paused.');      return;    }    await this.renderModel.stop(); // 停止渲染    if (this.renderModel.state === audio.AudioState.STATE_STOPPED) {      console.info('Renderer stopped.');    } else {      console.error('Stopping renderer failed.');    }  }
  // 销毁实例，释放资源  async release() {    // 渲染器状态不是released状态，才能release    if (this.renderModel.state === audio.AudioState.STATE_RELEASED) {      console.info('Renderer already released');      return;    }    await this.renderModel.release(); // 释放资源    if (this.renderModel.state === audio.AudioState.STATE_RELEASED) {      console.info('Renderer released');    } else {      console.error('Renderer release failed.');    }  }}   当同优先级或高优先级音频流要使用输出设备时，当前音频流会被中断，应用可以自行响应中断事件并做出处理。具体的音频并发处理方式可参考多音频播放的并发策略。  上一篇 使用AVPlayer开发音频播放功能 下一篇 使用OpenSL ES开发音频播放功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤及注意事项完整示例使用AVPlayer开发音频播放功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  使用AVPlayer可以实现端到端播放原始媒体资源，本开发指导将以完整地播放一首音乐作为示例，向开发者讲解AVPlayer音频播放相关功能。 播放的全流程包含：创建AVPlayer，设置播放资源，设置播放参数（音量/倍速/焦点模式），播放控制（播放/暂停/跳转/停止），重置，销毁资源。 在进行应用开发的过程中，开发者可以通过AVPlayer的state属性主动获取当前状态或使用on('stateChange')方法监听状态变化。如果应用在音频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。  图1 播放状态变化示意图  状态的详细说明请参考AVPlayerState。当播放处于prepared / playing / paused / completed状态时，播放引擎处于工作状态，这需要占用系统较多的运行内存。当客户端暂时不使用播放器时，调用reset()或release()回收内存资源，做好资源利用。  开发步骤及注意事项 详细的API说明请参考AVPlayer API参考。  创建实例createAVPlayer()，AVPlayer初始化idle状态。 设置业务需要的监听事件，搭配全流程场景使用。支持的监听事件包括：            事件类型 说明    stateChange 必要事件，监听播放器的state属性改变。   error 必要事件，监听播放器的错误信息。   durationUpdate 用于进度条，监听进度条长度，刷新资源时长。   timeUpdate 用于进度条，监听进度条当前位置，刷新当前时间。   seekDone 响应API调用，监听seek()请求完成情况。 当使用seek()跳转到指定播放位置后，如果seek操作成功，将上报该事件。   speedDone 响应API调用，监听setSpeed()请求完成情况。 当使用setSpeed()设置播放倍速后，如果setSpeed操作成功，将上报该事件。   volumeChange 响应API调用，监听setVolume()请求完成情况。 当使用setVolume()调节播放音量后，如果setVolume操作成功，将上报该事件。   bufferingUpdate 用于网络播放，监听网络播放缓冲信息，用于上报缓冲百分比以及缓存播放进度。   audioInterrupt 监听音频焦点切换信息，搭配属性audioInterruptMode使用。 如果当前设备存在多个音频正在播放，音频焦点被切换（即播放其他媒体如通话等）时将上报该事件，应用可以及时处理。    设置资源：设置属性url，AVPlayer进入initialized状态。       
说明
 下面代码示例中的url仅作示意使用，开发者需根据实际情况，确认资源有效性并设置：  如果使用本地资源播放，必须确认资源文件可用，并使用应用沙箱路径访问对应资源，参考获取应用文件路径。应用沙箱的介绍及如何向应用沙箱推送文件，请参考文件管理。 如果使用网络播放路径，需申请相关权限：ohos.permission.INTERNET。 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法可参考ResourceManager API参考。 需要使用支持的播放格式与协议。  
 准备播放：调用prepare()，AVPlayer进入prepared状态，此时可以获取duration，设置音量。 音频播控：播放play()，暂停pause()，跳转seek()，停止stop() 等操作。 （可选）更换资源：调用reset()重置资源，AVPlayer重新进入idle状态，允许更换资源url。 退出播放：调用release()销毁实例，AVPlayer进入released状态，退出播放。    完整示例       参考以下示例，完整地播放一首音乐。      已复制import media from '@ohos.multimedia.media';import fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
export class AVPlayerDemo {  private avPlayer;  private count: number = 0;
  // 注册avplayer回调函数  setAVPlayerCallback() {    // seek操作结果回调函数    this.avPlayer.on('seekDone', (seekDoneTime) => {      console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);    })    // error回调监听函数,当avPlayer在操作过程中出现错误时调用reset接口触发重置流程    this.avPlayer.on('error', (err) => {      console.error(`Invoke avPlayer failed, code is ${err.code}, message is ${err.message}`);      this.avPlayer.reset(); // 调用reset重置资源，触发idle状态    })    // 状态机变化回调函数    this.avPlayer.on('stateChange', async (state, reason) => {      switch (state) {        case 'idle': // 成功调用reset接口后触发该状态机上报          console.info('AVPlayer state idle called.');          this.avPlayer.release(); // 调用release接口销毁实例对象          break;        case 'initialized': // avplayer 设置播放源后触发该状态上报          console.info('AVPlayerstate initialized called.');          this.avPlayer.prepare().then(() => {            console.info('AVPlayer prepare succeeded.');          }, (err) => {            console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);          });          break;        case 'prepared': // prepare调用成功后上报该状态机          console.info('AVPlayer state prepared called.');          this.avPlayer.play(); // 调用播放接口开始播放          break;        case 'playing': // play成功调用后触发该状态机上报          console.info('AVPlayer state playing called.');          if (this.count !== 0) {            console.info('AVPlayer start to seek.');            this.avPlayer.seek(this.avPlayer.duration); //seek到音频末尾          } else {            this.avPlayer.pause(); // 调用暂停接口暂停播放          }          this.count++;          break;        case 'paused': // pause成功调用后触发该状态机上报          console.info('AVPlayer state paused called.');          this.avPlayer.play(); // 再次播放接口开始播放          break;        case 'completed': // 播放结束后触发该状态机上报          console.info('AVPlayer state completed called.');          this.avPlayer.stop(); //调用播放结束接口          break;        case 'stopped': // stop接口成功调用后触发该状态机上报          console.info('AVPlayer state stopped called.');          this.avPlayer.reset(); // 调用reset接口初始化avplayer状态          break;        case 'released':          console.info('AVPlayer state released called.');          break;        default:          console.info('AVPlayer state unknown called.');          break;      }    })  }
  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过url属性进行播放示例  async avPlayerUrlDemo() {    // 创建avPlayer实例对象    this.avPlayer = await media.createAVPlayer();    // 创建状态机变化回调函数    this.setAVPlayerCallback();    let fdPath = 'fd://';    // 通过UIAbilityContext获取沙箱地址filesDir，以下为Stage模型获方式，如需在FA模型上获取请参考《访问应用沙箱》获取地址    let context = getContext(this) as common.UIAbilityContext;    let pathDir = context.filesDir;    let path = pathDir + '/01.mp3';    // 打开相应的资源文件地址获取fd，并为url赋值触发initialized状态机上报    let file = await fs.open(path);    fdPath = fdPath + '' + file.fd;    this.avPlayer.url = fdPath;  }
  // 以下demo为使用资源管理接口获取打包在HAP内的媒体资源文件并通过fdSrc属性进行播放示例  async avPlayerFdSrcDemo() {    // 创建avPlayer实例对象    this.avPlayer = await media.createAVPlayer();    // 创建状态机变化回调函数    this.setAVPlayerCallback();    // 通过UIAbilityContext的resourceManager成员的getRawFd接口获取媒体资源播放地址    // 返回类型为{fd,offset,length},fd为HAP包fd地址，offset为媒体资源偏移量，length为播放长度    let context = getContext(this) as common.UIAbilityContext;    let fileDescriptor = await context.resourceManager.getRawFd('01.mp3');    // 为fdSrc赋值触发initialized状态机上报    this.avPlayer.fdSrc = fileDescriptor;    this.isSeek = false; // 不支持seek操作  }}    上一篇 音频播放开发概述 下一篇 使用AudioRenderer开发音频播放功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤及注意事项完整示例使用AVRecorder开发音频录制功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  使用AVRecorder可以实现音频录制功能，本开发指导将以“开始录制-暂停录制-恢复录制-停止录制”的一次流程为示例，向开发者讲解AVRecorder音频录制相关功能。 在进行应用开发的过程中，开发者可以通过AVRecorder的state属性，主动获取当前状态或使用on('stateChange')方法监听状态变化。开发过程中应该严格遵循状态机要求，例如只能在started状态下调用pause()接口，只能在paused状态下调用resume()接口。  图1 录制状态变化示意图   状态的详细说明请参考AVRecorderState。  开发步骤及注意事项 详细的API说明请参考AVRecorder API参考。  创建AVRecorder实例，实例创建完成进入idle状态。已复制import media from '@ohos.multimedia.media';
let avRecorder = undefined;media.createAVRecorder().then((recorder) => {  avRecorder = recorder;}, (err) => {  console.error(`Invoke createAVRecorder failed, code is ${err.code}, message is ${err.message}`);}) 设置业务需要的监听事件，监听状态变化及错误上报。            事件类型 说明    stateChange 必要事件，监听AVRecorder的state属性改变   error 必要事件，监听AVRecorder的错误信息    已复制// 状态上报回调函数avRecorder.on('stateChange', (state, reason) => {  console.log(`current state is ${state}`);  // 用户可以在此补充状态发生切换后想要进行的动作})
// 错误上报回调函数avRecorder.on('error', (err) => {  console.error(`avRecorder failed, code is ${err.code}, message is ${err.message}`);}) 配置音频录制参数，调用prepare()接口，此时进入prepared状态。       
说明
 配置参数需要注意：  prepare接口的入参avConfig中仅设置音频相关的配置参数，如示例代码所示。 需要使用支持的录制规格。 录制输出的url地址（即示例里avConfig中的url），形式为fd://xx (fd number)。需要调用基础文件操作接口（@ohos.file.fs）实现应用文件访问能力，获取方式参考应用文件访问与管理。  
 已复制let avProfile = {  audioBitrate: 100000, // 音频比特率  audioChannels: 2, // 音频声道数  audioCodec: media.CodecMimeType.AUDIO_AAC, // 音频编码格式，当前只支持aac  audioSampleRate: 48000, // 音频采样率  fileFormat: media.ContainerFormatType.CFT_MPEG_4A, // 封装格式，当前只支持m4a}let avConfig = {  audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC, // 音频输入源，这里设置为麦克风  profile: avProfile,  url: 'fd://35', // 参考应用文件访问与管理中的开发示例获取创建的音频文件fd填入此处}avRecorder.prepare(avConfig).then(() => {  console.log('Invoke prepare succeeded.');}, (err) => {  console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);}) 开始录制，调用start()接口，此时进入started状态。 暂停录制，调用pause()接口，此时进入paused状态。 恢复录制，调用resume()接口，此时再次进入started状态。 停止录制，调用stop()接口，此时进入stopped状态。 重置资源，调用reset()重新进入idle状态，允许重新配置录制参数。 销毁实例，调用release()进入released状态，退出录制。    完整示例       参考以下示例，完成“开始录制-暂停录制-恢复录制-停止录制”的完整流程。      已复制import media from '@ohos.multimedia.media';
export class AudioRecorderDemo {  private avRecorder;  private avProfile = {    audioBitrate: 100000, // 音频比特率    audioChannels: 2, // 音频声道数    audioCodec: media.CodecMimeType.AUDIO_AAC, // 音频编码格式，当前只支持aac    audioSampleRate: 48000, // 音频采样率    fileFormat: media.ContainerFormatType.CFT_MPEG_4A, // 封装格式，当前只支持m4a  };  private avConfig = {    audioSourceType: media.AudioSourceType.AUDIO_SOURCE_TYPE_MIC, // 音频输入源，这里设置为麦克风    profile: this.avProfile,    url: 'fd://35', // 参考应用文件访问与管理开发示例新建并读写一个文件  };
  // 注册audioRecorder回调函数  setAudioRecorderCallback() {    // 状态机变化回调函数    this.avRecorder.on('stateChange', (state, reason) => {      console.log(`AudioRecorder current state is ${state}`);    })    // 错误上报回调函数    this.avRecorder.on('error', (err) => {      console.error(`AudioRecorder failed, code is ${err.code}, message is ${err.message}`);    })  }
  // 开始录制对应的流程  async startRecordingProcess() {    // 1.创建录制实例    this.avRecorder = await media.createAVRecorder();    this.setAudioRecorderCallback();    // 2.获取录制文件fd赋予avConfig里的url；参考FilePicker文档    // 3.配置录制参数完成准备工作    await this.avRecorder.prepare(this.avConfig);    // 4.开始录制    await this.avRecorder.start();  }
  // 暂停录制对应的流程  async pauseRecordingProcess() {    if (this.avRecorder.state === 'started') { // 仅在started状态下调用pause为合理状态切换      await this.avRecorder.pause();    }  }
  // 恢复录制对应的流程  async resumeRecordingProcess() {    if (this.avRecorder.state === 'paused') { // 仅在paused状态下调用resume为合理状态切换      await this.avRecorder.resume();    }  }
  // 停止录制对应的流程  async stopRecordingProcess() {    // 1. 停止录制    if (this.avRecorder.state === 'started'    || this.avRecorder.state === 'paused') { // 仅在started或者paused状态下调用stop为合理状态切换      await this.avRecorder.stop();    }    // 2.重置    await this.avRecorder.reset();    // 3.释放录制实例    await this.avRecorder.release();    // 4.关闭录制文件fd  }
  // 一个完整的【开始录制-暂停录制-恢复录制-停止录制】示例  async audioRecorderDemo() {    await this.startRecordingProcess(); // 开始录制    // 用户此处可以自行设置录制时长，例如通过设置休眠阻止代码执行    await this.pauseRecordingProcess(); //暂停录制    await this.resumeRecordingProcess(); // 恢复录制    await this.stopRecordingProcess(); // 停止录制  }}    上一篇 音频录制开发概述 下一篇 使用AudioCapturer开发音频录制功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS上的OpenSL ES完整示例使用OpenSL ES开发音频播放功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  OpenSL ES全称为Open Sound Library for Embedded Systems，是一个嵌入式、跨平台、免费的音频处理库。为嵌入式移动多媒体设备上的应用开发者提供标准化、高性能、低延迟的API。HarmonyOS的Native API基于Khronos Group开发的OpenSL ES 1.0.1 API 规范实现，开发者可以通过<OpenSLES.h>和<OpenSLES_OpenHarmony.h>在HarmonyOS上使用相关API。  HarmonyOS上的OpenSL ES OpenSL ES中提供了以下的接口，HarmonyOS当前仅实现了部分OpenSL ES接口，可以实现音频播放的基础功能。 调用未实现接口后会返回SL_RESULT_FEATURE_UNSUPPORTED，当前没有相关扩展可以使用。 以下列表列举了HarmonyOS上已实现的OpenSL ES的接口，具体说明请参考OpenSL ES规范：  HarmonyOS上支持的Engine接口：  SLresult (*CreateAudioPlayer) (SLEngineItf self, SLObjectItf * pPlayer, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired) SLresult (*CreateAudioRecorder) (SLEngineItf self, SLObjectItf * pRecorder, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired) SLresult (*CreateOutputMix) (SLEngineItf self, SLObjectItf * pMix, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired)  HarmonyOS上支持的Object接口：  SLresult (*Realize) (SLObjectItf self, SLboolean async) SLresult (*GetState) (SLObjectItf self, SLuint32 * pState) SLresult (*GetInterface) (SLObjectItf self, const SLInterfaceID iid, void * pInterface) void (*Destroy) (SLObjectItf self)  HarmonyOS上支持的Playback接口：  SLresult (*SetPlayState) (SLPlayItf self, SLuint32 state) SLresult (*GetPlayState) (SLPlayItf self, SLuint32 *pState)  HarmonyOS上支持的Volume控制接口：        SLresult (*SetVolumeLevel) (SLVolumeItf self, SLmillibel level) SLresult (*GetVolumeLevel) (SLVolumeItf self, SLmillibel *pLevel) SLresult (*GetMaxVolumeLevel) (SLVolumeItf self, SLmillibel *pMaxLevel)  HarmonyOS上支持的BufferQueue接口：               以下接口需引入<OpenSLES_OpenHarmony.h>使用。             接口 说明    SLresult (*Enqueue) (SLOHBufferQueueItf self, const void *buffer, SLuint32 size) 根据情况将buffer加到相应队列中。 如果是播放操作，则将带有音频数据的buffer插入到filledBufferQ_队列中；如果是录音操作，则将录音使用后的空闲buffer插入到freeBufferQ_队列中。 self：表示调用该函数的BufferQueue接口对象。 buffer：播放时表示带有音频数据的buffer，录音时表示已存储完录音数据后的空闲buffer。 size：表示buffer的大小。   SLresult (*Clear) (SLOHBufferQueueItf self) 释放BufferQueue接口对象。 self：表示调用该函数的BufferQueue接口对象将被释放。   SLresult (*GetState) (SLOHBufferQueueItf self, SLOHBufferQueueState *state) 获取BufferQueue接口对象状态。 self：表示调用该函数的BufferQueue接口对象。 state：BufferQueue的当前状态。   SLresult (*RegisterCallback) (SLOHBufferQueueItf self, SlOHBufferQueueCallback callback, void* pContext) 注册回调函数。 self：表示调用该函数的BufferQueue接口对象。 callback：播放/录音时注册的回调函数。 pContext：播放时传入待播放音频文件，录音时传入将要录制的音频文件。   SLresult (*GetBuffer) (SLOHBufferQueueItf self, SLuint8** buffer, SLuint32* size) 根据情况获取相应的buffer。 如果是播放操作，则从freeBufferQ_队列中获取空闲buffer；如果是录音操作，则从filledBufferQ_队列中获取携带录音数据的buffer。 self：表示调用该函数的BufferQueue接口对象。 buffer：播放时表示空闲的buffer，录音时表示携带录音数据的buffer。 size：表示buffer的大小。        完整示例 参考以下示例代码，播放一个音频文件。  添加头文件。已复制#include "SLES/OpenSLES.h"#include "SLES/OpenSLES_OpenHarmony.h"#include "SLES/OpenSLES_Platform.h" 使用slCreateEngine接口和获取engine实例。已复制SLObjectItf engineObject = nullptr;slCreateEngine(&engineObject, 0, nullptr, 0, nullptr, nullptr);(*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE); 获取接口SL_IID_ENGINE的engineEngine实例。已复制SLEngineItf engineEngine = nullptr;(*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineEngine); 配置播放器信息，创建AudioPlayer。已复制SLDataLocator_BufferQueue slBufferQueue = {    SL_DATALOCATOR_BUFFERQUEUE,    0};
// 具体参数需要根据音频文件格式进行适配SLDataFormat_PCM pcmFormat = {    SL_DATAFORMAT_PCM,    2,                           // 通道数    SL_SAMPLINGRATE_48,          // 采样率    SL_PCMSAMPLEFORMAT_FIXED_16, // 音频采样格式    0,    0,    0};SLDataSource slSource = {&slBufferQueue, &pcmFormat};SLObjectItf pcmPlayerObject = nullptr;(*engineEngine)->CreateAudioPlayer(engineEngine, &pcmPlayerObject, &slSource, nullptr, 0, nullptr, nullptr);(*pcmPlayerObject)->Realize(pcmPlayerObject, SL_BOOLEAN_FALSE); 获取接口SL_IID_OH_BUFFERQUEUE的bufferQueueItf实例。已复制SLOHBufferQueueItf bufferQueueItf;(*pcmPlayerObject)->GetInterface(pcmPlayerObject, SL_IID_OH_BUFFERQUEUE, &bufferQueueItf); 打开音频文件，注册BufferQueueCallback回调。已复制static void BufferQueueCallback (SLOHBufferQueueItf bufferQueueItf, void *pContext, SLuint32 size){    SLuint8 *buffer = nullptr;    SLuint32 pSize;    (*bufferQueueItf)->GetBuffer(bufferQueueItf, &buffer, &pSize);    // 将待播放音频数据写入buffer    (*bufferQueueItf)->Enqueue(bufferQueueItf, buffer, size);}void *pContext; // 可传入自定义的上下文信息，会在Callback内收到(*bufferQueueItf)->RegisterCallback(bufferQueueItf, BufferQueueCallback, pContext); 获取接口SL_PLAYSTATE_PLAYING的playItf实例，开始播放。已复制SLPlayItf playItf = nullptr;(*pcmPlayerObject)->GetInterface(pcmPlayerObject, SL_IID_PLAY, &playItf);(*playItf)->SetPlayState(playItf, SL_PLAYSTATE_PLAYING); 结束音频播放。已复制(*playItf)->SetPlayState(playItf, SL_PLAYSTATE_STOPPED);(*pcmPlayerObject)->Destroy(pcmPlayerObject);(*engineObject)->Destroy(engineObject);    上一篇 使用AudioRenderer开发音频播放功能 下一篇 多音频播放的并发策略 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS上的OpenSL ES完整示例使用OpenSL ES开发音频录制功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  OpenSL ES全称为Open Sound Library for Embedded Systems，是一个嵌入式、跨平台、免费的音频处理库。为嵌入式移动多媒体设备上的应用开发者提供标准化、高性能、低延迟的API。HarmonyOS的Native API基于Khronos Group开发的OpenSL ES 1.0.1 API 规范实现，开发者可以通过<OpenSLES.h>和<OpenSLES_OpenHarmony.h>在HarmonyOS上使用相关API。  HarmonyOS上的OpenSL ES OpenSL ES中提供了以下的接口，HarmonyOS当前仅实现了部分OpenSL ES接口，可以实现音频录制的基础功能。 调用未实现接口后会返回SL_RESULT_FEATURE_UNSUPPORTED，当前没有相关扩展可以使用。 以下列表列举了HarmonyOS上已实现的OpenSL ES的接口，具体说明请参考OpenSL ES规范：  HarmonyOS上支持的Engine接口：  SLresult (*CreateAudioPlayer) (SLEngineItf self, SLObjectItf * pPlayer, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired) SLresult (*CreateAudioRecorder) (SLEngineItf self, SLObjectItf * pRecorder, SLDataSource *pAudioSrc, SLDataSink *pAudioSnk, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired) SLresult (*CreateOutputMix) (SLEngineItf self, SLObjectItf * pMix, SLuint32 numInterfaces, const SLInterfaceID * pInterfaceIds, const SLboolean * pInterfaceRequired)  HarmonyOS上支持的Object接口：  SLresult (*Realize) (SLObjectItf self, SLboolean async) SLresult (*GetState) (SLObjectItf self, SLuint32 * pState) SLresult (*GetInterface) (SLObjectItf self, const SLInterfaceID iid, void * pInterface) void (*Destroy) (SLObjectItf self)  HarmonyOS上支持的Recorder接口：  SLresult (*SetRecordState) (SLRecordItf self, SLuint32 state) SLresult (*GetRecordState) (SLRecordItf self,SLuint32 *pState)  HarmonyOS上支持的BufferQueue接口：               以下接口需引入<OpenSLES_OpenHarmony.h>使用。             接口 说明    SLresult (*Enqueue) (SLOHBufferQueueItf self, const void *buffer, SLuint32 size) 根据情况将buffer加到相应队列中。 如果是播放操作，则将带有音频数据的buffer插入到filledBufferQ_队列中；如果是录音操作，则将录音使用后的空闲buffer插入到freeBufferQ_队列中。 self：表示调用该函数的BufferQueue接口对象。 buffer：播放时表示带有音频数据的buffer，录音时表示已存储完录音数据后的空闲buffer。 size：表示buffer的大小。   SLresult (*Clear) (SLOHBufferQueueItf self) 释放BufferQueue接口对象。 self：表示调用该函数的BufferQueue接口对象将被释放。   SLresult (*GetState) (SLOHBufferQueueItf self, SLOHBufferQueueState *state) 获取BufferQueue接口对象状态。 self：表示调用该函数的BufferQueue接口对象。 state：BufferQueue的当前状态。   SLresult (*RegisterCallback) (SLOHBufferQueueItf self, SlOHBufferQueueCallback callback, void* pContext) 注册回调函数。 self：表示调用该函数的BufferQueue接口对象。 callback：播放/录音时注册的回调函数。 pContext：播放时传入待播放音频文件，录音时传入将要录制的音频文件。   SLresult (*GetBuffer) (SLOHBufferQueueItf self, SLuint8** buffer, SLuint32* size) 根据情况获取相应的buffer。 如果是播放操作，则从freeBufferQ_队列中获取空闲buffer；如果是录音操作，则从filledBufferQ_队列中获取携带录音数据的buffer。 self：表示调用该函数的BufferQueue接口对象。 buffer：播放时表示空闲的buffer，录音时表示携带录音数据的buffer。 size：表示buffer的大小。        完整示例 参考下列示例代码，完成音频录制。  添加头文件已复制#include "SLES/OpenSLES.h"#include "SLES/OpenSLES_OpenHarmony.h"#include "SLES/OpenSLES_Platform.h" 使用slCreateEngine接口创建引擎对象和实例化引擎对象engine。已复制SLObjectItf engineObject = nullptr;slCreateEngine(&engineObject, 0, nullptr, 0, nullptr, nullptr);(*engineObject)->Realize(engineObject, SL_BOOLEAN_FALSE); 获取接口SL_IID_ENGINE的引擎接口engineEngine实例。已复制SLEngineItf engineItf = nullptr;(*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineItf); 配置录音器信息（配置输入源audiosource、输出源audiosink），创建录音对象pcmCapturerObject。已复制SLDataLocator_IODevice io_device = {    SL_DATALOCATOR_IODEVICE,    SL_IODEVICE_AUDIOINPUT,    SL_DEFAULTDEVICEID_AUDIOINPUT,    NULL};SLDataSource audioSource = {    &io_device,    NULL};SLDataLocator_BufferQueue buffer_queue = {    SL_DATALOCATOR_BUFFERQUEUE,    3};// 具体参数需要根据音频文件格式进行适配SLDataFormat_PCM format_pcm = {    SL_DATAFORMAT_PCM,           // 输入的音频格式    1,                                              // 单声道    SL_SAMPLINGRATE_44_1,        // 采样率: 44100HZ    SL_PCMSAMPLEFORMAT_FIXED_16, // 音频采样格式,小尾数，带符号的16位整数    0,    0,    0};SLDataSink audioSink = {    &buffer_queue,    &format_pcm};
SLObjectItf pcmCapturerObject = nullptr;(*engineItf)->CreateAudioRecorder(engineItf, &pcmCapturerObject,    &audioSource, &audioSink, 0, nullptr, nullptr);(*pcmCapturerObject)->Realize(pcmCapturerObject, SL_BOOLEAN_FALSE);
 获取录音接口SL_IID_RECORD的recordItf接口实例。已复制SLRecordItf  recordItf;(*pcmCapturerObject)->GetInterface(pcmCapturerObject, SL_IID_RECORD, &recordItf); 获取接口 SL_IID_OH_BUFFERQUEUE 的 bufferQueueItf 实例已复制SLOHBufferQueueItf bufferQueueItf;(*pcmCapturerObject)->GetInterface(pcmCapturerObject, SL_IID_OH_BUFFERQUEUE, &bufferQueueItf); 注册BufferQueueCallback回调。已复制static void BufferQueueCallback(SLOHBufferQueueItf bufferQueueItf, void *pContext, SLuint32 size){    // 可从pContext获取注册时传入的使用者信息    SLuint8 *buffer = nullptr;    SLuint32 pSize = 0;    (*bufferQueueItf)->GetBuffer(bufferQueueItf, &buffer, &pSize);    if (buffer != nullptr) {        // 可从buffer内读取录音数据进行后续处理         (*bufferQueueItf)->Enqueue(bufferQueueItf, buffer, size);    }}void *pContext; // 可传入自定义的上下文信息，会在Callback内收到(*bufferQueueItf)->RegisterCallback(bufferQueueItf, BufferQueueCallback, pContext); 开始录音。已复制(*recordItf)->SetRecordState(recordItf, SL_RECORDSTATE_RECORDING); 结束音频录制。已复制(*recordItf)->SetRecordState(recordItf, SL_RECORDSTATE_STOPPED);(*pcmCapturerObject)->Destroy(pcmCapturerObject);    上一篇 使用AudioCapturer开发音频录制功能 下一篇 管理麦克风 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Module校验逻辑Ability校验逻辑Entry校验逻辑HAP唯一性校验逻辑 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 HAP是应用安装的基本单位，在DevEco Studio工程目录中，一个HAP对应一个Module。应用打包时，每个Module生成一个.hap文件。 应用如果包含多个Module，在应用市场上架时，会将多个.hap文件打包成一个.app文件（称为Bundle），但在云端分发和端侧安装时，仍然是以HAP为基本单位。 为了能够正常分发和安装应用，需要保证一个应用安装到设备时，Module的名称、Ability的名称不重复，并且只有一个Entry类型的Module与目标设备相对应。 DevEco Studio会在编译构建时，对HAP进行上述唯一性校验，如果校验不通过，将会编译失败或给出告警。 
说明
当前仅在API 8的工程中，针对distrofilter进行打包校验。 
 Module校验逻辑校验目的：同一目标设备上Module唯一。 校验Module的Name。如果多个Module的Name不同，则校验通过。如果Name相同，继续校验deviceType。校验设备类型deviceType。如果deviceType不相交，则校验通过。如果deviceType相交，继续校验distroFilter。deviceType不相交是指两个Module的deviceType中配置了完全不同的设备，例如： 已复制//Module1和Module2配置了完全不同的设备，deviceType不相交。//Module1{    "deviceType": ["tv", "tablet"]}//Module2{    "deviceType": ["car", "router"]} deviceType相交是指两个Module的deviceType中包含了相同的设备，例如： 已复制//Module1和Module2因为都包含“tablet”设备，导致deviceType相交。//Module1{    "deviceType": ["tv", "tablet"]}//Module2{    "deviceType": ["car", "tablet"]} 校验分发规则distroFilter。如果distroFilter不相交，则校验通过。如果distroFilter相交，则无法保证Module唯一性，校验失败，打包失败。distroFilter中包含属性apiVersion、screenShape、screenWindow、screenDensity和countryCode。相交的相关含义如下： distroFilter不相交：如果两个distroFilter中任意一个属性不相交，则两个distroFilter不相交。distroFilter相交：如果两个distroFilter中所有属性都相交，则两个distroFilter相交。 例如，两个Module中的apiVersion、screenShape、screenWindow、screenDensity都相交，但countryCode不相交，则可以区分两个Module，校验通过。 已复制//Module1和Module2的两个distroFilter中，countryCode不相交，则两个distroFilter不相交。//Module1{  "distroFilter": {    "apiVersion" : {      "policy": "include",      "value": [8,9]    },    "screenShape": {      "policy": "include",      "value": ["rect"]    },    "screenWindow": {      "policy": "include",      "value": ["454*454", "466*466"]    },    "screenDensity": {      "policy": "include",      "value": ["ldpi", "xldpi"]    },    "countryCode": {      "policy": "include",      "value": ["CN", "HK"]    }  }}//Module2{  "distroFilter": {    "apiVersion" : {      "policy": "include",      "value": [8,9]    },    "screenShape": {      "policy": "include",      "value": ["rect"]    },    "screenWindow": {      "policy": "include",      "value": ["454*454", "466*466"]    },    "screenDensity": {      "policy": "include",      "value": ["ldpi", "xldpi"]    },    "countryCode": {      "policy": "include",      "value": ["USA", "UK"]    }  }}   Ability校验逻辑校验目的：同一目标设备上Ability唯一。 校验Ability的Name。如果多个Ability的Name不同，则校验通过。如果Name相同，继续校验Ability所属Module的deviceType。校验Ability所属Module的deviceType。如果deviceType不相交，校验通过。如果deviceType相交，继续校验Ability所属Module的distroFilter。例如，两个Ability的Name相同，但其所属Module的deviceType不相交，校验通过。 已复制//Ability1和Ability2虽然名称相同，但由于其所属Module的deviceType不相交，所以可以区分两个Ability，校验通过。//Ability1{    "module": {        "name": "module_sample1",        "deviceType": ["tv", "tablet"],        "abilities": [    {        "name": "ability_sample"    }        ]    }}//Ability2{     "module": {        "name": "module_sample2",        "deviceType": ["car", "router"],        "abilities": [    {        "name": "ability_sample"    }        ]    }} 校验Ability所属Module的distroFilter。如果distroFilter不相交，校验通过。如果distroFilter相交，校验失败，抛出告警。例如，两个Ability的Name相同，其所属Module的deviceType也相交，但其所属Module的distroFilter不相交，校验通过。 已复制//Ability1和Ability2的Name相同，而且其所属Module的deviceType相交，但其所属Module的DistroFilter不相交，所以可以区分两个Ability，校验通过。//Ability1{    "module": {        "name": "module_sample",        "deviceType": ["tv", "tablet"],        "metadata": [            {                "name": "distroFilter_config"                "resource": "$profile:distroFilter_config_sample1"            }        ],        "abilities": [            {                "name": "ability_sample"            }        ]    }}//Ability1所属Module的distroFilter{  "distroFilter": {    "apiVersion" : {      "policy": "include",      "value": [8,9]    },    "screenShape": {      "policy": "include",      "value": ["rect"]    },    "screenWindow": {      "policy": "include",      "value": ["454*454", "466*466"]    },    "screenDensity": {      "policy": "include",      "value": ["ldpi", "xldpi"]    },    "countryCode": {      "policy": "include",      "value": ["CN", "HK"]    }  }}
//Ability2{    "module": {        "name": "module_sample2",        "deviceType":  ["tv", "tablet"],        "metadata": [            {                "name": "distroFilter_config"                "resource": "$profile:distroFilter_config_sample2"            }        ],        "abilities": [            {                "name": "ability_sample"            }        ]    }}//Ability2所属Module的distroFilter{  "distroFilter": {    "apiVersion" : {      "policy": "include",      "value": [8,9]    },    "screenShape": {      "policy": "include",      "value": ["rect"]    },    "screenWindow": {      "policy": "include",      "value": ["454*454", "466*466"]    },    "screenDensity": {      "policy": "include",      "value": ["ldpi", "xldpi"]    },    "countryCode": {      "policy": "include",      "value": ["USA", "UK"]    }  }}   Entry校验逻辑校验目的：目标设备只有一个Entry类型的Module与之对应，Feature类型的Module经过deviceType及distroFilter指明的目标设备都需要存在Entry类型的Module。 校验Feature类型的Module经过deviceType及distroFilter指明的目标设备都存在Entry类型的Module。例如，Bundle中存在一个Entry类型Module1，其支持设备为tablet和wearable，其分发规则为circle和rect形状的屏幕，同时存在一个Feature类型的Module2，通过分发规则可知，其可以分发到rect形状的tablet和wearable设备上，而rect形状的tablet和wearable设备上存在Entry类型的Module1，校验通过。 已复制//Entry类型Module1{    "module": {        "name": "module_sample1",        "type": "entry",        "deviceType": ["tablet", "wearable"],        "metadata": [            {                "name": "distroFilter_config",                "resource": "$profile:distroFilter_config1"            }        ]    }}//Module1的distroFilter，distroFilter_config1.json{    "screenShape":{        "policy": "include",        "value": ["circle", "rect"]    }}//Feature类型Module2{     "module": {        "name": "module_sample2",        "type": "feature",        "deviceType": ["tablet", "wearable"],         "metadata": [            {                "name": "distroFilter_config",                "resource": "$profile:distroFilter_config2"            }        ]    }}//Module2的distroFilter，distroFilter_config2.json{    "screenShape":{        "policy": "include",        "value": ["rect"]    }} 校验目标设备只有一个Entry类型的Module与之对应。校验Entry类型Module的deviceType。如果deviceType不相交，校验通过。如果deviceType相交，继续校验Entry类型Module的distroFilter。例如，同一个Bundle中存在两个Entry类型的Module，分别为Module1和Module2，两者的deviceType不相交，可以有效区分两个Module，校验通过。 已复制//Entry类型Module1{    "module": {        "name": "module_sample1",        "type": "entry",        "deviceType": ["tablet"]    }}//Entry类型Module2{     "module": {        name: "module_sample2",        "type": "entry",        "deviceType": ["wearable"]    }} 校验Entry类型Module的distroFilter。如果distroFilter不相交，校验通过。如果distroFilter相交，校验失败，打包失败。例如，同一个Bundle中存在两个Entry类型的Module，分别为Module1和Module2，两者的deviceType相交，但两者的distroFilter不相交，可以有效区分两个Module，校验通过。 已复制//Entry类型Module1{    "module": {        "name": "module_sample1",        "type": "entry",        "deviceType": ["wearable"],        "metadata": [    {        "name":"distroFilter_config"        "resource": "$profile:distroFilter_sample1"    }        ]    }}//Module1的distroFilter，distroFilter_sample1.json{    "distroFilter": {         "screenShape":{            "policy": "include",            "value": ["rect"]        }    }}//Entry类型Module1{     "module": {        "name": "module_sample2",        "type": "entry",        "deviceType": ["wearable"],        "metadata": [    {        "name":"distroFilter_config"        "resource": "$profile:distroFilter_sample2"    }        ]    }}//Module2的distroFilter，distroFilter_sample2.json{    "distroFilter": {         "screenShape":{            "policy": "include",            "value": ["circle"]        }    }}     上一篇 配置应用的依赖 下一篇 构建闭源HAR 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤Vibrator开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 当设备需要设置不同的振动效果时，可以调用Vibrator模块，例如：设备的按键可以设置不同强度和不同时长的振动，闹钟和来电可以设置不同强度和时长的单次或周期振动。 详细的接口介绍请参考Vibrator接口。   接口说明     模块 接口名 描述    ohos.vibrator startVibration(effect: VibrateEffect, attribute: VibrateAttribute): Promise<void> 根据指定振动效果和振动属性触发马达振动，使用Promise异步回调。   ohos.vibrator startVibration(effect: VibrateEffect, attribute: VibrateAttribute, callback: AsyncCallback<void>): void 根据指定振动效果和振动属性触发马达振动，使用Callback异步回调。   ohos.vibrator stopVibration(stopMode: VibratorStopMode): Promise<void> 按照指定模式停止马达的振动。   ohos.vibrator stopVibration(stopMode: VibratorStopMode, callback: AsyncCallback<void>): void 按照指定模式停止马达的振动。      开发步骤  控制设备上的振动器，需要申请权限ohos.permission.VIBRATE。具体配置方式请参考权限申请声明。 根据指定振动效果和振动属性触发马达振动。 已复制import vibrator from '@ohos.vibrator';try {    vibrator.startVibration({        type: 'time',        duration: 1000,    }, {        id: 0,        usage: 'alarm'    }, (error) => {        if (error) {            console.error('vibrate fail, error.code: ' + error.code + 'error.message: ', + error.message);            return;        }        console.log('Callback returned to indicate a successful vibration.');    });} catch (err) {    console.error('errCode: ' + err.code + ' ,msg: ' + err.message);} 按照指定模式停止马达的振动。 已复制import vibrator from '@ohos.vibrator';try {  // 按照VIBRATOR_STOP_MODE_TIME模式停止振动  vibrator.stopVibration(vibrator.VibratorStopMode.VIBRATOR_STOP_MODE_TIME, function (error) {      if (error) {          console.log('error.code' + error.code + 'error.message' + error.message);          return;      }      console.log('Callback returned to indicate successful.');  })} catch (err) {  console.info('errCode: ' + err.code + ' ,msg: ' + err.message);}    上一篇 Vibrator开发概述 下一篇 多模输入 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。运作机制约束与限制Vibrator开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 振动器模块服务最大化开放马达器件能力，通过拓展原生马达服务实现振动与交互融合设计，打造细腻精致的一体化振动体验和差异化体验，提升用户交互效率和易用性、提升用户体验、增强品牌竞争力。 运作机制Vibrator属于控制类小器件，主要包含以下四个模块：Vibrator API，Vibrator Framework，Vibrator Service和HDF层。 图1 控制类小器件中的Vibrator  Vibrator API：提供振动器基础的API，主要包含振动器的列表查询，振动器的振动器效果查询，触发/关闭振动器等接口。 Vibrator Framework：实现振动器的框架层管理，实现与控制类小器件Service的通信。 Vibrator Service：实现控制器的服务管理。 HDF层：适配不同设备。   约束与限制在使用振动器时，开发者需要配置请求振动器的权限ohos.permission.VIBRATE，才能控制振动器振动。   上一篇 振动 下一篇 Vibrator开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发指导开发步骤及注意事项完整示例视频播放 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在HarmonyOS系统中，提供两种视频播放开发的方案：  AVPlayer：功能较完善的音视频播放ArkTS/JS API，集成了流媒体和本地资源解析，媒体资源解封装，视频解码和渲染功能，适用于对媒体资源进行端到端播放的场景，可直接播放mp4、mkv等格式的视频文件。 Video组件：封装了视频播放的基础能力，需要设置数据源以及基础信息即可播放视频，但相对扩展能力较弱。Video组件由ArkUI提供能力，相关指导请参考UI开发文档-Video组件。  本开发指导将介绍如何使用AVPlayer开发视频播放功能，以完整地播放一个视频作为示例，实现端到端播放原始媒体资源。  开发指导 播放的全流程包含：创建AVPlayer，设置播放资源和窗口，设置播放参数（音量/倍速/缩放模式），播放控制（播放/暂停/跳转/停止），重置，销毁资源。在进行应用开发的过程中，开发者可以通过AVPlayer的state属性主动获取当前状态或使用on('stateChange')方法监听状态变化。如果应用在视频播放器处于错误状态时执行操作，系统可能会抛出异常或生成其他未定义的行为。  图1 播放状态变化示意图   状态的详细说明请参考AVPlayerState。当播放处于prepared / playing / paused / completed状态时，播放引擎处于工作状态，这需要占用系统较多的运行内存。当客户端暂时不使用播放器时，调用reset()或release()回收内存资源，做好资源利用。   开发步骤及注意事项 详细的API说明请参考AVPlayer API参考。  创建实例createAVPlayer()，AVPlayer初始化idle状态。 设置业务需要的监听事件，搭配全流程场景使用。支持的监听事件包括：            事件类型 说明    stateChange 必要事件，监听播放器的state属性改变。   error 必要事件，监听播放器的错误信息。   durationUpdate 用于进度条，监听进度条长度，刷新资源时长。   timeUpdate 用于进度条，监听进度条当前位置，刷新当前时间。   seekDone 响应API调用，监听seek()请求完成情况。 当使用seek()跳转到指定播放位置后，如果seek操作成功，将上报该事件。   speedDone 响应API调用，监听setSpeed()请求完成情况。 当使用setSpeed()设置播放倍速后，如果setSpeed操作成功，将上报该事件。   volumeChange 响应API调用，监听setVolume()请求完成情况。 当使用setVolume()调节播放音量后，如果setVolume操作成功，将上报该事件。   bitrateDone 响应API调用，用于HLS协议流，监听setBitrate()请求完成情况。 当使用setBitrate()指定播放比特率后，如果setBitrate操作成功，将上报该事件。   availableBitrates 用于HLS协议流，监听HLS资源的可选bitrates，用于setBitrate()。   bufferingUpdate 用于网络播放，监听网络播放缓冲信息。   startRenderFrame 用于视频播放，监听视频播放首帧渲染时间。   videoSizeChange 用于视频播放，监听视频播放的宽高信息，可用于调整窗口大小、比例。   audioInterrupt 监听音频焦点切换信息，搭配属性audioInterruptMode使用。 如果当前设备存在多个媒体正在播放，音频焦点被切换（即播放其他媒体如通话等）时将上报该事件，应用可以及时处理。    设置资源：设置属性url，AVPlayer进入initialized状态。       
说明
 下面代码示例中的url仅作示意使用，开发者需根据实际情况，确认资源有效性并设置：  如果使用本地资源播放，必须确认资源文件可用，并使用应用沙箱路径访问对应资源，参考获取应用文件路径。应用沙箱的介绍及如何向应用沙箱推送文件，请参考文件管理。 如果使用网络播放路径，需申请相关权限：ohos.permission.INTERNET。 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法可参考ResourceManager API参考。 需要使用支持的播放格式与协议。  
 设置窗口：获取并设置属性SurfaceID，用于设置显示画面。应用需要从XComponent组件获取surfaceID，获取方式请参考XComponent。 准备播放：调用prepare()，AVPlayer进入prepared状态，此时可以获取duration，设置缩放模式、音量等。 视频播控：播放play()，暂停pause()，跳转seek()，停止stop() 等操作。 （可选）更换资源：调用reset()重置资源，AVPlayer重新进入idle状态，允许更换资源url。 退出播放：调用release()销毁实例，AVPlayer进入released状态，退出播放。    完整示例 已复制import media from '@ohos.multimedia.media';import fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
export class AVPlayerDemo {  private avPlayer;  private count: number = 0;  private surfaceID: string; // surfaceID用于播放画面显示，具体的值需要通过Xcomponent接口获取，相关文档链接见上面Xcomponent创建方法
  // 注册avplayer回调函数  setAVPlayerCallback() {    // seek操作结果回调函数    this.avPlayer.on('seekDone', (seekDoneTime) => {      console.info(`AVPlayer seek succeeded, seek time is ${seekDoneTime}`);    })    // error回调监听函数,当avPlayer在操作过程中出现错误时调用reset接口触发重置流程    this.avPlayer.on('error', (err) => {      console.error(`Invoke avPlayer failed, code is ${err.code}, message is ${err.message}`);      this.avPlayer.reset(); // 调用reset重置资源，触发idle状态    })    // 状态机变化回调函数    this.avPlayer.on('stateChange', async (state, reason) => {      switch (state) {        case 'idle': // 成功调用reset接口后触发该状态机上报          console.info('AVPlayer state idle called.');          this.avPlayer.release(); // 调用release接口销毁实例对象          break;        case 'initialized': // avplayer 设置播放源后触发该状态上报          console.info('AVPlayerstate initialized called.');          this.avPlayer.surfaceId = this.surfaceID; // 设置显示画面，当播放的资源为纯音频时无需设置          this.avPlayer.prepare().then(() => {            console.info('AVPlayer prepare succeeded.');          }, (err) => {            console.error(`Invoke prepare failed, code is ${err.code}, message is ${err.message}`);          });          break;        case 'prepared': // prepare调用成功后上报该状态机          console.info('AVPlayer state prepared called.');          this.avPlayer.play(); // 调用播放接口开始播放          break;        case 'playing': // play成功调用后触发该状态机上报          console.info('AVPlayer state playing called.');          if (this.count !== 0) {            console.info('AVPlayer start to seek.');            this.avPlayer.seek(this.avPlayer.duration); //seek到视频末尾          } else {            this.avPlayer.pause(); // 调用暂停接口暂停播放          }          this.count++;          break;        case 'paused': // pause成功调用后触发该状态机上报          console.info('AVPlayer state paused called.');          this.avPlayer.play(); // 再次播放接口开始播放          break;        case 'completed': // 播放结束后触发该状态机上报          console.info('AVPlayer state completed called.');          this.avPlayer.stop(); //调用播放结束接口          break;        case 'stopped': // stop接口成功调用后触发该状态机上报          console.info('AVPlayer state stopped called.');          this.avPlayer.reset(); // 调用reset接口初始化avplayer状态          break;        case 'released':          console.info('AVPlayer state released called.');          break;        default:          console.info('AVPlayer state unknown called.');          break;      }    })  }
  // 以下demo为使用fs文件系统打开沙箱地址获取媒体文件地址并通过url属性进行播放示例  async avPlayerUrlDemo() {    // 创建avPlayer实例对象    this.avPlayer = await media.createAVPlayer();    // 创建状态机变化回调函数    this.setAVPlayerCallback();    let fdPath = 'fd://';    let context = getContext(this) as common.UIAbilityContext;    // 通过UIAbilityContext获取沙箱地址filesDir，以下为Stage模型获方式，如需在FA模型上获取请参考《访问应用沙箱》获取地址    let pathDir = context.filesDir;    let path = pathDir  + '/H264_AAC.mp4';     // 打开相应的资源文件地址获取fd，并为url赋值触发initialized状态机上报    let file = await fs.open(path);    fdPath = fdPath + '' + file.fd;    this.avPlayer.url = fdPath;  }
  // 以下demo为使用资源管理接口获取打包在HAP内的媒体资源文件并通过fdSrc属性进行播放示例  async avPlayerFdSrcDemo() {    // 创建avPlayer实例对象    this.avPlayer = await media.createAVPlayer();    // 创建状态机变化回调函数    this.setAVPlayerCallback();    // 通过UIAbilityContext的resourceManager成员的getRawFd接口获取媒体资源播放地址    // 返回类型为{fd,offset,length},fd为HAP包fd地址，offset为媒体资源偏移量，length为播放长度    let context = getContext(this) as common.UIAbilityContext;    let fileDescriptor = await context.resourceManager.getRawFd('H264_AAC.mp4');    // 为fdSrc赋值触发initialized状态机上报    this.avPlayer.fdSrc = fileDescriptor;  }}   上一篇 开发音频通话功能 下一篇 图片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。视频教程 更新时间: 2023-10-16 11:16 毫无帮助帮助不大一般很好非常好
分享
 为了方便开发者更好地学习HarmonyOS相关知识，本页面对当前有的视频教程资源进行了汇总，如下表所示： 主题  简介    <HarmonyOS第一课>运行Hello World  开启学习之旅，安装DevEco Studio开发工具，运行第一个应用。   <HarmonyOS第一课>ArkTS开发语言介绍  掌握基于TS扩展的ArkTS语言，以更接近自然语义快速开发应用。   <HarmonyOS第一课>应用程序框架  从应用入口开始，了解用户如何与应用交互，理解应用的生命周期。   <HarmonyOS第一课>从简单的页面开始  为应用选择合适的组件，构建漂亮的页面。   <HarmonyOS第一课>构建更加丰富的页面  了解组件状态管理的相关知识点，并进一步的学习一些常用的组件如video和弹窗，来构建更加丰富的页面。   <HarmonyOS主题课>ArkUI之属性动画  声明式UI框架，它使用极简的UI信息语法、丰富的UI动效组件和API、以及实时界面预览工具，帮助提升应用界面开发的效率。   <HarmonyOS第一课>从网络获取数据  学习如何访问网络，来构建一个可以从网络实时获取数据的应用。   <HarmonyOS第一课>保存应用数据  存储应用的一些常用配置，以便应用获得更快的数据存取速度。   <HarmonyOS主题课>三方库  包含UI、动画、图片、多媒体、文件数据、网络、安全、工具等类型的三方库，帮助快速开发应用。   <HarmonyOS主题课>使用DevEco Studio高效开发  包含环境准备、高效编辑代码、预览器的使用、运行和调试代码、高效测试、性能持续调优等关键场景，课程正在持续更新中，敬请期待。     上一篇 Codelabs 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。系统音量监听系统音量变化音频流音量播放音量管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  播放音量的管理主要包括对系统音量的管理和对音频流音量的管理。系统音量与音频流音量分别是指HarmonyOS系统的总音量和指定音频流的音量，其中音频流音量的大小受制于系统音量，管理两者的接口不同。 详细的API说明请参考audio API参考。  系统音量 管理系统音量的接口是AudioVolumeManager，在使用之前，需要使用getVolumeManager()获取AudioVolumeManager实例。目前该接口只能获取音量信息及监听音量变化，不能主动调节系统音量。 已复制import audio from '@ohos.multimedia.audio';let audioManager = audio.getAudioManager();let audioVolumeManager = audioManager.getVolumeManager();   监听系统音量变化 通过设置监听事件，可以监听系统音量的变化： 已复制audioVolumeManager.on('volumeChange', (volumeEvent) => {  console.info(`VolumeType of stream: ${volumeEvent.volumeType} `);  console.info(`Volume level: ${volumeEvent.volume} `);  console.info(`Whether to updateUI: ${volumeEvent.updateUi} `);});   音频流音量 管理音频流音量的接口是AVPlayer或AudioRenderer的setVolume()方法，使用AVPlayer设置音频流音量的示例代码如下：  已复制let volume = 1.0  // 指定的音量大小，取值范围为[0.00-1.00]，1表示最大音量avPlayer.setVolume(volume) 使用AudioRenderer设置音频流音量的示例代码如下： 已复制audioRenderer.setVolume(0.5).then(data=>{  // 音量范围为[0.0-1.0]  console.info('Invoke setVolume succeeded.');}).catch((err) => {    console.error(`Invoke setVolume failed, code is ${err.code}, message is ${err.message}`);});  上一篇 多音频播放的并发策略 下一篇 音频播放流管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。信息传递载体Want 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 请参见Stage模型的"信息传递载体Want"。  上一篇 FA模型的Context 下一篇 进程模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Want的定义与用途Want的类型Want参数说明Want概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   Want的定义与用途 Want是对象间信息传递的载体，可以用于应用组件间的信息传递。其使用场景之一是作为startAbility()的参数，包含了指定的启动目标以及启动时需携带的相关数据，如bundleName和abilityName字段分别指明目标Ability所在应用的包名以及对应包内的Ability名称。当UIAbilityA启动UIAbilityB并需要传入一些数据给UIAbilityB时，Want可以作为一个载体将数据传给UIAbilityB。 图1 Want用法示意    Want的类型  显式Want：在启动Ability时指定了abilityName和bundleName的Want称为显式Want。 当有明确处理请求的对象时，通过提供目标Ability所在应用的包名信息（bundleName），并在Want内指定abilityName便可启动目标Ability。显式Want通常用于在当前应用开发中启动某个已知的Ability。参数说明参见Want参数说明。 已复制let wantInfo = {    deviceId: '', // deviceId为空表示本设备    bundleName: 'com.example.myapplication',    abilityName: 'FuncAbility',} 隐式Want：在启动UIAbility时未指定abilityName的Want称为隐式Want。 当请求处理的对象不明确时，希望在当前应用中使用其他应用提供的某个能力（通过skills标签定义），而不关心提供该能力的具体应用，可以使用隐式Want。例如使用隐式Want描述需要打开一个链接的请求，而不关心通过具体哪个应用打开，系统将匹配声明支持该请求的所有应用。 已复制let wantInfo = {    // uncomment line below if wish to implicitly query only in the specific bundle.    // bundleName: 'com.example.myapplication',    action: 'ohos.want.action.search',    // entities can be omitted    entities: [ 'entity.system.browsable' ],    uri: 'https://www.test.com:8080/query/student',    type: 'text/plain',}; 
说明
           根据系统中待匹配Ability的匹配情况不同，使用隐式Want启动Ability时会出现以下三种情况。           未匹配到满足条件的Ability：启动失败。 匹配到一个满足条件的Ability：直接启动该Ability。 匹配到多个满足条件的Ability（UIAbility）：弹出选择框让用户选择。   
    Want参数说明     名称 读写属性 类型 必填 描述    deviceId 只读 string 否 表示目标Ability所在设备ID。如果未设置该字段，则表明本设备。   bundleName 只读 string 否 表示目标Ability所在应用名称。   moduleName 只读 string 否 表示目标Ability所属的模块名称。   abilityName 只读 string 否 表示目标Ability名称。如果未设置该字段，则该Want为隐式。如果在Want中同时指定了bundleName，moduleName和abilityName，则Want可以直接匹配到指定的Ability。   uri 只读 string 否 表示携带的数据，一般配合type使用，指明待处理的数据类型。如果在Want中指定了uri，则Want将匹配指定的Uri信息，包括scheme, schemeSpecificPart, authority和path信息。   type 只读 string 否 表示携带数据类型，使用MIME类型规范。例如："text/plain"、"image/*"等。   action 只读 string 否 表示要执行的通用操作（如：查看、分享、应用详情）。在隐式Want中，您可定义该字段，配合uri或parameters来表示对数据要执行的操作。如打开，查看该uri数据。例如，当uri为一段网址，action为ohos.want.action.viewData则表示匹配可查看该网址的Ability。   entities 只读 Array<string> 否 表示目标Ability额外的类别信息（如：浏览器，视频播放器），在隐式Want中是对action的补充。在隐式Want中，您可定义该字段，来过滤匹配UIAbility类别，如必须是浏览器。例如，在action字段的举例中，可存在多个应用声明了支持查看网址的操作，其中有应用为普通社交应用，有的为浏览器应用，您可通过entity.system.browsable过滤掉非浏览器的其他应用。   flags 只读 number 否 表示处理Want的方式。例如通过wantConstant.Flags.FLAG_ABILITY_CONTINUATION表示是否以设备间迁移方式启动Ability。   parameters 只读 {[key: string]: any} 否 此参数用于传递自定义数据，通过用户自定义的键值对进行数据填充，具体支持的数据类型如Want API所示。      上一篇 信息传递载体Want 下一篇 显式Want与隐式Want匹配规则 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。建立应用侧与前端页面数据通道 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  前端页面和应用侧之间可以用createWebMessagePorts()接口创建消息端口来实现两端的通信。 在下面的示例中，应用侧页面中通过createWebMessagePorts方法创建消息端口，再把其中一个端口通过postMessage()接口发送到前端页面，便可以在前端页面和应用侧之间互相发送消息。  应用侧代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();  ports: web_webview.WebMessagePort[];  @State sendFromEts: string = 'Send this message from ets to HTML';  @State receivedFromHtml: string = 'Display received message send from HTML';
  build() {    Column() {      // 展示接收到的来自HTML的内容      Text(this.receivedFromHtml)      // 输入框的内容发送到html      TextInput({placeholder: 'Send this message from ets to HTML'})        .onChange((value: string) => {          this.sendFromEts = value;        })
      Button('postMessage')        .onClick(() => {          try {            // 1、创建两个消息端口。            this.ports = this.controller.createWebMessagePorts();            // 2、在应用侧的消息端口(如端口1)上注册回调事件。            this.ports[1].onMessageEvent((result: web_webview.WebMessage) => {              let msg = 'Got msg from HTML:';              if (typeof(result) === 'string') {                console.info(`received string message from html5, string is: ${result}`);                msg = msg + result;              } else if (typeof(result) === 'object') {                if (result instanceof ArrayBuffer) {                  console.info(`received arraybuffer from html5, length is: ${result.byteLength}`);                  msg = msg + 'lenght is ' + result.byteLength;                } else {                  console.info('not support');                }              } else {                console.info('not support');              }              this.receivedFromHtml = msg;            })            // 3、将另一个消息端口(如端口0)发送到HTML侧，由HTML侧保存并使用。            this.controller.postMessage('__init_port__', [this.ports[0]], '*');          } catch (error) {            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);          }        })
      // 4、使用应用侧的端口给另一个已经发送到html的端口发送消息。      Button('SendDataToHTML')        .onClick(() => {          try {            if (this.ports && this.ports[1]) {              this.ports[1].postMessageEvent(this.sendFromEts);            } else {              console.error(`ports is null, Please initialize first`);            }          } catch (error) {            console.error(`ErrorCode: ${error.code}, Message: ${error.message}`);          }        })      Web({ src: $rawfile('xxx.html'), controller: this.controller })    }  }} 前端页面代码。已复制<!--xxx.html--><!DOCTYPE html><html><head>    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>WebView Message Port Demo</title></head><body>    <h1>WebView Message Port Demo</h1>    <div>        <input type="button" value="SendToEts" onclick="PostMsgToEts(msgFromJS.value);"/><br/>        <input id="msgFromJS" type="text" value="send this message from HTML to ets"/><br/>    </div>    <p class="output">display received message send from ets</p></body><script>var h5Port;var output = document.querySelector('.output');window.addEventListener('message', function (event) {    if (event.data === '__init_port__') {        if (event.ports[0] !== null) {            h5Port = event.ports[0]; // 1. 保存从ets侧发送过来的端口            h5Port.onmessage = function (event) {              // 2. 接收ets侧发送过来的消息.              var msg = 'Got message from ets:';              var result = event.data;              if (typeof(result) === 'string') {                console.info(`received string message from html5, string is: ${result}`);                msg = msg + result;              } else if (typeof(result) === 'object') {                if (result instanceof ArrayBuffer) {                  console.info(`received arraybuffer from html5, length is: ${result.byteLength}`);                  msg = msg + 'lenght is ' + result.byteLength;                } else {                  console.info('not support');                }              } else {                console.info('not support');              }              output.innerHTML = msg;            }        }    }})// 3. 使用h5Port往ets侧发送消息.function PostMsgToEts(data) {    if (h5Port) {      h5Port.postMessage(data);    } else {      console.error('h5Port is null, Please initialize first');    }}</script></html>   上一篇 前端页面调用应用侧函数 下一篇 管理页面跳转及浏览记录导航 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。设置基本属性和事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    设置深色模式  上传文件  在新窗口中打开页面  管理位置权限   上一篇 使用Web组件加载页面 下一篇 设置深色模式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Web组件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 Web组件用于在应用程序中显示Web页面内容，为开发者提供页面加载、页面交互、页面调试等能力。 页面加载：Web组件提供基础的前端页面加载的能力，包括加载网络页面、本地页面、Html格式文本数据。页面交互：Web组件提供丰富的页面交互的方式，包括：设置前端页面深色模式，新窗口中加载页面，位置权限管理，Cookie管理，应用侧使用前端页面JavaScript等能力。页面调试：Web组件支持使用Devtools工具调试前端页面。 下面通过常见使用场景举例，来具体介绍Web组件功能特性。  上一篇 Web 下一篇 使用Web组件加载页面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Cookie管理缓存与存储管理CacheDom Storage管理Cookie及数据存储 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   Cookie管理 Cookie是网络访问过程中，由服务端发送给客户端的一小段数据。客户端可持有该数据，并在后续访问该服务端时，方便服务端快速对客户端身份、状态等进行识别。 Web组件提供了WebCookieManager类，用于管理Web组件的Cookie信息。Cookie信息保存在应用沙箱路径下/proc/{pid}/root/data/storage/el2/base/cache/web/Cookiesd的文件中。 下面以setCookie()接口举例，为“www.example.com”设置单个Cookie的值“value=test”。其他Cookie的相关功能及使用，请参考WebCookieManager()接口文档。 已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Button('setCookie')        .onClick(() => {          try {            web_webview.WebCookieManager.setCookie('https://www.example.com', 'value=test');          } catch (error) {            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);          }        })      Web({ src: 'www.example.com', controller: this.controller })    }  }}   缓存与存储管理 在访问网站时，网络资源请求是相对比较耗时的。开发者可以通过Cache、Dom Storage等手段将资源保持至本地，以提升访问同一网站的速度。   Cache 使用cacheMode()配置页面资源的缓存模式，Web组件为开发者提供四种缓存模式，分别为：  Default : 优先使用未过期的缓存，如果缓存不存在，则从网络获取。 None : 加载资源使用cache，如果cache中无该资源则从网络中获取。 Online : 加载资源不使用cache，全部从网络中获取。 Only ：只从cache中加载资源。   在下面的示例中，选用缓存设置为None模式。 已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  @State mode: CacheMode = CacheMode.None;  controller: web_webview.WebviewController = new web_webview.WebviewController();  build() {    Column() {      Web({ src: 'www.example.com', controller: this.controller })        .cacheMode(this.mode)    }  }}      同时，为了获取最新资源，开发者可以通过removeCache()接口清除已经缓存的资源，示例代码如下：     已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  @State mode: CacheMode = CacheMode.None;  controller: web_webview.WebviewController = new web_webview.WebviewController();  build() {    Column() {      Button('removeCache')        .onClick(() => {          try {            // 设置为true时同时清除rom和ram中的缓存，设置为false时只清除ram中的缓存            this.controller.removeCache(true);          } catch (error) {            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);          }        })      Web({ src: 'www.example.com', controller: this.controller })        .cacheMode(this.mode)    }  }}   Dom Storage Dom Storage包含了Session Storage和Local Storage两类。前者为临时数据，其存储与释放跟随会话生命周期；后者为可持久化数据，落盘在应用目录下。两者的数据均通过Key-Value的形式存储，通常在访问需要客户端存储的页面时使用。开发者可以通过Web组件的属性接口domStorageAccess()进行使能配置，示例如下：  已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();  build() {    Column() {      Web({ src: 'www.example.com', controller: this.controller })        .domStorageAccess(true)    }  }}  上一篇 管理页面跳转及浏览记录导航 下一篇 自定义页面请求响应 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用Devtools工具调试前端页面 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Web组件支持使用DevTools工具调试前端页面。DevTools是一个 Web前端开发调试工具，提供了电脑上调试移动设备前端页面的能力。开发者通过setWebDebuggingAccess()接口开启Web组件前端页面调试能力，利用DevTools工具可以在PC端调试移动设备上的前端网页。 使用DevTools工具，可以执行以下步骤：  在应用代码中开启Web调试开关，具体如下：已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();  aboutToAppear() {    // 配置web开启调试模式    web_webview.WebviewController.setWebDebuggingAccess(true);  }  build() {    Column() {      Web({ src: 'www.example.com', controller: this.controller })    }  }}  将设备连接上电脑，在电脑端配置端口映射，配置方法如下：已复制// 添加映射 hdc fport tcp:9222 tcp:9222 // 查看映射 hdc fport ls  在电脑端chrome浏览器地址栏中输入chrome://inspect/#devices，页面识别到设备后，就可以开始页面调试。调试效果如下：  图1 页面调试效果图     上一篇 自定义页面请求响应 下一篇 ArkTS语言基础类库 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。上传文件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Web组件支持前端页面选择文件上传功能，应用开发者可以使用onShowFileSelector()接口来处理前端页面文件上传的请求。 下面的示例中，当用户在前端页面点击文件上传按钮，应用侧在onShowFileSelector()接口中收到文件上传请求，在此接口中开发者将上传的本地文件路径设置给前端页面。  应用侧代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview';@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController()  build() {    Column() {      // 加载本地local.html页面      Web({ src: $rawfile('local.html'), controller: this.controller })        .onShowFileSelector((event) => {            // 开发者设置要上传的文件路径           let fileList: Array<string> = [              'xxx/test.png',           ]           if(event){              event.result.handleFileList(fileList)           }           return true;        })    }  }}   local.html页面代码。已复制<!DOCTYPE html><html><head>    <meta charset="utf-8">    <title>Document</title></head>
<body>// 点击文件上传按钮<input type="file" value="file"></br></body></html>   上一篇 设置深色模式 下一篇 在新窗口中打开页面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。管理位置权限 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Web组件提供位置权限管理能力。开发者可以通过onGeolocationShow()接口对某个网站进行位置权限管理。Web组件根据接口响应结果，决定是否赋予前端页面权限。获取设备位置，需要开发者配置ohos.permission.LOCATION权限。 在下面的示例中，用户点击前端页面"获取位置"按钮，Web组件通过弹窗的形式通知应用侧位置权限请求消息，示例代码如下：  前端页面代码。已复制<!DOCTYPE html><html><body><p id="locationInfo">位置信息</p><button onclick="getLocation()">获取位置</button><script>var locationInfo=document.getElementById("locationInfo");function getLocation(){  if (navigator.geolocation) {    <!-- 前端页面访问设备地理位置 -->    navigator.geolocation.getCurrentPosition(showPosition);  }}function showPosition(position){  locationInfo.innerHTML="Latitude: " + position.coords.latitude + "<br />Longitude: " + position.coords.longitude;}</script></body></html>   应用代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview';import common from '@ohos.app.ability.common';import abilityAccessCtrl from '@ohos.abilityAccessCtrl';import geoLocationManager from '@ohos.geoLocationManager';
let context = getContext(this) as common.UIAbilityContext;let atManager = abilityAccessCtrl.createAtManager();
try{  atManager.requestPermissionsFromUser(context, ["ohos.permission.APPROXIMATELY_LOCATION"], (err, data) => {    let requestInfo: geoLocationManager.LocationRequest = {      'priority': 0x203,      'scenario': 0x300,      'maxAccuracy': 0    };    let locationChange = (location: geoLocationManager.Location):void => {      if(location){        console.log('locationChanger: location=' + JSON.stringify(location));      }    };    try{      geoLocationManager.on('locationChange', requestInfo, locationChange);      geoLocationManager.off('locationChange', locationChange);    } catch (err) {      console.error("errCode:" + err.code + ", errMessage:" + err.message);    }  })} catch (err) {  console.error("err:", err);}
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();  build() {    Column() {      Web({ src:$rawfile('getLocation.html'), controller:this.controller })        .geolocationAccess(true)        .onGeolocationShow((event) => {  // 地理位置权限申请通知          AlertDialog.show({            title: '位置权限请求',            message: '是否允许获取位置信息',            primaryButton: {              value: 'cancel',              action: () => {                if(event){                event.geolocation.invoke(event.origin, false, false);   // 不允许此站点地理位置权限请求                }              }            },            secondaryButton: {              value: 'ok',              action: () => {                if(event){                event.geolocation.invoke(event.origin, true, false);    // 允许此站点地理位置权限请求                }                              }            },            cancel: () => {              if(event){              event.geolocation.invoke(event.origin, false, false);   // 不允许此站点地理位置权限请求              }            }          })        })    }  }}   上一篇 在新窗口中打开页面 下一篇 在应用中使用前端页面JavaScript 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。在应用中使用前端页面JavaScript 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    应用侧调用前端页面函数  前端页面调用应用侧函数  建立应用侧与前端页面数据通道   上一篇 管理位置权限 下一篇 应用侧调用前端页面函数 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用侧调用前端页面函数 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用侧可以通过runJavaScript()方法调用前端页面的JavaScript相关函数。 在下面的示例中，点击应用侧的“runJavaScript”按钮时，来触发前端页面的htmlTest()方法。  前端页面代码。已复制<!-- index.html --><!DOCTYPE html><html><body><script>    function htmlTest() {        console.info('JavaScript Hello World! ');    }</script></body></html>   应用侧代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Web({ src: $rawfile('index.html'), controller: this.webviewController})      Button('runJavaScript')        .onClick(() => {           this.webviewController.runJavaScript('htmlTest()');        })    }  }}   上一篇 在应用中使用前端页面JavaScript 下一篇 前端页面调用应用侧函数 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前端页面调用应用侧函数 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  开发者使用Web组件将应用侧代码注册到前端页面中，注册完成之后，前端页面中使用注册的对象名称就可以调用应用侧的函数，实现在前端页面中调用应用侧方法。 注册应用侧代码有两种方式，一种在Web组件初始化使用调用，使用javaScriptProxy()接口。另外一种在Web组件初始化完成后调用，使用registerJavaScriptProxy()接口。 在下面的示例中，将test()方法注册在前端页面中， 该函数可以在前端页面触发运行。  javaScriptProxy()接口使用示例如下。已复制// xxx.etsimport web_webview from '@ohos.web.webview';
class testClass {  constructor() {  }
  test(): string {    return 'ArkTS Hello World!';  }}
@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();  // 声明需要注册的对象  @State testObj: testClass = new testClass();
  build() {    Column() {      // web组件加载本地index.html页面      Web({ src: $rawfile('index.html'), controller: this.webviewController})        // 将对象注入到web端        .javaScriptProxy({          object: this.testObj,          name: "testObjName",          methodList: ["test"],          controller: this.webviewController        })    }  }}   应用侧使用registerJavaScriptProxy()接口注册。已复制// xxx.etsimport web_webview from '@ohos.web.webview';import business_error from '@ohos.base';
class testClass {  constructor() {  }
  test(): string {    return "ArkUI Web Component";  }
  toString(): void {    console.log('Web Component toString');  }}
@Entry@Componentstruct Index {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();  @State testObj: testClass = new testClass();
  build() {    Column() {      Button('refresh')        .onClick(() => {          try {            this.webviewController.refresh();          } catch (error) {            let e: business_error.BusinessError = error as business_error.BusinessError;            console.error(`ErrorCode: ${e.code},  Message: ${e.message}`);          }        })      Button('Register JavaScript To Window')        .onClick(() => {          try {            this.webviewController.registerJavaScriptProxy(this.testObj, "testObjName", ["test", "toString"]);          } catch (error) {            let e: business_error.BusinessError = error as business_error.BusinessError;            console.error(`ErrorCode: ${e.code},  Message: ${e.message}`);          }        })      Web({ src: $rawfile('index.html'), controller: this.webviewController })    }  }} 
说明
 使用registerJavaScriptProxy()接口注册方法时，注册后需调用refresh()接口生效。 
   index.html前端页面触发应用侧代码。已复制<!-- index.html --><!DOCTYPE html><html><body><button type="button" onclick="callArkTS()">Click Me!</button><p id="demo"></p><script>    function callArkTS() {        let str = testObjName.test();        document.getElementById("demo").innerHTML = str;        console.info('ArkTS Hello World! :' + str);    }</script></body></html>   上一篇 应用侧调用前端页面函数 下一篇 建立应用侧与前端页面数据通道 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。在新窗口中打开页面 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Web组件提供了在新窗口打开页面的能力，开发者可以通过multiWindowAccess()接口来设置是否允许网页在新窗口打开。当有新窗口打开时，应用侧会在onWindowNew()接口中收到Web组件新窗口事件，开发者需要在此接口事件中，新建窗口来处理Web组件窗口请求。 
说明
  如果开发者在onWindowNew()接口通知中不需要打开新窗口，需要将ControllerHandler.setWebController()接口返回值设置成null。  
 如下面的本地示例，当用户点击“新窗口中打开网页”按钮时，应用侧会在onWindowNew()接口中收到Web组件新窗口事件。  应用侧代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview'
//在同一page页有两个web组件。在WebComponent新开窗口时，会跳转到NewWebViewComp。@CustomDialogstruct NewWebViewComp {controller?: CustomDialogControllerwebviewController1: web_webview.WebviewController = new web_webview.WebviewController()build() {    Column() {      Web({ src: "", controller: this.webviewController1 })        .javaScriptAccess(true)        .multiWindowAccess(false)        .onWindowExit(()=> {          console.info("NewWebViewComp onWindowExit")          if (this.controller) {            this.controller.close()          }        })      }  }}
@Entry@Componentstruct WebComponent {    controller: web_webview.WebviewController = new web_webview.WebviewController()    dialogController: CustomDialogController | null = null    build() {      Column() {        Web({ src:$rawfile("window.html"), controller: this.controller })          .javaScriptAccess(true)         //需要使能multiWindowAccess          .multiWindowAccess(true)          .onWindowNew((event) => {          if (this.dialogController) {            this.dialogController.close()          }          let popController:web_webview.WebviewController = new web_webview.WebviewController()          this.dialogController = new CustomDialogController({            builder: NewWebViewComp({webviewController1: popController})          })          this.dialogController.open()          //将新窗口对应WebviewController返回给Web内核。          //如果不需要打开新窗口请调用event.handler.setWebController接口设置成null。          //若不调用event.handler.setWebController接口，会造成render进程阻塞。          event.handler.setWebController(popController)        })    }  }}   window.html页面代码。已复制 <!DOCTYPE html><html><head>    <meta charset="utf-8">    <title>WindowEvent</title></head><body><input type="button" value="新窗口中打开网页" onclick="OpenNewWindow()"><script type="text/javascript">    function OpenNewWindow()    {        let openedWindow = window.open("about:blank", "", "location=no,status=no,scrollvars=no");        openedWindow.document.write("<p>这是我的窗口</p>");        openedWindow.focus();    }</script></body></html>   上一篇 上传文件 下一篇 管理位置权限 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。加载网络页面加载本地页面加载HTML格式的文本数据使用Web组件加载页面 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  页面加载是Web组件的基本功能。根据页面加载数据来源可以分为三种常用场景，包括加载网络页面、加载本地页面、加载HTML格式的富文本数据。 页面加载过程中，若涉及网络资源获取，需要配置ohos.permission.INTERNET网络访问权限。  加载网络页面 开发者可以在Web组件创建的时候指定默认加载的网络页面 。在默认页面加载完成后，如果开发者需要变更此Web组件显示的网络页面，可以通过调用loadUrl()接口加载指定网络网页。  在下面的示例中，在Web组件加载完“www.example.com”页面后，开发者可通过loadUrl接口将此Web组件显示页面变更为“www.example1.com”。 已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Button('loadUrl')        .onClick(() => {          try {            // 点击按钮时，通过loadUrl，跳转到www.example1.com            this.webviewController.loadUrl('www.example1.com');          } catch (error) {            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);          }        })      // 组件创建时，加载www.example.com      Web({ src: 'www.example.com', controller: this.webviewController})    }  }}  加载本地页面 将本地页面文件放在应用的rawfile目录下，开发者可以在Web组件创建的时候指定默认加载的本地页面 ，并且加载完成后可通过调用loadUrl()接口变更当前Web组件的页面。  在下面的示例中展示加载本地页面文件的方法：  将资源文件放置在应用的resources/rawfile目录下。       图1 资源文件路径    应用侧代码已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Button('loadUrl')        .onClick(() => {          try {            // 点击按钮时，通过loadUrl，跳转到local1.html            this.webviewController.loadUrl($rawfile("local1.html"));          } catch (error) {            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);          }        })      // 组件创建时，通过$rawfile加载本地文件local.html      Web({ src: $rawfile("local.html"), controller: this.webviewController })    }  }}   local.html页面代码。已复制<!-- local.html --><!DOCTYPE html><html>  <body>    <p>Hello World</p>  </body></html>   加载HTML格式的文本数据 Web组件可以通过loadData接口实现加载HTML格式的文本数据。当开发者不需要加载整个页面，只需要显示一些页面片段时，可通过此功能来快速加载页面。 已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Button('loadData')        .onClick(() => {          try {            // 点击按钮时，通过loadData，加载HTML格式的文本数据            this.controller.loadData(              "<html><body bgcolor=\"white\">Source:<pre>source</pre></body></html>",              "text/html",              "UTF-8"            );          } catch (error) {            console.error(`ErrorCode: ${error.code},  Message: ${error.message}`);          }        })      // 组件创建时，加载www.example.com      Web({ src: 'www.example.com', controller: this.controller })    }  }}   上一篇 Web组件概述 下一篇 设置基本属性和事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。历史记录导航页面跳转跨应用跳转管理页面跳转及浏览记录导航 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   历史记录导航 使用者在前端页面点击网页中的链接时，Web组件默认会自动打开并加载目标网址。当前端页面替换为新的加载链接时，会自动记录已经访问的网页地址。可以通过forward()和backward()接口向前/向后浏览上一个/下一个历史记录。       在下面的示例中，点击应用的按钮来触发前端页面的后退操作。      已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();  build() {    Column() {      Button('loadData')        .onClick(() => {          if (this.webviewController.accessBackward()) {            this.webviewController.backward();            return true;          }        })      Web({ src: 'https://www.example.com/cn/', controller: this.webviewController})    }  }}   如果存在历史记录，accessBackward()接口会返回true。同样，您可以使用accessForward()接口检查是否存在前进的历史记录。如果您不执行检查，那么当用户浏览到历史记录的末尾时，调用forward()和backward()接口时将不执行任何操作。  页面跳转 当点击网页中的链接需要跳转到应用内其他页面时，可以通过使用Web组件的onUrlLoadIntercept()接口来实现。 在下面的示例中，应用首页Index.ets加载前端页面route.html，在前端route.html页面点击超链接，可跳转到应用的ProfilePage.ets页面。  应用首页index.ets页面代码。已复制// index.etsimport web_webview from '@ohos.web.webview';import router from '@ohos.router';@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Web({ src: $rawfile('route.html'), controller: this.webviewController })        .onUrlLoadIntercept((event) => {          let url: string = event.data as string;          if (url.indexOf('native://') === 0) {            // 跳转其他界面            router.pushUrl({ url:url.substring(9) })            return true;          }          return false;        })    }  }}   route.html前端页面代码。已复制<!-- route.html --><!DOCTYPE html><html><body>  <div>      <a href="native://pages/ProfilePage">个人中心</a>   </div></body></html>   跳转页面ProfilePage.ets代码。已复制@Entry@Componentstruct ProfilePage {  @State message: string = 'Hello World';
  build() {    Column() {      Text(this.message)        .fontSize(20)    }  }}    跨应用跳转 Web组件可以实现点击前端页面超链接跳转到其他应用。 在下面的示例中，点击call.html前端页面中的超连接，跳转到电话应用的拨号界面。  应用侧代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview';import call from '@ohos.telephony.call';
@Entry@Componentstruct WebComponent {  webviewController: web_webview.WebviewController = new web_webview.WebviewController();
  build() {    Column() {      Web({ src: $rawfile('xxx.html'), controller: this.webviewController})        .onUrlLoadIntercept((event) => {          let url: string = event.data as string;          // 判断链接是否为拨号链接          if (url.indexOf('tel://') === 0) {            // 跳转拨号界面            call.makeCall(url.substring(6), (err) => {              if (!err) {                console.info('make call succeeded.');              } else {                console.info('make call fail, err is:' + JSON.stringify(err));              }            });            return true;          }          return false;        })    }  }}   前端页面call.html代码。已复制<!-- call.html --><!DOCTYPE html><html><body>  <div>    <a href="tel://xxx xxxx xxx">拨打电话</a>  </div></body></html>    上一篇 建立应用侧与前端页面数据通道 下一篇 管理Cookie及数据存储 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自定义页面请求响应 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Web组件支持在应用拦截到页面请求后自定义响应请求能力。开发者通过onInterceptRequest()接口来实现自定义资源请求响应 。自定义请求能力可以用于开发者自定义Web页面响应、自定义文件资源响应等场景。 Web网页上发起资源加载请求，应用层收到资源请求消息。应用层构造本地资源响应消息发送给Web内核。Web内核解析应用层响应信息，根据此响应信息进行页面资源加载。 在下面的示例中，Web组件通过拦截页面请求“https://www.example.com/test.html”，在应用侧代码构建响应资源，实现自定义页面响应场景。  前端页面index.html代码。已复制<!DOCTYPE html><html><head>    <meta charset="utf-8">    <title>example</title></head><body><!-- 页面资源请求 --><a href="https://www.example.com/test.html">intercept test!</a></body></html> 应用侧代码。已复制// xxx.etsimport web_webview from '@ohos.web.webview'
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController()  responseResource: WebResourceResponse = new WebResourceResponse()  // 开发者自定义响应数据  @State webdata: string = "<!DOCTYPE html>\n" +  "<html>\n"+  "<head>\n"+  "<title>intercept test</title>\n"+  "</head>\n"+  "<body>\n"+  "<h1>intercept test</h1>\n"+  "</body>\n"+  "</html>"  build() {    Column() {      Web({ src: $rawfile('index.html'), controller: this.controller })        .onInterceptRequest((event?: Record<string, WebResourceRequest>): WebResourceResponse => {          if (!event) {            return new WebResourceResponse();          }          let mRequest: WebResourceRequest = event.request as WebResourceRequest;          console.info('TAGLee: url:'+ mRequest.getRequestUrl());          //拦截页面请求，如果加载的url判断与目标url一致则返回自定义加载结果webdata          if(mRequest.getRequestUrl() === 'https://www.example.com/test.html'){            // 构造响应数据            this.responseResource.setResponseData(this.webdata);            this.responseResource.setResponseEncoding('utf-8');            this.responseResource.setResponseMimeType('text/html');            this.responseResource.setResponseCode(200);            this.responseResource.setReasonMessage('OK');            return this.responseResource;          }          return;        })    }  }}   上一篇 管理Cookie及数据存储 下一篇 使用Devtools工具调试前端页面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。设置深色模式 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Web组件支持对前端页面进行深色模式配置。  通过darkMode()接口可以配置不同的深色模式，WebDarkMode.Off模式表示关闭深色模式。WebDarkMode.On表示开启深色模式，并且深色模式跟随前端页面。WebDarkMode.Auto表示开启深色模式，并且深色模式跟随系统。             在下面的示例中, 通过darkMode()接口将页面深色模式配置为跟随系统。       已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();  @State mode: WebDarkMode = WebDarkMode.Auto;  build() {    Column() {      Web({ src: 'www.example.com', controller: this.controller })        .darkMode(this.mode)    }  }}  通过forceDarkAccess()接口可将前端页面强制配置深色模式，且深色模式不跟随前端页面和系统。配置该模式时候，需要将深色模式配置成WebDarkMode.On。             在下面的示例中, 通过forceDarkAccess()接口将页面强制配置为深色模式。       已复制// xxx.etsimport web_webview from '@ohos.web.webview';
@Entry@Componentstruct WebComponent {  controller: web_webview.WebviewController = new web_webview.WebviewController();  @State mode: WebDarkMode = WebDarkMode.On;  @State access: boolean = true;  build() {    Column() {      Web({ src: 'www.example.com', controller: this.controller })        .darkMode(this.mode)        .forceDarkAccess(this.access)    }  }}    上一篇 设置基本属性和事件 下一篇 上传文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤无着色器绘制2D图形着色器绘制彩色三角形WebGL开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 场景介绍WebGL主要帮助开发者在前端开发中完成图形图像的相关处理，比如绘制彩色图形等。 
说明
目前该功能仅支持使用兼容JS的类Web开发范式开发。 
  接口说明表1 WebGL主要接口列表 接口名  描述    canvas.getContext  获取canvas对象上下文。   webgl.createBuffer(): WebGLBuffer | null  创建与初始化WebGL数据缓冲区。   webgl.bindBuffer(target: GLenum, buffer: WebGLBuffer | null): void  将WebGL数据缓冲区与目标进行绑定。   webgl.bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length?: GLuint): void  创建并初始化WebGL的数据存储区。   webgl.getAttribLocation(program: WebGLProgram, name: string): GLint  从给定WebGL着色程序中获取着色器中attribute变量的地址。   webgl.vertexAttribPointer(index GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void  将缓冲区对象分配给变量。   webgl.enableVertexAttribArray(index: GLuint): void  连接变量与分配给它的缓冲区对象。   webgl.clearColor(red: GLclampf, green:GLclampf, blue: GLclampf, alpha: GLclampf): void  清空<canvas>指定的颜色。   webgl.clear(mask: GLbitfield): void  清空<canvas>。   webgl.drawArrays(mode: GLenum, first:;GLint, count: GLsizei): void  执行数据绘制。   webgl.flush(): void  刷新数据至GPU，清空缓冲区。   webgl.createProgram(): WebGLProgram | null  创建着色器程序对象。      开发步骤以下分别展示无着色器绘制2D图形和着色器绘制彩色三角形的两个场景示例及开发过程。 
说明
使用WebGL开发时，为保证界面图形显示效果，请使用真机运行。 
  无着色器绘制2D图形此场景为未使用WebGL绘制的2D图形（CPU绘制非GPU绘制）。开发示例如下： 创建页面布局。index.hml示例如下： 已复制<div class="container">    <canvas ref="canvas1" style="width : 400px; height : 200px; background-color : lightyellow;"></canvas>    <button class="btn-button" onclick="BtnDraw2D">BtnDraw2D</button></div> 设置页面样式。index.css示例如下： 已复制.container {    flex-direction: column;    justify-content: center;    align-items: center;}.btn-button {    margin: 1px;    height: 40px;    width: 220px;    background-color: lightblue;    font-size: 20px;    text-color: blue;} 编辑JavaScript代码文件，增加2D绘制逻辑代码。index.js示例如下： 已复制// index.jsexport default {//NAPI交互代码    data: {        title: "DEMO BY TEAMOL",        fit:"cover",        fits: ["cover", "contain", "fill", "none", "scale-down"]    },    onInit() {        this.title = this.$t('strings.world');    },    BtnDraw2D(){        // 获取canvas元素        const canvas = this.$refs.canvas1;        // 获取2D上下文        const ctx = canvas.getContext('2d');
        // 执行CPU绘制函数        // Set line width        ctx.lineWidth = 10;        // Wall        ctx.strokeRect(75, 140, 150, 110);        // Door        ctx.fillRect(130, 190, 40, 60);        // Roof        ctx.beginPath();        ctx.moveTo(50, 140);        ctx.lineTo(150, 60);        ctx.lineTo(250, 140);        ctx.closePath();        ctx.stroke();    }}  图1 点击按钮绘制2D图形的效果图   着色器绘制彩色三角形此场景为使用WebGL绘制的彩色三角形图形（GPU绘制）。开发示例如下： 创建页面布局。index.hml示例如下： 已复制<div class="container"><canvas ref="canvas1" style="width : 400px; height : 200px; background-color : lightyellow;"></canvas><button class="btn-button" onclick="BtnColorTriangle">BtnColorTriangle</button></div> 设置页面样式。index.css示例如下： 已复制.container {    flex-direction: column;    justify-content: center;    align-items: center;}.btn-button {    margin: 1px;    height: 40px;    width: 220px;    background-color: lightblue;    font-size: 20px;    text-color: blue;} 编辑JavaScript代码文件，增加彩色三角形绘制逻辑代码。index.js示例如下： 已复制// index.js
// WebGL相关预定义var gl = {    DEPTH_BUFFER_BIT: 0x00000100,    STENCIL_BUFFER_BIT: 0x00000400,    COLOR_BUFFER_BIT: 0x00004000,    POINTS: 0x0000,    LINES: 0x0001,    LINE_LOOP: 0x0002,    LINE_STRIP: 0x0003,    TRIANGLES: 0x0004,    TRIANGLE_STRIP: 0x0005,    TRIANGLE_FAN: 0x0006,    ZERO: 0,    ONE: 1,    SRC_COLOR: 0x0300,    ONE_MINUS_SRC_COLOR: 0x0301,    SRC_ALPHA: 0x0302,    ONE_MINUS_SRC_ALPHA: 0x0303,    DST_ALPHA: 0x0304,    ONE_MINUS_DST_ALPHA: 0x0305,    DST_COLOR: 0x0306,    ONE_MINUS_DST_COLOR: 0x0307,    SRC_ALPHA_SATURATE: 0x0308,    FUNC_ADD: 0x8006,    BLEND_EQUATION: 0x8009,    BLEND_EQUATION_RGB: 0x8009,    BLEND_EQUATION_ALPHA: 0x883D,    FUNC_SUBTRACT: 0x800A,    FUNC_REVERSE_SUBTRACT: 0x800B,    BLEND_DST_RGB: 0x80C8,    BLEND_SRC_RGB: 0x80C9,    BLEND_DST_ALPHA: 0x80CA,    BLEND_SRC_ALPHA: 0x80CB,    CONSTANT_COLOR: 0x8001,    ONE_MINUS_CONSTANT_COLOR: 0x8002,    CONSTANT_ALPHA: 0x8003,    ONE_MINUS_CONSTANT_ALPHA: 0x8004,    BLEND_COLOR: 0x8005,    ARRAY_BUFFER: 0x8892,    ELEMENT_ARRAY_BUFFER: 0x8893,    ARRAY_BUFFER_BINDING: 0x8894,    ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,    STREAM_DRAW: 0x88E0,    STATIC_DRAW: 0x88E4,    DYNAMIC_DRAW: 0x88E8,    BUFFER_SIZE: 0x8764,    BUFFER_USAGE: 0x8765,    CURRENT_VERTEX_ATTRIB: 0x8626,    FRONT: 0x0404,    BACK: 0x0405,    FRONT_AND_BACK: 0x0408,    CULL_FACE: 0x0B44,    BLEND: 0x0BE2,    DITHER: 0x0BD0,    STENCIL_TEST: 0x0B90,    DEPTH_TEST: 0x0B71,    SCISSOR_TEST: 0x0C11,    POLYGON_OFFSET_FILL: 0x8037,    SAMPLE_ALPHA_TO_COVERAGE: 0x809E,    SAMPLE_COVERAGE: 0x80A0,    NO_ERROR: 0,    INVALID_ENUM: 0x0500,    INVALID_VALUE: 0x0501,    INVALID_OPERATION: 0x0502,    OUT_OF_MEMORY: 0x0505,    CW: 0x0900,    CCW: 0x0901,    LINE_WIDTH: 0x0B21,    ALIASED_POINT_SIZE_RANGE: 0x846D,    ALIASED_LINE_WIDTH_RANGE: 0x846E,    CULL_FACE_MODE: 0x0B45,    FRONT_FACE: 0x0B46,    DEPTH_RANGE: 0x0B70,    DEPTH_WRITEMASK: 0x0B72,    DEPTH_CLEAR_VALUE: 0x0B73,    DEPTH_FUNC: 0x0B74,    STENCIL_CLEAR_VALUE: 0x0B91,    STENCIL_FUNC: 0x0B92,    STENCIL_FAIL: 0x0B94,    STENCIL_PASS_DEPTH_FAIL: 0x0B95,    STENCIL_PASS_DEPTH_PASS: 0x0B96,    STENCIL_REF: 0x0B97,    STENCIL_VALUE_MASK: 0x0B93,    STENCIL_WRITEMASK: 0x0B98,    STENCIL_BACK_FUNC: 0x8800,    STENCIL_BACK_FAIL: 0x8801,    STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,    STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,    STENCIL_BACK_REF: 0x8CA3,    STENCIL_BACK_VALUE_MASK: 0x8CA4,    STENCIL_BACK_WRITEMASK: 0x8CA5,    VIEWPORT: 0x0BA2,    SCISSOR_BOX: 0x0C10,    COLOR_CLEAR_VALUE: 0x0C22,    COLOR_WRITEMASK: 0x0C23,    UNPACK_ALIGNMENT: 0x0CF5,    PACK_ALIGNMENT: 0x0D05,    MAX_TEXTURE_SIZE: 0x0D33,    MAX_VIEWPORT_DIMS: 0x0D3A,    SUBPIXEL_BITS: 0x0D50,    RED_BITS: 0x0D52,    GREEN_BITS: 0x0D53,    BLUE_BITS: 0x0D54,    ALPHA_BITS: 0x0D55,    DEPTH_BITS: 0x0D56,    STENCIL_BITS: 0x0D57,    POLYGON_OFFSET_UNITS: 0x2A00,    POLYGON_OFFSET_FACTOR: 0x8038,    TEXTURE_BINDING_2D: 0x8069,    SAMPLE_BUFFERS: 0x80A8,    SAMPLES: 0x80A9,    RGBA8: 0x8058,    SAMPLE_COVERAGE_VALUE: 0x80AA,    SAMPLE_COVERAGE_INVERT: 0x80AB,    COMPRESSED_TEXTURE_FORMATS: 0x86A3,    DONT_CARE: 0x1100,    FASTEST: 0x1101,    NICEST: 0x1102,    GENERATE_MIPMAP_HINT: 0x8192,    BYTE: 0x1400,    UNSIGNED_BYTE: 0x1401,    SHORT: 0x1402,    UNSIGNED_SHORT: 0x1403,    INT: 0x1404,    UNSIGNED_INT: 0x1405,    FLOAT: 0x1406,    DEPTH_COMPONENT: 0x1902,    ALPHA: 0x1906,    RGB: 0x1907,    RGBA: 0x1908,    LUMINANCE: 0x1909,    LUMINANCE_ALPHA: 0x190A,    UNSIGNED_SHORT_4_4_4_4: 0x8033,    UNSIGNED_SHORT_5_5_5_1: 0x8034,    UNSIGNED_SHORT_5_6_5: 0x8363,    FRAGMENT_SHADER: 0x8B30,    VERTEX_SHADER: 0x8B31,    MAX_VERTEX_ATTRIBS: 0x8869,    MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,    MAX_VARYING_VECTORS: 0x8DFC,    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,    MAX_TEXTURE_IMAGE_UNITS: 0x8872,    MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,    SHADER_TYPE: 0x8B4F,    DELETE_STATUS: 0x8B80,    LINK_STATUS: 0x8B82,    VALIDATE_STATUS: 0x8B83,    ATTACHED_SHADERS: 0x8B85,    ACTIVE_UNIFORMS: 0x8B86,    ACTIVE_ATTRIBUTES: 0x8B89,    SHADING_LANGUAGE_VERSION: 0x8B8C,    CURRENT_PROGRAM: 0x8B8D,    NEVER: 0x0200,    LESS: 0x0201,    EQUAL: 0x0202,    LEQUAL: 0x0203,    GREATER: 0x0204,    NOTEQUAL: 0x0205,    GEQUAL: 0x0206,    ALWAYS: 0x0207,    KEEP: 0x1E00,    REPLACE: 0x1E01,    INCR: 0x1E02,    DECR: 0x1E03,    INVERT: 0x150A,    INCR_WRAP: 0x8507,    DECR_WRAP: 0x8508,    VENDOR: 0x1F00,    RENDERER: 0x1F01,    VERSION: 0x1F02,    NEAREST: 0x2600,    LINEAR: 0x2601,    NEAREST_MIPMAP_NEAREST: 0x2700,    LINEAR_MIPMAP_NEAREST: 0x2701,    NEAREST_MIPMAP_LINEAR: 0x2702,    LINEAR_MIPMAP_LINEAR: 0x2703,    TEXTURE_MAG_FILTER: 0x2800,    TEXTURE_MIN_FILTER: 0x2801,    TEXTURE_WRAP_S: 0x2802,    TEXTURE_WRAP_T: 0x2803,    TEXTURE_2D: 0x0DE1,    TEXTURE: 0x1702,    TEXTURE_CUBE_MAP: 0x8513,    TEXTURE_BINDING_CUBE_MAP: 0x8514,    TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,    TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,    TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,    TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,    TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,    TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,    MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,    TEXTURE0: 0x84C0,    TEXTURE1: 0x84C1,    TEXTURE2: 0x84C2,    TEXTURE3: 0x84C3,    TEXTURE4: 0x84C4,    TEXTURE5: 0x84C5,    TEXTURE6: 0x84C6,    TEXTURE7: 0x84C7,    TEXTURE8: 0x84C8,    TEXTURE9: 0x84C9,    TEXTURE10: 0x84CA,    TEXTURE11: 0x84CB,    TEXTURE12: 0x84CC,    TEXTURE13: 0x84CD,    TEXTURE14: 0x84CE,    TEXTURE15: 0x84CF,    TEXTURE16: 0x84D0,    TEXTURE17: 0x84D1,    TEXTURE18: 0x84D2,    TEXTURE19: 0x84D3,    TEXTURE20: 0x84D4,    TEXTURE21: 0x84D5,    TEXTURE22: 0x84D6,    TEXTURE23: 0x84D7,    TEXTURE24: 0x84D8,    TEXTURE25: 0x84D9,    TEXTURE26: 0x84DA,    TEXTURE27: 0x84DB,    TEXTURE28: 0x84DC,    TEXTURE29: 0x84DD,    TEXTURE30: 0x84DE,    TEXTURE31: 0x84DF,    ACTIVE_TEXTURE: 0x84E0,    REPEAT: 0x2901,    CLAMP_TO_EDGE: 0x812F,    MIRRORED_REPEAT: 0x8370,    FLOAT_VEC2: 0x8B50,    FLOAT_VEC3: 0x8B51,    FLOAT_VEC4: 0x8B52,    INT_VEC2: 0x8B53,    INT_VEC3: 0x8B54,    INT_VEC4: 0x8B55,    BOOL: 0x8B56,    BOOL_VEC2: 0x8B57,    BOOL_VEC3: 0x8B58,    BOOL_VEC4: 0x8B59,    FLOAT_MAT2: 0x8B5A,    FLOAT_MAT3: 0x8B5B,    FLOAT_MAT4: 0x8B5C,    SAMPLER_2D: 0x8B5E,    SAMPLER_CUBE: 0x8B60,    VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,    VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,    VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,    VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,    VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,    VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,    IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,    IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,    COMPILE_STATUS: 0x8B81,    LOW_FLOAT: 0x8DF0,    MEDIUM_FLOAT: 0x8DF1,    HIGH_FLOAT: 0x8DF2,    LOW_INT: 0x8DF3,    MEDIUM_INT: 0x8DF4,    HIGH_INT: 0x8DF5,    FRAMEBUFFER: 0x8D40,    RENDERBUFFER: 0x8D41,    RGBA4: 0x8056,    RGB5_A1: 0x8057,    RGB565: 0x8D62,    DEPTH_COMPONENT16: 0x81A5,    STENCIL_INDEX8: 0x8D48,    DEPTH_STENCIL: 0x84F9,    RENDERBUFFER_WIDTH: 0x8D42,    RENDERBUFFER_HEIGHT: 0x8D43,    RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,    RENDERBUFFER_RED_SIZE: 0x8D50,    RENDERBUFFER_GREEN_SIZE: 0x8D51,    RENDERBUFFER_BLUE_SIZE: 0x8D52,    RENDERBUFFER_ALPHA_SIZE: 0x8D53,    RENDERBUFFER_DEPTH_SIZE: 0x8D54,    RENDERBUFFER_STENCIL_SIZE: 0x8D55,    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,    COLOR_ATTACHMENT0: 0x8CE0,    DEPTH_ATTACHMENT: 0x8D00,    STENCIL_ATTACHMENT: 0x8D20,    DEPTH_STENCIL_ATTACHMENT: 0x821A,    NONE: 0,    FRAMEBUFFER_COMPLETE: 0x8CD5,    FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,    FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,    FRAMEBUFFER_UNSUPPORTED: 0x8CDD,    FRAMEBUFFER_BINDING: 0x8CA6,    RENDERBUFFER_BINDING: 0x8CA7,    MAX_RENDERBUFFER_SIZE: 0x84E8,    INVALID_FRAMEBUFFER_OPERATION: 0x0506,    UNPACK_FLIP_Y_WEBGL: 0x9240,    UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,    CONTEXT_LOST_WEBGL: 0x9242,    UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,    BROWSER_DEFAULT_WEBGL: 0x9244,    TEXTURE_MAX_LOD: 0x813B,    TEXTURE_BASE_LEVEL: 0x813C,    TEXTURE_IMMUTABLE_FORMAT: 0x912F,    UNIFORM_BLOCK_BINDING: 0x8A3F,    UNIFORM_BLOCK_DATA_SIZE: 0x8A40,    UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42,    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43,    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44,    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46,    RED: 0x1903,    PIXEL_UNPACK_BUFFER: 0x88EC,    RGB8: 0x8051,    R16F: 0x822D,    COPY_WRITE_BUFFER: 0x8F37,    TEXTURE_3D: 0x806F,    COMPRESSED_R11_EAC: 0x9270,    COPY_READ_BUFFER: 0x8F36,    TRANSFORM_FEEDBACK_BUFFER: 0x8C8E,    TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F,    TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85,    TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,    UNIFORM_BUFFER_BINDING: 0x8A28,    UNIFORM_BUFFER_SIZE: 0x8A2A,    UNIFORM_BUFFER_START: 0x8A29,    DYNAMIC_READ: 0x88E9,    READ_FRAMEBUFFER: 0x8CA8,    COLOR_ATTACHMENT1: 0x8CE1,    INTERLEAVED_ATTRIBS: 0x8C8C,    UNIFORM_OFFSET: 0x8A3B,    UNIFORM_TYPE: 0x8A37,    UNIFORM_SIZE: 0x8A38,    UNIFORM_BLOCK_INDEX: 0x8A3A,    UNIFORM_ARRAY_STRIDE: 0x8A3C,    UNIFORM_MATRIX_STRIDE: 0x8A3D,    UNIFORM_IS_ROW_MAJOR: 0x8A3E,    TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE}
// 顶点着色器程序var VSHADER_SOURCE =    'attribute vec4 a_Position;\n' + // attribute variable    'attribute vec4 a_Color;\n' +    'varying vec4 v_Color;\n' +    'void main() {\n' +    '  gl_Position = a_Position;\n' + // Set the vertex coordinates of the point    '  v_Color = a_Color;\n' +    '}\n';
// 片元着色器程序var FSHADER_SOURCE =    'precision mediump float;\n' +    'varying vec4 v_Color;\n' +    'void main() {\n' +    '  gl_FragColor = v_Color;\n' +    '}\n';
function initVertexBuffers(gl) {    // 顶点坐标和颜色    var verticesColors = new Float32Array([        0.0, -0.5, 1.0, 0.0, 0.0,        -0.5, -0.8, 0.0, 1.0, 0.0,        0.5, -0.8, 0.0, 0.0, 1.0,    ]);
    var n = 3; // 点的个数    var FSIZE = verticesColors.BYTES_PER_ELEMENT; //数组中每个元素的字节数
    // 创建缓冲区对象    var vertexBuffer = gl.createBuffer();    if (!vertexBuffer) {        console.log('Failed to create the buffer object');        return -1;    }
    // 将缓冲区对象绑定到目标    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);    // 向缓冲区对象写入数据    gl.bufferData(gl.ARRAY_BUFFER, verticesColors.buffer, gl.STATIC_DRAW);
    // 获取着色器中attribute变量a_Position的地址    var a_Position = gl.getAttribLocation(gl.program, 'a_Position');    if (a_Position < 0) {        console.log('Failed to get the storage location of a_Position');        return -1;    }    // 将缓冲区对象分配给a_Position变量    gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 5 * FSIZE, 0);
    // 连接a_Position变量与分配给它的缓冲区对象    gl.enableVertexAttribArray(a_Position);
    // 获取着色器中attribute变量a_Color的地址    var a_Color = gl.getAttribLocation(gl.program, 'a_Color');    if (a_Color < 0) {        console.log('Failed to get the storage location of a_Color');        return -1;    }    // 将缓冲区对象分配给a_Color变量    gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 5, FSIZE * 2);
    // 连接a_Color变量与分配给它的缓冲区对象    gl.enableVertexAttribArray(a_Color);
    // 解除绑定    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return n;}
/** * 创建并使能一个program对象 * @param gl 表示 WebGL上下文对 * @param vshader 表示顶点着色器 * @param fshader 表示片段着色器 * @return 如果WebGLProgram对象被创建并成功作为当前对象，则返回true；否则返回false  */function initShaders(gl, vshader, fshader) {    var program = createProgram(gl, vshader, fshader);    console.log("======createProgram program: " + program);    if (!program) {        console.log('Failed to create program');        return false;    }    gl.useProgram(program);    gl.program = program;    return true;}/** * 创建一个linked program对象 * @param gl 表示 WebGL上下文对象 * @param vshader 表示顶点着色器 * @param fshader 表示片段着色器 * @return 如果创建program成功，则返回创建的program；否则返回null */function createProgram(gl, vshader, fshader) {    console.log("======createProgram start======");    // 创建shader对象    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);    console.log("======vertexShader: " + vertexShader);    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);    if (!vertexShader || !fragmentShader) {        return null;    }    // 创建program对象    var program = gl.createProgram();    console.log("======createProgram program: " + program);    if (!program) {        return null;    }    // 将着色器附加到对象    gl.attachShader(program, vertexShader);    gl.attachShader(program, fragmentShader);    // 连接程序对象    gl.linkProgram(program);    // 检查连接对象的结果    var linked = gl.getProgramParameter(program, 0x8B82);    console.log("======getProgramParameter linked: " + linked);    if (!linked) {        var error = gl.getProgramInfoLog(program);        console.log('Failed to link the program: ' + error);        gl.deleteProgram(program);        gl.deleteShader(fragmentShader);        gl.deleteShader(vertexShader);        return null;    }    return program;}/**  * 创建一个shader对象  * @param gl 表示 WebGL上下文对象  * @param type 表示shader类型  * @param source 表示shader的源码   * @return 如果操作成功，返回创建的着色器对象；否则返回false  */ function loadShader(gl, type, source) {    console.log("======into loadShader====");    // 创建shader对象    var shader = gl.createShader(type);    if (shader == null) {        console.log('Failed to create the shader.');        return null;    }
    // 设置shader program    gl.shaderSource(shader, source);
    // 编译shader    gl.compileShader(shader);
    // 检查shader编译结果    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);    if (!compiled) {        var error = gl.getShaderInfoLog(shader);        console.log('Failed to compile the shader: ' + error);        gl.deleteShader(shader);        return null;    }    return shader;}export default {    data: {        title: "DEMO BY TEAMOL",        fit:"cover",        fits: ["cover", "contain", "fill", "none", "scale-down"]    }    ,onInit() {        this.title = this.$t('strings.world');    }    ,BtnColorTriangle() {        // 获取canvas元素        const el = this.$refs.canvas1;        // 获取webgl上下文        var gl = el.getContext('webgl');
        if (!gl) {            console.log('Failed to get the rendering context for WebGL');            return;        }
        // 初始化着色器        if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {            console.log('Failed to initialize shaders.');            return;        }
        // 设置顶点位置        var n = initVertexBuffers(gl);        if (n < 0) {            console.log('Failed to set the positions of the vertices');            return;        }
        // 指定清空<canvas>的颜色        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        // 清空<canvas>        gl.clear(gl.COLOR_BUFFER_BIT);
        // 绘制三角形        gl.drawArrays(gl.TRIANGLES, 0, n);
        // 清buffer        gl.flush();    }}  图2 点击按钮绘制彩色三角形的效果图    上一篇 概述 下一篇 媒体 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念着色器缓冲区着色器程序运作机制概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 WebGL的全称为Web Graphic Library(网页图形库)，主要用于交互式渲染2D图形和3D图形。目前HarmonyOS中使用的WebGL是基于OpenGL裁剪的OpenGL ES，可以在HTML5的canvas元素对象中使用，无需使用插件，支持跨平台。WebGL程序是由JavaScript代码组成的，其中使用的API可以利用用户设备提供的GPU硬件完成图形渲染和加速。更多信息请参考WebGL™标准。 基本概念 着色器可以理解为运行在显卡中的指令和数据。在WebGL中，着色器是用OpenGL ES着色语言(GLSL)编写的。 完整的着色器包括顶点着色器和片元着色器。顶点着色器和片元着色器的交互则涉及到图片光栅化。 顶点着色器：最基本的任务是接收三维空间中点的坐标，将其处理为二维空间中的坐标并输出。 片元着色器：最基本的任务是对需要处理的屏幕上的每个像素输出一个颜色值。 图片光栅化：将顶点着色器输出的二维空间中的点坐标，转化为需要处理的像素并传递给片元着色器的过程。   缓冲区驻存于内存中的JavaScript对象，存储着即将推送到着色器中的attribute对象。  着色器程序将缓冲区中的数据推送到着色器中还需涉及“着色器程序”，一个负责关联着色器和缓冲区的JavaScript对象。一个WebGLProgram 对象由两个编译过后的 WebGLShader 组成，即顶点着色器和片段着色器（均由 GLSL 语言所写）。  运作机制图1 WebGL运作机制  应用前端HTML5绘制界面组件。 Native API完成前端JavaScript与C++代码交互。 JavaScript engine为图形框架，为WebGL模块提供绘制对象Surface。 WebGL模块对外暴露OpenGL ES的GPU绘制接口。 中间接口层EGL（Embedded Graphics Library）完成不同平台的适配。    上一篇 WebGL 下一篇 WebGL开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤WebSocket连接 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 场景介绍使用WebSocket建立服务器与客户端的双向连接，需要先通过createWebSocket()方法创建WebSocket对象，然后通过connect()方法连接到服务器。当连接成功后，客户端会收到open事件的回调，之后客户端就可以通过send()方法与服务器进行通信。当服务器发信息给客户端时，客户端会收到message事件的回调。当客户端不要此连接时，可以通过调用close()方法主动断开连接，之后客户端会收到close事件的回调。 若在上述任一过程中发生错误，客户端会收到error事件的回调。  接口说明WebSocket连接功能主要由webSocket模块提供。使用该功能需要申请ohos.permission.INTERNET权限。具体接口说明如下表。 接口名  功能描述    createWebSocket()  创建一个WebSocket连接。   connect()  根据URL地址，建立一个WebSocket连接。   send()  通过WebSocket连接发送数据。   close()  关闭WebSocket连接。   on(type: 'open')  订阅WebSocket的打开事件。   off(type: 'open')  取消订阅WebSocket的打开事件。   on(type: 'message')  订阅WebSocket的接收到服务器消息事件。   off(type: 'message')  取消订阅WebSocket的接收到服务器消息事件。   on(type: 'close')  订阅WebSocket的关闭事件。   off(type: 'close')  取消订阅WebSocket的关闭事件   on(type: 'error')  订阅WebSocket的Error事件。   off(type: 'error')  取消订阅WebSocket的Error事件。      开发步骤导入需要的webSocket模块。 创建一个WebSocket连接，返回一个WebSocket对象。 （可选）订阅WebSocket的打开、消息接收、关闭、Error事件。 根据URL地址，发起WebSocket连接。 使用完WebSocket连接之后，主动断开连接。 已复制import webSocket from '@ohos.net.webSocket';
var defaultIpAddress = "ws://";let ws = webSocket.createWebSocket();ws.on('open', (err, value) => {    console.log("on open, status:" + JSON.stringify(value));    // 当收到on('open')事件时，可以通过send()方法与服务器进行通信    ws.send("Hello, server!", (err, value) => {        if (!err) {            console.log("Message sent successfully");        } else {            console.log("Failed to send the message. Err:" + JSON.stringify(err));        }    });});ws.on('message', (err, value) => {    console.log("on message, message:" + value);    // 当收到服务器的`bye`消息时（此消息字段仅为示意，具体字段需要与服务器协商），主动断开连接    if (value === 'bye') {        ws.close((err, value) => {            if (!err) {                console.log("Connection closed successfully");            } else {                console.log("Failed to close the connection. Err: " + JSON.stringify(err));            }        });    }});ws.on('close', (err, value) => {    console.log("on close, code is " + value.code + ", reason is " + value.reason);});ws.on('error', (err) => {    console.log("on error, error:" + JSON.stringify(err));});ws.connect(defaultIpAddress, (err, value) => {    if (!err) {        console.log("Connected successfully");    } else {        console.log("Connection failed. Err:" + JSON.stringify(err));    }});    上一篇 HTTP数据请求 下一篇 Socket连接 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片概述运作机制接口说明开发步骤实现卡片生命周期接口配置卡片配置文件卡片信息的持久化卡片数据交互开发卡片页面开发卡片事件服务卡片开发指导（FA模型） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   卡片概述 服务卡片（以下简称“卡片”）是一种界面展示形式，可以将应用的重要信息或操作前置到卡片，以达到服务直达、减少体验层级的目的。 卡片常用于嵌入到其他应用（当前只支持系统应用）中作为其界面的一部分显示，并支持拉起页面、发送消息等基础的交互功能。 卡片的基本概念：  卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。 卡片管理服务：用于管理系统中所添加卡片的常驻代理服务，包括卡片对象的管理与使用，以及卡片周期性刷新等。 卡片提供方：提供卡片显示内容元服务，控制卡片的显示内容、控件布局以及控件点击事件。    运作机制 卡片框架的运作机制如图1所示。 图1 卡片框架运作机制（FA模型）  卡片使用方包含以下模块：  卡片使用：包含卡片的创建、删除、请求更新等操作。 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作到卡片管理服务。  卡片管理服务包含以下模块：  周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。 通信适配层：负责与卡片使用方和提供方进行RPC通信。  卡片提供方包含以下模块：  卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。 通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。  
说明
 实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。 
   接口说明 FormAbility生命周期接口如下：     接口名 描述    onCreate(want: Want): formBindingData.FormBindingData 卡片提供方接收创建卡片的通知接口。   onCastToNormal(formId: string): void 卡片提供方接收临时卡片转常态卡片的通知接口   onUpdate(formId: string): void 卡片提供方接收更新卡片的通知接口。   onVisibilityChange(newStatus: { [key: string]: number }): void 卡片提供方接收修改可见性的通知接口。   onEvent(formId: string, message: string): void 卡片提供方接收处理卡片事件的通知接口。   onDestroy(formId: string): void 卡片提供方接收销毁卡片的通知接口。   onAcquireFormState?(want: Want): formInfo.FormState 卡片提供方接收查询卡片状态的通知接口。   onShare?(formId: string): {[key: string]: any} 卡片提供方接收卡片分享的通知接口。    FormProvider类有如下API接口，具体的API介绍详见接口文档。     接口名 描述    setFormNextRefreshTime(formId: string, minute: number, callback: AsyncCallback<void>): void; 设置指定卡片的下一次更新时间。   setFormNextRefreshTime(formId: string, minute: number): Promise<void>; 设置指定卡片的下一次更新时间，以promise方式返回。   updateForm(formId: string, formBindingData: FormBindingData, callback: AsyncCallback<void>): void; 更新指定的卡片。   updateForm(formId: string, formBindingData: FormBindingData): Promise<void>; 更新指定的卡片，以promise方式返回。    formBindingData类有如下API接口，具体的API介绍详见接口文档。     接口名 描述    createFormBindingData(obj?: Object | string): FormBindingData 创建一个FormBindingData对象。      开发步骤 FA卡片开发，即基于FA模型的卡片提供方开发，主要涉及如下关键步骤：  实现卡片生命周期接口：开发FormAbility生命周期回调函数。 配置卡片配置文件：配置应用配置文件config.json。 卡片信息的持久化：对卡片信息进行持久化管理。 卡片数据交互：通过updateForm()更新卡片显示的信息。 开发卡片页面：使用HML+CSS+JSON开发JS卡片页面。 开发卡片事件：为卡片添加router事件和message事件。    实现卡片生命周期接口 创建FA模型的卡片，需实现卡片的生命周期接口。先参考IDE开发服务卡片指南生成服务卡片模板。  在form.ts中，导入相关模块 已复制import formBindingData from '@ohos.app.form.formBindingData';import formInfo from '@ohos.app.form.formInfo';import formProvider from '@ohos.app.form.formProvider';import dataStorage from '@ohos.data.storage'; 在form.ts中，实现卡片生命周期接口 已复制export default {    onCreate(want) {        console.info('FormAbility onCreate');        // 使用方创建卡片时触发，提供方需要返回卡片数据绑定类        let obj = {            "title": "titleOnCreate",            "detail": "detailOnCreate"        };        let formData = formBindingData.createFormBindingData(obj);        return formData;    },    onCastToNormal(formId) {        // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理        console.info('FormAbility onCastToNormal');    },    onUpdate(formId) {        // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新        console.info('FormAbility onUpdate');        let obj = {            "title": "titleOnUpdate",            "detail": "detailOnUpdate"        };        let formData = formBindingData.createFormBindingData(obj);        formProvider.updateForm(formId, formData).catch((error) => {            console.info('FormAbility updateForm, error:' + JSON.stringify(error));        });    },    onVisibilityChange(newStatus) {        // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，仅系统应用生效        console.info('FormAbility onVisibilityChange');    },    onEvent(formId, message) {        // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发        console.info('FormAbility onEvent');    },    onDestroy(formId) {        // 删除卡片实例数据        console.info('FormAbility onDestroy');    },    onAcquireFormState(want) {        console.info('FormAbility onAcquireFormState');        return formInfo.FormState.READY;    },}  
说明
 FormAbility不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务。 
   配置卡片配置文件 卡片需要在应用配置文件config.json中进行配置。  js模块，用于对应卡片的js相关资源，内部字段结构说明：     属性名称 含义 数据类型 是否可缺省    name 表示JS Component的名字。该标签不可缺省，默认值为default。 字符串 否   pages 表示JS Component的页面用于列举JS Component中每个页面的路由信息[页面路径+页面名称]。该标签不可缺省，取值为数组，数组第一个元素代表JS FA首页。 数组 否   window 用于定义与显示窗口相关的配置。 对象 可缺省   type 表示JS应用的类型。取值范围如下： normal：标识该JS Component为应用实例。 form：标识该JS Component为卡片实例。 字符串 可缺省，缺省值为“normal”   mode 定义JS组件的开发模式。 对象 可缺省，缺省值为空    配置示例如下： 已复制   "js": [{       "name": "widget",       "pages": ["pages/index/index"],       "window": {           "designWidth": 720,           "autoDesignWidth": true       },       "type": "form"   }] abilities模块，用于对应卡片的FormAbility，内部字段结构说明：     属性名称 含义 数据类型 是否可缺省    name 表示卡片的类名。字符串最大长度为127字节。 字符串 否   description 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。   isDefault 表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。 true：默认卡片。 false：非默认卡片。 布尔值 否   type 表示卡片的类型。取值范围如下： JS：JS卡片。 字符串 否   colorMode 表示卡片的主题样式，取值范围如下： auto：自适应。 dark：深色主题。 light：浅色主题。 字符串 可缺省，缺省值为“auto”。   supportDimensions 表示卡片支持的外观规格，取值范围： 1 * 2：表示1行2列的二宫格。 2 * 2：表示2行2列的四宫格。 2 * 4：表示2行4列的八宫格。 4 * 4：表示4行4列的十六宫格。 字符串数组 否   defaultDimension 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否   updateEnabled 表示卡片是否支持周期性刷新，取值范围： true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。 false：表示不支持周期性刷新。 布尔类型 否   scheduledUpdateTime 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 字符串 可缺省，缺省值为“0:0”。   updateDuration 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。 当取值为0时，表示该参数不生效。 当取值为正整数N时，表示刷新周期为30*N分钟。 updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 数值 可缺省，缺省值为“0”。   formConfigAbility 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。   formVisibleNotify 标识是否允许卡片使用卡片可见性通知。 字符串 可缺省，缺省值为空。   jsComponentName 表示JS卡片的Component名称。字符串最大长度为127字节。 字符串 否   metaData 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。   customizeData 表示自定义的卡片信息。 对象数组 可缺省，缺省值为空。    配置示例如下： 已复制   "abilities": [{       "name": "FormAbility",       "description": "This is a FormAbility",       "formsEnabled": true,       "icon": "$media:icon",       "label": "$string:form_FormAbility_label",       "srcPath": "FormAbility",       "type": "service",       "srcLanguage": "ets",       "formsEnabled": true,       "formConfigAbility": "ability://com.example.entry.MainAbility",       "forms": [{           "colorMode": "auto",           "defaultDimension": "2*2",           "description": "This is a service widget.",           "formVisibleNotify": true,           "isDefault": true,           "jsComponentName": "widget",           "name": "widget",           "scheduledUpdateTime": "10:30",           "supportDimensions": ["2*2"],           "type": "JS",           "updateEnabled": true       }]   }]    卡片信息的持久化 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息，且卡片管理服务支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。 已复制const DATA_STORAGE_PATH = "/data/storage/el2/base/haps/form_store";async function storeFormInfo(formId: string, formName: string, tempFlag: boolean) {    // 此处仅对卡片ID：formId，卡片名：formName和是否为临时卡片：tempFlag进行了持久化    let formInfo = {        "formName": formName,        "tempFlag": tempFlag,        "updateCount": 0    };    try {        const storage = await dataStorage.getStorage(DATA_STORAGE_PATH);        // put form info        await storage.put(formId, JSON.stringify(formInfo));        console.info(`storeFormInfo, put form info successfully, formId: ${formId}`);        await storage.flush();    } catch (err) {        console.error(`failed to storeFormInfo, err: ${JSON.stringify(err)}`);    }}
// ...    onCreate(want) {        console.info('FormAbility onCreate');
        let formId = want.parameters["ohos.extra.param.key.form_identity"];        let formName = want.parameters["ohos.extra.param.key.form_name"];        let tempFlag = want.parameters["ohos.extra.param.key.form_temporary"];        // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用        // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例        storeFormInfo(formId, formName, tempFlag);
        let obj = {            "title": "titleOnCreate",            "detail": "detailOnCreate"        };        let formData = formBindingData.createFormBindingData(obj);        return formData;    }// ... 且需要适配onDestroy卡片删除通知接口，在其中实现卡片实例数据的删除。 已复制const DATA_STORAGE_PATH = "/data/storage/el2/base/haps/form_store";async function deleteFormInfo(formId: string) {    try {        const storage = await dataStorage.getStorage(DATA_STORAGE_PATH);        // del form info        await storage.delete(formId);        console.info(`deleteFormInfo, del form info successfully, formId: ${formId}`);        await storage.flush();    } catch (err) {        console.error(`failed to deleteFormInfo, err: ${JSON.stringify(err)}`);    }}
// ...    onDestroy(formId) {        console.info('FormAbility onDestroy');        // 删除之前持久化的卡片实例数据        // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例        deleteFormInfo(formId);    }// ... 具体的持久化方法可以参考应用数据持久化。 需要注意的是，卡片使用方在请求卡片时传递给提供方应用的Want数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片：  常态卡片：卡片使用方会持久化的卡片； 临时卡片：卡片使用方不会持久化的卡片；  由于临时卡片的数据具有非持久化的特殊性，某些场景例如卡片服务框架死亡重启，此时临时卡片数据在卡片管理服务中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。   卡片数据交互 当卡片应用需要更新数据时（如触发了定时更新或定点更新），卡片应用获取最新数据，并调用updateForm()接口更新主动触发卡片的更新。 已复制onUpdate(formId) {    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新    console.info('FormAbility onUpdate');    let obj = {        "title": "titleOnUpdate",        "detail": "detailOnUpdate"    };    let formData = formBindingData.createFormBindingData(obj);    // 调用updateForm接口去更新对应的卡片，仅更新入参中携带的数据信息，其他信息保持不变    formProvider.updateForm(formId, formData).catch((error) => {        console.info('FormAbility updateForm, error:' + JSON.stringify(error));    });}   开发卡片页面 开发者可以使用类Web范式（HML+CSS+JSON）开发JS卡片页面。生成如下卡片页面，可以这样配置卡片页面文件：  
说明
 当前仅支持JS扩展的类Web开发范式来实现卡片的UI界面。 
  HML：使用类Web范式的组件描述卡片的页面信息。 已复制<div class="container">  <stack>    <div class="container-img">      <image src="/common/widget.png" class="bg-img"></image>    </div>    <div class="container-inner">      <text class="title">{{title}}</text>      <text class="detail_text" onclick="routerEvent">{{detail}}</text>    </div>  </stack></div> CSS：HML中类Web范式组件的样式信息。 已复制.container {  flex-direction: column;  justify-content: center;  align-items: center;}
.bg-img {  flex-shrink: 0;  height: 100%;}
.container-inner {  flex-direction: column;  justify-content: flex-end;  align-items: flex-start;  height: 100%;  width: 100%;  padding: 12px;}
.title {  font-size: 19px;  font-weight: bold;  color: white;  text-overflow: ellipsis;  max-lines: 1;}
.detail_text {  font-size: 16px;  color: white;  opacity: 0.66;  text-overflow: ellipsis;  max-lines: 1;  margin-top: 6px;} JSON：卡片页面中的数据和事件交互。 已复制{  "data": {    "title": "TitleDefault",    "detail": "TextDefault"  },  "actions": {    "routerEvent": {      "action": "router",      "abilityName": "com.example.entry.MainAbility",      "params": {        "message": "add detail"      }    }  }}    开发卡片事件 卡片支持为组件设置交互事件(action)，包括router事件和message事件，其中router事件用于Ability跳转，message事件用于卡片开发人员自定义点击事件。关键步骤说明如下：  在hml中为组件设置onclick属性，其值对应到json文件的actions字段中。 如何设置router事件：  action属性值为"router"； abilityName为跳转目标的Ability名（支持跳转FA模型的PageAbility组件和Stage模型的UIAbility组件），如目前DevEco创建的FA模型的MainAbility默认名为com.example.entry.MainAbility； params为传递给跳转目标Ability的自定义参数，可以按需填写。其值可以在目标Ability启动时的want中的parameters里获取。如FA模型MainAbility的onCreate生命周期里可以通过featureAbility.getWant()获取到want，然后在其parameters字段下获取到配置的参数；  如何设置message事件：  action属性值为"message"； params为message事件的用户自定义参数，可以按需填写。其值可以在卡片生命周期函数onEvent中的message里获取；   示例如下：  hml文件 已复制<div class="container">    <stack>        <div class="container-img">            <image src="/common/widget.png" class="bg-img"></image>        </div>        <div class="container-inner">            <text class="title" onclick="routerEvent">{{title}}</text>            <text class="detail_text" onclick="messageEvent">{{detail}}</text>        </div>    </stack></div> css文件 已复制.container {  flex-direction: column;  justify-content: center;  align-items: center;}
.bg-img {  flex-shrink: 0;  height: 100%;}
.container-inner {  flex-direction: column;  justify-content: flex-end;  align-items: flex-start;  height: 100%;  width: 100%;  padding: 12px;}
.title {  font-size: 19px;  font-weight: bold;  color: white;  text-overflow: ellipsis;  max-lines: 1;}
.detail_text {  font-size: 16px;  color: white;  opacity: 0.66;  text-overflow: ellipsis;  max-lines: 1;  margin-top: 6px;} json文件 已复制{  "data": {    "title": "TitleDefault",    "detail": "TextDefault"  },  "actions": {    "routerEvent": {      "action": "router",      "abilityName": "com.example.entry.MainAbility",      "params": {        "message": "add detail"      }    },    "messageEvent": {      "action": "message",      "params": {        "message": "add detail"      }    }  }}    上一篇 DataAbility权限控制 下一篇 FA模型的Context 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。窗口模块的定义窗口模块的用途基本概念实现原理约束与限制窗口开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 窗口模块的定义窗口模块用于在同一块物理屏幕上，提供多个应用界面显示、交互的机制。 对应用开发者而言，窗口模块提供了界面显示和交互能力。 对终端用户而言，窗口模块提供了控制应用界面的方式。 对整个操作系统而言，窗口模块提供了不同应用界面的组织管理逻辑。   窗口模块的用途在HarmonyOS中，窗口模块主要负责以下职责： 提供应用和系统界面的窗口对象。 应用开发者通过窗口加载UI界面，实现界面显示功能。 组织不同窗口的显示关系，即维护不同窗口间的叠加层次和位置属性。 应用和系统的窗口具有多种类型，不同类型的窗口具有不同的默认位置和叠加层次（Z轴高度）。同时，用户操作也可以在一定范围内对窗口的位置和叠加层次进行调整。 提供窗口动效。 在窗口显示、隐藏及窗口间切换时，窗口模块通常会添加动画效果，以使各个交互过程更加连贯流畅。在HarmonyOS中，应用窗口的动效为默认行为，不需要开发者进行设置或者修改。 指导输入事件分发。 即根据当前窗口的状态或焦点，进行事件的分发。触摸和鼠标事件根据窗口的位置和尺寸进行分发，而键盘事件会被分发至焦点窗口。应用开发者可以通过窗口模块提供的接口设置窗口是否可以触摸和是否可以获焦。   基本概念HarmonyOS的窗口模块将窗口界面分为系统窗口、应用窗口两种基本类型。 系统窗口：系统窗口指完成系统特定功能的窗口。如音量条、壁纸、通知栏、状态栏、导航栏等。应用窗口：应用窗口区别于系统窗口，指与应用显示相关的窗口。根据显示内容的不同，应用窗口又分为应用主窗口、应用子窗口两种类型。应用主窗口：应用主窗口用于显示应用界面，会在"任务管理界面"显示。应用子窗口：应用子窗口用于显示应用的弹窗、悬浮窗等辅助窗口，不会在"任务管理界面"显示。应用子窗口的生命周期跟随应用主窗口。   实现原理当前窗口的实现和开发与应用开发模型相关联，不同模型下的接口功能略有区别。当前应用开发模型分为FA模型和Stage模型。 两个模型的整体架构和设计思想，详见应用模型解读。 针对窗口开发，推荐使用Stage模型进行相关开发。  约束与限制应用主窗口与子窗口存在大小限制，宽度范围：[320, 2560]，高度范围：[240, 2560]，单位为vp。    上一篇 窗口管理 下一篇 管理应用窗口（Stage模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。窗口属性 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 具体获取窗口实例、设置窗口属性的接口描述及示例见接口文档。  上一篇 启动指定页面 下一篇 申请授权 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述功能介绍运行原理约束与限制接口说明开发步骤实现延迟任务回调拓展能力实现延迟任务调度延迟任务 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述   功能介绍 应用退至后台后，需要执行实时性要求不高的任务，例如有网络时不定期主动获取邮件等，可以使用延迟任务。当应用满足设定条件（包括网络类型、充电类型、存储状态、电池状态、定时状态等）时，将任务添加到执行队列，系统会根据内存、功耗、设备温度、用户使用习惯等统一调度拉起应用。   运行原理 图1 延迟任务实现原理  应用调用延迟任务接口添加、删除、查询延迟任务，延迟任务管理模块会根据任务设置的条件（通过WorkInfo参数设置，包括网络类型、充电类型、存储状态等）和系统状态（包括内存、功耗、设备温度、用户使用习惯等）统一决策调度时机。 当满足调度条件或调度结束时，系统会回调应用WorkSchedulerExtensionAbility中 onWorkStart() 或 onWorkStop() 的方法，同时会为应用单独创建一个Extension扩展进程用以承载WorkSchedulerExtensionAbility，并给WorkSchedulerExtensionAbility一定的活动周期，开发者可以在对应回调方法中实现自己的任务逻辑。   约束与限制  数量限制：一个应用同一时刻最多申请10个延迟任务。 执行频率限制：系统对延迟任务做分级管控，限制延迟任务调度的执行频率。通过能效资源接口申请了WORK_SCHEDULER资源的应用，会被放在能效资源豁免分组中。 表1 应用活跃程度分组     应用活跃分组 延迟任务执行频率    活跃分组 最小间隔2小时   经常使用分组 最小间隔4小时   常用使用 最小间隔24小时   极少使用分组 最小间隔48小时   受限使用分组 禁止   从未使用分组 禁止   能效资源豁免分组 不受限制    超时：WorkSchedulerExtensionAbility单次回调最长运行2分钟。如果超时不取消，系统会终止对应的Extension进程。对于系统特权应用，可以通过能效资源接口申请WORK_SCHEDULER资源，扩展单次回调运行时长，扩展后在充电状态下为20分钟，非充电状态下为10分钟。 调度延迟：系统会根据内存、功耗、设备温度、用户使用习惯等统一调度，如当系统内存资源不足或温度达到一定挡位时，系统将延迟调度该任务。 WorkSchedulerExtensionAbility接口调用限制：为实现对WorkSchedulerExtensionAbility能力的管控，在WorkSchedulerExtensionAbility中限制以下接口的调用： @ohos.resourceschedule.backgroundTaskManager (后台任务管理) @ohos.backgroundTaskManager (后台任务管理) @ohos.multimedia.audio (音频管理) @ohos.multimedia.media (媒体服务)    接口说明 表2 延迟任务主要接口 以下是延迟任务开发使用的相关接口，更多接口及使用方式请见延迟任务文档。     接口名 接口描述    startWork(work: WorkInfo): void; 申请延迟任务   stopWork(work: WorkInfo, needCancel?: boolean): void; 取消延迟任务   getWorkStatus(workId: number, callback: AsyncCallback<Array<WorkInfo>>): void; 获取延迟任务状态（Callback形式）   getWorkStatus(workId: number): Promise<WorkInfo>; 获取延迟任务状态（Promise形式）   obtainAllWorks(callback: AsyncCallback<Array<WorkInfo>>): void; 获取所有延迟任务（Callback形式）   obtainAllWorks(): Promise<Array<WorkInfo>>; 获取所有延迟任务（Promise形式）   stopAndClearWorks(): void; 停止并清除任务   isLastWorkTimeOut(workId: number, AsyncCallback<boolean>): void; 获取上次任务是否超时（针对RepeatWork，Callback形式）   isLastWorkTimeOut(workId: number): Promise<boolean>; 获取上次任务是否超时（针对RepeatWork，Promise形式）    表3 WorkInfo参数     名称 类型 必填 说明    workId number 是 延迟任务ID。   bundleName string 是 延迟任务包名。   abilityName string 是 延迟任务回调通知的组件名。   networkType NetworkType 否 网络类型。   isCharging boolean 否 是否充电。 - true表示充电触发延迟回调，false表示不充电触发延迟回调。   chargerType ChargingType 否 充电类型。   batteryLevel number 否 电量。   batteryStatus BatteryStatus 否 电池状态。   storageRequest StorageRequest 否 存储状态。   isRepeat boolean 否 是否循环任务。 - true表示循环任务，false表示非循环任务。   repeatCycleTime number 否 循环间隔，单位为毫秒。   repeatCount number 否 循环次数。   isPersisted boolean 否 是否持久化保存工作。 - true表示持久化保存工作。false表示非持久化保存工作。   isDeepIdle boolean 否 是否要求设备进入空闲状态。 - true表示需要，false表示不需要。   idleWaitTime number 否 空闲等待时间，单位为毫秒。   parameters [key: string]: number | string | boolean 否 携带参数信息。    WorkInfo参数用于设置应用条件，参数设置时需遵循以下规则：  workId、bundleName、abilityName为必填项，bundleName需为本应用包名。 携带参数信息仅支持number、string、boolean三种类型。 至少设置一个满足的条件，包括网络类型、充电类型、存储状态、电池状态、定时状态等。 对于重复任务，任务执行间隔至少20分钟。设置重复任务时间间隔时，须同时设置是否循环或循环次数中的一个。  表4 延迟任务回调接口 以下是延迟任务回调开发使用的相关接口，更多接口及使用方式请见延迟任务回调文档。     接口名 接口描述    onWorkStart(work: workScheduler.WorkInfo): void 延迟调度任务开始的回调   onWorkStop(work: workScheduler.WorkInfo): void 延迟调度任务结束的回调      开发步骤 延迟任务调度开发步骤分为两步：实现延迟任务调度扩展能力、实现延迟任务调度。  延迟任务调度扩展能力：实现WorkSchedulerExtensionAbility开始和结束的回调接口。 延迟任务调度：调用延迟任务接口，实现延迟任务申请、取消等功能。    实现延迟任务回调拓展能力  新建工程目录。 在工程entry Module对应的ets目录(./entry/src/main/ets)下，新建目录及ArkTS文件，例如新建一个目录并命名为WorkSchedulerExtension。在WorkSchedulerExtension目录下，新建一个ArkTS文件并命名为WorkSchedulerExtension.ets，用以实现延迟任务回调接口。 导入模块。 已复制import WorkSchedulerExtensionAbility from '@ohos.WorkSchedulerExtensionAbility';import workScheduler from '@ohos.resourceschedule.workScheduler'; 实现WorkSchedulerExtension生命周期接口。 已复制export default class MyWorkSchedulerExtensionAbility extends WorkSchedulerExtensionAbility {  // 延迟任务开始回调  onWorkStart(workInfo: workScheduler.WorkInfo) {    console.info(`onWorkStart, workInfo = ${JSON.stringify(workInfo)}`);  }
  // 延迟任务结束回调  onWorkStop(workInfo: workScheduler.WorkInfo) {    console.info(`onWorkStop, workInfo is ${JSON.stringify(workInfo)}`);  }} 在module.json5配置文件中注册WorkSchedulerExtensionAbility，并设置如下标签：  type标签设置为“workScheduler”。 srcEntry标签设置为当前ExtensionAbility组件所对应的代码路径。  已复制{  "module": {      "extensionAbilities": [        {          "name": "MyWorkSchedulerExtensionAbility",          "srcEntry": "./ets/WorkSchedulerExtension/WorkSchedulerExtension.ets",          "label": "$string:WorkSchedulerExtensionAbility_label",          "description": "$string:WorkSchedulerExtensionAbility_desc",          "type": "workScheduler"        }      ]  }}    实现延迟任务调度  导入模块。 已复制import workScheduler from '@ohos.resourceschedule.workScheduler';import { BusinessError } from '@ohos.base'; 申请延迟任务。 已复制// 创建workinfoconst workInfo: workScheduler.WorkInfo = {  workId: 1,  networkType: workScheduler.NetworkType.NETWORK_TYPE_WIFI,  bundleName: 'com.example.application',  abilityName: 'MyWorkSchedulerExtensionAbility'}
try {  workScheduler.startWork(workInfo);  console.info(`startWork success`);} catch (error) {  console.error(`startWork failed. code is ${(error as BusinessError).code} message is ${(error as BusinessError).message}`);} 取消延迟任务。 已复制// 创建workinfoconst workInfo: workScheduler.WorkInfo = {  workId: 1,  networkType: workScheduler.NetworkType.NETWORK_TYPE_WIFI,  bundleName: 'com.example.application',   abilityName: 'MyWorkSchedulerExtensionAbility' }
try {  workScheduler.stopWork(workInfo);  console.info(`stopWork success`);} catch (error) {  console.error(`stopWork failed. code is ${(error as BusinessError).code} message is ${(error as BusinessError).message}`);}    上一篇 长时任务 下一篇 代理提醒 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。注意事项开发步骤XML转换 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  将XML文本转换为JavaScript对象可以更轻松地处理和操作数据，并且更适合在JavaScript应用程序中使用。 语言基础类库提供ConvertXML类将XML文本转换为JavaScript对象，输入为待转换的XML字符串及转换选项，输出为转换后的JavaScript对象。具体转换选项可见@ohos.convertxml。  注意事项 XML解析及转换需要确保传入的XML数据符合标准格式。   开发步骤 此处以XML转为JavaScript对象后获取其标签值为例，说明转换效果。  引入模块。 已复制import convertxml from '@ohos.convertxml'; 输入待转换的XML，设置转换选项。 已复制let xml =  '<?xml version="1.0" encoding="utf-8"?>' +    '<note importance="high" logged="true">' +    '    <title>Happy</title>' +    '    <todo>Work</todo>' +    '    <todo>Play</todo>' +    '</note>';let options = {  // trim: false 转换后是否删除文本前后的空格，否  // declarationKey: "_declaration" 转换后文件声明使用_declaration来标识  // instructionKey: "_instruction" 转换后指令使用_instruction标识  // attributesKey: "_attributes" 转换后属性使用_attributes标识  // textKey: "_text" 转换后标签值使用_text标识  // cdataKey: "_cdata" 转换后未解析数据使用_cdata标识  // docTypeKey: "_doctype" 转换后文档类型使用_doctype标识  // commentKey: "_comment" 转换后注释使用_comment标识  // parentKey: "_parent" 转换后父类使用_parent标识  // typeKey: "_type" 转换后元素类型使用_type标识  // nameKey: "_name" 转换后标签名称使用_name标识  // elementsKey: "_elements" 转换后元素使用_elements标识  trim: false,  declarationKey: "_declaration",  instructionKey: "_instruction",  attributesKey: "_attributes",  textKey: "_text",  cdataKey: "_cdata",  docTypeKey: "_doctype",  commentKey: "_comment",  parentKey: "_parent",  typeKey: "_type",  nameKey: "_name",  elementsKey: "_elements"} 调用转换函数，打印结果。 已复制let conv = new convertxml.ConvertXML();let result = conv.convertToJSObject(xml, options);let strRes = JSON.stringify(result); // 将js对象转换为json字符串，用于显式输出console.info(strRes);// 也可以直接处理转换后的JS对象，获取标签值let title = result['_elements'][0]['_elements'][0]['_elements'][0]['_text']; // 解析<title>标签对应的值let todo = result['_elements'][0]['_elements'][1]['_elements'][0]['_text']; // 解析<todo>标签对应的值let todo2 = result['_elements'][0]['_elements'][2]['_elements'][0]['_text']; // 解析<todo>标签对应的值console.info(title); // Happyconsole.info(todo); // Workconsole.info(todo2); // Play 输出结果如下所示： 已复制strRes:{"_declaration":{"_attributes":{"version":"1.0","encoding":"utf-8"}},"_elements":[{"_type":"element","_name":"note", "_attributes":{"importance":"high","logged":"true"},"_elements":[{"_type":"element","_name":"title", "_elements":[{"_type":"text","_text":"Happy"}]},{"_type":"element","_name":"todo", "_elements":[{"_type":"text","_text":"Work"}]},{"_type":"element","_name":"todo", "_elements":[{"_type":"text","_text":"Play"}]}]}]}title:Happytodo:Worktodo2:Play    上一篇 XML解析 下一篇 通知 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。注意事项开发步骤XML生成 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  XML可以作为数据交换格式，被各种系统和应用程序所支持。例如Web服务，可以将结构化数据以XML格式进行传递。 XML还可以作为消息传递格式，在分布式系统中用于不同节点之间的通信与交互。  注意事项  XML标签必须成对出现，生成开始标签就要生成结束标签。 XML标签对大小写敏感，开始标签与结束标签大小写要一致。    开发步骤 XML模块提供XmlSerializer类来生成XML文件，输入为固定长度的Arraybuffer或DataView对象，该对象用于存放输出的XML数据。 通过调用不同的方法来写入不同的内容，如startElement(name: string)写入元素开始标记，setText(text: string)写入标签值。 XML模块的API接口可以参考@ohos.xml的详细描述，按需求调用对应函数可以生成一份完整的XML文件。  引入模块。 已复制import xml from '@ohos.xml'; import util from '@ohos.util'; 创建缓冲区，构造XmlSerializer对象（可以基于Arraybuffer构造XmlSerializer对象， 也可以基于DataView构造XmlSerializer对象）。 已复制// 1.基于Arraybuffer构造XmlSerializer对象let arrayBuffer = new ArrayBuffer(2048); // 创建一个2048字节的缓冲区let thatSer = new xml.XmlSerializer(arrayBuffer); // 基于Arraybuffer构造XmlSerializer对象
// 2.基于DataView构造XmlSerializer对象let arrayBuffer = new ArrayBuffer(2048); // 创建一个2048字节的缓冲区let dataView = new DataView(arrayBuffer); // 使用DataView对象操作ArrayBuffer对象let thatSer = new xml.XmlSerializer(dataView); // 基于DataView构造XmlSerializer对象 调用XML元素生成函数。 已复制thatSer.setDeclaration(); // 写入xml的声明thatSer.startElement('bookstore'); // 写入元素开始标记thatSer.startElement('book'); // 嵌套元素开始标记thatSer.setAttributes('category', 'COOKING'); // 写入属性及属性值thatSer.startElement('title');thatSer.setAttributes('lang', 'en');thatSer.setText('Everyday'); // 写入标签值thatSer.endElement(); // 写入结束标记thatSer.startElement('author');thatSer.setText('Giada');thatSer.endElement();thatSer.startElement('year');thatSer.setText('2005');thatSer.endElement();thatSer.endElement();thatSer.endElement(); 使用Uint8Array操作Arraybuffer，调用TextDecoder对Uint8Array解码后输出。 已复制let view = new Uint8Array(arrayBuffer); // 使用Uint8Array读取arrayBuffer的数据let textDecoder = util.TextDecoder.create(); // 调用util模块的TextDecoder类let res = textDecoder.decodeWithStream(view); // 对view解码console.info(res); 输出结果如下： 已复制<?xml version=\"1.0\" encoding=\"utf-8\"?><bookstore>\r\n  <book category=\"COOKING\">\r\n    <title lang=\"en\">Everyday</title>\r\n    <author>Giada</author>\r\n    <year>2005</year>\r\n  </book>\r\n</bookstore>    上一篇 XML概述 下一篇 XML解析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。