您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。修改数据删除数据管理数据 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 当您的应用有数据记录时，您可以在数据模型中对数据进行删除、修改和查询的操作。 修改数据数据模型的数据分为草稿态和发布态两种状态，两种状态的数据是相互隔离的。 草稿态：数据模型还未发布过，只有在体验环境（还未发布上架的应用环境）可看到此状态的数据。应用发布上架前，可以在体验环境使用草稿态的数据预览效果。发布态：数据模型已发布，在正式环境（在华为应用市场发布上架的应用环境）才可以看到此状态的数据。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击待编辑数据操作列的管理数据，进入管理数据模型详情页。 在数据列表，点击待修改数据操作列的编辑。
说明
如果数据模型中包含加密字段，在AGC控制台不支持修改数据，只能在客户端修改数据。 
  在弹出的“编辑模型实例数据”框中填写完信息后，点击“提交”，数据会更新为修改后的数据。  删除数据登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击需要删除数据操作列的管理数据，进入管理数据模型详情页。
说明
如果数据模型中包含加密字段，在AGC控制台不支持删除数据，只能在客户端删除数据。 
  删除单条数据在数据列表，点击要删除数据操作列的删除。  删除多条或所有数据在数据列表，选择所有要删除数据或全选，点击右上角的删除。   在弹出的提示框中，点击确认，删除数据成功。   上一篇 新建数据模型 下一篇 维护数据模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。修改数据模型发布数据模型导出数据模型导出数据模型导入数据模型通过json文件导入数据模型通过Excel表导入数据模型删除数据模型维护数据模型 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 修改数据模型
说明
如果待修改的数据模型状态为“已发布”，当您修改（如新增字段等操作）并保存了数据模型信息后，数据模型状态会变更为“未发布”，您需要重新发布此数据模型才能同步至生产环境。 
 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击需要修改数据模型操作列的编辑（或点击数据模型名称进入详情页，点击详情页的编辑），进入数据模型详情页，修改模型配置或基本信息。在模型配置页签，可以添加字段、编辑已有字段、删除字段或修改登录权限。
说明
每个数据模型最多配置100个字段，包括主键字段和系统字段。每个数据模型最多创建5个加密字段，85个非加密字段。 
  其中，查询多条和查询单条方法支持的查询条件参考下表： 方法名称  方法说明    查询多条  查询条件对象。 relation，判断关系，包含以下9种：EqualTo：表示相等。NotEqualTo：表示不相等。GreaterThan：大于。GreaterThanOrEqualTo：大于或等于。LessThan：小于。LessThanOrEqualTo：小于或等于。BeginsWith：匹配字段值头部，查询字段值以给定value开头的数据记录。EndsWith：匹配字段值尾部，查询字段值以给定value结束的数据记录。Contains：查询字段值包含给定value的数据记录。 field，查询字段名称：数据模型字段标题。value：查询字段值。   查询单条      点击添加字段，在页面右侧弹出的编辑数据模型框，填写字段信息完成后，点击确定。点击操作列的“”编辑已有字段，在页面右侧弹出的编辑数据模型框，填写字段信息完成后，点击确定。点击操作列的“”可删除已有字段。  编辑基本信息。 参数名称  说明    数据模型ID（草稿态）  未发布数据模型ID，不可编辑。   数据模型ID（发布态）  已发布数据模型ID，不可编辑，如果还未发布过，显示--。   标题  数据模型标题。   名称  数据模型名称，不可编辑。   上次发布时间  如果发布过该模型，则显示最后一次发布时间。如果未发布过该模型，显示--。   描述  数据模型描述（1~255字符）。   类型  用户定义。   创建时间  数据模型创建成功的时间。       点击页面右上角的保存，在页面弹出的提示框中点击确定，完成数据模型编辑。您还可以维护可使用此数据模型的角色，以便拥有对应角色的用户才可以查看或者维护。具体参见角色与权限。  发布数据模型发布数据模型才能将数据模型应用至生产环境。发布数据模型有两种方式： 方式一：登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击待发布数据模型操作列的发布。 在弹出的提示框中，点击确认，发布数据模型成功。发布成功后，发布状态更新为已发布，发布时间更新为发布时的系统时间，操作列的发布置灰。  方式二：登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击待发布数据模型标题。 进入数据模型详情页，点击基本信息页签，点击立即发布。 在弹出的提示框中，点击确认，发布数据模型成功。发布成功后，回到数据模型列表，对应数据模型的发布状态更新为已发布，发布时间更新为发布时的系统时间，操作列的发布置灰。    导出数据模型当您想要创建一个相同配置的数据模型，您可以使用数据模型的导出功能。  导出数据模型登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择DevEco低代码 > 数据模型。在数据模型列表，点击需要导出数据模型操作列的导出，在下拉框中选择需要导出数据模型的类别。 
说明
如果导出的数据模型中有“关联关系”类型的字段，则此类型字段不会被导出。 
 待文件导出结束后保存文件（文件命名方式为“发布态的数据模型ID.json”）。  导入数据模型您可以通过两种方式快速创建数据模型： 通过json文件导入：导出已有数据模型，将导出的json文件定制后导入。通过Excel表导入：下载Excel模板，编辑后导入Excel表。  通过json文件导入数据模型
说明
当项目下的数据模型个数已达到50个上限时，“导入数据模型”按钮将置灰，无法导入数据模型。 
 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击导入数据模型。 在弹出的导入框中，点击“选择文件”待上传json文件。 上传成功，点击“导入”，导入成功后，将新增一条数据模型记录，除了“名称”重新命名，其他信息与导入的数据模型相同。
说明
导出的json文件中不会包含“关联关系”类型的字段，如果新建数据模型有此类型字段，需进入新生成的数据模型手动设置。 
 为导入新生成的数据模型配置数据。  通过Excel表导入数据模型
说明
当项目下的数据模型个数已达到50个上限时，“导入数据模型”按钮将置灰，无法导入数据模型。 
 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击导入数据模型。 在弹出的导入框中，点击“下载Excel导入模板”，下载模板。 根据表格中的填写说明，配置表格信息。
说明
表格中不支持设置“关联关系”类型字段，此类字段需进入新生成的数据模型手动设置。 
 返回“导入数据模型”页面，点击“选择文件”选择待上传编辑完成的Excel表。 上传成功，点击“导入”，导入成功后，将新增一条数据模型记录，新数据模型的标题和名称将根据导入Excel文件的名称命名。如果有“关联关系”类型字段，对新数据模型进行编辑。也可以为新数据模型配置角色和权限。为导入新生成的数据模型配置数据。  删除数据模型登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 数据模型。在数据模型列表，点击需要删除数据模型操作列的删除。 在弹出的提示框中，点击确认，删除数据模型成功。   上一篇 管理数据 下一篇 连接器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。变量命名不支持与方法命名重复文本选择器目前低码无法实现引用数据源的变量定义数据模型中定义的图片类型资源不支持带有中文名字无法选中父组件组件文字显示不全场景常见问题 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 变量命名不支持与方法命名重复问题现象 若变量命名与方法命名重复并且在同一个页面中同时使用变量和方法会出现变量未定义，无响应代码生成的现象。 只使用变量的场景变量会正常定义并初始化：  如果在引用了变量的同时绑定了同名方法，然后修改变量的默认值或传入的场景：   解决措施 尽量避免变量名与方法名重名。  文本选择器目前低码无法实现引用数据源的变量定义问题现象 目前低码无法实现以下类型的数组定义。   解决措施 通过高码实现该组件功能。   数据模型中定义的图片类型资源不支持带有中文名字问题现象 若数据模型中的图片使用中文名字会导致在运行时图片无法加载。 解决措施 请勿使用在数据模型中使用带有中文符号的图片资源。   无法选中父组件问题现象 子组件如果覆盖住了父组件，是无法通过画布选中父组件的，右键功能也无法选中父组件。 解决措施 可以通过左侧的组件树选择，或者通过点击小眼睛隐藏子组件的方式，在画布上选中父组件。   组件文字显示不全场景问题现象 在使用组件可能遇到文字显示不全场景。  解决措施 将组件宽度增加或文字字体缩小就可以显示正常。    上一篇 角色与权限 下一篇 HarmonyOS应用安全测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。连接器 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    新建连接器  维护连接器   上一篇 维护数据模型 下一篇 新建连接器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。导入模板导出模板删除模板模板中心 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 当您的应用已发布了发布版或开放式测试版，您可以通过直接导入模板的方式创建自定义模板，或者也可以把自定义模板导出供您使用。 导入模板
说明
自定义模板支持最多导入500个。 
 您可以将本地的模板导入进来，或者将该项目下的应用先导出为模板，然后再导入。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 模板中心，选择“自定义应用模板”，点击导入模板。 在弹出的导入模板框中选择模板ZIP包，填写模板名称和版本号后，点击确定。 参数名称  参数说明    导入项目  当前所在项目名称，不可编辑。   上传文件  点击“选择文件”，选择本地已有的模板ZIP，包的大小不可超过100M。   模板名称  模板的名称（1~128个字符）。   版本号  模板的版本号，如1.1.1。   封面图  可展示模板样式内容的图片。       导出模板登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 模板中心，选择“自定义应用模板”，点击导出模板文件。 在弹出的提示框中点击确定，模板将以ZIP包的形式导出。   删除模板登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 模板中心，选择“自定义应用模板”，点击删除。 在弹出的提示框中点击确定，模板删除成功。    上一篇 维护连接器 下一篇 区块与页面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。平台操作指导 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    应用  数据模型  连接器  模板中心  区块与页面  用户权限   上一篇 应用推送发布 下一篇 应用 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。直接创建元服务通过模板创建元服务前提条件操作步骤创建应用 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 直接创建元服务应用管理页面以卡片形式展示应用，目前仅支持创建元服务。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择应用管理，进入应用管理页面，点击创建元服务。 在弹出的新建元服务应用框，根据需求选择以下任一方式创建：方式一：如果您在本项目没有创建过元服务，可选择新建应用选项。 配置项名称  配置项说明    应用名称  1~30个字符。   应用包名  只允许使用英文字母、数字、"_"，首字符必须是字母，以“.”分隔，至少包含3段，每一段必须以数字或者字母结束。     方式二：如果本项目在AGC已创建过应用，可选择选择已有AGC应用，此种方式会创建一个与已有AGC应用同名的应用。 配置项名称  配置项说明    选择元服务  在AGC项目下已经创建的元服务，此选项会列出本项目下所有的元服务。   元服务包名  选择元服务后，包名自动填充。      填写应用信息或选择已有AGC应用后，点击新建。
说明
单个项目下最多支持创建50个应用，当应用数量达到上限时，系统会弹出提示框，建议您参考删除应用，删掉不需要的应用。如果您对应用数上限有疑问，请与联系客服（agconnect@huawei.com）。 
 创建完成后，系统将跳转到应用开发界面，该页面的使用详情请参考开发界面介绍。  通过模板创建元服务通过模板创建的元服务将包含模板中已经有的资源，如关联的数据模型或连接器，在模板的基础上继续开发元服务，可极大的节约开发时间。目前，系统仅支持通过导入用户自定义模板创建元服务。  前提条件由于目前仅支持通过用户自定义的模板创建元服务，因此需要您先导入模板。  操作步骤登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择应用管理，进入应用管理页面，点击从模板新建。 在弹出的从模板新建框中，根据需求选择模板，填写元服务名称和包名后，点击确定，应用创建完成。
说明
元服务名称和元服务包名标准请参考配置项说明。 
  如果模板中关联了连接器，需要补充配置一些信息。关联云函数类型连接器的模板：如果连接器中有配置鉴权信息，需要去对应连接器的“鉴权设置”页面重新配置“Client ID”和“Client Secret”。关联支付连接器的模板：如果连接器中有配置支付信息，需要去对应连接器的“支付配置”页面重新配置相关信息。    上一篇 应用 下一篇 维护应用 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看应用信息编辑应用导出应用模板修改应用信息删除应用维护应用 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 查看应用信息您可以在应用详情页面查看应用的基本信息如应用ID、应用版本如发布的版本号等信息。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 应用管理，在应用列表中搜索您要修改的应用名称，点击应用卡片，进入应用详情页面。   编辑应用您可以通过编辑应用进入到应用设计界面，从而可以快速开发您的应用。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 应用管理，进入应用管理页面。在应用列表中搜索您要修改的应用，点击卡片上的编辑应用（或点击应用名称，进入应用详情页，点击右上角的编辑应用）。 系统将跳转到应用开发界面，使用详情可参见低代码开发元服务。  导出应用模板如果您想要创建一个相同功能的应用，建议您将已创建好的应用转化为自定义模板，方便您在创建模板时直接使用此模板。 
说明
仅已发布了发布版本或开放式测试版本的应用才支持导出为模板。导出的模板适用于所有低代码项目。 
 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 应用管理，在应用列表中搜索您要导出为模板的应用，点击应用卡片上的转换为模板。 填写信息后点击确定。模板以ZIP包的形式下载到本地，导出成功后可以到模板中心查看管理该模板及其相关的资源。  配置项  配置项说明    模板名称  1~128个字符。   版本号  版本号格式：1.0.0 - 99.99.99，如1.1.0。   封面图  可展示模板样式内容的图片。   是否携带业务数据  选择“携带业务数据导出”，则会把元服务相关的数据模型、数据信息一起导出。       修改应用信息如果您要修改应用的名称和描述，可以点击应用详情页的“编辑信息”进行修改。  登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 应用管理，进入应用管理页面。在应用列表中搜索您要修改的应用，点击应用卡片，进入应用详情页面。点击页面右上角的编辑信息，在弹出的编辑应用信息窗口修改应用的名称和描述。  删除应用如果应用的数量达到了上限或者应用不再需要，您可以将应用删除。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 应用管理，进入应用管理页面。在应用列表中搜索您要删除的应用，点击删除应用。 
注意
删除应用后，该应用下的所有配置将被清空且无法恢复，请谨慎操作。 
     上一篇 创建应用 下一篇 数据模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    创建应用  维护应用   上一篇 平台操作指导 下一篇 创建应用 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。数据模型 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    新建数据模型  管理数据  维护数据模型   上一篇 维护应用 下一篇 新建数据模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。新建角色编辑角色发布角色角色与权限 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco低代码预置了三种角色： 默认访客：用于匿名访问应用时使用，默认访客可以访问应用所有页面和数据。默认外部用户：用于实名登录应用时使用，登录后可以访问应用所有页面和数据。默认超级管理员：可以查看、修改所有应用数据。 新建角色如果系统角色无法满足您的需求，您可以重新定义新的角色，并为角色设置权限。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 用户权限 > 角色与权限，点击新建角色。 输入角色信息，点击确定。 点击新建角色所在行的编辑，为角色设置对数据的访问权限。 “已关联应用”选择可以使用该角色的应用。 在数据模型权限区域，将罗列应用所有的数据模型，点击每个数据模型所在行的行权限设置，设置相关权限。 默认无权限查看和修改数据，可以更新为查看修改本人创建的数据，或者查看、修改所有数据，设置完成，点击确定。 设置完行权限后，您还可以进一步对某个字段进行权限设置，点击数据模型所在行的列权限设置。 对自定义的字段设置权限后，点击确定。 设置完成，点击右上角的保存。  编辑角色点击待编辑角色所在行的编辑。 在数据模型权限区域，点击待修改数据模型所在行的行权限设置和列权限设置。 编辑完成，点击右上角的保存。  发布角色点击待发布角色所在行的发布。  
说明
发布后的角色如果再做更新，将重新变成“未发布”状态，需要重新发布后，才可在正式环境生效。 
   上一篇 用户权限 下一篇 常见问题 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。用户权限 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     角色与权限   上一篇 区块与页面 下一篇 角色与权限 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述功能介绍约束与限制接口说明开发步骤代理提醒 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述   功能介绍 应用退到后台或进程终止后，仍然有一些提醒用户的定时类任务，例如购物类应用抢购提醒等，为满足此类功能场景，系统提供了代理提醒（reminderAgentManager）的能力。当应用退至后台或进程终止后，系统会代理应用做相应的提醒。当前支持的提醒类型包括：倒计时、日历和闹钟。  倒计时类：基于倒计时的提醒功能。 日历类：基于日历的提醒功能。 闹钟类：基于时钟的提醒功能。    约束与限制  个数限制：一个三方应用支持最多30个有效提醒（有效即发布成功），一个系统应用支持最多10000个有效提醒，整个系统最多支持12000个有效提醒。 跳转限制：点击提醒通知后跳转的应用必须是申请代理提醒的本应用。    接口说明 表1 主要接口 以下是代理提醒的相关接口，下表均以Promise形式为例，更多接口及使用方式请见后台代理提醒文档。     接口名 描述    publishReminder(reminderReq: ReminderRequest): Promise<number> 发布一个定时提醒类通知。   cancelReminder(reminderId: number): Promise<void> 取消一个指定的提醒类通知。   getValidReminders(): Promise<Array<ReminderRequest>> 获取当前应用设置的所有有效的提醒。   cancelAllReminders(): Promise<void> 取消当前应用设置的所有提醒。   addNotificationSlot(slot: NotificationSlot): Promise<void> 注册一个提醒类需要使用的通知通道（NotificationSlot）。   removeNotificationSlot(slotType: notification.SlotType): Promise<void> 删除指定的通知通道（NotificationSlot）。      开发步骤  申请ohos.permission.PUBLISH_AGENT_REMINDER权限，配置方式请参阅配置文件权限声明。 使能通知开关。获得用户授权后，才能使用代理提醒功能。 导入模块。 已复制import reminderAgentManager from '@ohos.reminderAgentManager';import notificationManager from '@ohos.notificationManager'; 定义目标提醒代理。开发者根据实际需要，选择定义如下类型的提醒。  定义倒计时实例。 已复制let targetReminderAgent: reminderAgentManager.ReminderRequestTimer = {  reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_TIMER, // 提醒类型为倒计时类型  triggerTimeInSeconds: 10,  actionButton: [// 设置弹出的提醒通知信息上显示的按钮类型和标题    {      title: 'close',      type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_CLOSE    }  ],  wantAgent: { // 点击提醒通知后跳转的目标UIAbility信息    pkgName: 'com.example.myapplication',    abilityName: 'EntryAbility'  },  maxScreenWantAgent: { // 全屏显示提醒到达时自动拉起的目标UIAbility信息    pkgName: 'com.example.myapplication',    abilityName: 'EntryAbility'  },  title: 'this is title', // 指明提醒标题  content: 'this is content', // 指明提醒内容  expiredContent: 'this reminder has expired', // 指明提醒过期后需要显示的内容  notificationId: 100, // 指明提醒使用的通知的ID号，相同ID号的提醒会覆盖  slotType: notificationManager.SlotType.SOCIAL_COMMUNICATION // 指明提醒的Slot类型} 定义日历实例。 已复制let targetReminderAgent: reminderAgentManager.ReminderRequestCalendar = {  reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_CALENDAR, // 提醒类型为日历类型  dateTime: { // 指明提醒的目标时间    year: 2023,    month: 1,    day: 1,    hour: 11,    minute: 14,    second: 30  },  repeatMonths: [1], // 指明重复提醒的月份  repeatDays: [1], // 指明重复提醒的日期  actionButton: [// 设置弹出的提醒通知信息上显示的按钮类型和标题    {      title: 'close',      type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_CLOSE    },    {      title: 'snooze',      type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_SNOOZE    },  ],  wantAgent: { // 点击提醒通知后跳转的目标UIAbility信息    pkgName: 'com.example.myapplication',    abilityName: 'EntryAbility'  },  maxScreenWantAgent: { // 全屏显示提醒到达时自动拉起的目标UIAbility信息    pkgName: 'com.example.myapplication',    abilityName: 'EntryAbility'  },  ringDuration: 5, // 指明响铃时长（单位：秒）  snoozeTimes: 2, // 指明延迟提醒次数  timeInterval: 5, // 执行延迟提醒间隔（单位：秒）  title: 'this is title', // 指明提醒标题  content: 'this is content', // 指明提醒内容  expiredContent: 'this reminder has expired', // 指明提醒过期后需要显示的内容  snoozeContent: 'remind later', // 指明延迟提醒时需要显示的内容  notificationId: 100, // 指明提醒使用的通知的ID号，相同ID号的提醒会覆盖  slotType: notificationManager.SlotType.SOCIAL_COMMUNICATION // 指明提醒的Slot类型} 定义闹钟实例。 已复制let targetReminderAgent: reminderAgentManager.ReminderRequestAlarm = {  reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_ALARM, // 提醒类型为闹钟类型  hour: 23, // 指明提醒的目标时刻  minute: 9, // 指明提醒的目标分钟  daysOfWeek: [2], // 指明每周哪几天需要重复提醒  actionButton: [ // 设置弹出的提醒通知信息上显示的按钮类型和标题    {      title: 'close',      type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_CLOSE    },    {      title: 'snooze',      type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_SNOOZE    },  ],  wantAgent: { // 点击提醒通知后跳转的目标UIAbility信息    pkgName: 'com.example.myapplication',    abilityName: 'EntryAbility'  },  maxScreenWantAgent: { // 全屏显示提醒到达时自动拉起的目标UIAbility信息    pkgName: 'com.example.myapplication',    abilityName: 'EntryAbility'  },  ringDuration: 5, // 指明响铃时长（单位：秒）  snoozeTimes: 2, // 指明延迟提醒次数  timeInterval: 5, // 执行延迟提醒间隔（单位：秒）  title: 'this is title', // 指明提醒标题  content: 'this is content', // 指明提醒内容  expiredContent: 'this reminder has expired', // 指明提醒过期后需要显示的内容  snoozeContent: 'remind later', // 指明延迟提醒时需要显示的内容  notificationId: 99, // 指明提醒使用的通知的ID号，相同ID号的提醒会覆盖  slotType: notificationManager.SlotType.SOCIAL_COMMUNICATION // 指明提醒的Slot类型}           发布相应的提醒代理。代理发布后，应用即可使用后台代理提醒功能。        已复制reminderAgentManager.publishReminder(targetReminderAgent).then(res => {  console.info('Succeeded in publishing reminder. ');  let reminderId: number = res; // 发布的提醒ID}).catch(err => {  console.error(`Failed to publish reminder. Code: ${err.code}, message: ${err.message}`);})  根据需要删除提醒任务。已复制// reminderId的值从发布提醒代理成功之后的回调中获得reminderAgentManager.cancelReminder(reminderId).then(() => {  console.info('Succeeded in canceling reminder.');}).catch(err => {  console.error(`Failed to cancel reminder. Code: ${err.code}, message: ${err.message}`);});    上一篇 延迟任务 下一篇 设备管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。AOT编译模式使用AOT编译使用type编译模式使用partial编译模式参考信息：编译release版本的HAP开启AOT编译模式 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 AOT（Ahead Of Time）即提前编译，能够在Host端（即运行DevEco Studio的电脑）将字节码提前编译成Target端（即运行应用的设备）可运行的机器码，这样字节码可以获得充分编译优化，放到Target端运行时可以获得加速。 对性能有高要求的开发者可通过在DevEco Studio完成相关的编译配置，开启AOT编译模式，提升应用运行性能。 
说明
当前仅支持API 9及以上版本Stage模型的ArkTS工程。Node.js需要10.14以上版本。仅支持在64位ROM上运行。 
 AOT编译模式在模块级build-profile.json5文件中，buildOption内的aotCompileMode字段可以设置为以下值，对应不同的AOT模式。 取值  不同的AOT编译模式    type  默认模式，仅编译类型信息到字节码文件，编译速度最快。   partial  使用记录高频操作信息的ap文件（Arkcompiler Profile）进行部分编译，编译速度较快。      使用AOT编译打开ArkTS工程，同步完成。在模块级build-profile.json5文件中，配置buildOption内的字段。已复制{  "apiType": 'stageMode',  "buildOption": {    "aotCompileMode": "type"  },  ...} 当aotCompileMode设置为partial时，需要设置apPath。如果设置为type时，则无需关注此步骤。partial类型配置的示例如下：已复制"aotCompileMode": "partial" "apPath":"./modules.ap" 其中，ap文件获取方式为：打开生成ap文件的开关：已复制hdc shell param set ark.profile true 先配置为type类型，打包出HAP后运行在真机上，在需要优化的场景进行操作，从而记录常用操作。操作结束后，真机里记录的ap文件即可放入应用AOT编译使用的目录，通过命令行来获取ap文件：已复制hdc file recv /data/local/ark-profile/100/{bundle_name}/modules.ap {apPath} {bundle_name}: 表示包名。{apPath}: 表示buildOption设置的apPath参数对应的路径。   4. 若设备不再需要获取ap文件，可以通过下面两个方法关闭：hdc shell param set ark.profile false设备重启  
说明
应用代码变化或常用操作变化时，需要重复以上步骤更新ap文件。 
 编译release版本的HAP。   使用type编译模式打开ArkTS工程，同步完成。在模块级build-profile.json5文件中，配置buildOption内的字段。已复制{  "apiType": 'stageMode',  "buildOption": {    "aotCompileMode": "type"  },  ...} 编译release版本的HAP。   使用partial编译模式使用partial编译模式需要先使用type模式进行编译，获取到ap文件后，再进行partial模式编译。 参考使用type编译模式，配置为type模式，编译HAP。获取ap文件：打开生成ap文件的开关：已复制hdc shell param set ark.profile true 将步骤一打包出的HAP后运行在真机上，在需要优化的场景进行操作，从而记录高频操作。操作结束后，真机里记录的ap文件即可放入应用AOT编译使用的目录，通过命令行来获取ap文件：已复制hdc file recv /data/local/ark-profile/100/{bundle_name}/modules.ap {apPath} {bundle_name}: 表示包名。{apPath}: 表示buildOption设置的apPath参数对应的路径。  4. 若设备不再需要获取ap文件，可以通过下面两个方法关闭：hdc shell param set ark.profile false设备重启  
说明
应用代码变化或常用操作变化时，需要重复以上步骤更新ap文件。 
 在模块级build-profile.json5文件中，配置buildOption内的字段。已复制{  "apiType": 'stageMode',  "buildOption": {     "aotCompileMode": "partial",     "apPath":"./modules.ap"  },  ...} 编译release版本的HAP。   参考信息：编译release版本的HAP在菜单栏点击Run，选择Edit Configurations。 左上角点击+，选择Hvigor。在Application parameters内配置以下参数：已复制--mode module -p product=default assembleHap -p debuggable=false  配置完成后，点击OK。 在右上角点击启动编译。    上一篇 默认开启模块化编译模式 下一篇 配置应用的依赖 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。app.json5配置文件 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  先通过一个示例，整体认识一下app.json5配置文件。 已复制{  "app": {    "bundleName": "com.application.myapplication",    "vendor": "example",    "versionCode": 1000000,    "versionName": "1.0.0",    "icon": "$media:app_icon",    "label": "$string:app_name",    "description": "$string:description_application",    "minAPIVersion": 9,    "targetAPIVersion": 9,    "apiReleaseType": "Release",    "debug": false,    "car": {      "minAPIVersion": 8,    }  },} app.json5配置文件包含以下标签。 表1 app.json5文件配置标签说明     属性名称 含义 数据类型 是否可缺省    bundleName 标识应用的Bundle名称，用于标识应用的唯一性。该标签不可缺省。标签的值命名规则 ： - 字符串以字母、数字、下划线和符号“.”组成。 - 以字母开头。 - 最小长度7个字节，最大长度127个字节。 推荐采用反域名形式命名（如com.example.demo，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。 字符串 该标签不可缺省。   bundleType 标识应用的Bundle类型，用于区分应用或者原子化服务。该标签可选值为app和atomicService ： - app：当前Bundle为普通应用。 - atomicService：当前Bundle为元服务。 字符串 该标签可以缺省，缺省为app。   debug 标识应用是否可调试，该标签由IDE编译构建时生成。 - true：可调试。 - false：不可调试。 布尔值 该标签可以缺省，缺省为false。   icon 标识应用的图标，标签值为图标资源文件的索引。 字符串 该标签不可缺省。   label 标识应用的名称，标签值为字符串资源的索引。 字符串 该标签不可缺省。   description 标识应用的描述信息，标签值是字符串类型（最大255个字节）或对描述内容的字符串资源索引。 字符串 该标签可缺省，缺省值为空。   vendor 标识对应用开发厂商的描述。该标签的值是字符串类型（最大255个字节）。 字符串 该标签可以缺省，缺省为空。   versionCode 标识应用的版本号，该标签值为32位非负整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。开发者可以将该值设置为任何正整数，但是必须确保应用的新版本都使用比旧版本更大的值。该标签不可缺省，versionCode值应小于2^31次方。 数值 该标签不可缺省。   versionName 标识应用版本号的文字描述，用于向用户展示。 该标签仅由数字和点构成，推荐采用“A.B.C.D”四段式的形式。四段式推荐的含义如下所示。 第一段：主版本号/Major，范围0-99，重大修改的版本，如实现新的大功能或重大变化。 第二段：次版本号/Minor，范围0-99，表示实现较突出的特点，如新功能添加或大问题修复。 第三段：特性版本号/Feature，范围0-99，标识规划的新版本特性。 第四段：修订版本号/Patch，范围0-999，表示维护版本，修复bug。 标签最大字节长度为127。 字符串 该标签不可缺省。   minCompatibleVersionCode 标识应用能够兼容的最低历史版本号，用于跨设备兼容性判断。 
说明
 当前版本暂不支持跨设备能力。 
 数值 该标签可缺省，缺省值等于versionCode标签值。   minAPIVersion 标识应用运行需要的SDK的API最小版本。 数值 由build-profile.json5中的compatibleSdkVersion生成。   targetAPIVersion 标识应用运行需要的API目标版本。 数值 由build-profile.json5中的compileSdkVersion生成。   apiReleaseType 标识应用运行需要的API目标版本的类型，采用字符串类型表示。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。 - Canary：受限发布的版本。 - Beta：公开发布的Beta版本。 - Release：公开发布的正式版本。 该字段由DevEco Studio读取当前使用的SDK的Stage来生成。 字符串 该标签可缺省，由IDE生成并覆盖。   multiProjects 标识当前工程是否支持多个工程的联合开发。 - true：当前工程支持多个工程的联合开发。 - false：当前工程不支持多个工程的联合开发。多工程开发可以参考文档：多工程构建。 布尔值 可缺省，缺省值为false。   tablet 标识对tablet设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。 如果使用该属性对tablet设备做了特殊配置，则应用在tablet设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时tablet设备使用app.json5公共区域配置的属性值。   tv 标识对tv设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。 如果使用该属性对tv设备做了特殊配置，则应用在tv设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时tv设备使用app.json5公共区域配置的属性值。   wearable 标识对wearable设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。 如果使用该属性对wearable设备做了特殊配置，则应用在wearable设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时wearable设备使用app.json5公共区域配置的属性值。   car 标识对car设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。 如果使用该属性对car设备做了特殊配置，则应用在car设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时car设备使用app.json5公共区域配置的属性值。   phone 标识对phone设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。 如果使用该属性对phone设备做了特殊配置，则应用在phone设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时phone设备使用app.json5公共区域配置的属性值。     上一篇 应用配置文件概述（Stage模型） 下一篇 module.json5配置文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用数据持久化 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    应用数据持久化概述  通过用户首选项实现数据持久化  通过键值型数据库实现数据持久化  通过关系型数据库实现数据持久化   上一篇 数据管理概述 下一篇 应用数据持久化概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用数据持久化概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 应用数据持久化，是指应用将内存中的数据通过文件或数据库的形式保存到设备上。内存中的数据形态通常是任意的数据结构或数据对象，存储介质上的数据形态可能是文本、数据库、二进制文件等。 HarmonyOS标准系统支持典型的存储数据形态，包括用户首选项、键值型数据库、关系型数据库。 开发者可以根据如下功能介绍，选择合适的数据形态以满足自己应用数据的持久化需要。 用户首选项（Preferences）：通常用于保存应用的配置信息。数据通过文本的形式保存在设备中，应用使用过程中会将文本中的数据全量加载到内存中，所以访问速度快、效率高，但不适合需要存储大量数据的场景。键值型数据库（KV-Store）：一种非关系型数据库，其数据以“键值”对的形式进行组织、索引和存储，其中“键”作为唯一标识符。适合很少数据关系和业务关系的业务数据存储，同时因其在分布式场景中降低了解决数据库版本兼容问题的复杂度，和数据同步过程中冲突解决的复杂度而被广泛使用。相比于关系型数据库，更容易做到跨设备跨版本兼容。关系型数据库（RelationalStore）：一种关系型数据库，以行和列的形式存储数据，广泛用于应用中的关系型数据的处理，包括一系列的增、删、改、查等接口，开发者也可以运行自己定义的SQL语句来满足复杂业务场景的需要。  上一篇 应用数据持久化 下一篇 通过用户首选项实现数据持久化 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用文件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    应用文件概述  应用沙箱目录  应用文件访问与管理  向应用沙箱推送文件  应用文件分享   上一篇 文件管理概述 下一篇 应用文件概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发示例新建并读写一个文件读取文件内容并写入到另一个文件以流的形式读写文件查看文件列表应用文件访问 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用需要对应用文件目录下的应用文件进行查看、创建、读写、删除、移动、复制、获取属性等访问操作，下文介绍具体方法。  接口说明 开发者通过基础文件操作接口（ohos.file.fs）实现应用文件访问能力，主要功能如下表所示。     表1 基础文件操作接口功能         接口名 功能 接口类型 支持同步 支持异步    access 检查文件是否存在 方法 √ √   close 关闭文件 方法 √ √   copyFile 复制文件 方法 √ √   createStream 基于文件路径打开文件流 方法 √ √   listFile 列出文件夹下所有文件名 方法 √ √   mkdir 创建目录 方法 √ √   moveFile 移动文件 方法 √ √   open 打开文件 方法 √ √   read 从文件读取数据 方法 √ √   rename 重命名文件或文件夹 方法 √ √   rmdir 删除整个目录 方法 √ √   stat 获取文件详细属性信息 方法 √ √   unlink 删除单个文件 方法 √ √   write 将数据写入文件 方法 √ √   Stream.close 关闭文件流 方法 √ √   Stream.flush 刷新文件流 方法 √ √   Stream.write 将数据写入流文件 方法 √ √   Stream.read 从流文件读取数据 方法 √ √   File.fd 获取文件描述符 属性 - -   OpenMode 设置文件打开标签 属性 - -   Filter 设置文件过滤配置项 类型 - -     开发示例 在对应用文件开始访问前，开发者需要获取应用文件路径。以从UIAbilityContext获取HAP级别的文件路径为例进行说明，UIAbilityContext的获取方式请参见获取UIAbility的上下文信息。 下面介绍几种常用操作示例。   新建并读写一个文件 以下示例代码演示了如何新建一个文件并对其读写。 已复制// pages/xxx.etsimport fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
function createFile() {  // 获取应用文件路径  let context = getContext(this) as common.UIAbilityContext;  let filesDir = context.filesDir;
  // 新建并打开文件  let file = fs.openSync(filesDir + '/test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);  // 写入一段内容至文件  let writeLen = fs.writeSync(file.fd, "Try to write str.");  console.info("The length of str is: " + writeLen);  // 从文件读取一段内容  let buf = new ArrayBuffer(1024);  let readLen = fs.readSync(file.fd, buf, { offset: 0 });  console.info("the content of file: " + String.fromCharCode.apply(null, new Uint8Array(buf.slice(0, readLen))));  // 关闭文件  fs.closeSync(file);}   读取文件内容并写入到另一个文件       以下示例代码演示了如何从一个文件读写内容到另一个文件。      已复制// pages/xxx.etsimport fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
function readWriteFile() {  // 获取应用文件路径  let context = getContext(this) as common.UIAbilityContext;  let filesDir = context.filesDir;
  // 打开文件  let srcFile = fs.openSync(filesDir + '/test.txt', fs.OpenMode.READ_WRITE);  let destFile = fs.openSync(filesDir + '/destFile.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);  // 读取源文件内容并写入至目的文件  let bufSize = 4096;  let readSize = 0;  let buf = new ArrayBuffer(bufSize);  let readLen = fs.readSync(srcFile.fd, buf, { offset: readSize });  while (readLen > 0) {    readSize += readLen;    fs.writeSync(destFile.fd, buf);    readLen = fs.readSync(srcFile.fd, buf, { offset: readSize });  }  // 关闭文件  fs.closeSync(srcFile);  fs.closeSync(destFile);} 
说明
 使用读写接口时，需注意可选项参数offset的设置。对于已存在且读写过的文件，文件偏移指针默认在上次读写操作的终止位置。 
    以流的形式读写文件 以下示例代码演示了如何使用流接口进行文件读写： 已复制// pages/xxx.etsimport fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
async function readWriteFileWithStream() {  // 获取应用文件路径  let context = getContext(this) as common.UIAbilityContext;  let filesDir = context.filesDir;
  // 打开文件流  let inputStream = fs.createStreamSync(filesDir + '/test.txt', 'r+');  let outputStream = fs.createStreamSync(filesDir + '/destFile.txt', "w+");  // 以流的形式读取源文件内容并写入目的文件  let bufSize = 4096;  let readSize = 0;  let buf = new ArrayBuffer(bufSize);  let readLen = await inputStream.read(buf, { offset: readSize });  readSize += readLen;  while (readLen > 0) {    await outputStream.write(buf);    readLen = await inputStream.read(buf, { offset: readSize });    readSize += readLen;  }  // 关闭文件流  inputStream.closeSync();  outputStream.closeSync();} 
说明
 使用流接口时，需注意流的及时关闭。同时流的异步接口应严格遵循异步接口使用规范，避免同步、异步接口混用。流接口不支持并发读写。 
   查看文件列表 以下示例代码演示了如何查看文件列表： 已复制// 查看文件列表import fs from '@ohos.file.fs';import common from '@ohos.app.ability.common';
// 获取应用文件路径let context = getContext(this) as common.UIAbilityContext;let filesDir = context.filesDir;
// 查看文件列表let options = {  recursion: false,  listNum: 0,  filter: {    suffix: ['.png', '.jpg', '.txt'],          // 匹配文件后缀名为'.png','.jpg','.txt'    displayName: ['test*'],                    // 匹配文件全名以'test'开头    fileSizeOver: 0,                           // 匹配文件大小大于等于0    lastModifiedAfter: new Date(0).getTime(),  // 匹配文件最近修改时间在1970年1月1日之后  },}let files = fs.listFileSync(filesDir, options);for (let i = 0; i < files.length; i++) {  console.info(`The name of file: ${files[i]}`);}   上一篇 应用文件访问与管理 下一篇 应用文件上传下载 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用文件访问与管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    应用文件访问  应用文件上传下载  应用及文件系统空间统计   上一篇 应用沙箱目录 下一篇 应用文件访问 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用文件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。“应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“应用沙箱目录”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。系统文件及其目录对于应用是只读的；应用仅能保存文件到“应用文件目录”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。 下文将详细介绍应用沙箱、应用文件目录、应用文件访问与管理、应用文件分享等相关内容。  上一篇 应用文件 下一篇 应用沙箱目录 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。上传应用文件下载网络资源文件至应用文件目录应用文件上传下载 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用可以将应用文件上传到网络服务器，也可以从网络服务器下载网络资源文件到本地应用文件目录。  上传应用文件 开发者可以使用上传下载模块（ohos.request）的上传接口将本地文件上传。文件上传过程使用系统服务代理完成。 
说明
 当前上传应用文件功能，仅支持上传应用缓存文件路径（cacheDir）下的文件。 使用上传下载模块接口，需申请相关权限：ohos.permission.INTERNET。 
 以下示例代码演示了如何将应用缓存文件路径下的文件上传至网络服务器。 已复制// pages/xxx.etsimport common from '@ohos.app.ability.common';import fs from '@ohos.file.fs';import request from '@ohos.request';
// 获取应用文件路径let context = getContext(this) as common.UIAbilityContext;let cacheDir = context.cacheDir;
// 新建一个本地应用文件let file = fs.openSync(cacheDir + '/test.txt', fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);fs.writeSync(file.fd, 'upload file test');fs.closeSync(file);
// 上传任务配置项let uploadConfig = {  url: 'https://xxx',  header: { key1: 'value1', key2: 'value2' },  method: 'POST',  files: [    { filename: 'test.txt', name: 'test', uri: 'internal://cache/test.txt', type: 'txt' }  ],  data: [    { name: 'name', value: 'value' }  ]}
// 将本地应用文件上传至网络服务器try {  request.uploadFile(context, uploadConfig)    .then((uploadTask) => {      uploadTask.on('complete', (taskStates) => {        for (let i = 0; i < taskStates.length; i++) {          console.info(`upload complete taskState: ${JSON.stringify(taskStates[i])}`);        }      });    })    .catch((err) => {      console.error(`Invoke uploadFile failed, code is ${err.code}, message is ${err.message}`);    })} catch (err) {  console.error(`Invoke uploadFile failed, code is ${err.code}, message is ${err.message}`);}   下载网络资源文件至应用文件目录 开发者可以使用上传下载模块（ohos.request）的下载接口将网络资源文件下载到应用文件目录。对已下载的网络资源文件，开发者可以使用基础文件IO接口（ohos.file.fs）对其进行访问，使用方式与应用文件访问一致。文件下载过程使用系统服务代理完成。 
说明
 当前网络资源文件仅支持下载至应用文件目录。 使用上传下载模块接口，需申请相关权限：ohos.permission.INTERNET。 
 以下示例代码演示了如何将网络资源文件下载到应用文件目录： 已复制// pages/xxx.ets// 将网络资源文件下载到应用文件目录并读取一段内容import common from '@ohos.app.ability.common';import fs from '@ohos.file.fs';import request from '@ohos.request';
// 获取应用文件路径let context = getContext(this) as common.UIAbilityContext;let filesDir = context.filesDir;
try {  request.downloadFile(context, {    url: 'https://xxxx/xxxx.txt',    filePath: filesDir + '/xxxx.txt'  }).then((downloadTask) => {    downloadTask.on('complete', () => {      console.info('download complete');      let file = fs.openSync(filesDir + '/xxxx.txt', fs.OpenMode.READ_WRITE);      let buf = new ArrayBuffer(1024);      let readLen = fs.readSync(file.fd, buf);      console.info(`The content of file: ${String.fromCharCode.apply(null, new Uint8Array(buf.slice(0, readLen)))}`);      fs.closeSync(file);    })  }).catch((err) => {    console.error(`Invoke downloadTask failed, code is ${err.code}, message is ${err.message}`);  });} catch (err) {  console.error(`Invoke downloadFile failed, code is ${err.code}, message is ${err.message}`);}   上一篇 应用文件访问 下一篇 应用及文件系统空间统计 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发示例应用及文件系统空间统计 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在系统中，可能出现系统空间不够或者cacheDir等目录受系统配额限制等情况，需要应用开发者关注系统剩余空间，同时控制应用自身占用的空间大小。  接口说明 API的详细介绍请参见ohos.file.statvfs、ohos.file.storageStatistics。    表1 文件系统空间和应用空间统计          模块 接口名 功能    @ohos.file.storageStatistics getCurrentBundleStats 获取当前应用的存储空间大小（单位为Byte）。   @ohos.file.statvfs getFreeSize 获取指定文件系统的剩余空间大小（单位为Byte）。   @ohos.file.statvfs getTotalSize 获取指定文件系统的总空间大小（单位为Byte）。       表2 应用空间统计          BundleStats属性 含义 统计路径    appSize 应用安装文件大小（单位为Byte） 应用安装文件保存在以下目录： /data/storage/el1/bundle   cacheSize 应用缓存文件大小（单位为Byte） 应用的缓存文件保存在以下目录： /data/storage/el1/base/cache /data/storage/el1/base/haps/entry/cache /data/storage/el2/base/cache /data/storage/el2/base/haps/entry/cache   dataSize 应用文件存储大小（除应用安装文件和缓存文件）（单位为Byte） 应用文件由本地文件、分布式文件以及数据库文件组成。 本地文件保存在以下目录（注意缓存文件目录为以下目录的子目录）： /data/storage/el1/base /data/storage/el2/base 分布式文件保存在以下目录： /data/storage/el2/distributedfiles 数据库文件保存在以下目录： /data/storage/el1/database /data/storage/el2/database      开发示例  获取文件系统数据分区剩余空间大小。已复制import statvfs from '@ohos.file.statvfs';
let path = "/data";statvfs.getFreeSize(path, (err, number) => {  if (err) {    console.error(`Invoke getFreeSize failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info(`Invoke getFreeSize succeeded, size is ${number}`);  }}); 获取当前应用的存储空间大小。已复制import storageStatistics from "@ohos.file.storageStatistics";
storageStatistics.getCurrentBundleStats((err, bundleStats) => {  if (err) {    console.error(`Invoke getCurrentBundleStats failed, code is ${err.code}, message is ${err.message}`);  } else {    console.info(`Invoke getCurrentBundleStats succeeded, appsize is ${bundleStats.appSize}`);  }});    上一篇 应用文件上传下载 下一篇 向应用沙箱推送文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用沙箱目录与应用沙箱路径应用文件目录与应用文件路径应用沙箱目录 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用沙箱是一种以安全防护为目的的隔离机制，避免数据受到恶意路径穿越访问。在这种沙箱的保护机制下，应用可见的目录范围即为“应用沙箱目录”。  对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“应用文件目录”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。 应用沙箱限制了应用可见的数据的最小范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。因此，本应用的文件也不为其他应用可见，从而保护了应用文件的安全。 应用可以在“应用文件目录”下保存和处理自己的应用文件；系统文件及其目录对于应用是只读的；而应用若需访问用户文件，则需要通过特定API同时经过用户的相应授权才能进行。  下图展示了应用沙箱下，应用可访问的文件范围和方式。  图1 应用沙箱文件访问关系图   应用沙箱目录与应用沙箱路径 在应用沙箱保护机制下，应用无法获知除自身应用文件目录之外的其他应用或用户的数据目录位置及存在。同时，所有应用的目录可见范围均经过权限隔离与文件路径挂载隔离，形成了独立的路径视图，屏蔽了实际物理路径：  如下图所示，在普通应用（也称三方应用）视角下，不仅可见的目录与文件数量限制到了最小范围，并且可见的目录与文件路径也与系统进程等其他进程看到的不同。我们将普通应用视角下看到的“应用沙箱目录”下某个文件或某个具体目录的路径，称为“应用沙箱路径”。 一般情况下，开发者的hdc shell环境等效于系统进程视角，因此“应用沙箱路径”与开发者使用hdc工具调试时看到的真实物理路径不同，其对应关系详见应用沙箱路径和调试进程视角下的真实物理路径。 从实际物理路径推导物理路径与沙箱路径并不是1：1的映射关系，沙箱路径总是少于系统进程视角可见的物理路径。有些调试进程视角下的物理路径在对应的应用沙箱目录是无法找到的，而沙箱路径总是能够找到其对应的物理路径。   图2 应用沙箱路径（不同权限与角色的进程下可见的文件路径不同）    应用文件目录与应用文件路径 如前文所述，“应用沙箱目录”内分为两类：应用文件目录和系统文件目录。 系统文件目录对应用的可见范围由HarmonyOS系统预置，开发者无需关注。 在此主要介绍应用文件目录，如下图所示。应用文件目录下某个文件或某个具体目录的路径称为应用文件路径。应用文件目录下的各个文件路径，具备不同的属性和特征。   图3 应用文件目录结构图   一级目录data/：代表应用文件目录。 二级目录storage/：代表本应用持久化文件目录。 三级目录el1/、el2/：代表不同文件加密类型。       el1，设备级加密区：设备开机后即可访问的数据区。 el2，用户级加密区：设备开机后，需要至少一次解锁对应用户的锁屏界面（密码、指纹、人脸等方式或无密码状态）后，才能够访问的加密数据区。  应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户解锁前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。切换应用文件加密类型目录的方法请参见获取和修改加密分区。 四级、五级目录：通过ApplicationContext可以获取base下的files、cache、preferences、temp、distributedfiles等目录的应用文件路径，应用全局信息可以存放在这些目录下。 通过UIAbilityContext、AbilityStageContext、ExtensionContext可以获取hap级别应用文件路径。HAP信息可以存放在这些目录下，存放在此目录的文件会跟随HAP的卸载而删除，不会影响app级别目录下的文件。在开发态，一个应用包含一个或者多个HAP，详见Stage模型应用程序包结构。 Context上下文获取及上述应用文件路径的获取，详见应用上下文Context。 
说明
  禁止直接使用上图中四级目录之前的目录名组成的路径字符串，否则可能导致后续应用版本因应用文件路径变化导致不兼容问题。 应通过Context属性获取应用文件路径，包括但不限于上图中绿色背景的路径。  
 应用文件路径具体说明及生命周期如下表所示。    表1 应用文件路径详细说明           目录名 Context属性名称 类型 说明    bundle bundleCodeDir 安装文件路径 应用安装后的app的hap资源包所在目录；随应用卸载而清理。   base NA 本设备文件路径 应用在本设备上存放持久化数据的目录，子目录包含files/、cache/、temp/和haps/；随应用卸载而清理。   database databaseDir 数据库路径 应用在el1加密条件下存放通过分布式数据库服务操作的文件目录；随应用卸载而清理。   distributedfiles distributedFilesDir 分布式文件路径 应用在el2加密条件下存放分布式文件的目录，应用将文件放入该目录可分布式跨设备直接访问；随应用卸载而清理。   files filesDir 应用通用文件路径 应用在本设备内部存储上通用的存放默认长期保存的文件路径；随应用卸载而清理。   cache cacheDir 应用缓存文件路径 应用在本设备内部存储上用于缓存下载的文件或可重新生成的缓存文件的路径，应用cache目录大小超过配额或者系统空间达到一定条件，自动触发清理该目录下文件；用户通过系统空间管理类应用也可能触发清理该目录。应用需判断文件是否仍存在，决策是否需重新缓存该文件。   preferences preferencesDir 应用首选项文件路径 应用在本设备内部存储上通过数据库API存储配置类或首选项的目录；随应用卸载而清理。详见通过用户首选项实现数据持久化。   temp tempDir 应用临时文件路径 应用在本设备内部存储上仅在应用运行期间产生和需要的文件，应用退出后即清理。    对于上述各类应用文件路径，常见使用场景如下：  安装文件路径可以用于存储应用的代码资源数据，主要包括应用安装的HAP资源包、可重复使用的库文件以及插件资源等。此路径下存储的代码资源数据可以被用于动态加载。 数据库路径仅用于保存应用的私有数据库数据，主要包括数据库文件等。此路径下仅适用于存储分布式数据库相关文件数据。 分布式文件路径可以用于保存应用分布式场景下的数据，主要包括应用多设备共享文件、应用多设备备份文件、应用多设备群组协助文件。此路径下存储这些数据，使得应用更加适合多设备使用场景。 应用通用文件路径可以用于保存应用的任何私有数据，主要包括用户持久性文件、图片、媒体文件以及日志文件等。此路径下存储这些数据，使得数据保持私有、安全且持久有效。 应用缓存文件路径可以用于保存应用的缓存数据，主要包括离线数据、图片缓存、数据库备份以及临时文件等。此路径下存储的数据可能会被系统自动清理，因此不要存储重要数据。 应用首选项文件路径可以用于保存应用的首选项数据，主要包括应用首选项文件以及配置文件等。此路径下仅适用于存储小量数据。 应用临时文件路径可以用于保存应用的临时生成的数据，主要包括数据库缓存、图片缓存、临时日志文件、以及下载的应用安装包文件等。此路径下存储使用后即可删除的数据。    上一篇 应用文件概述 下一篇 应用文件访问与管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。version对象内部结构apiVersion内部结构app对象内部结构 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 app对象包含应用全局配置信息，内部结构如下： 表1 app对象内部结构说明 属性名称  含义  数据类型  是否可缺省    bundleName  标识应用的Bundle名称，用于标识应用的唯一性。Bundle名称是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~127字节。Bundle名称通常采用反向域名形式表示（例如，"com.example.myapplication"）。建议第一级为域名后缀"com"，第二级为厂商/个人名，也可以采用多级。  字符串  不可缺省。   vendor  标识对应用开发厂商的描述。字符串长度不超过255字节。  字符串  可缺省，缺省值为空。   version  标识应用的版本信息。  对象  不可缺省。   apiVersion  标识应用程序所依赖的HarmonyOS API版本。  对象  可缺省，缺省值为空。   smartWindowSize  标识应用在模拟器中运行时使用的屏幕尺寸。  字符串  可缺省，缺省值为空。   smartWindowDeviceType  标识应用在模拟器中运行时可以模拟的设备。  字符串数组  可缺省，缺省值为空。     version对象内部结构表2 version对象内部结构说明 属性名称  含义  数据类型  是否可缺省    name  标识应用的版本号，用于向应用的终端用户呈现。取值可以自定义，长度不超过127字节。自定义规则如下：API5及更早的版本：推荐使用三段数字版本号（也兼容两段式版本号），如A.B.C(也兼容A.B)，其中A、B、C取值为0-999范围内的整数。除此之外不支持其他格式。 A段，一般表示主版本号(Major)。 B段，一般表示次版本号(Minor)。 C段，一般表示修订版本号(Patch)。API6版本起：推荐采用四段式数字版本号，如A.B.C.D，其中A、B、C取值为0-99范围内的整数，D的取值为0-999范围内的整数。 A段，一般表示主版本号(Major)。 B段，一般表示次版本号(Minor)。 C段，一般表示特性版本号(Feature)。 D段，一般表示修订版本号(Patch)。  数值  不可缺省。   code  标识应用的版本号，仅用于HarmonyOS管理该应用，不对应用的终端用户呈现。取值规则如下：API5及更早版本：二进制32位以内的非负整数，需要从version.name的值转换得到。转换规则为：code值=A * 1,000,000 + B * 1,000 + C例如，version.name字段取值为2.2.1，则code值为2002001。API6版本起：code的取值不与version.name字段的取值关联，开发者可自定义code取值，取值范围为2^31以内的非负整数，但是每次应用版本的更新，均需要更新code字段的值，新版本code取值必须大于旧版本code的值。  数值  不可缺省。   minCompatibleVersionCode  标识应用可兼容的最低版本号，用于跨设备场景下，判断其他设备上该应用的版本是否兼容。格式与version.code字段的格式要求相同。 
说明
当前版本暂不支持跨设备能力。 
  数值  可缺省，缺省值为code标签值。      apiVersion内部结构表3 apiVersion内部结构说明 属性名称  含义  数据类型  是否可缺省    compatible  运行应用所需要的最低API版本，取值范围为0~2147483647。  数值  配置在build.profile中，打包时由IDE填充到config.json中。   target  用于标识应用运行时使用的API版本，取值范围为0~2147483647。  数值  配置在build.profile中，打包时由IDE填充到config.json中。   releaseType  用于标识应用运行时SDK的状态。 canary：面向特定开发者早期预览版本，不承诺质量，不承诺API稳定。 beta：公开发布的Beta版本，早期Beta版本不承诺API稳定，经历若干次发布后，通过Release Notes对开发者声明该Beta版本为API稳定里程碑，后续版本的API冻结。 release：正式发布版本，承诺质量，API不可变更。当版本处于此状态时版本号中不呈现Stage字段。  字符串  配置在build.profile中，打包时由IDE填充到config.json中。     app对象示例 已复制"app": {    "bundleName": "com.example.myapplication",    "vendor": "example",    "version": {      "code": 8,      "name": "8.0.1"    },    "apiVersion": {      "compatible": 8,      "target": 9,      "releaseType": "Beta1"    }  }   上一篇 应用配置文件概述（FA模型） 下一篇 deviceConfig内部结构 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。附录 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     代码检查规则表  通过DevEco Studio编译和上传软件包  DevEco Studio配置参数列表   上一篇 hvigor命令行 下一篇 代码检查规则表 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用/组件级配置 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  开发者在开发应用时，需要配置应用的一些标签，例如应用的包名、图标等标识特征的属性。这一章节描述了开发者在开发应用时需要配置的一些关键标签。  应用包名配置 应用包名需在config.json文件中app标签下配置bundleName字段，该字段用于指定应用的包名，需保证唯一性。包名是由字母、数字、下划线（_）和点号（.）组成的字符串，必须以字母开头。支持的字符串长度为7~127字节。包名通常采用反向域名形式表示（例如，"com.example.myapplication"）。建议第一级为域名后缀"com"，第二级为厂商/个人名，也可以采用多级。应用名称配置可以参考app标签说明。 应用图标和标签配置 FA模型不支持直接配置应用图标和标签，会以符合规则的PageAbility的图标和标签作为应用图标和标签。PageAbility的图标和标签配置请参见PageAbility组件配置。需在config.json文件的abilities标签下配置icon字段，标签值为资源文件的索引。图标需要在配置IDE的资源文件中，路径为/resource/base/media。取值示例：$media:ability_icon。标签值为资源文件的索引，标识Ability对用户显示的名称。取值可以是Ability名称，也可以是对该名称的资源索引，以支持多语言。如果在该Ability的skills属性中，actions的取值包含 "action.system.home"，entities取值中包含"entity.system.home"，则该Ability的icon和label将同时作为应用的icon和label。如果存在多个符合条件的Ability，则取位置靠前的Ability的icon和label作为应用的icon和label。应用图标和标签配置可以参考abilities标签说明。 已复制  "abilities": [    "icon": "$media:icon",    "label": "$string:MainAbility_label",    "skills": [        {        "entities": ["entity.system.home"],        "actions": ["action.system.home"]      }    ]    // ...  } 应用版本声明配置 应用版本声明配置需在config.json中的app标签下配置version字段，以说明应用当前的版本号和版本名称以及应用能够兼容的最低历史版本号。应用版本配置说明可以参考version标签说明。 Module支持的设备类型配置 Module支持的设备类型需要在config.json文件中配置deviceType字段，如果deviceType标签中添加了某种设备，则表明当前的module支持在该设备上运行。具体的deviceType配置规则可以参考deviceType标签说明。 组件权限申请配置 组件权限申请配置需在confog.json中的module标签下配置reqPermission字段。来声明需要申请权限的名称，申请权限的原因以及权限使用的场景。组件权限申请可以参考reqPermission标签说明。   上一篇 FA模型应用组件 下一篇 PageAbility组件开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用/组件级配置 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在开发应用时，需要配置应用的一些标签，例如应用的包名、图标等标识特征的属性。本文描述了在开发应用需要配置的一些关键标签。图标和标签通常一起配置，可以分为应用图标、应用标签和入口图标、入口标签，分别对应app.json5配置文件和module.json5配置文件文件中的icon和label标签。应用图标和标签是在设置应用中使用，例如设置应用中的应用列表。入口图标是应用安装完成后在设备桌面上显示出来的，如图一所示。入口图标是以UIAbility为粒度，支持同一个应用存在多个入口图标和标签，点击后进入对应的UIAbility界面。 图1 应用图标和标签   应用包名配置 应用需要在工程的AppScope目录下的app.json5配置文件中配置bundleName标签，该标签用于标识应用的唯一性。推荐采用反域名形式命名（如com.example.demo，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。 应用图标和标签配置 Stage模型的应用需要配置应用图标和应用标签。应用图标和标签是在设置应用中使用，例如设置应用中的应用列表，会显示出对应的图标和标签。 应用图标需要在工程的AppScope目录下的app.json5配置文件中配置icon标签。应用图标需配置为图片的资源索引，配置完成后，该图片即为应用的图标。 应用标签需要在工程的AppScope模块下的app.json5配置文件中配置label标签。标识应用对用户显示的名称，需要配置为字符串资源的索引。 已复制  {    "app": {      "icon": "$media:app_icon",      "label": "$string:app_name"      // ...    }  } 入口图标和标签配置 Stage模型支持对组件配置入口图标和入口标签。入口图标和入口标签会显示在桌面上。 入口图标需要在module.json5配置文件中配置，在abilities标签下面有icon标签。例如希望在桌面上显示该UIAbility的图标，则需要在skills标签下面的entities中添加"entity.system.home"、actions中添加"action.system.home"。同一个应用有多个UIAbility配置上述字段时，桌面上会显示出多个图标，分别对应各自的UIAbility。 已复制{  "module": {    // ...    "abilities": [      {        // $开头的为资源值        "icon": "$media:icon",        "label": "$string:EntryAbility_label",        "skills": [          {            "entities": [              "entity.system.home"            ],            "actions": [              "action.system.home"            ]          }        ],      }    ]  }} 应用版本声明配置 应用版本声明需要在工程的AppScope目录下的app.json5配置文件中配置versionCode标签和versionName标签。versionCode用于标识应用的版本号，该标签值为32位非负整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。versionName标签标识版本号的文字描述。 Module支持的设备类型配置 Module支持的设备类型需要在module.json5配置文件中配置deviceTypes标签，如果deviceTypes标签中添加了某种设备，则表明当前的Module支持在该设备上运行。 Module权限配置 Module访问系统或其他应用受保护部分所需的权限信息需要在module.json5配置文件中配置requestPermission标签。该标签用于声明需要申请权限的名称、申请权限的原因以及权限使用的场景。   上一篇 Stage模型应用组件 下一篇 UIAbility组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。配置文件的内部结构应用配置文件概述（FA模型） 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 每个应用项目必须在项目的代码目录下加入配置文件，这些配置文件会向HarmonyOS的编译工具、HarmonyOS操作系统和应用市场提供描述应用的基本信息。 应用配置文件需申明以下内容： 应用的软件包名称，应用的开发厂商，版本号等应用的基本配置信息，这些信息被要求设置在app这个字段下。 应用的组件的基本信息，包括所有的Ability，设备类型，组件的类型以及当前组件所使用的语法类型。 应用在具体设备上的配置信息，这些信息会影响应用在设备上的具体功能。  在FA模型的应用开发过程中，需要在config.json配置文件中对应用的包结构进行声明。 配置文件的内部结构config.json由app、deviceConfig和module三个部分组成，缺一不可。 属性名称  含义  数据类型  是否可缺省    app  标识应用的全局配置信息。同一个应用的不同HAP的app配置必须保持一致。  对象  不可缺省。   deviceConfig  标识应用在具体设备上的配置信息。  对象  不可缺省。   module  标识HAP的配置信息。该标签下的配置只对当前HAP生效。  对象  不可缺省。     config.json示例： 已复制{  "app": {    "vendor": "example",    "bundleName": "com.example.demo",    "version": {      "code": 1000000,      "name": "1.0.0"    }  },  "deviceConfig": {  },  "module": {    "mainAbility": ".MainAbility_entry",    "deviceType": [      "tablet"    ],    "commonEvents": [      {        "name": ".MainAbility",        "permission": "ohos.permission.GET_BUNDLE_INFO",        "data": [          "com.example.demo",          "100"        ],        "events": [          "install",          "update"        ]      }    ],    "abilities": [      {        "skills": [          {            "entities": [              "entity.system.home"            ],            "actions": [              "action.system.home"            ]          }        ],        "orientation": "unspecified",        "visible": true,        "srcPath": "MainAbility_entry",        "name": ".MainAbility_entry",        "srcLanguage": "ets",        "icon": "$media:icon",        // $string:MainAbility_entry_desc为资源索引        "description": "$string:MainAbility_entry_desc",        "formsEnabled": false,        // $string:MainAbility_entry_label为资源索引        "label": "$string:MainAbility_entry_label",        "type": "page",        "launchType": "standard"      }    ],    "distro": {      "moduleType": "entry",      "installationFree": false,      "deliveryWithInstall": true,      "moduleName": "myapplication"    },    "package": "com.example.myapplication",    "srcPath": "",    "name": ".myapplication",    "js": [      {        "mode": {          "syntax": "ets",          "type": "pageAbility"        },        "pages": [          "pages/index"        ],        "name": ".MainAbility_entry",        "window": {          "designWidth": 720,          "autoDesignWidth": false        }      }    ]  }}   上一篇 应用配置文件（FA模型） 下一篇 app对象内部结构 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用配置文件概述（Stage模型） 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  每个应用项目必须在项目的代码目录下加入配置文件，这些配置文件会向编译工具、操作系统和应用市场提供应用的基本信息。 在基于Stage模型开发的应用项目代码下，都存在一个app.json5及一个或多个module.json5这两种配置文件。 app.json5主要包含以下内容：  应用的全局配置信息，包含应用的包名、开发厂商、版本号等基本信息。 特定设备类型的配置信息。  module.json5主要包含以下内容：  Module的基本配置信息，例如Module名称、类型、描述、支持的设备类型等基本信息。 应用组件信息，包含UIAbility组件和ExtensionAbility组件的描述信息。 应用运行过程中所需的权限信息。   上一篇 应用配置文件（Stage模型） 下一篇 app.json5配置文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发步骤FA模型的Context 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  FA模型下只有一个Context。Context中的所有功能都是通过方法来提供的，它提供了一些featureAbility中不存在的方法，相当于featureAbility的一个扩展和补全。  接口说明 FA模型下使用Context，需要通过featureAbility下的接口getContext来获取，而在此之前，需要先导入对应的包： 已复制import featureAbility from "@ohos.ability.featureAbility"; 然后使用如下方式获取对应的Context对象： 已复制let context = featureAbility.getContext() 最终返回的对象为Context，其对应的接口说明请参见接口文档。   开发步骤  查询Bundle信息。 已复制import featureAbility from '@ohos.ability.featureAbility'export default {  onCreate() {    // 获取context并调用相关方法    let context = featureAbility.getContext();    context.getBundleName((data, bundleName)=>{      console.info("ability bundleName:" + bundleName)    });    console.info('Application onCreate')  },  onDestroy() {    console.info('Application onDestroy')  },} 设置当前featureAbility的显示方向。 已复制import featureAbility from '@ohos.ability.featureAbility'import bundle from '@ohos.bundle';
export default {  onCreate() {    // 获取context并调用相关方法    let context = featureAbility.getContext();    context.setDisplayOrientation(bundle.DisplayOrientation.LANDSCAPE).then(() => {        console.info("Set display orientation.")    })    console.info('Application onCreate')  },  onDestroy() {    console.info('Application onDestroy')  },}    上一篇 服务卡片开发指导（FA模型） 下一篇 信息传递载体Want 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述Context的典型使用场景获取应用文件路径获取和修改加密分区创建其他应用或其他Module的Context订阅进程内Ability生命周期变化应用上下文Context 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 Context是应用中对象的上下文，其提供了应用的一些基础信息，例如resourceManager（资源管理）、applicationInfo（当前应用信息）、dir（应用开发路径）、area（文件分区）等，以及应用的一些基本方法，例如createBundleContext()、getApplicationContext()等。UIAbility组件和各种ExtensionAbility派生类组件都有各自不同的Context类。分别有基类Context、ApplicationContext、AbilityStageContext、UIAbilityContext、ExtensionContext、ServiceExtensionContext等Context。  各类Context的继承关系  各类Context的持有关系  各类Context的获取方式  获取UIAbilityContext。每个UIAbility中都包含了一个Context属性，提供操作Ability、获取Ability的配置信息、应用向用户申请授权等能力。 已复制import UIAbility from '@ohos.app.ability.UIAbility';export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        let uiAbilityContext = this.context;        // ...    }} 获取AbilityStageContext。Module级别的Context，和基类Context相比，额外提供HapModuleInfo、Configuration等信息。 已复制import AbilityStage from "@ohos.app.ability.AbilityStage";export default class MyAbilityStage extends AbilityStage {    onCreate() {        let abilityStageContext = this.context;        // ...    }} 获取ApplicationContext。应用级别的Context。ApplicationContext在基类Context的基础上提供了订阅应用内Ability的生命周期的变化、订阅系统内存变化和订阅应用内系统环境的变化的能力，在UIAbility、ExtensionAbility、AbilityStage中均可以获取。 已复制import UIAbility from '@ohos.app.ability.UIAbility';export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        let applicationContext = this.context.getApplicationContext();        // ...    }}     Context的典型使用场景 本章节通过如下典型场景来介绍Context的用法：  获取应用文件路径 获取和修改加密分区 创建其他应用或其他Module的Context 订阅进程内Ability生命周期变化    获取应用文件路径 基类Context提供了获取应用文件路径的能力，ApplicationContext、AbilityStageContext、UIAbilityContext和ExtensionContext均继承该能力。应用文件路径属于应用沙箱路径，具体请参见应用沙箱目录。 上述各类Context获取的应用文件路径有所不同。  通过ApplicationContext获取应用级别的应用文件路径，此路径是应用全局信息推荐的存放路径，这些文件会跟随应用的卸载而删除。     属性 路径    bundleCodeDir <路径前缀>/el1/bundle/   cacheDir <路径前缀>/<加密等级>/base/cache/   filesDir <路径前缀>/<加密等级>/base/files/   preferencesDir <路径前缀>/<加密等级>/base/preferences/   tempDir <路径前缀>/<加密等级>/base/temp/   databaseDir <路径前缀>/<加密等级>/database/   distributedFilesDir <路径前缀>/el2/distributedFiles/    通过AbilityStageContext、UIAbilityContext、ExtensionContext获取HAP级别的应用文件路径。此路径是HAP相关信息推荐的存放路径，这些文件会跟随HAP的卸载而删除，但不会影响应用级别路径的文件，除非该应用的HAP已全部卸载。     属性 路径    bundleCodeDir <路径前缀>/el1/bundle/   cacheDir <路径前缀>/<加密等级>/base/haps/<module-name>/cache/   filesDir <路径前缀>/<加密等级>/base/haps/<module-name>/files/   preferencesDir <路径前缀>/<加密等级>/base/haps/<module-name>/preferences/   tempDir <路径前缀>/<加密等级>/base/haps/<module-name>/temp/   databaseDir <路径前缀>/<加密等级>/database/<module-name>/   distributedFilesDir <路径前缀>/el2/distributedFiles/<module-name>/     示例代码如下。 已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        let cacheDir = this.context.cacheDir;        let tempDir = this.context.tempDir;        let filesDir = this.context.filesDir;        let databaseDir = this.context.databaseDir;        let bundleCodeDir = this.context.bundleCodeDir;        let distributedFilesDir = this.context.distributedFilesDir;        let preferencesDir = this.context.preferencesDir;        // ...    }}   获取和修改加密分区 上一个场景中，引入了加密等级的概念，通过对Context的area属性的读写来实现获取和设置当前加密分区，支持如下两种加密等级：  AreaMode.EL1：设备级加密区，设备开机后可访问的数据区。 AreaMode.EL2：用户级加密区，设备开机，首次输入密码后才能够访问的数据区。  已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        // 存储普通信息前，切换到EL1设备级加密        if (this.context.area === 1) { // 获取area            this.context.area = 0;     // 修改area        }        // 存储普通信息
        // 存储敏感信息前，切换到EL2用户级加密        if (this.context.area === 0) { // 获取area            this.context.area = 1;     // 修改area        }        // 存储敏感信息    }}   创建其他应用或其他Module的Context 基类Context提供创建其他应用或其他Module的Context的方法为createModuleContext(moduleName:string)，创建其他应用或者其他Module的Context，从而通过该Context获取相应的资源信息（例如获取其他Module的获取应用开发路径信息）。       调用createModuleContext(moduleName:string)方法，获取本应用中其他Module的Context。获取到其他Module的Context之后，即可获取到相应Module的资源信息。      已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        let moduleName2 = "module1";        let context2 = this.context.createModuleContext(moduleName2);        // ...    }}    订阅进程内Ability生命周期变化 在应用内的DFX统计场景，如需要统计对应页面停留时间和访问频率等信息，可以使用订阅进程内Ability生命周期变化功能。 在进程内Ability生命周期变化时，如创建、可见/不可见、获焦/失焦、销毁等，会触发进入相应的回调，其中返回的此次注册监听生命周期的ID（每次注册该ID会自增+1，当超过监听上限数量2^63-1时，返回-1），以在UIAbilityContext中使用为例进行说明。 已复制import UIAbility from '@ohos.app.ability.UIAbility';import Window from '@ohos.window';
const TAG: string = "[Example].[Entry].[EntryAbility]";
export default class EntryAbility extends UIAbility {    lifecycleId: number;
    onCreate(want, launchParam) {        let abilityLifecycleCallback = {            onAbilityCreate(ability) {                console.info(TAG, "onAbilityCreate ability:" + JSON.stringify(ability));            },            onWindowStageCreate(ability, windowStage) {                console.info(TAG, "onWindowStageCreate ability:" + JSON.stringify(ability));                console.info(TAG, "onWindowStageCreate windowStage:" + JSON.stringify(windowStage));            },            onWindowStageActive(ability, windowStage) {                console.info(TAG, "onWindowStageActive ability:" + JSON.stringify(ability));                console.info(TAG, "onWindowStageActive windowStage:" + JSON.stringify(windowStage));            },            onWindowStageInactive(ability, windowStage) {                console.info(TAG, "onWindowStageInactive ability:" + JSON.stringify(ability));                console.info(TAG, "onWindowStageInactive windowStage:" + JSON.stringify(windowStage));            },            onWindowStageDestroy(ability, windowStage) {                console.info(TAG, "onWindowStageDestroy ability:" + JSON.stringify(ability));                console.info(TAG, "onWindowStageDestroy windowStage:" + JSON.stringify(windowStage));            },            onAbilityDestroy(ability) {                console.info(TAG, "onAbilityDestroy ability:" + JSON.stringify(ability));            },            onAbilityForeground(ability) {                console.info(TAG, "onAbilityForeground ability:" + JSON.stringify(ability));            },            onAbilityBackground(ability) {                console.info(TAG, "onAbilityBackground ability:" + JSON.stringify(ability));            },            onAbilityContinue(ability) {                console.info(TAG, "onAbilityContinue ability:" + JSON.stringify(ability));            }        }        // 1. 通过context属性获取applicationContext        let applicationContext = this.context.getApplicationContext();        // 2. 通过applicationContext注册监听应用内生命周期        this.lifecycleId = applicationContext.on("abilityLifecycle", abilityLifecycleCallback);        console.info(TAG, "register callback number: " + JSON.stringify(this.lifecycleId));    }
    onDestroy() {        let applicationContext = this.context.getApplicationContext();        applicationContext.off("abilityLifecycle", this.lifecycleId, (error, data) => {            console.info(TAG, "unregister callback success, err: " + JSON.stringify(error));        });    }}   上一篇 AbilityStage组件容器 下一篇 信息传递载体Want 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。后台任务（Background Task）管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    后台任务总体概述  短时任务  长时任务  延迟任务  代理提醒   上一篇 跨设备文件访问 下一篇 后台任务总体概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用模型的构成要素 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 应用模型是HarmonyOS为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。 HarmonyOS应用模型的构成要素包括： 应用组件 应用组件是应用的基本组成单位，是应用的运行入口。用户启动、使用和退出应用过程中，应用组件会在不同的状态间切换，这些状态称为应用组件的生命周期。应用组件提供生命周期的回调函数，开发者通过应用组件的生命周期回调感知应用的状态变化。应用开发者在编写应用时，首先需要编写的就是应用组件，同时还需编写应用组件的生命周期回调函数，并在应用配置文件中配置相关信息。这样，操作系统在运行期间通过配置文件创建应用组件的实例，并调度它的生命周期回调函数，从而执行开发者的代码。 应用进程模型 应用进程模型定义应用进程的创建和销毁方式，以及进程间的通信方式。 应用线程模型 应用线程模型定义应用进程内线程的创建和销毁方式、主线程和UI线程的创建方式、线程间的通信方式。 应用任务管理模型 应用任务管理模型定义任务（Mission）的创建和销毁方式，以及任务与组件间的关系。HarmonyOS应用任务管理由系统应用负责，三方应用无需关注，下文不做具体介绍。 应用配置文件 应用配置文件中包含应用配置信息、应用组件信息、权限信息、开发者自定义信息等，这些信息在编译构建、分发和运行阶段分别提供给编译工具、应用市场和操作系统使用。   上一篇 应用模型概述 下一篇 应用模型解读 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS应用模型概况通过对比认识FA模型与Stage模型应用模型解读 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   HarmonyOS应用模型概况 随着系统的演进发展，HarmonyOS先后提供了两种应用模型：  FA（Feature Ability）模型：HarmonyOS早期版本开始支持的模型，已经不再主推。 Stage模型：HarmonyOS 3.1 Developer Preview版本开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。  Stage模型之所以成为主推模型，源于其设计思想。Stage模型的设计基于如下出发点。  为复杂应用而设计  多个应用组件共享同一个ArkTS引擎（运行ArkTS语言的虚拟机）实例，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。 采用面向对象的开发方式，使得复杂应用代码可读性高、易维护性好、可扩展性强。  支持多设备和多窗口形态 应用组件管理和窗口管理在架构层面解耦：  便于系统对应用组件进行裁剪（无屏设备可裁剪窗口）。 便于系统扩展窗口形态。 在多设备（如桌面设备和移动设备）上，应用组件可使用同一套生命周期。  平衡应用能力和系统管控成本 Stage模型重新定义应用能力的边界，平衡应用能力和系统管控成本。  提供特定场景（如卡片、输入法）的应用组件，以便满足更多的使用场景。 规范化后台进程管理：为保障用户体验，Stage模型对后台应用进程进行了有序治理，应用程序不能随意驻留在后台，同时应用后台行为受到严格管理，防止恶意应用行为。     通过对比认识FA模型与Stage模型 Stage模型与FA模型最大的区别在于：Stage模型中，多个应用组件共享同一个ArkTS引擎实例；而FA模型中，每个应用组件独享一个ArkTS引擎实例。因此在Stage模型中，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。Stage模型作为主推的应用模型，开发者通过它能够更加便利地开发出分布式场景下的复杂应用。 可通过如下对比表格了解两种模型的整体概况。 表1 FA模型与Stage模型差异概览     项目 FA模型 Stage模型    应用组件 1. 组件分类  - PageAbility组件：包含UI界面，提供展示UI的能力。详细介绍请参见PageAbility组件概述。 - ServiceAbility组件：提供后台服务的能力，无UI界面。详细介绍请参见ServiceAbility组件概述。 - DataAbility组件：提供数据分享的能力，无UI界面。详细介绍请参见DataAbility组件概述。 2. 开发方式 通过导出匿名对象、固定入口文件的方式指定应用组件。开发者无法进行派生，不利于扩展能力。 1. 组件分类  - UIAbility组件：包含UI界面，提供展示UI的能力，主要用于和用户交互。详细介绍请参见UIAbility组件概述。 - ExtensionAbility组件：提供特定场景（如卡片、输入法）的扩展能力，满足更多的使用场景。详细介绍请参见ExtensionAbility组件。 2. 开发方式 采用面向对象的方式，将应用组件以类接口的形式开放给开发者，可以进行派生，利于扩展能力。   进程模型 有两类进程： 1. 主进程 2. 渲染进程 详细介绍请参见进程模型。 有三类进程： 1. 主进程 2. ExtensionAbility进程 3. 渲染进程 详细介绍请参见进程模型。   线程模型 1. ArkTS引擎实例的创建 一个进程可以运行多个应用组件实例，每个应用组件实例运行在一个单独的ArkTS引擎实例中。 2. 线程模型 每个ArkTS引擎实例都在一个单独线程（非主线程）上创建，主线程没有ArkTS引擎实例。 3. 进程内对象共享：不支持。 详细介绍请参见线程模型。 1. ArkTS引擎实例的创建 一个进程可以运行多个应用组件实例，所有应用组件实例共享一个ArkTS引擎实例。 2. 线程模型 ArkTS引擎实例在主线程上创建。 3. 进程内对象共享：支持。 详细介绍请参见线程模型。   应用配置文件 使用config.json描述应用信息、HAP信息和应用组件信息。 详细介绍请参见应用配置文件概述（FA模型）。 使用app.json5描述应用信息，module.json5描述HAP信息、应用组件信息。 详细介绍请参见应用配置文件概述（Stage模型）。      上一篇 应用模型的构成要素 下一篇 Stage模型开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发者终端设备用户应用程序包安装和卸载流程 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  开发者开发者可以通过调试命令进行应用的安装和卸载，可参考多HAP的调试流程。 图1 应用程序包安装和卸载流程（开发者）     终端设备用户开发者将应用上架应用市场后，终端设备用户可以在终端设备上使用应用市场进行应用的安装和卸载。 图2 应用程序包安装和卸载流程（终端设备用户）    上一篇 多HAP运行机制及数据通信方式 下一篇 应用程序包更新流程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用程序包概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。一个应用所对应的软件包文件，称为“应用程序包”。 HarmonyOS提供了应用程序包开发、安装、查询、更新、卸载的管理机制，方便开发者开发和管理HarmonyOS应用，具体如下： 应用软件所涉及的文件多种多样，开发者可通过HarmonyOS提供的集成开发工具将其开发的可执行代码、资源、三方库等文件整合到一起制作成HarmonyOS应用程序包，便于开发者对应用程序的部署。 应用软件所涉及的设备类型多种多样，开发者可通过HarmonyOS提供的应用程序包配置文件指定其应用程序包的分发设备类型，便于应用市场对应用程序包的分发管理。 应用软件所包含的功能多种多样，将不同的功能特性按模块来划分和管理是一种良好的设计方式。HarmonyOS提供了同一应用程序的多包管理的机制，开发者可以将不同的功能特性聚合到不同的包中，方便后续的维护与扩展。 应用软件涉及的芯片平台多种多样，有x86、ARM等，还有32位、64位之分，HarmonyOS为应用程序包屏蔽了芯片平台的差异，使应用程序包在不同的芯片平台都能够安装运行。 应用软件涉及的软件信息多种多样，有应用版本、应用名称、组件、申请权限等的信息，HarmonyOS包管理为开发者提供了这些信息的查询接口，方便开发者在程序中查询所需要的包信息。 应用软件涉及的资源多种多样，有媒体资源、原生资源、字符资源以及国际化的资源等，HarmonyOS包管理将不同的资源归档到不同的目录中，并集成资源索引文件，方便应用对资源的查找和使用。   上一篇 应用程序包基础知识 下一篇 应用程序包结构 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。FA模型应用程序包结构 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 基于FA模型开发的应用，其应用程序包结构如下图应用程序包结构（FA模型）所示。开发者需要熟悉应用程序包结构相关的基本概念。 FA模型与Stage模型不同之处在于HAP内部文件存放位置不同，FA模型将所有的资源文件、库文件和代码文件都放在assets文件夹中，在文件夹内部进一步区分。 config.json是应用配置文件，IDE会自动生成一部分模块代码，开发者按需修改其中的配置。详细字段请参见应用配置文件。 assets是HAP所有的资源文件、库文件和代码文件的集合，内部可以分为entry和js文件夹。entry文件夹中存放的是resources目录和resources.index文件。 resources目录用于存放应用的资源文件（字符串、图片等），便于开发者使用和维护，详见资源分类与访问。 resources.index是资源索引表，由IDE调用SDK工具生成。 js文件夹中存放的是编译后的代码文件。 pack.info是Bundle中用于描述每个HAP属性的文件，例如app中的bundleName和versionCode信息、module中的name、type和abilities等信息，由IDE工具生成Bundle包时自动生成。  图1 应用程序包结构（FA模型）   上一篇 Stage模型应用程序包结构 下一篇 应用程序包多HAP机制 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Stage模型应用程序包结构 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  基于Stage模型开发的应用，经编译打包后，其应用程序包结构如下图应用程序包结构（Stage模型）所示。开发者需要熟悉应用程序包结构相关的基本概念。  在开发态，一个应用包含一个或者多个Module，可以在DevEco Studio工程中创建一个或者多个Module。Module是HarmonyOS应用/服务的基本功能单元，包含了源代码、资源文件、第三方库及应用/服务配置文件，每一个Module都可以独立进行编译和运行。Module分为“Ability”和“Library”两种类型，“Ability”类型的Module对应于编译后的HAP（Harmony Ability Package）；“Library”类型的Module对应于HAR（Harmony Archive），或者HSP（Harmony Shared Package）。 一个Module可以包含一个或多个UIAbility组件，如下图所示。 图1 Module与UIAbility组件关系示意图  全文中介绍到的Module默认指的是“Ability”类型的Module。 开发者通过DevEco Studio把应用程序编译为一个或者多个.hap后缀的文件，即HAP。HAP是HarmonyOS应用安装的基本单位，包含了编译后的代码、资源、三方库及配置文件。HAP可分为Entry和Feature两种类型。  Entry类型的HAP：是应用的主模块，在module.json5配置文件中的type标签配置为“entry”类型。在同一个应用中，同一设备类型只支持一个Entry类型的HAP，通常用于实现应用的入口界面、入口图标、主特性功能等。 Feature类型的HAP：是应用的动态特性模块，在module.json5配置文件中的type标签配置为“feature”类型。一个应用程序包可以包含一个或多个Feature类型的HAP，也可以不包含；Feature类型的HAP通常用于实现应用的特性功能，可以配置成按需下载安装，也可以配置成随Entry类型的HAP一起下载安装（请参见module对象内部结构中的“deliveryWithInstall”）。  每个HarmonyOS应用可以包含多个.hap文件，一个应用中的.hap文件合在一起称为一个Bundle，而bundleName就是应用的唯一标识（请参见app.json5配置文件中的bundleName标签）。需要特别说明的是：在应用上架到应用市场时，需要把应用包含的所有.hap文件（即Bundle）打包为一个.app后缀的文件用于上架，这个.app文件称为App Pack（Application Package），其中同时包含了描述App Pack属性的pack.info文件；在云端（服务器）分发和终端设备安装时，都是以HAP为单位进行分发和安装的。 打包后的HAP包结构包括ets、libs、resources等文件夹和resources.index、module.json、pack.info等文件。  ets目录用于存放应用代码编译后的字节码文件。 libs目录用于存放库文件。库文件是HarmonyOS应用依赖的第三方代码（.so二进制文件）。 resources目录用于存放应用的资源文件（字符串、图片等），便于开发者使用和维护，详见资源分类与访问。 resources.index是资源索引表，由IDE编译工程时生成。 module.json是HAP的配置文件，内容由工程配置中的module.json5和app.json5组成，该文件是HAP中必不可少的文件。IDE会自动生成一部分默认配置，开发者按需修改其中的配置。详细字段请参见应用配置文件。 pack.info是Bundle中用于描述每个HAP属性的文件，例如app中的bundleName和versionCode信息、module中的name、type和abilities等信息，由IDE工具生成Bundle包时自动生成。  图2 应用程序包结构（Stage模型）    上一篇 应用程序包结构 下一篇 FA模型应用程序包结构 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用程序包更新流程 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS包管理服务提供了应用程序包更新能力，更新方式如下。 应用市场内更新：新版本应用通过应用市场上架后，应用市场通知终端用户该应用有新版本，终端用户可以根据通知到应用市场（客户端）进行应用升级。应用内检测升级：终端用户启动应用时，应用市场检测到该应用有新版本会通知终端用户，可以到应用市场进行应用的下载更新。  上一篇 应用程序包安装和卸载流程 下一篇 共享包 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念场景介绍接口说明设置应用子窗口开发步骤体验窗口沉浸式能力开发步骤管理应用窗口（FA模型） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   基本概念 窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。 沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用子窗口（弹窗、悬浮窗口等辅助窗口）无法使用沉浸式能力。   场景介绍 在FA模型下，管理应用窗口的典型场景有：  设置应用子窗口属性及目标页面 体验窗口沉浸式能力  以下分别介绍具体开发方式。   接口说明 上述场景涉及的常用接口如下表所示。更多API说明请参见API参考。     实例名 接口名 描述    window静态方法 createWindow(config: Configuration, callback: AsyncCallback<Window>): void 创建子窗口。 -config：创建窗口时的参数。   window静态方法 findWindow(name: string): Window 查找name所对应的窗口。   Window setUIContent(path: string, callback: AsyncCallback<void>): void 为当前窗口加载具体页面内容。   Window moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void 移动当前窗口。   Window setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void 设置屏幕亮度值。   Window resize(width: number, height: number, callback: AsyncCallback<void>): void 改变当前窗口大小。   Window setWindowSystemBarEnable(names: Array<'status'|'navigation'>): Promise<void> 设置导航栏、状态栏是否显示。   Window showWindow(callback: AsyncCallback<void>): void 显示当前窗口。   Window on(type: 'touchOutside', callback: Callback<void>): void 开启本窗口区域外的点击事件的监听。   Window destroyWindow(callback: AsyncCallback<void>): void 销毁当前窗口。      设置应用子窗口 开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。   开发步骤  创建/获取子窗口对象。  可以通过window.createWindow接口创建子窗口。 也可以通过window.findWindow接口来查找已经创建的窗口从而得到子窗口。  已复制   import window from '@ohos.window';
   let windowClass = null;   // 方式一：创建子窗口。   let config = {name: "subWindow", windowType: window.WindowType.TYPE_APP};   window.createWindow(config, (err, data) => {       if (err.code) {           console.error('Failed to create the subWindow. Cause: ' + JSON.stringify(err));           return;       }       console.info('Succeeded in creating subWindow. Data: ' + JSON.stringify(data));       windowClass = data;   });   // 方式二：查找得到子窗口。   try {       windowClass = window.findWindow('subWindow');   } catch (exception) {       console.error('Failed to find the Window. Cause: ' + JSON.stringify(exception));   }  设置子窗口属性。子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。 已复制// 移动子窗口位置。windowClass.moveWindowTo(300, 300, (err) => {  if (err.code) {    console.error('Failed to move the window. Cause:' + JSON.stringify(err));    return;  }  console.info('Succeeded in moving the window.');});// 改变子窗口大小。windowClass.resize(500, 500, (err) => {  if (err.code) {    console.error('Failed to change the window size. Cause:' + JSON.stringify(err));    return;  }  console.info('Succeeded in changing the window size.');});  加载显示子窗口的具体内容。使用setUIContent和showWindow接口加载显示子窗口的具体内容。 已复制// 为子窗口加载对应的目标页面。windowClass.setUIContent("pages/page2", (err) => {    if (err.code) {        console.error('Failed to load the content. Cause: ' + JSON.stringify(err));        return;    }    console.info('Succeeded in loading the content.');    // 显示子窗口。    windowClass.showWindow((err) => {     if (err.code) {            console.error('Failed to show the window. Cause: ' + JSON.stringify(err));            return;        }        console.info('Succeeded in showing the window.');    });});  销毁子窗口。当不再需要某些子窗口时，可根据场景的具体实现逻辑，使用destroyWindow接口销毁子窗口。 已复制// 销毁子窗口。当不再需要某些子窗口时，可根据场景的具体实现逻辑，使用destroy接口销毁子窗口。windowClass.destroyWindow((err) => {    if (err.code) {        console.error('Failed to destroy the subwindow. Cause:' + JSON.stringify(err));        return;    }    console.info('Succeeded in destroying the subwindow.');});     体验窗口沉浸式能力 在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。   开发步骤  获取主窗口对象。 
说明
 沉浸式能力需要在成功获取应用主窗口对象的前提下进行。 确保应用内最后显示的窗口为主窗口，然后再使用window.getLastWindow接口来获取得到主窗口。 
 已复制import window from '@ohos.window';
let mainWindowClass = null;// 获取主窗口。window.getLastWindow(this.context,(err, data) => {  if (err.code) {    console.error('Failed to get the subWindow. Cause: ' + JSON.stringify(err));    return;  }  console.info('Succeeded in getting subWindow. Data: ' + JSON.stringify(data));  mainWindowClass = data;});  实现沉浸式效果。调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。  已复制// 实现沉浸式效果：设置导航栏、状态栏不显示。let names = [];mainWindowClass.setWindowSystemBarEnable(names, (err) => {  if (err.code) {    console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));    return;  }  console.info('Succeeded in setting the system bar to be visible.');});   加载显示沉浸式窗口的具体内容。使用setUIContent和showWindow接口加载显示沉浸式窗口的具体内容。 已复制// 为沉浸式窗口加载对应的目标页面。mainWindowClass.setUIContent("pages/page3", (err) => {    if (err.code) {        console.error('Failed to load the content. Cause: ' + JSON.stringify(err));        return;    }    console.info('Succeeded in loading the content.');    // 显示沉浸式窗口。    mainWindowClass.showWindow((err) => {        if (err.code) {            console.error('Failed to show the window. Cause: ' + JSON.stringify(err));            return;        }        console.info('Succeeded in showing the window.');    });});     上一篇 管理应用窗口（Stage模型） 下一篇 WebGL 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念场景介绍接口说明设置应用主窗口开发步骤设置应用子窗口开发步骤体验窗口沉浸式能力开发步骤设置悬浮窗开发步骤管理应用窗口（Stage模型） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   基本概念  窗口沉浸式能力：指对状态栏、导航栏等系统窗口进行控制，减少状态栏导航栏等系统界面的突兀感，从而使用户获得最佳体验的能力。沉浸式能力只在应用主窗口作为全屏窗口时生效。通常情况下，应用子窗口（弹窗、悬浮窗口等辅助窗口）无法使用沉浸式能力。   悬浮窗：全局悬浮窗口是一种特殊的应用窗口，具备在应用主窗口和对应Ability退至后台后仍然可以在前台显示的能力。 悬浮窗口可以用于应用退至后台后，使用小窗继续播放视频，或者为特定的应用创建悬浮球等快速入口。应用在创建悬浮窗口前，需要申请对应的权限。    场景介绍 在Stage模型下，管理应用窗口的典型场景有：  设置应用主窗口属性及目标页面 设置应用子窗口属性及目标页面 体验窗口沉浸式能力 设置悬浮窗  以下分别介绍具体开发方式。   接口说明 上述场景涉及的常用接口如下表所示。更多API说明请参见API参考。     实例名 接口名 描述    WindowStage getMainWindow(callback: AsyncCallback<Window>): void 获取WindowStage实例下的主窗口。 此接口仅可在Stage模型下使用。   WindowStage loadContent(path: string, callback: AsyncCallback<void>): void 为当前WindowStage的主窗口加载具体页面。 此接口仅可在Stage模型下使用。   WindowStage createSubWindow(name: string, callback: AsyncCallback<Window>): void 创建子窗口。 此接口仅可在Stage模型下使用。   window静态方法 createWindow(config: Configuration, callback: AsyncCallback<Window>): void 创建系统窗口。 -config：创建窗口时的参数。   Window setUIContent(path: string, callback: AsyncCallback<void>): void 为当前窗口加载具体页面。   Window setWindowBrightness(brightness: number, callback: AsyncCallback<void>): void 设置屏幕亮度值。   Window setWindowTouchable(isTouchable: boolean, callback: AsyncCallback<void>): void 设置窗口是否为可触状态。   Window moveWindowTo(x: number, y: number, callback: AsyncCallback<void>): void 移动当前窗口位置。   Window resize(width: number, height: number, callback: AsyncCallback<void>): void 改变当前窗口大小。   Window setWindowSystemBarEnable(names: Array<'status'|'navigation'>): Promise<void> 设置导航栏、状态栏是否显示。   Window showWindow(callback: AsyncCallback<void>): void 显示当前窗口。   Window on(type: 'touchOutside', callback: Callback<void>): void 开启本窗口区域外的点击事件的监听。   Window destroyWindow(callback: AsyncCallback<void>): void 销毁当前窗口。      设置应用主窗口 在Stage模型下，应用主窗口由UIAbility创建并维护生命周期。在UIAbility的onWindowStageCreate回调中，通过WindowStage获取应用主窗口，即可对其进行属性设置等操作。还可以在应用配置文件中设置应用主窗口的属性，如最大窗口宽度maxWindowWidth等，详见module.json5配置文件。   开发步骤  获取应用主窗口。通过getMainWindow接口获取应用主窗口。  设置主窗口属性。可设置主窗口的背景色、亮度值、是否可触等多个属性，开发者可根据需要选择对应的接口。本示例以设置“是否可触”属性为例。  为主窗口加载对应的目标页面。通过loadContent接口加载主窗口的目标页面。   已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onWindowStageCreate(windowStage) {        // 1.获取应用主窗口。        let windowClass = null;        windowStage.getMainWindow((err, data) => {            if (err.code) {                console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));                return;            }            windowClass = data;            console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));            // 2.设置主窗口属性。以设置"是否可触"属性为例。            let isTouchable = true;            windowClass.setWindowTouchable(isTouchable, (err) => {                if (err.code) {                    console.error('Failed to set the window to be touchable. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in setting the window to be touchable.');            })        })        // 3.为主窗口加载对应的目标页面。        windowStage.loadContent("pages/page2", (err) => {            if (err.code) {                console.error('Failed to load the content. Cause:' + JSON.stringify(err));                return;            }            console.info('Succeeded in loading the content.');        });    }};   设置应用子窗口 开发者可以按需创建应用子窗口，如弹窗等，并对其进行属性设置等操作。   开发步骤  创建应用子窗口。通过createSubWindow接口创建应用子窗口。  设置子窗口属性。子窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置窗口背景色、亮度等属性。  加载显示子窗口的具体内容。通过setUIContent和showWindow接口加载显示子窗口的具体内容。  销毁子窗口。当不再需要某些子窗口时，可根据具体实现逻辑，使用destroyWindow接口销毁子窗口。   已复制import UIAbility from '@ohos.app.ability.UIAbility';
let windowStage_ = null;let sub_windowClass = null;export default class EntryAbility extends UIAbility {    showSubWindow() {        // 1.创建应用子窗口。        windowStage_.createSubWindow("mySubWindow", (err, data) => {            if (err.code) {                console.error('Failed to create the subwindow. Cause: ' + JSON.stringify(err));                return;            }            sub_windowClass = data;            console.info('Succeeded in creating the subwindow. Data: ' + JSON.stringify(data));            // 2.子窗口创建成功后，设置子窗口的位置、大小及相关属性等。            sub_windowClass.moveWindowTo(300, 300, (err) => {                if (err.code) {                    console.error('Failed to move the window. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in moving the window.');            });            sub_windowClass.resize(500, 500, (err) => {                if (err.code) {                    console.error('Failed to change the window size. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in changing the window size.');            });            // 3.为子窗口加载对应的目标页面。            sub_windowClass.setUIContent("pages/page3", (err) => {                if (err.code) {                    console.error('Failed to load the content. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in loading the content.');                // 3.显示子窗口。                sub_windowClass.showWindow((err) => {                    if (err.code) {                        console.error('Failed to show the window. Cause: ' + JSON.stringify(err));                        return;                    }                    console.info('Succeeded in showing the window.');                });            });        })    }
    destroySubWindow() {        // 4.销毁子窗口。当不再需要子窗口时，可根据具体实现逻辑，使用destroy对其进行销毁。        sub_windowClass.destroyWindow((err) => {            if (err.code) {                console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));                return;            }            console.info('Succeeded in destroying the window.');        });    }
    onWindowStageCreate(windowStage) {        windowStage_ = windowStage;        // 开发者可以在适当的时机，如主窗口上按钮点击事件等，创建子窗口。并不一定需要在onWindowStageCreate调用，这里仅作展示        this.showSubWindow();    }
    onWindowStageDestroy() {        // 开发者可以在适当的时机，如子窗口上点击关闭按钮等，销毁子窗口。并不一定需要在onWindowStageDestroy调用，这里仅作展示        this.destroySubWindow();    }};   体验窗口沉浸式能力 在看视频、玩游戏等场景下，用户往往希望隐藏状态栏、导航栏等不必要的系统窗口，从而获得更佳的沉浸式体验。此时可以借助窗口沉浸式能力（窗口沉浸式能力都是针对应用主窗口而言的），达到预期效果。   开发步骤  获取应用主窗口。通过getMainWindow接口获取应用主窗口。  实现沉浸式效果。调用setWindowSystemBarEnable接口，设置导航栏、状态栏不显示，从而达到沉浸式效果。   加载显示沉浸式窗口的具体内容。通过loadContent接口加载沉浸式窗口的具体内容。   已复制import UIAbility from '@ohos.app.ability.UIAbility';
export default class EntryAbility extends UIAbility {    onWindowStageCreate(windowStage) {        // 1.获取应用主窗口。        let windowClass = null;        windowStage.getMainWindow((err, data) => {            if (err.code) {                console.error('Failed to obtain the main window. Cause: ' + JSON.stringify(err));                return;            }            windowClass = data;            console.info('Succeeded in obtaining the main window. Data: ' + JSON.stringify(data));
            // 2.实现沉浸式效果：设置导航栏、状态栏不显示。            let names = [];            windowClass.setWindowSystemBarEnable(names, (err) => {                if (err.code) {                    console.error('Failed to set the system bar to be visible. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in setting the system bar to be visible.');            });        })        // 3.为沉浸式窗口加载对应的目标页面。        windowStage.loadContent("pages/page2", (err) => {            if (err.code) {                console.error('Failed to load the content. Cause:' + JSON.stringify(err));                return;            }            console.info('Succeeded in loading the content.');        });    }};   设置悬浮窗 悬浮窗可以在已有的任务基础上，创建一个始终在前台显示的窗口。即使创建悬浮窗的任务退至后台，悬浮窗仍然可以在前台显示。通常悬浮窗位于所有应用窗口之上；开发者可以创建悬浮窗，并对悬浮窗进行属性设置等操作。   开发步骤 前提条件：创建WindowType.TYPE_FLOAT即悬浮窗类型的窗口，需要申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，配置方式请参见配置文件权限声明。  创建悬浮窗。通过window.createWindow接口创建悬浮窗类型的窗口。  对悬浮窗进行属性设置等操作。悬浮窗窗口创建成功后，可以改变其大小、位置等，还可以根据应用需要设置悬浮窗背景色、亮度等属性。  加载显示悬浮窗的具体内容。通过setUIContent和showWindow接口加载显示悬浮窗的具体内容。  销毁悬浮窗。当不再需要悬浮窗时，可根据具体实现逻辑，使用destroyWindow接口销毁悬浮窗。   已复制import UIAbility from '@ohos.app.ability.UIAbility';import window from '@ohos.window';
export default class EntryAbility extends UIAbility {    onWindowStageCreate(windowStage) {        // 1.创建悬浮窗。        let windowClass = null;        let config = {name: "floatWindow", windowType: window.WindowType.TYPE_FLOAT, ctx: this.context};        window.createWindow(config, (err, data) => {            if (err.code) {                console.error('Failed to create the floatWindow. Cause: ' + JSON.stringify(err));                return;            }            console.info('Succeeded in creating the floatWindow. Data: ' + JSON.stringify(data));            windowClass = data;            // 2.悬浮窗窗口创建成功后，设置悬浮窗的位置、大小及相关属性等。            windowClass.moveWindowTo(300, 300, (err) => {                if (err.code) {                    console.error('Failed to move the window. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in moving the window.');            });            windowClass.resize(500, 500, (err) => {                if (err.code) {                    console.error('Failed to change the window size. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in changing the window size.');            });            // 3.为悬浮窗加载对应的目标页面。            windowClass.setUIContent("pages/page4", (err) => {                if (err.code) {                    console.error('Failed to load the content. Cause:' + JSON.stringify(err));                    return;                }                console.info('Succeeded in loading the content.');                // 3.显示悬浮窗。                windowClass.showWindow((err) => {                    if (err.code) {                        console.error('Failed to show the window. Cause: ' + JSON.stringify(err));                        return;                    }                    console.info('Succeeded in showing the window.');                });            });            // 4.销毁悬浮窗。当不再需要悬浮窗时，可根据具体实现逻辑，使用destroy对其进行销毁。            windowClass.destroyWindow((err) => {                if (err.code) {                    console.error('Failed to destroy the window. Cause: ' + JSON.stringify(err));                    return;                }                console.info('Succeeded in destroying the window.');            });        });    }};   上一篇 窗口开发概述 下一篇 管理应用窗口（FA模型） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明应用恢复接口功能介绍框架故障管理流程示意应用故障管理接口支持场景开发示例使能开启自恢复特性数据保存和恢复应用恢复开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 应用在运行中不可避免会产生一些非预期的行为，如运行时抛出未处理的异常和错误，违反框架的调用/运行约束等。 系统默认对异常的处理方式为进程退出，如果应用使用过程中产生了用户数据，直接退出可能会导致用户工作中断，数据丢失。 如果使用应用故障恢复相关接口，则可对临时数据进行保存，应用退出后会重启应用并恢复先前的状态和数据，能给用户带来更好的使用体验。 目前该接口仅支持单进程单Ability的Stage模型应用开发。   接口说明 应用故障恢复接口由appRecovery模块提供，开发者可以通过import引入，详见开发示例。本文档描述的为API9版本的接口行为，后续接口行为变更会更新本文档。   应用恢复接口功能介绍     接口名称 说明    enableAppRecovery(restart?: RestartFlag, saveOccasion?: SaveOccasionFlag, saveMode?: SaveModeFlag) : void; 使能应用恢复功能。   saveAppState(): boolean; 主动保存当前应用中Ability的状态。   restartApp(): void; 重启当前进程，如果有已经保存的Ability状态，会在Ability的OnCreate生命周期回调的want参数中的wantParam属性传入。    由于本接口为故障处理时使用，不会返回异常，需要开发者熟悉使用的场景。 enableAppRecovery: 需要在应用初始化阶段调用，比如AbilityStage的OnCreate调用赋能。具体其各参数定义详见参数说明。 saveAppState: 调用后框架会回调Ability的onSaveState方法，如果在onSaveState方法中同意保存数据，则会将相关数据及Ability的页面栈持久化到应用的本地缓存。 restartApp: 调用后框架会杀死当前应用进程，并重新拉起处于前台的Ability，其中启动原因为APP_RECOVERY。   框架故障管理流程示意 故障管理是应用提升用户体验的重要手段。应用程序框架为开发者提供了故障监听、故障恢复、以及故障查询三种方式来管理应用的故障。  故障监听指的是通过errorManager注册ErrorObserver，监听故障的发生，并通知到监听方。 故障恢复指的是appRecovery，及故障发生后，将应用重启恢复到故障之前的状态。 故障查询指的是faultLogger通过其查询接口获取当前的故障信息。  下图中并没有标记faultLogger的调用时机，开发者可以根据应用启动时传入的LastExitReason来决定是否调用faultLogger查询上次的故障信息。  这里建议应用开发者使用errorManager对应用的异常进行处理，处理完成后开发者可以选择调用状态保存接口并主动重启应用。 如果开发者没有注册ErrorObserver也没有使能自动恢复，则按照系统的默认逻辑执行进程退出。用户可以选择从启动器再次打开应用。 如果开发者使能了自动恢复，框架会首先检查当前故障是否支持状态保存以及开发者是否配置了状态保存，如果支持则会回调Ability的onSaveState的接口。最后重启应用。   应用故障管理接口支持场景 通常的故障类型有JS程序Crash、应用程序卡死、C++程序Crash。Crash故障时应用一般都会被关闭。Freeze故障为应用无响应卡屏场景。应用上层无需关注故障类型，底层恢复框架会根据故障类型来实现不同场景的故障管理。     故障名称 故障监听 状态保存 自动重启 日志查询    JS_CRASH 支持 支持 支持 支持   APP_FREEZE 不支持 不支持 支持 支持   CPP_CRASH 不支持 不支持 不支持 支持    这里状态保存指的是故障时状态保存，对于应用卡死场景，开发者可以采用定时保存状态或者在Ability切入后台后自动保存的方式最大限度的保护用户数据。   开发示例   使能开启自恢复特性 开发者需要在应用模块初始化时使能appRecovery功能。下面为示例的AbilityStage。 已复制import AbilityStage from '@ohos.app.ability.AbilityStage'import appRecovery from '@ohos.app.ability.appRecovery'
export default class MyAbilityStage extends AbilityStage {    onCreate() {        console.info("[Demo] MyAbilityStage onCreate")        appRecovery.enableAppRecovery(appRecovery.RestartFlag.ALWAYS_RESTART,            appRecovery.SaveOccasionFlag.SAVE_WHEN_ERROR | appRecovery.SaveOccasionFlag.SAVE_WHEN_BACKGROUND,            appRecovery.SaveModeFlag.SAVE_WITH_FILE);    }}   数据保存和恢复 在使能appRecovery功能后，开发者可以在Ability中采用主动保存状态，主动恢复或者选择被动恢复的方式使用appRecovery功能。 下面为示例的MainAbility。  导包 已复制import errorManager from '@ohos.app.ability.errorManager'import appRecovery from '@ohos.app.ability.appRecovery'import AbilityConstant from '@ohos.app.ability.AbilityConstant' 主动触发保存和恢复  定义和注册ErrorObserver callback，具体可参考errorManager里的使用方法。  已复制  var registerId = -1;  var callback = {      onUnhandledException(errMsg) {          console.log(errMsg);          appRecovery.saveAppState();          appRecovery.restartApp();      }  }
  onWindowStageCreate(windowStage) {      // Main window is created, set main page for this ability      console.log("[Demo] EntryAbility onWindowStageCreate")
      globalThis.registerObserver = (() => {          registerId = errorManager.on('error', callback);      })
      windowStage.loadContent("pages/index", null);  }  数据保存  callback触发appRecovery.saveAppState()调用后，会触发MainAbility的onSaveState(state, wantParams)函数回调。 已复制  onSaveState(state, wantParams) {      // Ability has called to save app data      console.log("[Demo] EntryAbility onSaveState")      wantParams["myData"] = "my1234567";      return AbilityConstant.OnSaveResult.ALL_AGREE;  }  数据恢复  callback触发后appRecovery.restartApp()调用后，应用会重启，重启后会走到MainAbility的onCreate(want, launchParam)函数，保存的数据会在want参数的parameters里。 已复制storage: LocalStorageonCreate(want, launchParam) {    console.log("[Demo] EntryAbility onCreate")    globalThis.abilityWant = want;    if (launchParam.launchReason == AbilityConstant.LaunchReason.APP_RECOVERY) {        this.storage = new LocalStorage();        let recoveryData = want.parameters["myData"];        this.storage.setOrCreate("myData", recoveryData);        this.context.restoreWindowStage(this.storage);    }}  取消注册ErrorObserver callback  已复制onWindowStageDestroy() {    // Main window is destroyed, release UI related resources    console.log("[Demo] EntryAbility onWindowStageDestroy")
    globalThis.unRegisterObserver = (() => {        errorManager.off('error', registerId, (err) => {            console.error("[Demo] err:", err);        });    })} 被动保存和恢复 被动保存和恢复依赖恢复框架底层触发，无需注册监听ErrorObserver callback，只需实现Ability的onSaveState接口数据保存和onCreate接口数据恢复流程即可。 已复制export default class EntryAbility extends Ability {    storage: LocalStorage    onCreate(want, launchParam) {        console.log("[Demo] EntryAbility onCreate")        globalThis.abilityWant = want;        if (launchParam.launchReason == AbilityConstant.LaunchReason.APP_RECOVERY) {            this.storage = new LocalStorage();            let recoveryData = want.parameters["myData"];            this.storage.setOrCreate("myData", recoveryData);            this.context.restoreWindowStage(this.storage);        }    }
    onSaveState(state, wantParams) {        // Ability has called to save app data        console.log("[Demo] EntryAbility onSaveState")        wantParams["myData"] = "my1234567";        return AbilityConstant.OnSaveResult.ALL_AGREE;    }}  上一篇 错误管理开发指导 下一篇 国际化 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    动画概述  页面内的动画  页面间的动画   上一篇 使用画布绘制自定义图形（Canvas） 下一篇 动画概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。页面间的动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    放大缩小视图  页面转场动画   上一篇 弹簧曲线动画 下一篇 放大缩小视图 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。动画概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 动画的原理是在一个时间段内，多次改变UI外观，由于人眼会产生视觉暂留，所以最终看到的就是一个“连续”的动画。UI的一次改变称为一个动画帧，对应一次屏幕刷新，而决定动画流畅度的一个重要指标就是帧率FPS（Frame Per Second），即每秒的动画帧数，帧率越高则动画就会越流畅。 ArkUI中，产生动画的方式是改变属性值且指定动画参数。动画参数包含了如动画时长、变化规律（即曲线）等参数。当属性值发生变化后，按照动画参数，从原来的状态过渡到新的状态，即形成一个动画。 ArkUI提供的动画能力按照页面的分类方式，可分为页面内的动画和页面间的动画。如下图所示，页面内的动画指在一个页面内即可发生的动画，页面间的动画指两个页面跳转时才会发生的动画。 图1 按照页面分类的动画  如果按照基础能力分，可分为属性动画、显式动画、转场动画三部分。如下图所示。 图2 按照基础能力分类的动画  本文按照页面的分类方式，从使用场景出发，提供各种动画的使用方法和注意事项，使开发者快速学习动画。  上一篇 使用动画 下一篇 页面内的动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。页面内的动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    布局更新动画  组件内转场动画  弹簧曲线动画   上一篇 动画概述 下一篇 布局更新动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。管理应用拥有的状态 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    管理应用拥有的状态概述  LocalStorage：页面级UI状态存储  AppStorage：应用全局的UI状态存储  PersistentStorage：持久化存储UI状态  Environment：设备环境查询   上一篇 @Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化 下一篇 管理应用拥有的状态概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。管理应用拥有的状态概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  上一个章节中介绍的装饰器仅能在页面内，即一个组件树上共享状态变量。如果开发者要实现应用级的，或者多个页面的状态数据共享，就需要用到应用级别的状态管理的概念。ArkTS根据不同特性，提供了多种应用状态管理的能力：  LocalStorage：页面级UI状态存储，通常用于UIAbility内、页面间的状态共享。 AppStorage：特殊的单例LocalStorage对象，由UI框架在应用程序启动时创建，为应用程序UI状态属性提供中央存储； PersistentStorage：持久化存储UI状态，通常和AppStorage配合使用，选择AppStorage存储的数据写入磁盘，以确保这些属性在应用程序重新启动时的值与应用程序关闭时的值相同； Environment：应用程序运行的设备的环境参数，环境参数会同步到AppStorage中，可以和AppStorage搭配使用。   上一篇 管理应用拥有的状态 下一篇 LocalStorage：页面级UI状态存储 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述@StorageProp装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现@StorageLink装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现使用场景从应用逻辑使用AppStorage和LocalStorage从UI内部使用AppStorage和LocalStorage不建议借助@StorageLink的双向同步机制实现事件通知限制条件AppStorage：应用全局的UI状态存储 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 AppStorage是应用全局的UI状态存储，是和应用的进程绑定的，由UI框架在应用程序启动时创建，为应用程序UI状态属性提供中央存储。 和AppStorage不同的是，LocalStorage是页面级的，通常应用于页面内的数据共享。而AppStorage是应用级的全局状态共享，还相当于整个应用的“中枢”，持久化数据PersistentStorage和环境变量Environment都是通过和AppStorage中转，才可以和UI交互。 本文仅介绍AppStorage使用场景和相关的装饰器：@StorageProp和@StorageLink。 概述AppStorage是在应用启动的时候会被创建的单例。它的目的是为了提供应用状态数据的中心存储，这些状态数据在应用级别都是可访问的。AppStorage将在应用运行过程保留其属性。属性通过唯一的键字符串值访问。 AppStorage可以和UI组件同步，且可以在应用业务逻辑中被访问。 AppStorage中的属性可以被双向同步，数据可以是存在于本地或远程设备上，并具有不同的功能，比如数据持久化（详见PersistentStorage）。这些数据是通过业务逻辑中实现，与UI解耦，如果希望这些数据在UI中使用，需要用到@StorageProp和@StorageLink。  @StorageProp在上文中已经提到，如果要建立AppStorage和自定义组件的联系，需要使用@StorageProp和@StorageLink装饰器。使用@StorageProp(key)/@StorageLink(key)装饰组件内的变量，key标识了AppStorage的属性。 当自定义组件初始化的时候，@StorageProp(key)/@StorageLink(key)装饰的变量会通过给定的key，绑定在AppStorage对应的属性，完成初始化。本地初始化是必要的，因为无法保证AppStorage一定存在给定的key，这取决于应用逻辑，是否在组件初始化之前在AppStorage实例中存入对应的属性。  @StorageProp(key)是和AppStorage中key对应的属性建立单向数据同步，我们允许本地改变的发生，但是对于@StorageProp，本地的修改永远不会同步回AppStorage中，相反，如果AppStorage给定key的属性发生改变，改变会被同步给@StorageProp，并覆盖掉本地的修改。 装饰器使用规则说明 @StorageProp变量装饰器  说明    装饰器参数  key：常量字符串，必填（字符串需要有引号）。   允许装饰的变量类型  Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化和行为表现。 类型必须被指定，且必须和AppStorage中对应属性相同。不支持any，不允许使用undefined和null。   同步类型  单向同步：从AppStorage的对应属性到组件的状态变量。 组件本地的修改是允许的，但是AppStorage中给定的属性一旦发生变化，将覆盖本地的修改。   被装饰变量的初始值  必须指定，如果AppStorage实例中不存在属性，则作为初始化默认值，并存入AppStorage中。      变量的传递/访问规则说明 传递/访问  说明    从父节点初始化和更新  禁止，@StorageProp不支持从父节点初始化，只能AppStorage中key对应的属性初始化，如果没有对应key的话，将使用本地默认值初始化   初始化子节点  支持，可用于初始化@State、@Link、@Prop、@Provide。   是否支持组件外访问  否。      图1 @StorageProp初始化规则图示   观察变化和行为表现观察变化  当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。当装饰的数据类型为class或者Object时，可以观察到赋值和属性赋值的变化，即Object.keys(observedObject)返回的所有属性。当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 框架行为 当@StorageProp(key)装饰的数值改变被观察到时，修改不会被同步回AppStorage对应属性键值key的属性中。当前@StorageProp(key)单向绑定的数据会被修改，即仅限于当前组件的私有成员变量改变，其他的绑定该key的数据不会同步改变。当@StorageProp(key)装饰的数据本身是状态变量，它的改变虽然不会同步回AppStorage中，但是会引起所属的自定义组件的重新渲染。当AppStorage中key对应的属性发生改变时，会同步给所有@StorageProp(key)装饰的数据，@StorageProp(key)本地的修改将被覆盖。 @StorageLink@StorageLink(key)是和AppStorage中key对应的属性建立双向数据同步： 本地修改发生，该修改会被写回AppStorage中；AppStorage中的修改发生后，该修改会被同步到所有绑定AppStorage对应key的属性上，包括单向（@StorageProp和通过Prop创建的单向绑定变量）、双向（@StorageLink和通过Link创建的双向绑定变量）变量和其他实例（比如PersistentStorage）。  装饰器使用规则说明 @StorageLink变量装饰器  说明    装饰器参数  key：常量字符串，必填（字符串需要有引号）。   允许装饰的变量类型  Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化和行为表现。 类型必须被指定，且必须和AppStorage中对应属性相同。不支持any，不允许使用undefined和null。   同步类型  双向同步：从AppStorage的对应属性到自定义组件，从自定义组件到AppStorage对应属性。   被装饰变量的初始值  必须指定，如果AppStorage实例中不存在属性，则作为初始化默认值，并存入AppStorage中。      变量的传递/访问规则说明 传递/访问  说明    从父节点初始化和更新  禁止。   初始化子节点  支持，可用于初始化常规变量、@State、@Link、@Prop、@Provide。   是否支持组件外访问  否。      图2 @StorageLink初始化规则图示   观察变化和行为表现观察变化  当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。当装饰的数据类型为class或者Object时，可以观察到赋值和属性赋值的变化，即Object.keys(observedObject)返回的所有属性。当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。 框架行为 当@StorageLink(key)装饰的数值改变被观察到时，修改将被同步回AppStorage对应属性键值key的属性中。AppStorage中属性键值key对应的数据一旦改变，属性键值key绑定的所有的数据（包括双向@StorageLink和单向@StorageProp）都将同步修改。当@StorageLink(key)装饰的数据本身是状态变量，它的改变不仅仅会同步回AppStorage中，还会引起所属的自定义组件的重新渲染。 使用场景 从应用逻辑使用AppStorage和LocalStorageAppStorage是单例，它的所有API都是静态的，使用方法类似于LocalStorage对应的非静态方法。 已复制AppStorage.SetOrCreate('PropA', 47);
let storage: LocalStorage = new LocalStorage({ 'PropA': 17 });let propA: number = AppStorage.Get('PropA') // propA in AppStorage == 47, propA in LocalStorage == 17var link1: SubscribedAbstractProperty<number> = AppStorage.Link('PropA'); // link1.get() == 47var link2: SubscribedAbstractProperty<number> = AppStorage.Link('PropA'); // link2.get() == 47var prop: SubscribedAbstractProperty<number> = AppStorage.Prop('PropA'); // prop.get() == 47
link1.set(48); // two-way sync: link1.get() == link2.get() == prop.get() == 48prop.set(1); // one-way sync: prop.get() == 1; but link1.get() == link2.get() == 48link1.set(49); // two-way sync: link1.get() == link2.get() == prop.get() == 49
storage.get('PropA') // == 17 storage.set('PropA', 101);storage.get('PropA') // == 101
AppStorage.Get('PropA') // == 49link1.get() // == 49link2.get() // == 49prop.get() // == 49  从UI内部使用AppStorage和LocalStorage@StorageLink变量装饰器与AppStorage配合使用，正如@LocalStorageLink与LocalStorage配合使用一样。此装饰器使用AppStorage中的属性创建双向数据同步。 已复制AppStorage.SetOrCreate('PropA', 47);let storage = new LocalStorage({ 'PropA': 48 });
@Entry(storage)@Componentstruct CompA {  @StorageLink('PropA') storLink: number = 1;  @LocalStorageLink('PropA') localStorLink: number = 1;
  build() {    Column({ space: 20 }) {      Text(`From AppStorage ${this.storLink}`)        .onClick(() => this.storLink += 1)
      Text(`From LocalStorage ${this.localStorLink}`)        .onClick(() => this.localStorLink += 1)    }  }}  不建议借助@StorageLink的双向同步机制实现事件通知不建议开发者使用@StorageLink和AppStorage的双向同步的机制来实现事件通知，AppStorage是和UI相关的数据存储，改变会带来UI的刷新，相对于一般的事件通知，UI刷新的成本较大。 TapImage中的点击事件，会触发AppStorage中tapIndex对应属性的改变。因为@StorageLink是双向同步，修改会同步回AppStorage中，所以，所有绑定AppStorage的tapIndex自定义组件都会被通知UI刷新。UI刷新带来的成本是巨大的，因此不建议开发者使用此方式来实现基本的事件通知功能。 已复制// xxx.etsclass ViewData {  title: string;  uri: Resource;  color: Color = Color.Black;
  constructor(title: string, uri: Resource) {    this.title = title;    this.uri = uri  }}
@Entry@Componentstruct Gallery2 {  dataList: Array<ViewData> = [new ViewData('flower', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon'))]  scroller: Scroller = new Scroller()
  build() {    Column() {      Grid(this.scroller) {        ForEach(this.dataList, (item: ViewData, index?: number) => {          GridItem() {            TapImage({              uri: item.uri,              index: index            })          }.aspectRatio(1)
        }, (item: ViewData, index?: number) => {          return JSON.stringify(item) + index;        })      }.columnsTemplate('1fr 1fr')    }
  }}
@Componentexport struct TapImage {  @StorageLink('tapIndex') @Watch('onTapIndexChange') tapIndex: number = -1;  @State tapColor: Color = Color.Black;  private index: number = 0;  private uri: Resource = {    id: 0,    type: 0,    moduleName: "",    bundleName: ""  };
  // 判断是否被选中  onTapIndexChange() {    if (this.tapIndex >= 0 && this.index === this.tapIndex) {      console.info(`tapindex: ${this.tapIndex}, index: ${this.index}, red`)      this.tapColor = Color.Red;    } else {      console.info(`tapindex: ${this.tapIndex}, index: ${this.index}, black`)      this.tapColor = Color.Black;    }  }
  build() {    Column() {      Image(this.uri)        .objectFit(ImageFit.Cover)        .onClick(() => {          this.tapIndex = this.index;        })        .border({ width: 5, style: BorderStyle.Dotted, color: this.tapColor })    }
  }} 开发者可以使用emit订阅某个事件并接收事件回调，可以减少开销，增强代码的可读性。 已复制// xxx.etsimport emitter from '@ohos.events.emitter';
let NextID: number = 0;
class ViewData {  title: string;  uri: Resource;  color: Color = Color.Black;  id: number;
  constructor(title: string, uri: Resource) {    this.title = title;    this.uri = uri    this.id = NextID++;  }}
@Entry@Componentstruct Gallery2 {  dataList: Array<ViewData> = [new ViewData('flower', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon'))]  scroller: Scroller = new Scroller()  private preIndex: number = -1
  build() {    Column() {      Grid(this.scroller) {        ForEach(this.dataList, (item: ViewData) => {          GridItem() {            TapImage({              uri: item.uri,              index: item.id            })          }.aspectRatio(1)          .onClick(() => {            if (this.preIndex === item.id) {              return            }            let innerEvent: emitter.InnerEvent = { eventId: item.id }            // 选中态：黑变红            let eventData: emitter.EventData = {              data: {                "colorTag": 1              }            }            emitter.emit(innerEvent, eventData)
            if (this.preIndex != -1) {              console.info(`preIndex: ${this.preIndex}, index: ${item.id}, black`)              let innerEvent: emitter.InnerEvent = { eventId: this.preIndex }              // 取消选中态：红变黑              let eventData: emitter.EventData = {                data: {                  "colorTag": 0                }              }              emitter.emit(innerEvent, eventData)            }            this.preIndex = item.id          })        }, (item: ViewData) => JSON.stringify(item))      }.columnsTemplate('1fr 1fr')    }
  }}
@Componentexport struct TapImage {  @State tapColor: Color = Color.Black;  private index: number = 0;  private uri: Resource = {    id: 0,    type: 0,    moduleName: "",    bundleName: ""  };
  onTapIndexChange(colorTag: emitter.EventData) {    if (colorTag.data != null) {      this.tapColor = colorTag.data.colorTag ? Color.Red : Color.Black    }  }
  aboutToAppear() {    //定义事件ID    let innerEvent: emitter.InnerEvent = { eventId: this.index }    emitter.on(innerEvent, data => {      this.onTapIndexChange(data)    })  }
  build() {    Column() {      Image(this.uri)        .objectFit(ImageFit.Cover)        .border({ width: 5, style: BorderStyle.Dotted, color: this.tapColor })    }  }} 以上通知事件逻辑简单，也可以简化成三元表达式。 已复制// xxx.etsclass ViewData {  title: string;  uri: Resource;  color: Color = Color.Black;
  constructor(title: string, uri: Resource) {    this.title = title;    this.uri = uri  }}
@Entry@Componentstruct Gallery2 {  dataList: Array<ViewData> = [new ViewData('flower', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon')), new ViewData('OMG', $r('app.media.icon'))]  scroller: Scroller = new Scroller()
  build() {    Column() {      Grid(this.scroller) {        ForEach(this.dataList, (item: ViewData, index?: number) => {          GridItem() {            TapImage({              uri: item.uri,              index: index            })          }.aspectRatio(1)
        }, (item: ViewData, index?: number) => {          return JSON.stringify(item) + index;        })      }.columnsTemplate('1fr 1fr')    }
  }}
@Componentexport struct TapImage {  @StorageLink('tapIndex') tapIndex: number = -1;  @State tapColor: Color = Color.Black;  private index: number = 0;  private uri: Resource = {    id: 0,    type: 0,    moduleName: "",    bundleName: ""  };
  build() {    Column() {      Image(this.uri)        .objectFit(ImageFit.Cover)        .onClick(() => {          this.tapIndex = this.index;        })        .border({          width: 5,          style: BorderStyle.Dotted,          color: (this.tapIndex >= 0 && this.index === this.tapIndex) ? Color.Red : Color.Black        })    }  }}  限制条件AppStorage与PersistentStorage以及Environment配合使用时，需要注意以下几点： 在AppStorage中创建属性后，调用PersistentStorage.persistProp()接口时，会使用在AppStorage中已经存在的值，并覆盖PersistentStorage中的同名属性，所以建议要使用相反的调用顺序，反例可见在PersistentStorage之前访问AppStorage中的属性。如果在AppStorage中已经创建属性后，再调用Environment.envProp()创建同名的属性，会调用失败。因为AppStorage已经有同名属性，Environment环境变量不会再写入AppStorage中，所以建议AppStorage中属性不要使用Environment预置环境变量名。状态装饰器装饰的变量，改变会引起UI的渲染更新，如果改变的变量不是用于UI更新，只是用于消息传递，推荐使用 emitter方式。例子可见不建议借助@StorageLink的双向同步机制实现事件通知。   上一篇 LocalStorage：页面级UI状态存储 下一篇 PersistentStorage：持久化存储UI状态 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本语法 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    基本语法概述  声明式UI描述  自定义组件  @Builder装饰器：自定义构建函数  @BuilderParam装饰器：引用@Builder函数  @Styles装饰器：定义组件重用样式  @Extend装饰器：定义扩展组件样式  stateStyles：多态样式   上一篇 初识ArkTS语言 下一篇 基本语法概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本语法概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  在初步了解了ArkTS语言之后，我们以一个具体的示例来说明ArkTS的基本组成。如下图所示，当开发者点击按钮时，文本内容从“Hello World”变为“Hello ArkUI”。  图1 示例效果图   本示例中，ArkTS的基本组成如下所示。  图2 ArkTS的基本组成   
说明
 自定义变量不能与基础通用属性/事件名重复。 
  装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。 UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。 自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。 系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。 属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。 事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。 系统组件、属性方法、事件方法具体使用可参考基于ArkTS的声明式开发范式。  除此之外，ArkTS扩展了多种语法范式来使开发更加便捷：  @Builder/@BuilderParam：特殊的封装UI描述的方法，细粒度的封装和复用UI描述。 @Extend/@Styles：扩展内置组件和封装属性样式，更灵活地组合内置组件。 stateStyles：多态样式，可以依据组件的内部状态的不同，设置不同样式。   上一篇 基本语法 下一篇 声明式UI描述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。学习ArkTS语言 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    初识ArkTS语言  基本语法  状态管理  渲染控制   上一篇 资源分类与访问 下一篇 初识ArkTS语言 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。装饰器使用说明自定义组件内自定义构建函数全局自定义构建函数参数传递规则按引用传递参数按值传递参数@Builder装饰器：自定义构建函数 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
 前面章节介绍了如何创建一个自定义组件。该自定义组件内部UI结构固定，仅与使用方进行数据传递。ArkUI还提供了一种更轻量的UI元素复用机制@Builder，@Builder所装饰的函数遵循build()函数语法规则，开发者可以将重复使用的UI元素抽象成一个方法，在build方法里调用。 为了简化语言，我们将@Builder装饰的函数也称为“自定义构建函数”。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 装饰器使用说明 自定义组件内自定义构建函数定义的语法： 已复制@Builder MyBuilderFunction(){ ... } 使用方法： 已复制this.MyBuilderFunction() 允许在自定义组件内定义一个或多个@Builder方法，该方法被认为是该组件的私有、特殊类型的成员函数。自定义构建函数可以在所属组件的build方法和其他自定义构建函数中调用，但不允许在组件外调用。在自定义函数体中，this指代当前所属组件，组件的状态变量可以在自定义构建函数内访问。建议通过this访问自定义组件的状态变量而不是参数传递。  全局自定义构建函数定义的语法： 已复制@Builder function MyGlobalBuilderFunction(){ ... } 使用方法： 已复制MyGlobalBuilderFunction()  全局的自定义构建函数可以被整个应用获取，不允许使用this和bind方法。如果不涉及组件状态变化，建议使用全局的自定义构建方法。 参数传递规则自定义构建函数的参数传递有按值传递和按引用传递两种，均需遵守以下规则： 参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。在自定义构建函数内部，不允许改变参数值。如果需要改变参数值，且同步回调用点，建议使用@Link。@Builder内UI语法遵循UI语法规则。只有传入一个参数，且参数需要直接传入对象字面量才会按引用传递该参数，其余传递方式均为按值传递。  按引用传递参数按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@Builder方法内的UI刷新。ArkUI提供$$作为按引用传递参数的范式。 已复制overBuilder( $$ : { paramA1: string, paramB1 : string } ); 已复制@Builder function overBuilder($$: { paramA1: string }) {  Row() {    Text(`UseStateVarByReference: ${$$.paramA1} `)  }}@Entry@Componentstruct Parent {  @State label: string = 'Hello';  build() {    Column() {      // 在Parent组件中调用overBuilder的时候，将this.label引用传递给overBuilder      overBuilder({ paramA1: this.label })      Button('Click me').onClick(() => {        // 点击“Click me”后，UI从“Hello”刷新为“ArkUI”        this.label = 'ArkUI';      })    }  }}  按值传递参数调用@Builder装饰的函数默认按值传递。当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新。所以当使用状态变量的时候，推荐使用按引用传递。 已复制@Builder function overBuilder(paramA1: string) {  Row() {    Text(`UseStateVarByValue: ${paramA1} `)  }}@Entry@Componentstruct Parent {  @State label: string = 'Hello';  build() {    Column() {      overBuilder(this.label)    }  }}   上一篇 页面和自定义组件生命周期 下一篇 @BuilderParam装饰器：引用@Builder函数 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。装饰器使用说明初始化@BuilderParam装饰的方法使用场景参数初始化组件尾随闭包初始化组件@BuilderParam装饰器：引用@Builder函数 更新时间: 2024-03-20 16:31 毫无帮助帮助不大一般很好非常好
分享
 当开发者创建了自定义组件，并想对该组件添加特定功能时，例如在自定义组件中添加一个点击跳转操作。若直接在组件内嵌入事件方法，将会导致所有引入该自定义组件的地方均增加了该功能。为解决此问题，ArkUI引入了@BuilderParam装饰器，@BuilderParam用来装饰指向@Builder方法的变量，开发者可在初始化自定义组件时对此属性进行赋值，为自定义组件增加特定的功能。该装饰器用于声明任意UI描述的一个元素，类似slot占位符。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 装饰器使用说明 初始化@BuilderParam装饰的方法@BuilderParam装饰的方法只能被自定义构建函数（@Builder装饰的方法）初始化。 使用所属自定义组件的自定义构建函数或者全局的自定义构建函数，在本地初始化@BuilderParam。已复制@Builder function overBuilder() {}
@Componentstruct Child {  @Builder doNothingBuilder() {};
  // 使用自定义组件的自定义构建函数初始化@BuilderParam  @BuilderParam customBuilderParam: () => void = this.doNothingBuilder;  // 使用全局自定义构建函数初始化@BuilderParam  @BuilderParam customOverBuilderParam: () => void = overBuilder;  build(){}}  用父组件自定义构建函数初始化子组件@BuilderParam装饰的方法。已复制@Componentstruct Child {  // 使用父组件@Builder装饰的方法初始化子组件@BuilderParam  @BuilderParam customBuilderParam: () => void;
  build() {    Column() {      this.customBuilderParam()    }  }}
@Entry@Componentstruct Parent {  @Builder componentBuilder() {    Text(`Parent builder `)  }
  build() {    Column() {      Child({ customBuilderParam: this.componentBuilder })    }  }}    需注意this指向正确。以下示例中，Parent组件在调用this.componentBuilder()时，this指向其所属组件，即“Parent”。@Builder componentBuilder()传给子组件@BuilderParam customBuilderParam，在Child组件中调用this.customBuilderParam()时，this指向在Child的label，即“Child”。
说明
开发者谨慎使用bind改变函数调用的上下文，可能会使this指向混乱。 
 已复制@Componentstruct Child {  label: string = `Child`  @BuilderParam customBuilderParam: () => void;
  build() {    Column() {      this.customBuilderParam()    }  }}
@Entry@Componentstruct Parent {  label: string = `Parent`
  @Builder componentBuilder() {    Text(`${this.label}`)  }
  build() {    Column() {      this.componentBuilder()      Child({ customBuilderParam: this.componentBuilder })    }  }}    使用场景 参数初始化组件@BuilderParam装饰的方法可以是有参数和无参数的两种形式，需与指向的@Builder方法类型匹配。@BuilderParam装饰的方法类型需要和@Builder方法类型一致。 已复制@Builder function overBuilder($$ : {label: string }) {  Text($$.label)    .width(400)    .height(50)    .backgroundColor(Color.Green)}
@Componentstruct Child {  label: string = 'Child'  // 无参数类型，指向的componentBuilder也是无参数类型  @BuilderParam customBuilderParam: () => void;  // 有参数类型，指向的GlobalBuilder1也是有参数类型的方法  @BuilderParam customOverBuilderParam: ($$ : { label : string}) => void;
  build() {    Column() {      this.customBuilderParam()      this.customOverBuilderParam({label: 'global Builder label' } )    }  }}
@Entry@Componentstruct Parent {  label: string = 'Parent'
  @Builder componentBuilder() {    Text(`${this.label}`)  }
  build() {    Column() {      this.componentBuilder()      Child({ customBuilderParam: this.componentBuilder, customOverBuilderParam: overBuilder })    }  }}   尾随闭包初始化组件在自定义组件中使用@BuilderParam装饰的属性时也可通过尾随闭包进行初始化。在初始化自定义组件时，组件后紧跟一个大括号“{}”形成尾随闭包场景。 
说明
此场景下自定义组件内有且仅有一个使用@BuilderParam装饰的属性。 
 开发者可以将尾随闭包内的内容看做@Builder装饰的函数传给@BuilderParam。示例如下： 已复制// xxx.ets@Componentstruct CustomContainer {  @Prop header: string;  // 使用父组件的尾随闭包{}(@Builder装饰的方法)初始化子组件@BuilderParam  @BuilderParam closer: () => void
  build() {    Column() {      Text(this.header)        .fontSize(30)      this.closer()    }  }}
@Builder function specificParam(label1: string, label2: string) {  Column() {    Text(label1)      .fontSize(30)    Text(label2)      .fontSize(30)  }}
@Entry@Componentstruct CustomContainerUser {  @State text: string = 'header';
  build() {    Column() {      // 创建CustomContainer，在创建CustomContainer时，通过其后紧跟一个大括号“{}”形成尾随闭包      // 作为传递给子组件CustomContainer @BuilderParam closer: () => void的参数      CustomContainer({ header: this.text }) {        Column() {          specificParam('testA', 'testB')        }.backgroundColor(Color.Yellow)        .onClick(() => {          this.text = 'changeHeader';        })      }    }  }}    上一篇 @Builder装饰器：自定义构建函数 下一篇 @Styles装饰器：定义组件重用样式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加常用组件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    按钮（Button）  单选框（Radio）  切换按钮（Toggle）  进度条（Progress）  文本显示（Text/Span）  文本输入（TextInput/TextArea）  自定义弹窗（CustomDialog）  视频播放（Video）  XComponent   上一篇 添加组件 下一篇 按钮（Button） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建按钮设置按钮类型自定义样式添加事件场景示例按钮（Button） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Button是按钮组件，通常用于响应用户的点击操作，其类型包括胶囊按钮、圆形按钮、普通按钮。Button当做为容器使用时可以通过添加子组件实现包含文字、图片等元素的按钮。具体用法请参考Button。  创建按钮 Button通过调用接口来创建，接口调用有以下两种形式：   创建不包含子组件的按钮。已复制Button(label?: string, options?: { type?: ButtonType, stateEffect?: boolean }) 该接口用于创建不包含子组件的按钮，其中label用来设置按钮文字，type用于设置Button类型，stateEffect属性设置Button是否开启点击效果。 已复制Button('Ok', { type: ButtonType.Normal, stateEffect: true })   .borderRadius(8)   .backgroundColor(0x317aff)   .width(90)  .height(40)    创建包含子组件的按钮。已复制Button(options?: {type?: ButtonType, stateEffect?: boolean}) 该接口用于创建包含子组件的按钮，只支持包含一个子组件，子组件可以是基础组件或者容器组件。 已复制Button({ type: ButtonType.Normal, stateEffect: true }) {  Row() {    Image($r('app.media.loading')).width(20).height(40).margin({ left: 12 })    Text('loading').fontSize(12).fontColor(0xffffff).margin({ left: 5, right: 12 })  }.alignItems(VerticalAlign.Center)}.borderRadius(8).backgroundColor(0x317aff).width(90).height(40)    设置按钮类型 Button有三种可选类型，分别为Capsule（胶囊类型）、Circle（圆形按钮）和Normal（普通按钮），通过type进行设置。   胶囊按钮（默认类型）此类型按钮的圆角自动设置为高度的一半，不支持通过borderRadius属性重新设置圆角。 已复制Button('Disable', { type: ButtonType.Capsule, stateEffect: false })   .backgroundColor(0x317aff)   .width(90)  .height(40)    圆形按钮此类型按钮为圆形，不支持通过borderRadius属性重新设置圆角。 已复制Button('Circle', { type: ButtonType.Circle, stateEffect: false })   .backgroundColor(0x317aff)   .width(90)   .height(90)  普通按钮此类型的按钮默认圆角为0，支持通过borderRadius属性重新设置圆角。 已复制Button('Ok', { type: ButtonType.Normal, stateEffect: true })   .borderRadius(8)   .backgroundColor(0x317aff)   .width(90)  .height(40)    自定义样式  设置边框弧度。               一般使用通用属性来自定义按钮样式。例如通过borderRadius属性设置按钮的边框弧度。        已复制Button('circle border', { type: ButtonType.Normal })   .borderRadius(20)  .height(40)      设置文本样式。通过添加文本样式设置按钮文本的展示样式。 已复制Button('font style', { type: ButtonType.Normal })   .fontSize(20)   .fontColor(Color.Pink)   .fontWeight(800)    设置背景颜色。添加backgroundColor属性设置按钮的背景颜色。 已复制Button('background color').backgroundColor(0xF55A42)    用作功能型按钮。为删除操作创建一个按钮。 已复制Button({ type: ButtonType.Circle, stateEffect: true }) {   Image($r('app.media.ic_public_delete_filled')).width(30).height(30) }.width(55).height(55).margin({ left: 20 }).backgroundColor(0xF55A42)    添加事件 Button组件通常用于触发某些操作，可以绑定onClick事件来响应点击操作后的自定义行为。  已复制Button('Ok', { type: ButtonType.Normal, stateEffect: true })   .onClick(()=>{     console.info('Button onClick')   })  场景示例  用于启动操作。可以用按钮启动任何用户界面元素，按钮会根据用户的操作触发相应的事件。例如，在List容器里通过点击按钮进行页面跳转。 已复制// xxx.etsimport router from '@ohos.router';@Entry@Componentstruct ButtonCase1 {  build() {    List({ space: 4 }) {      ListItem() {        Button("First").onClick(() => {          router.pushUrl({ url: 'pages/first_page' })        })          .width('100%')      }      ListItem() {        Button("Second").onClick(() => {          router.pushUrl({ url: 'pages/second_page' })        })          .width('100%')      }      ListItem() {        Button("Third").onClick(() => {          router.pushUrl({ url: 'pages/third_page' })        })          .width('100%')      }    }    .listDirection(Axis.Vertical)    .backgroundColor(0xDCDCDC).padding(20)  }}     用于表单的提交。在用户登录/注册页面，使用按钮进行登录或注册操作。 已复制// xxx.ets@Entry@Componentstruct ButtonCase2 {  build() {    Column() {      TextInput({ placeholder: 'input your username' }).margin({ top: 20 })      TextInput({ placeholder: 'input your password' }).type(InputType.Password).margin({ top: 20 })      Button('Register').width(300).margin({ top: 20 })        .onClick(() => {          // 需要执行的操作        })    }.padding(20)  }}  悬浮按钮在可以滑动的界面，滑动时按钮始终保持悬浮状态。 已复制// xxx.ets@Entry@Componentstruct HoverButtonExample {  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  build() {    Stack() {      List({ space: 20, initialIndex: 0 }) {        ForEach(this.arr, (item) => {          ListItem() {            Text('' + item)              .width('100%').height(100).fontSize(16)              .textAlign(TextAlign.Center).borderRadius(10).backgroundColor(0xFFFFFF)          }        }, item => item)      }.width('90%')      Button() {        Image($r('app.media.ic_public_add'))          .width(50)          .height(50)      }      .width(60)      .height(60)      .position({x: '80%', y: 600})      .shadow({radius: 10})      .onClick(() => {        // 需要执行的操作      })    }    .width('100%')    .height('100%')    .backgroundColor(0xDCDCDC)    .padding({ top: 5 })  }}    上一篇 添加常用组件 下一篇 单选框（Radio） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建自定义弹窗弹窗的交互完整示例自定义弹窗（CustomDialog） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  自定义弹窗（CustomDialog）可用于广告、中奖、警告、软件更新等与用户交互响应操作。开发者可以通过CustomDialogController类显示自定义弹窗。具体用法请参考自定义弹窗。  创建自定义弹窗  使用@CustomDialog装饰器装饰自定义弹窗。 @CustomDialog装饰器用于装饰自定义弹框，此装饰器内进行自定义内容（也就是弹框内容）。已复制@CustomDialogstruct CustomDialogExample {  controller: CustomDialogController  build() {    Column() {      Text('我是内容')      .fontSize(20)      .margin({ top: 10, bottom: 10 })    }  }}  创建构造器，与装饰器呼应相连。已复制dialogController: CustomDialogController = new CustomDialogController({    builder: CustomDialogExample({}),})  点击与onClick事件绑定的组件使弹窗弹出已复制Flex({justifyContent:FlexAlign.Center}){  Button('click me')    .onClick(() => {      this.dialogController.open()    })}.width('100%')      弹窗的交互 弹窗可用于数据交互，完成用户一系列响应操作。   在@CustomDialog装饰器内添加按钮操作，同时添加数据函数的创建。已复制@CustomDialogstruct CustomDialogExample {  controller: CustomDialogController  cancel: () => void  confirm: () => void  build() {    Column() {      Text('我是内容').fontSize(20).margin({ top: 10, bottom: 10 })      Flex({ justifyContent: FlexAlign.SpaceAround }) {        Button('cancel')          .onClick(() => {            this.controller.close()            this.cancel()          }).backgroundColor(0xffffff).fontColor(Color.Black)        Button('confirm')          .onClick(() => {            this.controller.close()            this.confirm()          }).backgroundColor(0xffffff).fontColor(Color.Red)      }.margin({ bottom: 10 })    }  }}  页面内需要在构造器内进行接收，同时创建相应的函数操作。已复制dialogController: CustomDialogController = new CustomDialogController({    builder: CustomDialogExample({      cancel: this.onCancel,      confirm: this.onAccept,    }),    alignment: DialogAlignment.Default,  // 可设置dialog的对齐方式，设定显示在底部或中间等，默认为底部显示  })  onCancel() {    console.info('Callback when the first button is clicked')  }  onAccept() {    console.info('Callback when the second button is clicked')  }     完整示例 已复制// xxx.ets@CustomDialogstruct CustomDialogExample {  controller: CustomDialogController  cancel: () => void  confirm: () => void  build() {    Column() {      Text('我是内容').fontSize(20).margin({ top: 10, bottom: 10 })      Flex({ justifyContent: FlexAlign.SpaceAround }) {        Button('cancel')          .onClick(() => {            this.controller.close()            this.cancel()          }).backgroundColor(0xffffff).fontColor(Color.Black)        Button('confirm')          .onClick(() => {            this.controller.close()            this.confirm()          }).backgroundColor(0xffffff).fontColor(Color.Red)      }.margin({ bottom: 10 })    }  }}
@Entry@Componentstruct DialogExample {  dialogController: CustomDialogController = new CustomDialogController({    builder: CustomDialogExample({      cancel: this.onCancel,      confirm: this.onAccept,    }),    alignment: DialogAlignment.Default,  // 可设置dialog的对齐方式，设定显示在底部或中间等，默认为底部显示  })  onCancel() {    console.info('Callback when the first button is clicked')  }  onAccept() {    console.info('Callback when the second button is clicked')  }
  build() {    Flex({ justifyContent: FlexAlign.Center }) {      Button('click me')        .onClick(() => {          this.dialogController.open()        })    }.width('100%')  }}    上一篇 文本输入（TextInput/TextArea） 下一篇 视频播放（Video） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建进度条设置进度条样式场景示例进度条（Progress） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Progress是进度条显示组件，显示内容通常为某次目标操作的当前进度。具体用法请参考Progress。  创建进度条 Progress通过调用接口来创建，接口调用形式如下：  已复制Progress(options: {value: number, total?: number, type?: ProgressType}) 该接口用于创建type样式的进度条，其中value用于设置初始进度值，total用于设置进度总长度，type决定Progress样式。 已复制Progress({ value: 24, total: 100, type: ProgressType.Linear }) // 创建一个进度总长为100，初始进度值为24的线性进度条   设置进度条样式 Progress有5种可选类型，在创建时通过设置ProgressType枚举类型给type可选项指定Progress类型。其分别为：ProgressType.Linear（线性样式）、 ProgressType.Ring（环形无刻度样式）、ProgressType.ScaleRing（环形有刻度样式）、ProgressType.Eclipse（圆形样式）和ProgressType.Capsule（胶囊样式）。   线性样式进度条（默认类型）      
说明
 从API version9开始，组件高度大于宽度的时候自适应垂直显示，相等时仍然保持水平显示。 
 已复制Progress({ value: 20, total: 100, type: ProgressType.Linear }).width(200).height(50)Progress({ value: 20, total: 100, type: ProgressType.Linear }).width(50).height(200)  环形无刻度样式进度条已复制// 从左往右，1号环形进度条，默认前景色为蓝色，默认strokeWidth进度条宽度为2.0vpProgress({ value: 40, total: 150, type: ProgressType.Ring }).width(100).height(100)// 从左往右，2号环形进度条Progress({ value: 40, total: 150, type: ProgressType.Ring }).width(100).height(100)    .color(Color.Grey)    // 进度条前景色为灰色    .style({ strokeWidth: 15})    // 设置strokeWidth进度条宽度为15.0vp  环形有刻度样式进度条已复制Progress({ value: 20, total: 150, type: ProgressType.ScaleRing }).width(100).height(100)    .backgroundColor(Color.Black)    .style({ scaleCount: 20, scaleWidth: 5 })    // 设置环形有刻度进度条总刻度数为20，刻度宽度为5vpProgress({ value: 20, total: 150, type: ProgressType.ScaleRing }).width(100).height(100)    .backgroundColor(Color.Black)    .style({ strokeWidth: 15, scaleCount: 20, scaleWidth: 5 })    // 设置环形有刻度进度条宽度15，总刻度数为20，刻度宽度为5vpProgress({ value: 20, total: 150, type: ProgressType.ScaleRing }).width(100).height(100)    .backgroundColor(Color.Black)    .style({ strokeWidth: 15, scaleCount: 20, scaleWidth: 3 })    // 设置环形有刻度进度条宽度15，总刻度数为20，刻度宽度为3vp  圆形样式进度条已复制// 从左往右，1号圆形进度条，默认前景色为蓝色Progress({ value: 10, total: 150, type: ProgressType.Eclipse }).width(100).height(100)// 从左往右，2号圆形进度条，指定前景色为灰色Progress({ value: 20, total: 150, type: ProgressType.Eclipse }).color(Color.Grey).width(100).height(100)  胶囊样式进度条      
说明
 1、头尾两端圆弧处的进度展示效果与ProgressType.Eclipse样式相同； 2、中段处的进度展示效果为矩形状长条，与ProgressType.Linear线性样式相似； 3、组件高度大于宽度的时候自适应垂直显示。 
 已复制Progress({ value: 10, total: 150, type: ProgressType.Capsule }).width(100).height(50)Progress({ value: 20, total: 150, type: ProgressType.Capsule }).width(50).height(100).color(Color.Grey)Progress({ value: 50, total: 150, type: ProgressType.Capsule }).width(50).height(100).backgroundColor(Color.Black)    场景示例       更新当前进度值，如应用安装进度条。可通过点击Button增加progressValue，.value()属性将progressValue设置给Progress组件，进度条组件即会触发刷新，更新当前进度。      已复制@Entry@Componentstruct ProgressCase1 {   @State progressValue: number = 0    // 设置进度条初始值为0  build() {    Column() {      Column() {        Progress({value:0, total:100, type:ProgressType.Capsule}).width(200).height(50)          .style({strokeWidth:50}).value(this.progressValue)        Row().width('100%').height(5)        Button("进度条+5")          .onClick(()=>{            this.progressValue += 5            if (this.progressValue > 100){              this.progressValue = 0            }          })      }    }.width('100%').height('100%')  }}     上一篇 切换按钮（Toggle） 下一篇 文本显示（Text/Span） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建单选框添加事件场景示例单选框（Radio） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Radio是单选框组件，通常用于提供相应的用户交互选择项，同一组的Radio中只有一个可以被选中。具体用法请参考Radio。  创建单选框 Radio通过调用接口来创建，接口调用形式如下： 已复制Radio(options: {value: string, group: string})       该接口用于创建一个单选框，其中value是单选框的名称，group是单选框的所属群组名称。checked属性可以设置单选框的状态，状态分别为false和true时，设置为true时表示单选框被选中。Radio仅支持选中和未选中两种样式，不支持自定义颜色和形状。      已复制Radio({ value: 'Radio1', group: 'radioGroup' })  .checked(false)Radio({ value: 'Radio2', group: 'radioGroup' })  .checked(true)     添加事件 除支持通用事件外，Radio通常用于选中后触发某些操作，可以绑定onChange事件来响应选中操作后的自定义行为。  已复制  Radio({ value: 'Radio1', group: 'radioGroup' })    .onChange((isChecked: boolean) => {      if(isChecked) {        //需要执行的操作      }    })  Radio({ value: 'Radio2', group: 'radioGroup' })    .onChange((isChecked: boolean) => {      if(isChecked) {        //需要执行的操作      }    })  场景示例 通过点击Radio切换声音模式。 已复制// xxx.etsimport promptAction from '@ohos.promptAction';@Entry@Componentstruct RadioExample {  build() {    Row() {      Column() {        Radio({ value: 'Radio1', group: 'radioGroup' }).checked(true)          .height(50)          .width(50)          .onChange((isChecked: boolean) => {            if(isChecked) {              // 切换为响铃模式              promptAction.showToast({ message: 'Ringing mode.' })            }          })        Text('Ringing')      }      Column() {        Radio({ value: 'Radio2', group: 'radioGroup' })          .height(50)          .width(50)          .onChange((isChecked: boolean) => {            if(isChecked) {              // 切换为振动模式              promptAction.showToast({ message: 'Vibration mode.' })            }          })        Text('Vibration')      }      Column() {        Radio({ value: 'Radio3', group: 'radioGroup' })          .height(50)          .width(50)          .onChange((isChecked: boolean) => {            if(isChecked) {              // 切换为静音模式              promptAction.showToast({ message: 'Silent mode.' })            }          })        Text('Silent')      }    }.height('100%').width('100%').justifyContent(FlexAlign.Center)  }}    上一篇 按钮（Button） 下一篇 切换按钮（Toggle） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建切换按钮自定义样式添加事件场景示例切换按钮（Toggle） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Toggle组件提供状态按钮样式，勾选框样式及开关样式，一般用于两种状态之间的切换。具体用法请参考Toggle。  创建切换按钮 Toggle通过调用接口来创建，接口调用形式如下：  已复制Toggle(options: { type: ToggleType, isOn?: boolean }) 该接口用于创建切换按钮，其中ToggleType为开关类型，包括Button、Checkbox和Switch，isOn为切换按钮的状态，接口调用有以下两种形式：  创建不包含子组件的Toggle。当ToggleType为Checkbox或者Switch时，用于创建不包含子组件的Toggle： 已复制Toggle({ type: ToggleType.Checkbox, isOn: false })Toggle({ type: ToggleType.Checkbox, isOn: true })  已复制Toggle({ type: ToggleType.Switch, isOn: false })Toggle({ type: ToggleType.Switch, isOn: true })    创建包含子组件的Toggle。当ToggleType为Button时，只能包含一个子组件，如果子组件有文本设置，则相应的文本内容会显示在按钮内部。 已复制Toggle({ type: ToggleType.Button, isOn: false }) {  Text('status button')  .fontColor('#182431')  .fontSize(12)}.width(100)Toggle({ type: ToggleType.Button, isOn: true }) {  Text('status button')  .fontColor('#182431')  .fontSize(12)}.width(100)    自定义样式  通过selectedColor属性设置Toggle打开选中后的背景颜色。已复制Toggle({ type: ToggleType.Button, isOn: true }) {  Text('status button')  .fontColor('#182431')  .fontSize(12)}.width(100).selectedColor(Color.Pink)Toggle({ type: ToggleType.Checkbox, isOn: true })  .selectedColor(Color.Pink)Toggle({ type: ToggleType.Switch, isOn: true })  .selectedColor(Color.Pink)  通过switchPointColor属性设置Switch类型的圆形滑块颜色，仅对type为ToggleType.Switch生效。已复制Toggle({ type: ToggleType.Switch, isOn: false })  .switchPointColor(Color.Pink)Toggle({ type: ToggleType.Switch, isOn: true })  .switchPointColor(Color.Pink)     添加事件 除支持通用事件外，Toggle通常用于选中和取消选中后触发某些操作，可以绑定onChange事件来响应操作后的自定义行为。 已复制Toggle({ type: ToggleType.Switch, isOn: false })  .onChange((isOn: boolean) => {      if(isOn) {        // 需要执行的操作      }  })   场景示例 Toggle可用于切换蓝牙开关状态。  已复制// xxx.etsimport promptAction from '@ohos.promptAction';@Entry@Componentstruct ToggleExample {  build() {    Column() {      Row() {        Text("Bluetooth Mode")        .height(50)        .fontSize(16)      }      Row() {        Text("Bluetooth")          .height(50)          .padding({left: 10})          .fontSize(16)          .textAlign(TextAlign.Start)          .backgroundColor(0xFFFFFF)        Toggle({ type: ToggleType.Switch })          .margin({left: 200, right: 10})          .onChange((isOn: boolean) => {            if(isOn) {              promptAction.showToast({ message: 'Bluetooth is on.' })            } else {              promptAction.showToast({ message: 'Bluetooth is off.' })            }          })      }      .backgroundColor(0xFFFFFF)    }    .padding(10)    .backgroundColor(0xDCDCDC)    .width('100%')    .height('100%')  }}   上一篇 单选框（Radio） 下一篇 进度条（Progress） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建文本添加子组件自定义文本样式添加事件场景示例文本显示（Text/Span） 更新时间: 2024-03-20 16:30 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
  Text是文本组件，通常用于展示用户的视图，如显示文章的文字。具体用法可参考Text。  创建文本 Text可通过以下两种方式来创建：   string字符串已复制Text('我是一段文本')    引用Resource资源资源引用类型可以通过$r创建Resource类型对象，文件位置为/resources/base/element/string.json。 已复制Text($r('app.string.module_desc'))  .baselineOffset(0)  .fontSize(30)  .border({ width: 1 })  .padding(10)  .width(300)    添加子组件 Span只能作为Text组件的子组件显示文本内容。可以在一个Text内添加多个Span来显示一段信息，例如产品说明书、承诺书等。  创建Span。Span组件需要写到Text组件内，单独写Span组件不会显示信息，Text与Span同时配置文本内容时，Span内容覆盖Text内容。 已复制Text('我是Text') {  Span('我是Span')}.padding(10).borderWidth(1)  设置文本装饰线及颜色。通过decoration设置文本装饰线及颜色。 已复制Text() {  Span('我是Span1，').fontSize(16).fontColor(Color.Grey)    .decoration({ type: TextDecorationType.LineThrough, color: Color.Red })  Span('我是Span2').fontColor(Color.Blue).fontSize(16)    .fontStyle(FontStyle.Italic)    .decoration({ type: TextDecorationType.Underline, color: Color.Black })  Span('，我是Span3').fontSize(16).fontColor(Color.Grey)    .decoration({ type: TextDecorationType.Overline, color: Color.Green })}.borderWidth(1).padding(10)  通过textCase设置文字一直保持大写或者小写状态。已复制Text() {  Span('I am Upper-span').fontSize(12)    .textCase(TextCase.UpperCase)}.borderWidth(1).padding(10)  添加事件。由于Span组件无尺寸信息，事件仅支持点击事件onClick。 已复制Text() {  Span('I am Upper-span').fontSize(12)    .textCase(TextCase.UpperCase)    .onClick(()=>{      console.info('我是Span——onClick')    })}    自定义文本样式  通过textAlign属性设置文本对齐样式。已复制Text('左对齐')  .width(300)  .textAlign(TextAlign.Start)  .border({ width: 1 })  .padding(10)Text('中间对齐')  .width(300)  .textAlign(TextAlign.Center)  .border({ width: 1 })  .padding(10)Text('右对齐')  .width(300)  .textAlign(TextAlign.End)  .border({ width: 1 })  .padding(10)  通过textOverflow属性控制文本超长处理，textOverflow需配合maxLines一起使用（默认情况下文本自动折行）。已复制Text('This is the setting of textOverflow to Clip text content This is the setting of textOverflow to None text content. This is the setting of textOverflow to Clip text content This is the setting of textOverflow to None text content.')  .width(250)  .textOverflow({ overflow: TextOverflow.None })  .maxLines(1)  .fontSize(12)  .border({ width: 1 }).padding(10)Text('我是超长文本，超出的部分显示省略号。I am an extra long text, with ellipses displayed for any excess。')  .width(250)  .textOverflow({ overflow: TextOverflow.Ellipsis })  .maxLines(1)  .fontSize(12)  .border({ width: 1 }).padding(10)   通过lineHeight属性设置文本行高。已复制Text('This is the text with the line height set. This is the text with the line height set.')  .width(300).fontSize(12).border({ width: 1 }).padding(10)Text('This is the text with the line height set. This is the text with the line height set.')  .width(300).fontSize(12).border({ width: 1 }).padding(10)  .lineHeight(20)  通过decoration属性设置文本装饰线样式及其颜色。已复制Text('This is the text')  .decoration({    type: TextDecorationType.LineThrough,    color: Color.Red  })  .borderWidth(1).padding(10).margin(5)Text('This is the text')  .decoration({    type: TextDecorationType.Overline,    color: Color.Red  })  .borderWidth(1).padding(10).margin(5)Text('This is the text')  .decoration({    type: TextDecorationType.Underline,    color: Color.Red  })  .borderWidth(1).padding(10).margin(5)  通过baselineOffset属性设置文本基线的偏移量。已复制Text('This is the text content with baselineOffset 0.')  .baselineOffset(0)  .fontSize(12)  .border({ width: 1 })  .padding(10)  .width('100%')  .margin(5)Text('This is the text content with baselineOffset 30.')  .baselineOffset(30)  .fontSize(12)  .border({ width: 1 })  .padding(10)  .width('100%')  .margin(5)
Text('This is the text content with baselineOffset -20.')  .baselineOffset(-20)  .fontSize(12)  .border({ width: 1 })  .padding(10)  .width('100%')  .margin(5)  通过letterSpacing属性设置文本字符间距。已复制Text('This is the text content with letterSpacing 0.')  .letterSpacing(0)  .fontSize(12)  .border({ width: 1 })  .padding(10)  .width('100%')  .margin(5)Text('This is the text content with letterSpacing 3.')  .letterSpacing(3)  .fontSize(12)  .border({ width: 1 })  .padding(10)  .width('100%')  .margin(5)Text('This is the text content with letterSpacing -1.')  .letterSpacing(-1)  .fontSize(12)  .border({ width: 1 })  .padding(10)  .width('100%')  .margin(5)  通过minFontSize与maxFontSize自适应字体大小，minFontSize设置文本最小显示字号，maxFontSize设置文本最大显示字号，minFontSize与maxFontSize必须搭配同时使用，以及需配合maxline或布局大小限制一起使用，单独设置不生效。已复制Text('我的最大字号为30，最小字号为5，宽度为250，maxLines为1')  .width(250)  .maxLines(1)  .maxFontSize(30)  .minFontSize(5)  .border({ width: 1 })  .padding(10)  .margin(5)Text('我的最大字号为30，最小字号为5，宽度为250，maxLines为2')  .width(250)  .maxLines(2)  .maxFontSize(30)  .minFontSize(5)  .border({ width: 1 })  .padding(10)  .margin(5)Text('我的最大字号为30，最小字号为15，宽度为250,高度为50')  .width(250)  .height(50)  .maxFontSize(30)  .minFontSize(15)  .border({ width: 1 })  .padding(10)  .margin(5)Text('我的最大字号为30，最小字号为15，宽度为250,高度为100')  .width(250)  .height(100)  .maxFontSize(30)  .minFontSize(15)  .border({ width: 1 })  .padding(10)  .margin(5)  通过textCase属性设置文本大小写。已复制Text('This is the text content with textCase set to Normal.')  .textCase(TextCase.Normal)  .padding(10)  .border({ width: 1 })  .padding(10)  .margin(5)
// 文本全小写展示Text('This is the text content with textCase set to LowerCase.')  .textCase(TextCase.LowerCase)  .border({ width: 1 })  .padding(10)  .margin(5)
// 文本全大写展示Text('This is the text content with textCase set to UpperCase.')  .textCase(TextCase.UpperCase)  .border({ width: 1 })  .padding(10)  .margin(5)  通过copyOption属性设置文本是否可复制粘贴。已复制Text("这是一段可复制文本")  .fontSize(30)  .copyOption(CopyOptions.InApp)     添加事件 Text组件可以添加通用事件，可以绑定onClick、onTouch等事件来响应操作。 已复制Text('点我')  .onClick(()=>{      console.info('我是Text的点击响应事件');   })   场景示例 已复制// xxx.ets@Entry@Componentstruct TextExample {  build() {    Column() {      Row() {        Text("1").fontSize(14).fontColor(Color.Red).margin({ left: 10, right: 10 })        Text("我是热搜词条1")          .fontSize(12)          .fontColor(Color.Blue)          .maxLines(1)          .textOverflow({ overflow: TextOverflow.Ellipsis })          .fontWeight(300)        Text("爆")          .margin({ left: 6 })          .textAlign(TextAlign.Center)          .fontSize(10)          .fontColor(Color.White)          .fontWeight(600)          .backgroundColor(0x770100)          .borderRadius(5)          .width(15)          .height(14)      }.width('100%').margin(5)
      Row() {        Text("2").fontSize(14).fontColor(Color.Red).margin({ left: 10, right: 10 })        Text("我是热搜词条2 我是热搜词条2 我是热搜词条2 我是热搜词条2 我是热搜词条2")          .fontSize(12)          .fontColor(Color.Blue)          .fontWeight(300)          .constraintSize({ maxWidth: 200 })          .maxLines(1)          .textOverflow({ overflow: TextOverflow.Ellipsis })        Text("热")          .margin({ left: 6 })          .textAlign(TextAlign.Center)          .fontSize(10)          .fontColor(Color.White)          .fontWeight(600)          .backgroundColor(0xCC5500)          .borderRadius(5)          .width(15)          .height(14)      }.width('100%').margin(5)
      Row() {        Text("3").fontSize(14).fontColor(Color.Orange).margin({ left: 10, right: 10 })        Text("我是热搜词条3")          .fontSize(12)          .fontColor(Color.Blue)          .fontWeight(300)          .maxLines(1)          .constraintSize({ maxWidth: 200 })          .textOverflow({ overflow: TextOverflow.Ellipsis })        Text("热")          .margin({ left: 6 })          .textAlign(TextAlign.Center)          .fontSize(10)          .fontColor(Color.White)          .fontWeight(600)          .backgroundColor(0xCC5500)          .borderRadius(5)          .width(15)          .height(14)      }.width('100%').margin(5)
      Row() {        Text("4").fontSize(14).fontColor(Color.Grey).margin({ left: 10, right: 10 })        Text("我是热搜词条4 我是热搜词条4 我是热搜词条4 我是热搜词条4 我是热搜词条4")          .fontSize(12)          .fontColor(Color.Blue)          .fontWeight(300)          .constraintSize({ maxWidth: 200 })          .maxLines(1)          .textOverflow({ overflow: TextOverflow.Ellipsis })      }.width('100%').margin(5)    }.width('100%')  }}
    上一篇 进度条（Progress） 下一篇 文本输入（TextInput/TextArea） 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建输入框设置输入框类型自定义样式添加事件场景示例文本输入（TextInput/TextArea） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  TextInput、TextArea是输入框组件，通常用于响应用户的输入操作，比如评论区的输入、聊天框的输入、表格的输入等，也可以结合其它组件构建功能页面，例如登录注册页面。具体用法参考TextInput、TextArea。  创建输入框 TextInput为单行输入框、TextArea为多行输入框。通过以下接口来创建。 已复制TextArea(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextAreaController})  已复制TextInput(value?:{placeholder?: ResourceStr, text?: ResourceStr, controller?: TextInputController})  单行输入框已复制TextInput()    多行输入框已复制TextArea()  多行输入框文字超出一行时会自动折行。 已复制TextArea({text:"我是TextArea我是TextArea我是TextArea我是TextArea"}).width(300)    设置输入框类型 TextInput有5种可选类型，分别为Normal基本输入模式、Password密码输入模式、Email邮箱地址输入模式、Number纯数字输入模式、PhoneNumber电话号码输入模式。通过type属性进行设置：   基本输入模式（默认类型）已复制TextInput()  .type(InputType.Normal)  密码输入模式已复制TextInput()  .type(InputType.Password)    自定义样式  设置无输入时的提示文本。TextInput({placeholder:'我是提示文本'}) 已复制TextInput({placeholder:'我是提示文本'})     设置输入框当前的文本内容。已复制TextInput({placeholder:'我是提示文本',text:'我是当前文本内容'})  添加backgroundColor改变输入框的背景颜色。已复制TextInput({placeholder:'我是提示文本',text:'我是当前文本内容'})  .backgroundColor(Color.Pink)  更丰富的样式可以结合通用属性实现。   添加事件 文本框主要用于获取用户输入的信息，把信息处理成数据进行上传，绑定onChange事件可以获取输入框内改变的内容。用户也可以使用通用事件来进行相应的交互操作。  已复制TextInput()  .onChange((value: string) => {    console.info(value);  })  .onFocus(() => {    console.info('获取焦点');  })  场景示例 用于表单的提交，在用户登录/注册页面，用户的登录或注册的输入操作。  已复制@Entry@Componentstruct TextInputSample {  build() {    Column() {      TextInput({ placeholder: 'input your username' }).margin({ top: 20 })        .onSubmit((EnterKeyType)=>{          console.info(EnterKeyType+'输入法回车键的类型值')        })      TextInput({ placeholder: 'input your password' }).type(InputType.Password).margin({ top: 20 })        .onSubmit((EnterKeyType)=>{          console.info(EnterKeyType+'输入法回车键的类型值')        })      Button('Sign in').width(150).margin({ top: 20 })    }.padding(20)  }}    上一篇 文本显示（Text/Span） 下一篇 自定义弹窗（CustomDialog） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建视频组件加载视频资源加载本地视频加载沙箱路径视频加载网络视频添加属性事件调用Video控制器使用其他说明视频播放（Video） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Video组件用于播放视频文件并控制其播放状态，常用于为短视频应用和应用内部视频的列表页面。当视频完整出现时会自动播放，用户点击视频区域则会暂停播放，同时显示播放进度条，通过拖动播放进度条指定视频播放到具体位置。具体用法请参考Video。  创建视频组件 Video通过调用接口来创建，接口调用形式如下： 已复制Video(value: {src?: string | Resource, currentProgressRate?: number | string | PlaybackSpeed, previewUri?: string | PixelMap | Resource, controller?: VideoController}) 该接口用于创建视频播放组件。其中，src指定视频播放源的路径，加载方式请参考加载视频资源，currentProgressRate用于设置视频播放倍速，previewUri指定视频未播放时的预览图片路径，controller设置视频控制器，用于自定义控制视频。   加载视频资源 Video组件支持加载本地视频和网络视频。   加载本地视频  普通本地视频。加载本地视频时，首先在本地rawfile目录指定对应的文件，如下图所示。  再使用资源访问符$rawfile()引用视频资源。 已复制@Componentexport struct VideoPlayer{   private controller:VideoController;   private previewUris: Resource = $r ('app.media.preview');   private innerResource: Resource = $rawfile('videoTest.mp4');   build(){     Column() {       Video({         src: this.innerResource,         previewUri: this.previewUris,         controller: this.controller       })   } }}    Data Ability提供的视频路径带有dataability://前缀，使用时确保对应视频资源存在即可。已复制@Componentexport struct VideoPlayer{   private controller:VideoController;   private previewUris: Resource = $r ('app.media.preview');   private videoSrc: string = 'dataability://device_id/com.domainname.dataability.videodata/video/10'   build(){     Column() {       Video({         src: this.videoSrc,         previewUri: this.previewUris,         controller: this.controller       })   } }}   加载沙箱路径视频 支持file:///data/storage路径前缀的字符串，用于读取应用沙箱路径内的资源。需要保证应用沙箱目录路径下的文件存在并且有可读权限。 已复制@Componentexport struct VideoPlayer {  private controller: VideoController;  private videoSrc: string = 'file:///data/storage/el2/base/haps/entry/files/show.mp4'
  build() {    Column() {      Video({        src: this.videoSrc,        controller: this.controller      })    }  }}   加载网络视频 加载网络视频时，需要申请权限ohos.permission.INTERNET，具体申请方式请参考权限申请声明。此时，Video的src属性为网络视频的链接。 已复制@Componentexport struct VideoPlayer{   private controller:VideoController;   private previewUris: Resource = $r ('app.media.preview');   private videoSrc: string= 'https://www.example.com/example.mp4' // 使用时请替换为实际视频加载网址   build(){     Column() {       Video({         src: this.videoSrc,         previewUri: this.previewUris,         controller: this.controller       })   } }}   添加属性 Video组件属性主要用于设置视频的播放形式。例如设置视频播放是否静音、播放时是否显示控制条等。 已复制@Componentexport struct VideoPlayer {  private controller: VideoController;
  build() {    Column() {      Video({        controller: this.controller      })        .muted(false) //设置是否静音        .controls(false) //设置是否显示默认控制条        .autoPlay(false) //设置是否自动播放        .loop(false) //设置是否循环播放        .objectFit(ImageFit.Contain) //设置视频适配模式    }  }}   事件调用       Video组件回调事件主要为播放开始、暂停结束、播放失败、视频准备和操作进度条等事件，除此之外，Video组件也支持通用事件的调用，如点击、触摸等事件的调用。详细的事件请参考事件说明。      已复制@Entry@Componentstruct VideoPlayer{  private controller:VideoController;  private previewUris: Resource = $r ('app.media.preview');  private innerResource: Resource = $rawfile('videoTest.mp4');  build(){    Column() {      Video({        src: this.innerResource,        previewUri: this.previewUris,        controller: this.controller      })        .onUpdate((event) => {   //更新事件回调          console.info("Video update.");        })        .onPrepared((event) => {  //准备事件回调          console.info("Video prepared.");        })        .onError(() => {          //失败事件回调          console.info("Video error.");        })    }  }}    Video控制器使用 Video控制器主要用于控制视频的状态，包括播放、暂停、停止以及设置进度等，详细的使用请参考VideoController使用说明。  默认控制器默认的控制器支持视频的开始、暂停、进度调整、全屏显示四项基本功能。 已复制@Entry@Componentstruct VideoGuide {  @State videoSrc: Resource = $rawfile('videoTest.mp4')  @State previewUri: string = 'common/videoIcon.png'  @State curRate: PlaybackSpeed = PlaybackSpeed.Speed_Forward_1_00_X    build() {    Row() {      Column() {        Video({          src: this.videoSrc,          previewUri: this.previewUri,          currentProgressRate: this.curRate        })      }      .width('100%')    }    .height('100%')  }} 自定义控制器               使用自定义的控制器，先将默认控制器关闭掉，之后可以使用button以及slider等组件进行自定义的控制与显示，适合自定义较强的场景下使用。        已复制@Entry@Componentstruct VideoGuide {  @State videoSrc: Resource = $rawfile('videoTest.mp4')  @State previewUri: string = 'common/videoIcon.png'  @State curRate: PlaybackSpeed = PlaybackSpeed.Speed_Forward_1_00_X  @State isAutoPlay: boolean = false  @State showControls: boolean = true  @State sliderStartTime: string = '';  @State currentTime: number = 0;  @State durationTime: number = 0;  @State durationStringTime: string ='';  controller: VideoController = new VideoController()
  build() {    Row() {      Column() {        Video({          src: this.videoSrc,          previewUri: this.previewUri,          currentProgressRate: this.curRate,          controller: this.controller        }).controls(false).autoPlay(true)        .onPrepared((event)=>{          this.durationTime = event.duration        })        .onUpdate((event)=>{          this.currentTime =event.time        })        Row() {          Text(JSON.stringify(this.currentTime) + 's')          Slider({            value: this.currentTime,            min: 0,            max: this.durationTime          })          .onChange((value: number, mode: SliderChangeMode) => {              this.controller.setCurrentTime(value);            }).width("90%")          Text(JSON.stringify(this.durationTime) + 's')        }        .opacity(0.8)        .width("100%")      }      .width('100%')    }    .height('40%')  }}     其他说明 Video组件已经封装好了视频播放的基础能力，开发者无需进行视频实例的创建，视频信息的设置获取，只需要设置数据源以及基础信息即可播放视频，相对扩展能力较弱。如果开发者想自定义视频播放，还请参考媒体系统播放音视频。   上一篇 自定义弹窗（CustomDialog） 下一篇 XComponent 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。surface类型使用EGL/OpenGLES渲染native侧代码开发要点Napi模块注册解析XComponent组件的NativeXComponent实例注册XComponent事件回调创建EGL/OpenGLES环境ArkTS侧语法介绍媒体数据写入component类型场景示例相关实例XComponent 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
  XComponent组件作为一种绘制组件，通常用于满足开发者较为复杂的自定义绘制需求，例如相机预览流的显示和游戏画面的绘制。 其可通过指定其type字段来实现不同的功能，主要有两个“surface”和“component”字段可供选择。 对于“surface”类型，开发者可将相关数据传入XComponent单独拥有的“NativeWindow”来渲染画面。 对于“component”类型则主要用于实现动态加载显示内容的目的。  surface类型 XComponent设置为surface类型时通常用于EGL/OpenGLES和媒体数据写入，并将其显示在XComponent组件上。 设置为“surface“类型时XComponent组件可以和其他组件一起进行布局和渲染。 同时XComponent又拥有单独的“NativeWindow“，可以为开发者在native侧提供native window用来创建EGL/OpenGLES环境，进而使用标准的OpenGL ES开发。 除此之外，媒体相关应用（视频、相机等）也可以将相关数据写入XComponent所提供的NativeWindow，从而实现呈现相应画面。   使用EGL/OpenGLES渲染   native侧代码开发要点 HarmonyOS的应用如果要通过js来桥接native，一般需要使用napi接口来处理js交互，XComponent同样不例外，具体使用请参考Native API在应用工程中的使用指导。 Native侧处理js逻辑的文件类型为so：  每个模块对应一个so so的命名规则为 lib{模块名}.so   对于使用XComponent进行标准OpenGL ES开发的场景，CMAKELists.txt文件内容大致如下： 已复制cmake_minimum_required(VERSION 3.4.1)project(XComponent) # 项目名称
set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})# 头文件查找路径include_directories(${NATIVERENDER_ROOT_PATH}                    ${NATIVERENDER_ROOT_PATH}/include                    )
# 编译目标so，SHARED表示动态库add_library(nativerender SHARED            xxx.cpp            )
# 查找相关库 (包括OpenGL ES相关库和XComponent提供的ndk接口)find_library( EGL-lib              EGL )
find_library( GLES-lib              GLESv3 )
find_library( libace-lib              ace_ndk.z )
# 编译so所需要的依赖target_link_libraries(nativerender PUBLIC ${EGL-lib} ${GLES-lib} ${libace-lib} libace_napi.z.so libc++.a)  Napi模块注册 已复制static napi_value Init(napi_env env, napi_value exports){    // 定义暴露在模块上的方法    napi_property_descriptor desc[] ={        DECLARE_NAPI_FUNCTION("changeColor", PluginRender::NapiChangeColor),    };    // 通过此接口开发者可在exports上挂载native方法（即上面的PluginRender::NapiChangeColor），exports会通过js引擎绑定到js层的一个js对象    NAPI_CALL(env, napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc));    return exports;}
static napi_module nativerenderModule = {    .nm_version = 1,    .nm_flags = 0,    .nm_filename = nullptr,    .nm_register_func = Init, // 指定加载对应模块时的回调函数    .nm_modname = "nativerender", // 指定模块名称，对于XComponent相关开发，这个名称必须和ArkTS侧XComponent中libraryname的值保持一致    .nm_priv = ((void*)0),    .reserved = { 0 },};
extern "C" __attribute__((constructor)) void RegisterModule(void){    // 注册so模块    napi_module_register(&nativerenderModule);}   解析XComponent组件的NativeXComponent实例 NativeXComponent为XComponent提供了在native层的实例，可作为js层和native层XComponent绑定的桥梁。XComponent所提供的的NDK接口都依赖于该实例。具体NDK接口可参考Native XComponent。  可以在模块被加载时的回调内（即Napi模块注册中的Init函数）解析获得NativeXComponent实例 已复制{    // ...    napi_status status;    napi_value exportInstance = nullptr;    OH_NativeXComponent *nativeXComponent = nullptr;    // 用来解析出被wrap了NativeXComponent指针的属性    status = napi_get_named_property(env, exports, OH_NATIVE_XCOMPONENT_OBJ, &exportInstance);    if (status != napi_ok) {        return false;    }    // 通过napi_unwrap接口，解析出NativeXComponent的实例指针    status = napi_unwrap(env, exportInstance, reinterpret_cast<void**>(&nativeXComponent));    // ...}  注册XComponent事件回调 依赖解析XComponent组件的NativeXComponent实例拿到的NativeXComponent指针，通过OH_NativeXComponent_RegisterCallback接口进行回调注册  已复制{    ...    OH_NativeXComponent *nativeXComponent = nullptr;    // 解析出NativeXComponent实例
    OH_NativeXComponent_Callback callback;    callback->OnSurfaceCreated = OnSurfaceCreatedCB; // surface创建成功后触发，开发者可以从中获取native window的句柄    callback->OnSurfaceChanged = OnSurfaceChangedCB; // surface发生变化后触发，开发者可以从中获取native window的句柄以及XComponent的变更信息    callback->OnSurfaceDestroyed = OnSurfaceDestroyedCB; // surface销毁时触发，开发者可以在此释放资源    callback->DispatchTouchEvent = DispatchTouchEventCB; // XComponent的touch事件回调接口，开发者可以从中获得此次touch事件的信息
    OH_NativeXComponent_RegisterCallback(nativeXComponent, callback);    ...}  创建EGL/OpenGLES环境 在注册的OnSurfaceCreated回调中开发者能拿到native window的句柄（其本质就是XComponent所单独拥有的NativeWindow），因此可以在这里创建应用自己的EGL/OpenGLES开发环境，由此开始具体渲染逻辑的开发。 已复制EGLCore* eglCore_; // EGLCore为封装了OpenGL相关接口的类uint64_t width_;uint64_t height_;void OnSurfaceCreatedCB(OH_NativeXComponent* component, void* window){    int32_t ret = OH_NativeXComponent_GetXComponentSize(component, window, &width_, &height_);    if (ret === OH_NATIVEXCOMPONENT_RESULT_SUCCESS) {        eglCore_->GLContextInit(window, width_, height_); // 初始化OpenGL环境    }}   ArkTS侧语法介绍 开发者在ArkTS侧使用如下代码即可用XComponent组件进行利用EGL/OpenGLES渲染的开发。 已复制XComponent({ id: 'xcomponentId1', type: 'surface', libraryname: 'nativerender' })  .onLoad((context) => {})  .onDestroy(() => {})  id : 与XComponent组件为一一对应关系，不可重复。通常开发者可以在native侧通过OH_NativeXComponent_GetXComponentId接口来获取对应的id从而绑定对应的XComponent。 libraryname：加载模块的名称，必须与在native侧Napi模块注册时nm_modname的名字一致。       
说明
           应用加载模块实现跨语言调用有两种方式：           使用NAPI的import方式加载：已复制import nativerender from "libnativerender.so" 使用XComponent组件加载，本质也是使用了NAPI机制来加载。该加载方式和import加载方式的区别在于，在加载动态库是会将XComponent的NativeXComponent实例暴露到应用的native层中，从而让开发者可以使用XComponent的NDK接口。   
 onLoad事件        触发时刻：XComponent准备好surface后触发。 参数context：其上面挂载了暴露在模块上的native方法，使用方法类似于利用 import context2 from "libnativerender.so" 直接加载模块后获得的context2实例。 时序：onLoad事件的触发和Surface相关，其和native侧的OnSurfaceCreated的时序如下图：  onDestroy事件触发时刻：XComponent组件被销毁时触发与一般ArkUI的组件销毁时机一致，其和native侧的OnSurfaceDestroyed的时序如下图：     媒体数据写入 XComponent所持有的NativeWindow符合“生产者-消费者”模型 HarmonyOS上Camera、AVPlayer等符合生产者设计的部件都可以将数据写入XComponent持有的NativeWindow并通过XComponent显示。  开发者可通过绑定XComponentController获得对应XComponent的surfaceId（该id可以唯一确定一个surface），从而传给相应的部件接口。 已复制@State surfaceId:string = "";mXComponentController: XComponentController = new XComponentController();XComponent({ id: '', type: 'surface', controller: this.mXComponentController })  .onLoad(() => {    this.surfaceId = this.mXComponentController.getXComponentSurfaceId()  }) 具体部件接口可参考： VideoPlayer、 等。   component类型 XComponent设置为component类型时通常用于在XComponent内部执行非UI逻辑以实现动态加载显示内容的目的。  
说明
 type为"component"时，XComponent作为容器，子组件沿垂直方向布局：  垂直方向上对齐格式：FlexAlign.Start 水平方向上对齐格式：FlexAlign.Center  不支持所有的事件响应。 布局方式更改和事件响应均可通过挂载子组件来设置。 内部所写的非UI逻辑需要封装在一个或多个函数内。 
  场景示例 已复制@Builderfunction addText(label: string): void {  Text(label)    .fontSize(40)}
@Entry@Componentstruct Index {  @State message: string = 'Hello XComponent'  @State messageCommon: string = 'Hello World'  build() {    Row() {      Column() {        XComponent({ id: 'xcomponentId-container', type: 'component' }) {          addText(this.message)          Divider()            .margin(4)            .strokeWidth(2)            .color('#F1F3F5')            .width("80%")          Column() {            Text(this.messageCommon)              .fontSize(30)          }        }      }      .width('100%')    }    .height('100%')  }}    相关实例 针对XComponent，有以下示例工程可供参考：  Native XComponent组件的使用（ArkTS）    上一篇 视频播放（Video） 下一篇 添加气泡和菜单 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用通用事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    触屏事件  键鼠事件  焦点事件   上一篇 交互事件概述 下一篇 触屏事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。鼠标事件onHoveronMousehoverEffect按键事件onKeyEvent键鼠事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  键鼠事件指键盘，鼠标外接设备的输入事件。  鼠标事件 支持的鼠标事件包含通过外设鼠标、触控板触发的事件。 鼠标事件可触发以下回调：     名称 描述    onHover(event: (isHover: boolean) => void) 鼠标进入或退出组件时触发该回调。 isHover：表示鼠标是否悬浮在组件上，鼠标进入时为true, 退出时为false。   onMouse(event: (event?: MouseEvent) => void) 当前组件被鼠标按键点击时或者鼠标在组件上悬浮移动时，触发该回调，event返回值包含触发事件时的时间戳、鼠标按键、动作、鼠标位置在整个屏幕上的坐标和相对于当前组件的坐标。    当组件绑定onHover回调时，可以通过hoverEffect属性设置该组件的鼠标悬浮态显示效果。   图1 鼠标事件数据流    鼠标事件传递到ArkUI之后，会先判断鼠标事件是否是左键的按下/抬起/移动，然后做出不同响应：  是：鼠标事件先转换成相同位置的触摸事件，执行触摸事件的碰撞测试、手势判断和回调响应。接着去执行鼠标事件的碰撞测试和回调响应。 否：事件仅用于执行鼠标事件的碰撞测试和回调响应。  
说明
 所有单指可响应的触摸事件/手势事件，均可通过鼠标左键来操作和响应。例如当我们需要开发单击Button跳转页面的功能、且需要支持手指点击和鼠标左键点击，那么只绑定一个点击事件（onClick）就可以实现该效果。若需要针对手指和鼠标左键的点击实现不一样的效果，可以在onClick回调中，使用回调参数中的source字段即可判断出当前触发事件的来源是手指还是鼠标。 
  onHover 已复制onHover(event: (isHover?: boolean) => void)  鼠标悬浮事件回调。参数isHover类型为boolean，表示鼠标进入组件或离开组件。该事件不支持自定义冒泡设置，默认父子冒泡。 若组件绑定了该接口，当鼠标指针从组件外部进入到该组件的瞬间会触发事件回调，参数isHover等于true；鼠标指针离开组件的瞬间也会触发该事件回调，参数isHover等于false。 
说明
 事件冒泡：在一个树形结构中，当子节点处理完一个事件后，再将该事件交给它的父节点处理。 
  已复制// xxx.ets@Entry@Componentstruct MouseExample {  @State isHovered: boolean = false;
  build() {    Column() {      Button(this.isHovered ? 'Hovered!' : 'Not Hover')        .width(200).height(100)        .backgroundColor(this.isHovered ? Color.Green : Color.Gray)        .onHover((isHover: boolean) => { // 使用onHover接口监听鼠标是否悬浮在Button组件上          this.isHovered = isHover;        })    }.width('100%').height('100%').justifyContent(FlexAlign.Center)  }}  该示例创建了一个Button组件，初始背景色为灰色，内容为“Not Hover”。示例中的Button组件绑定了onHover回调，在该回调中将this.isHovered变量置为回调参数：isHover。 当鼠标从Button外移动到Button内的瞬间，回调响应，isHover值等于true，isHovered的值变为true，将组件的背景色改成Color.Green，内容变为“Hovered!”。 当鼠标从Button内移动到Button外的瞬间，回调响应，isHover值等于false，又将组件变成了初始的样式。   onMouse 已复制onMouse(event: (event?: MouseEvent) => void)  鼠标事件回调。绑定该API的组件每当鼠标指针在该组件内产生行为（MouseAction）时，触发事件回调，参数为MouseEvent对象，表示触发此次的鼠标事件。该事件支持自定义冒泡设置，默认父子冒泡。常见用于开发者自定义的鼠标行为逻辑处理。 开发者可以通过回调中的MouseEvent对象获取触发事件的坐标（screenX/screenY/x/y）、按键（MouseButton）、行为（MouseAction）、时间戳（timestamp）、交互组件的区域（EventTarget）、事件来源（SourceType）等。MouseEvent的回调函数stopPropagation用于设置当前事件是否阻止冒泡。 
说明
 按键（MouseButton）的值：Left/Right/Middle/Back/Forward 均对应鼠标上的实体按键，当这些按键被按下或松开时触发这些按键的事件。None表示无按键，会出现在鼠标没有按键按下或松开的状态下，移动鼠标所触发的事件中。 
 已复制// xxx.ets@Entry@Componentstruct MouseExample {  @State isHovered: boolean = false;  @State buttonText: string = '';  @State columnText: string = '';
  build() {    Column() {      Button(this.isHovered ? 'Hovered!' : 'Not Hover')        .width(200)        .height(100)        .backgroundColor(this.isHovered ? Color.Green : Color.Gray)        .onHover((isHover: boolean) => {          this.isHovered = isHover        })        .onMouse((event: MouseEvent) => {    // 给Button组件设置onMouse回调          this.buttonText = 'Button onMouse:\n' + '' +          'button = ' + event.button + '\n' +          'action = ' + event.action + '\n' +          'x,y = (' + event.x + ',' + event.y + ')' + '\n' +          'screenXY=(' + event.screenX + ',' + event.screenY + ')';        })      Divider()      Text(this.buttonText).fontColor(Color.Green)      Divider()      Text(this.columnText).fontColor(Color.Red)    }    .width('100%')    .height('100%')    .justifyContent(FlexAlign.Center)    .borderWidth(2)    .borderColor(Color.Red)    .onMouse((event: MouseEvent) => {    // 给Column组件设置onMouse回调      this.columnText = 'Column onMouse:\n' + '' +      'button = ' + event.button + '\n' +      'action = ' + event.action + '\n' +      'x,y = (' + event.x + ',' + event.y + ')' + '\n' +      'screenXY=(' + event.screenX + ',' + event.screenY + ')';    })  }} 在onHover示例的基础上，给Button绑定onMouse接口。在回调中，打印出鼠标事件的button/action等回调参数值。同时，在外层的Column容器上，也做相同的设置。整个过程可以分为以下两个动作：  移动鼠标：当鼠标从Button外部移入Button的过程中，仅触发了Column的onMouse回调；当鼠标移入到Button内部后，由于onMouse事件默认是冒泡的，所以此时会同时响应Column的onMouse回调和Button的onMouse回调。此过程中，由于鼠标仅有移动动作没有点击动作，因此打印信息中的button均为0（MouseButton.None的枚举值）、action均为3（MouseAction.Move的枚举值）。 点击鼠标：鼠标进入Button后进行了2次点击，分别是左键点击和右键点击。左键点击时：button = 1（MouseButton.Left的枚举值），按下时 action = 1（MouseAction.Press的枚举值），抬起时 action = 2（MouseAction.Release的枚举值）。 右键点击时：button = 2（MouseButton.Right的枚举值），按下时 action = 1（MouseAction.Press的枚举值），抬起时 action = 2（MouseAction.Release的枚举值）。   如果需要阻止鼠标事件冒泡，可以通过调用stopPropagation()方法进行设置。 已复制Button(this.isHovered ? 'Hovered!' : 'Not Hover')  .width(200)  .height(100)  .backgroundColor(this.isHovered ? Color.Green : Color.Gray)  .onHover((isHover: boolean) => {    this.isHovered = isHover;  })  .onMouse((event: MouseEvent) => {    event.stopPropagation(); // 在Button的onMouse事件中设置阻止冒泡    this.buttonText = 'Button onMouse:\n' + '' +    'button = ' + event.button + '\n' +    'action = ' + event.action + '\n' +    'x,y = (' + event.x + ',' + event.y + ')' + '\n' +    'screenXY=(' + event.screenX + ',' + event.screenY + ')';  }) 在子组件（Button）的onMouse中，通过回调参数event调用stopPropagation回调方法（如下）即可阻止Button子组件的鼠标事件冒泡到父组件Column上。 已复制event.stopPropagation() 效果是：当鼠标在Button组件上操作时，仅Button的onMouse回调会响应，Column的onMouse回调不会响应。  hoverEffect 已复制hoverEffect(value: HoverEffect)  鼠标悬浮态效果设置的通用属性。参数类型为HoverEffect，HoverEffect提供的Auto、Scale、Highlight效果均为固定效果，开发者无法自定义设置效果参数。    表1 HoverEffect说明         HoverEffect枚举值 效果说明    Auto 组件默认提供的悬浮态效果，由各组件定义。   Scale 动画播放方式，鼠标悬浮时：组件大小从100%放大至105%，鼠标离开时：组件大小从105%缩小至100%。   Highlight 动画播放方式，鼠标悬浮时：组件背景色叠加一个5%透明度的白色，视觉效果是组件的原有背景色变暗，鼠标离开时：组件背景色恢复至原有样式。   None 禁用悬浮态效果    已复制// xxx.ets@Entry@Componentstruct HoverExample {  build() {    Column({ space: 10 }) {      Button('Auto')        .width(170).height(70)      Button('Scale')        .width(170).height(70)        .hoverEffect(HoverEffect.Scale)      Button('Highlight')        .width(170).height(70)        .hoverEffect(HoverEffect.Highlight)      Button('None')        .width(170).height(70)        .hoverEffect(HoverEffect.None)    }.width('100%').height('100%').justifyContent(FlexAlign.Center)  }}  Button默认的悬浮态效果就是缩放效果，因此Auto和Scale的效果一样，Highlight会使背板颜色变暗，None会禁用悬浮态效果。  按键事件  图2 按键事件数据流     按键事件由外设键盘等设备触发，经驱动和多模处理转换后发送给当前获焦的窗口。窗口获取到事件后，会先给输入法分发（输入法会消费按键用作输入），若输入法未消费该按键事件，才会将事件发给ArkUI框架。因此，当某输入框组件获焦，且打开了输入法，此时大部分按键事件均会被输入法消费，例如字母键会被输入法用来往输入框中输入对应字母字符、方向键会被输入法用来切换选中备选词。 按键事件到ArkUI框架之后，会先找到完整的父子节点获焦链。从叶子节点到根节点，逐一发送按键事件。  onKeyEvent 已复制onKeyEvent(event: (event?: KeyEvent) => void)  按键事件回调，当绑定该方法的组件处于获焦状态下，外设键盘的按键事件会触发该API的回调响应，回调参数为KeyEvent，可由该参数获得当前按键事件的按键行为（KeyType）、键码（keyCode）、按键英文名称（keyText）、事件来源设备类型（KeySource）、事件来源设备id（deviceId）、元键按压状态（metaKey）、时间戳（timestamp）、阻止冒泡设置（stopPropagation）。 已复制// xxx.ets@Entry@Componentstruct KeyEventExample {  @State buttonText: string = '';  @State buttonType: string = '';  @State columnText: string = '';  @State columnType: string = '';
  build() {    Column() {      Button('onKeyEvent')        .width(140).height(70)        .onKeyEvent((event: KeyEvent) => { // 给Button设置onKeyEvent事件          if (event.type === KeyType.Down) {            this.buttonType = 'Down';          }          if (event.type === KeyType.Up) {            this.buttonType = 'Up';          }          this.buttonText = 'Button: \n' +          'KeyType:' + this.buttonType + '\n' +          'KeyCode:' + event.keyCode + '\n' +          'KeyText:' + event.keyText;        })
      Divider()      Text(this.buttonText).fontColor(Color.Green)
      Divider()      Text(this.columnText).fontColor(Color.Red)    }.width('100%').height('100%').justifyContent(FlexAlign.Center)    .onKeyEvent((event: KeyEvent) => { // 给父组件Column设置onKeyEvent事件      if (event.type === KeyType.Down) {        this.columnType = 'Down';      }      if (event.type === KeyType.Up) {        this.columnType = 'Up';      }      this.columnText = 'Column: \n' +      'KeyType:' + this.buttonType + '\n' +      'KeyCode:' + event.keyCode + '\n' +      'KeyText:' + event.keyText;    })  }} 上述示例中给组件Button和其父容器Column绑定onKeyEvent。应用打开页面加载后，组件树上第一个可获焦的非容器组件自动获焦，该应用只有一个Button组件，因此该组件会自动获焦，由于Button是Column的子节点，Button获焦也同时意味着Column获焦。获焦机制见焦点事件。  打开应用后，依次在键盘上按这些按键：“空格、回车、左Ctrl、左Shift、字母A、字母Z”。  由于onKeyEvent事件默认是冒泡的，所以Button和Column的onKeyEvent都可以响应。 每个按键都有2次回调，分别对应KeyType.Down和KeyType.Up，表示按键被按下、然后抬起。  如果要阻止冒泡，即仅Button响应键盘事件，Column不响应，在Button的onKeyEvent回调中加入event.stopPropagation()方法即可，如下： 已复制Button('onKeyEvent')  .width(140).height(70)  .onKeyEvent((event: KeyEvent) => {    // 通过stopPropagation阻止事件冒泡    event.stopPropagation();    if (event.type === KeyType.Down) {      this.buttonType = 'Down';    }    if (event.type === KeyType.Up) {       this.buttonType = 'Up';    }     this.buttonText = 'Button: \n' +     'KeyType:' + this.buttonType + '\n' +     'KeyCode:' + event.keyCode + '\n' +     'KeyText:' + event.keyText;})   上一篇 触屏事件 下一篇 焦点事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念走焦规则监听组件的焦点变化设置组件是否获焦自定义默认焦点自定义TAB键走焦顺序groupDefaultFocusfocusOnTouchfocusControl.requestFocus焦点事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   基本概念  焦点指向当前应用界面上唯一的一个可交互元素，当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入设备与应用程序进行间接交互时，基于焦点的导航和交互是重要的输入手段。   默认焦点应用打开或切换页面后，若当前页上存在可获焦的组件，则树形结构的组件树中第一个可获焦的组件默认获得焦点。可以使用自定义默认焦点进行自定义指定。 获焦指组件获得了焦点，同一时刻，应用中最多只有1个末端组件是获焦的，且此时它的所有祖宗组件（整个组件链）均是获焦的。当期望某个组件获焦，须确保该组件及其所有的祖宗节点均是可获焦的（focusable属性为true）。 失焦指组件从获焦状态变成了非获焦状态，失去了焦点。组件失焦时，它的所有祖宗组件（失焦组件链）与新的获焦组件链不相同的节点都会失焦。 走焦表示焦点在当前应用中转移的过程，走焦会带来原焦点组件的失焦和新焦点组件的获焦。应用中焦点发生变化的方式按行为可分为两类：  主动走焦：指开发者/用户主观的行为导致焦点移动，包含：外接键盘上按下TAB/方向键、使用requestFocus主动给指定组件申请焦点、组件focusOnTouch属性为true后点击组件。 被动走焦：指组件焦点因其他操作被动的转移焦点，此特性为焦点系统默认行为，无法由开发者自由设定，例如当使用if-else语句将处于获焦的组件删除/将处于获焦的组件（或其父组件）置成不可获焦时、当页面切换时。  焦点态获焦组件的样式，不同组件的焦点态样式大同小异，默认情况下焦点态不显示，仅使用外接键盘按下TAB键/方向键时才会触发焦点态样式出现。首次触发焦点态显示的TAB键/方向键不会触发走焦。当应用接收到点击事件时（包括手指触屏的按下事件和鼠标左键的按下事件），自动隐藏焦点态样式。焦点态样式由后端组件定义，开发者无法修改。    走焦规则 走焦规则是指用户使用“TAB键/SHIFT+TAB键/方向键”主动进行走焦，或焦点系统在执行被动走焦时的顺序规则。组件的走焦规则默认由走焦系统定义，由焦点所在的容器决定。  线性走焦：常见的容器有Flex、Row、Column、List，这些都是典型的单方向容器，组件在这些容器内的排列都是线性的，那么走焦规则也是线性的。走焦的方向和方向键的方向一致。        图1 线性走焦示意图  例如Row容器，使用方向键左右（←/→）即可将焦点在相邻的2个可获焦组件之间来回切换。 十字走焦：使用方向键上(↑)下(↓)左(←)右(→)可以使焦点在相邻的组件上切换。典型的是Grid容器，如下图：        图2 Grid组件十字走焦示意图  
说明
  TAB/SHIFT+TAB键在以上两种走焦规则上的功能和方向键一致。TAB键等同于“先执行方向键右，若无法走焦，再执行方向键下”，SHIFT+TAB键等同于“先执行方向键左，若无法走焦，再执行方向键上”。 触发走焦的按键是按下的事件（DOWN事件）。 删除组件、设置组件无法获焦后，会使用线性走焦规则，自动先往被删除/Unfocusable组件的前置兄弟组件上走焦，无法走焦的话，再往后置兄弟组件上走焦。  
 tabIndex走焦：给组件设置tabIndex通用属性，自定义组件的TAB键/SHIFT+TAB键的走焦顺序。 区域走焦：给容器组件设置tabIndex通用属性，再结合groupDefaultFocus通用属性，自定义容器区域的TAB键/SHIFT+TAB键的走焦顺序和默认获焦组件。 走焦至容器组件规则：当焦点走焦到容器（该容器没有配置groupDefaultFocus）上时，若该容器组件为首次获焦，则会先计算目标容器组件的子组件的区域位置，得到距离目标容器中心点最近的子组件，焦点会走到目标容器上的该子组件上。若该容器非首次获焦，焦点会自动走焦到上一次目标容器中获焦的子组件。 焦点交互：当某组件获焦时，该组件的固有点击任务或开发者绑定的onClick回调任务，会自动挂载到空格/回车按键上，当按下按键时，任务就和手指/鼠标点击一样被执行。   
说明
 本文涉及到的焦点均为组件焦点，另外一个焦点的概念是：窗口焦点，指向当前获焦的窗口。当窗口失焦时，该窗口应用中的所有获焦组件全部失焦。 
  监听组件的焦点变化 已复制onFocus(event: () => void)  获焦事件回调，绑定该API的组件获焦时，回调响应。 已复制onBlur(event:() => void) 失焦事件回调，绑定该API的组件失焦时，回调响应。 onFocus和onBlur两个接口通常成对使用，来监听组件的焦点变化。 以下示例代码展示获焦/失焦回调的使用方法： 已复制// xxx.ets@Entry@Componentstruct FocusEventExample {  @State oneButtonColor: Color = Color.Gray;  @State twoButtonColor: Color = Color.Gray;  @State threeButtonColor: Color = Color.Gray;
  build() {    Column({ space: 20 }) {      // 通过外接键盘的上下键可以让焦点在三个按钮间移动，按钮获焦时颜色变化，失焦时变回原背景色      Button('First Button')        .width(260)        .height(70)        .backgroundColor(this.oneButtonColor)        .fontColor(Color.Black)          // 监听第一个组件的获焦事件，获焦后改变颜色        .onFocus(() => {          this.oneButtonColor = Color.Green;        })          // 监听第一个组件的失焦事件，失焦后改变颜色        .onBlur(() => {          this.oneButtonColor = Color.Gray;        })
      Button('Second Button')        .width(260)        .height(70)        .backgroundColor(this.twoButtonColor)        .fontColor(Color.Black)          // 监听第二个组件的获焦事件，获焦后改变颜色        .onFocus(() => {          this.twoButtonColor = Color.Green;        })          // 监听第二个组件的失焦事件，失焦后改变颜色        .onBlur(() => {          this.twoButtonColor = Color.Grey;        })
      Button('Third Button')        .width(260)        .height(70)        .backgroundColor(this.threeButtonColor)        .fontColor(Color.Black)          // 监听第三个组件的获焦事件，获焦后改变颜色        .onFocus(() => {          this.threeButtonColor = Color.Green;        })          // 监听第三个组件的失焦事件，失焦后改变颜色        .onBlur(() => {          this.threeButtonColor = Color.Gray ;        })    }.width('100%').margin({ top: 20 })  }}  上述示例包含以下4步：  应用打开时，“First Button”默认获取焦点，onFocus回调响应，背景色变成绿色。 按下TAB键（或方向键下↓），“First Button”显示焦点态样式：组件外围有一个蓝色的闭合框。不触发走焦，焦点仍然在“First Button”上。 按下TAB键（或方向键下↓），触发走焦，“Second Button”获焦，onFocus回调响应，背景色变成绿色；“First Button”失焦、onBlur回调响应，背景色变回灰色。 按下TAB键（或方向键下↓），触发走焦，“Third Button”获焦，onFocus回调响应，背景色变成绿色；“Second Button”失焦、onBlur回调响应，背景色变回灰色。   设置组件是否获焦 通过focusable接口设置组件是否可获焦： 已复制focusable(value: boolean) 按照组件的获焦能力可大致分为三类：  默认可获焦的组件，通常是有交互行为的组件，例如Button、Checkbox，TextInput组件，此类组件无需设置任何属性，默认即可获焦。 有获焦能力，但默认不可获焦的组件，典型的是Text、Image组件，此类组件缺省情况下无法获焦，若需要使其获焦，可使用通用属性focusable(true)使能。 无获焦能力的组件，通常是无任何交互行为的展示类组件，例如Blank、Circle组件，此类组件即使使用focusable属性也无法使其可获焦。   
说明
  focusable为false表示组件不可获焦，同样可以使组件变成不可获焦的还有通用属性enabled。 当某组件处于获焦状态时，将其的focusable属性或enabled属性设置为false，会自动使该组件失焦，然后焦点按照走焦规则将焦点转移给其他组件。  
    表1 基础组件获焦能力         基础组件 是否有获焦能力 focusable默认值 走焦规则    AlphabetIndexer 是 true 线性走焦   Blank 否 false /   Button 是 true /   Checkbox 是 true /   CheckboxGroup 是 true /   DataPanel 否 false /   DatePicker 是 true 线性走焦   Divider 否 false /   Gauge 否 false /   Image 是 false /   ImageAnimator 是 false /   LoadingProgress 否 false /   Marquee 否 false /   Menu 是 true 线性走焦   MenuItem 是 true /   MenuItemGroup 是 true 线性走焦   Navigation 否 false 组件自定义   NavRouter 否 false 跟随子容器   NavDestination 否 false 线性走焦   PatternLock 否 false /   Progress 否 false /   QRCode 否 false /   Radio 是 true /   Rating 是 true /   RichText 否 false /   ScrollBar 否 false /   Search 是 true /   Select 是 true 线性走焦   Slider 是 true /   Span 否 false /   Stepper 是 true /   StepperItem 是 true /   Text 是 false /   TextArea 是 true /   TextClock 否 false /   TextInput 是 true /   TextPicker 是 true 线性走焦   TextTimer 否 false /   TimePicker 是 true 线性走焦   Toggle 是 true /   Web 是 true Web组件自定义   XComponent 否 false /       表2 容器组件获焦能力         容器组件 是否可获焦 focusable默认值 走焦规则    Badge 否 false /   Column 是 true 线性走焦   ColumnSplit 是 true /   Counter 是 true 线性走焦   Flex 是 true 线性走焦   GridCol 是 true 容器组件自定义   GridRow 是 true 容器组件自定义   Grid 是 true 容器组件自定义   GridItem 是 true 跟随子组件   List 是 true 线性走焦   ListItem 是 true 跟随子组件   ListItemGroup 是 true 跟随List组件   Navigator 否 true 容器组件自定义   Panel 否 true 跟随子组件   Refresh 否 false /   RelativeContainer 否 true 容器组件自定义   Row 是 true 线性走焦   RowSplit 是 true /   Scroll 是 true 线性走焦   SideBarContainer 是 true 线性走焦   Stack 是 true 线性走焦   Swiper 是 true 容器组件自定义   Tabs 是 true 容器组件自定义   TabContent 是 true 跟随子组件       表3 媒体组件获焦能力         媒体组件 是否可获焦 focusable默认值 走焦规则    Video 是 true /       表4 画布组件获焦能力         画布组件 是否可获焦 focusable默认值 走焦规则    Canvas 否 false /    以下示例为大家展示focusable接口的使用方法： 已复制// xxx.ets@Entry@Componentstruct FocusableExample {  @State textFocusable: boolean = true;  @State color1: Color = Color.Yellow;  @State color2: Color = Color.Yellow;
  build() {    Column({ space: 5 }) {      Text('Default Text')    // 第一个Text组件未设置focusable属性，默认不可获焦        .borderColor(this.color1)        .borderWidth(2)        .width(300)        .height(70)        .onFocus(() => {          this.color1 = Color.Blue;        })        .onBlur(() => {          this.color1 = Color.Yellow;        })      Divider()
      Text('focusable: ' + this.textFocusable)    // 第二个Text设置了focusable属性，初始值为true        .borderColor(this.color2)        .borderWidth(2)        .width(300)        .height(70)        .focusable(this.textFocusable)        .onFocus(() => {          this.color2 = Color.Blue;        })        .onBlur(() => {          this.color2 = Color.Yellow;        })
      Divider()
      Row() {        Button('Button1')          .width(140).height(70)        Button('Button2')          .width(160).height(70)      }
      Divider()      Button('Button3')        .width(300).height(70)
      Divider()    }.width('100%').justifyContent(FlexAlign.Center)    .onKeyEvent((e) => {    // 绑定onKeyEvent，在该Column组件获焦时，按下'F'键，可将第二个Text的focusable置反      if (e.keyCode === 2022 && e.type === KeyType.Down) {        this.textFocusable = !this.textFocusable;      }    })  }} 运行效果：  上述示例包含默认获焦和主动走焦两部分： 默认获焦：  根据默认焦点的说明，该应用打开后，默认第一个可获焦元素获焦： 第一个Text组件没有设置focusable(true)属性，该Text组件无法获焦。 第二个Text组件的focusable属性显式设置为true，说明该组件可获焦，那么默认焦点将置到它身上。  主动走焦： 按键盘F键，触发onKeyEvent，focusable置为false，Text组件变成不可获焦，焦点自动转移，按照被动走焦中的说明项，焦点会自动从Text组件先向上寻找下一个可获焦组件，由于上一个组件是一个不可获焦的Text，所以向下寻找下一个可获焦的组件，找到并使焦点转移到Row容器上，根据走焦至容器规则，计算Button1和Button2的位置，Button2比Button1更大，因此焦点会自动转移到Button2上。  自定义默认焦点 已复制defaultFocus(value: boolean) 焦点系统在页面初次构建完成时，会搜索当前页下的所有组件，找到第一个绑定了defaultFocus(true)的组件，然后将该组件置为默认焦点，若无任何组件绑定defaultFocus(true)，则将第一个找到的可获焦的组件置为默认焦点。 以如下应用为例，应用布局如下：  以下是实现该应用的示例代码，且示例代码中没有设置defaultFocus： 已复制// xxx.etsimport promptAction from '@ohos.promptAction';
class MyDataSource implements IDataSource {  private list: number[] = [];  private listener: DataChangeListener;
  constructor(list: number[]) {    this.list = list;  }
  totalCount(): number {    return this.list.length;  }
  getData(index: number): any {    return this.list[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    this.listener = listener;  }
  unregisterDataChangeListener() {  }}
@Entry@Componentstruct SwiperExample {  private swiperController: SwiperController = new SwiperController()  private data: MyDataSource = new MyDataSource([])
  aboutToAppear(): void {    let list = []    for (let i = 1; i <= 4; i++) {      list.push(i.toString());    }    this.data = new MyDataSource(list);  }
  build() {    Column({ space: 5 }) {      Swiper(this.swiperController) {        LazyForEach(this.data, (item: string) => {          Row({ space: 20 }) {            Column() {              Button('1').width(200).height(200)                .fontSize(40)                .backgroundColor('#dadbd9')            }
            Column({ space: 20 }) {              Row({ space: 20 }) {                Button('2')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')                Button('3')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')              }
              Row({ space: 20 }) {                Button('4')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')                Button('5')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')              }
              Row({ space: 20 }) {                Button('6')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')                Button('7')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')              }            }          }          .width(480)          .height(380)          .justifyContent(FlexAlign.Center)          .borderWidth(2)          .borderColor(Color.Gray)          .backgroundColor(Color.White)        }, item => item)      }      .cachedCount(2)      .index(0)      .interval(4000)      .indicator(true)      .loop(true)      .duration(1000)      .itemSpace(0)      .curve(Curve.Linear)      .onChange((index: number) => {        console.info(index.toString());      })      .margin({ left: 20, top: 20, right: 20 })
      Row({ space: 40 }) {        Button('←')          .fontSize(40)          .fontWeight(FontWeight.Bold)          .fontColor(Color.Black)          .backgroundColor(Color.Transparent)          .onClick(() => {            this.swiperController.showPrevious();          })        Button('→')          .fontSize(40)          .fontWeight(FontWeight.Bold)          .fontColor(Color.Black)          .backgroundColor(Color.Transparent)          .onClick(() => {            this.swiperController.showNext();          })      }      .width(480)      .height(50)      .justifyContent(FlexAlign.Center)      .borderWidth(2)      .borderColor(Color.Gray)      .backgroundColor('#f7f6dc')
      Row({ space: 40 }) {        Button('Cancel')          .fontSize(30)          .fontColor('#787878')          .type(ButtonType.Normal)          .width(140)          .height(50)          .backgroundColor('#dadbd9')                Button('OK')          .fontSize(30)          .fontColor('#787878')          .type(ButtonType.Normal)          .width(140)          .height(50)          .backgroundColor('#dadbd9')          .onClick(() => {            promptAction.showToast({ message: 'Button OK on clicked' });          })      }      .width(480)      .height(80)      .justifyContent(FlexAlign.Center)      .borderWidth(2)      .borderColor(Color.Gray)      .backgroundColor('#dff2e4')      .margin({ left: 20, bottom: 20, right: 20 })    }.backgroundColor('#f2f2f2')    .margin({ left: 50, top: 50, right: 20 })  }}  当前应用上无任何defaultFocus设置，所以第一个可获焦的组件默认获取焦点，按下TAB键/方向键让获焦的组件显示焦点态样式：  假设开发者想让应用打开的时候，无需执行多余的切换焦点操作，直接点击按键的空格/回车键，就可以执行Button-OK的onClick回调操作，那么就可以给这个Button绑定defaultFocus(true)，让它成为该页面上的默认焦点： 已复制Button('OK')  .defaultFocus(true)    // 设置Button-OK为defaultFocus  .fontSize(30)  .fontColor('#787878')  .type(ButtonType.Normal)  .width(140).height(50).backgroundColor('#dadbd9')  .onClick(() => {    promptAction.showToast({ message: 'Button OK on clicked' });  })  打开应用后按TAB键，Button-OK显示了焦点态，说明默认焦点变更到了Button-OK上。然后按下空格，响应了Button-OK的onClick事件。  自定义TAB键走焦顺序 已复制tabIndex(index: number) tabIndex用于设置自定义TAB键走焦顺序，默认值为0。使用“TAB/Shift+TAB键”走焦时（方向键不影响），系统会自动获取到所有配置了tabIndex大于0的组件，然后按照递增/递减排序进行走焦。  以defaultFocus提供的示例为例，默认情况下的走焦顺序如下：  默认的走焦顺序从第一个获焦组件一路走到最后一个获焦组件，会经历Button1->Button4->Button5->Button7->左箭头->右箭头->ButtonOK。这种走焦队列比较完整，遍历了大部分的组件。但缺点是从第一个走到最后一个所经历的路径较长。 如果想实现快速的从第一个走到最后一个，又不想牺牲太多的遍历完整性，就可以使用tabIndex通用属性。 比如：开发者把白色的区域当为一个整体，黄色的区域当为一个整体，绿色的区域当为一个整体，实现Button1->左箭头->ButtonOK这种队列的走焦顺序，只需要在Button1、左箭头、ButtonOK这三个组件上依次增加tabIndex(1)、tabIndex(2)、tabIndex(3)。tabIndex的参数表示TAB走焦的顺序（从大于0的数字开始，从小到大排列）。 已复制  Button('1').width(200).height(200)    .fontSize(40)    .backgroundColor('#dadbd9')    .tabIndex(1)    // Button-1设置为第一个tabIndex节点 已复制  Button('←')    .fontSize(40)    .fontWeight(FontWeight.Bold)    .fontColor(Color.Black)    .backgroundColor(Color.Transparent)    .onClick(() => {      this.swiperController.showPrevious();    })    .tabIndex(2)    // Button-左箭头设置为第二个tabIndex节点 已复制Button('OK')  .fontSize(30)  .fontColor('#787878')  .type(ButtonType.Normal)  .width(140).height(50).backgroundColor('#dadbd9')  .onClick(() => {    promptAction.showToast({ message: 'Button OK on clicked' });  })  .tabIndex(3)    // Button-OK设置为第三个tabIndex节点  
说明
  当焦点处于tabIndex(大于0)节点上时，TAB/ShiftTAB会优先在tabIndex(大于0)的队列中寻找后置/前置的节点，存在则走焦至相应的tabIndex节点。若不存在，则使用默认的走焦逻辑继续往后/往前走焦。 当焦点处于tabIndex(等于0)节点上时，TAB/ShiftTAB使用默认的走焦逻辑走焦，走焦的过程中会跳过tabIndex(大于0)和tabIndex(小于0）的节点。 当焦点处于tabIndex(小于0)节点上时，TAB/ShiftTAB无法走焦。  
  groupDefaultFocus 已复制groupDefaultFocus(value: boolean) 自定义TAB键走焦顺序中所展示的使用tabIndex完成快速走焦的能力有如下问题： 每个区域（白色/黄色/绿色三个区域）都设置了某个组件为tabIndex节点（白色-Button1、黄色-左箭头、绿色-ButtonOK），但这样设置之后，只能在这3个组件上按TAB/ShiftTab键走焦时会有快速走焦的效果。 解决方案是给每个区域的容器设置tabIndex，但是这样设置的问题是：第一次走焦到容器上时，获焦的子组件是默认的第一个可获焦组件，并不是自己想要的组件（Button1、左箭头、ButtonOK）。 这样便引入了groupDefaultFocus通用属性，参数：boolean，默认值：false。 用法需和tabIndex组合使用，使用tabIndex给区域（容器）绑定走焦顺序，然后给Button1、左箭头、ButtonOK绑定groupDefaultFocus(true)，这样在首次走焦到目标区域（容器）上时，它的绑定了groupDefaultFocus(true)的子组件同时获得焦点。 已复制// xxx.etsimport promptAction from '@ohos.promptAction';
class MyDataSource implements IDataSource {  private list: number[] = [];  private listener: DataChangeListener;
  constructor(list: number[]) {    this.list = list;  }
  totalCount(): number {    return this.list.length;  }
  getData(index: number): any {    return this.list[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    this.listener = listener;  }
  unregisterDataChangeListener() {  }}
@Entry@Componentstruct SwiperExample {  private swiperController: SwiperController = new SwiperController()  private data: MyDataSource = new MyDataSource([])
  aboutToAppear(): void {    let list = []    for (let i = 1; i <= 4; i++) {      list.push(i.toString());    }    this.data = new MyDataSource(list);  }
  build() {    Column({ space: 5 }) {      Swiper(this.swiperController) {        LazyForEach(this.data, (item: string) => {          Row({ space: 20 }) {    // 设置该Row组件为tabIndex的第一个节点            Column() {              Button('1').width(200).height(200)                .fontSize(40)                .backgroundColor('#dadbd9')                .groupDefaultFocus(true)    // 设置Button-1为第一个tabIndex的默认焦点            }
            Column({ space: 20 }) {              Row({ space: 20 }) {                Button('2')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')                Button('3')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')              }
              Row({ space: 20 }) {                Button('4')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')                Button('5')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')              }
              Row({ space: 20 }) {                Button('6')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')                Button('7')                  .width(100)                  .height(100)                  .fontSize(40)                  .type(ButtonType.Normal)                  .borderRadius(20)                  .backgroundColor('#dadbd9')              }            }          }          .width(480)          .height(380)          .justifyContent(FlexAlign.Center)          .borderWidth(2)          .borderColor(Color.Gray)          .backgroundColor(Color.White)          .tabIndex(1)        }, item => item)      }      .cachedCount(2)      .index(0)      .interval(4000)      .indicator(true)      .loop(true)      .duration(1000)      .itemSpace(0)      .curve(Curve.Linear)      .onChange((index: number) => {        console.info(index.toString());      })      .margin({ left: 20, top: 20, right: 20 })
      Row({ space: 40 }) {    // 设置该Row组件为第二个tabIndex节点        Button('←')          .fontSize(40)          .fontWeight(FontWeight.Bold)          .fontColor(Color.Black)          .backgroundColor(Color.Transparent)          .onClick(() => {            this.swiperController.showPrevious();          })          .groupDefaultFocus(true)    // 设置Button-左箭头为第二个tabIndex节点的默认焦点        Button('→')          .fontSize(40)          .fontWeight(FontWeight.Bold)          .fontColor(Color.Black)          .backgroundColor(Color.Transparent)          .onClick(() => {            this.swiperController.showNext();          })      }      .width(480)      .height(50)      .justifyContent(FlexAlign.Center)      .borderWidth(2)      .borderColor(Color.Gray)      .backgroundColor('#f7f6dc')      .tabIndex(2)
      Row({ space: 40 }) {    // 设置该Row组件为第三个tabIndex节点        Button('Cancel')          .fontSize(30)          .fontColor('#787878')          .type(ButtonType.Normal)          .width(140)          .height(50)          .backgroundColor('#dadbd9')
        Button('OK')          .fontSize(30)          .fontColor('#787878')          .type(ButtonType.Normal)          .width(140)          .height(50)          .backgroundColor('#dadbd9')          .defaultFocus(true)          .onClick(() => {            promptAction.showToast({ message: 'Button OK on clicked' });          })          .groupDefaultFocus(true)    // 设置Button-OK为第三个tabIndex节点的默认焦点      }      .width(480)      .height(80)      .justifyContent(FlexAlign.Center)      .borderWidth(2)      .borderColor(Color.Gray)      .backgroundColor('#dff2e4')      .margin({ left: 20, bottom: 20, right: 20 })      .tabIndex(3)    }.backgroundColor('#f2f2f2')    .margin({ left: 50, top: 50, right: 20 })  }}    focusOnTouch 已复制focusOnTouch(value: boolean) 点击获焦能力，参数：boolean，默认值：false（输入类组件：TextInput、TextArea、Search、Web默认值是true）。 点击是指使用触屏或鼠标左键进行单击，默认为false的组件，例如Button，不绑定该API时，点击Button不会使其获焦，当给Button绑定focusOnTouch(true)时，点击Button会使Button立即获得焦点。 给容器绑定focusOnTouch(true)时，点击容器区域，会立即使容器的第一个可获焦组件获得焦点。 示例代码： 已复制// requestFocus.etsimport promptAction from '@ohos.promptAction';
@Entry@Componentstruct RequestFocusExample {  @State idList: string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'N']
  build() {    Column({ space:20 }){      Button("id: " + this.idList[0] + " focusOnTouch(true) + focusable(false)")        .width(400).height(70).fontColor(Color.White).focusOnTouch(true)        .focusable(false)      Button("id: " + this.idList[1] + " default")        .width(400).height(70).fontColor(Color.White)      Button("id: " + this.idList[2] + " focusOnTouch(false)")        .width(400).height(70).fontColor(Color.White).focusOnTouch(false)      Button("id: " + this.idList[3] + " focusOnTouch(true)")        .width(400).height(70).fontColor(Color.White).focusOnTouch(true)    }.width('100%').margin({ top:20 })  }}  效果：  解读： Button-A虽然设置了focusOnTouch(true)，但是同时也设置了focusable(false)，该组件无法获焦，因此点击后也无法获焦； Button-B不设置相关属性，点击后不会获焦； Button-C设置了focusOnTouch(false)，同Button-B，点击后也不会获焦； Button-D设置了focusOnTouch(true)，点击即可使其获焦； 
说明
 由于焦点态的阐述的特性，焦点态在屏幕接收点击事件后会立即清除。因此该示例代码在每次点击后，需要再次按下TAB键使焦点态再次显示，才可知道当前焦点所在的组件。 
  focusControl.requestFocus 已复制focusControl.requestFocus(id: string) 主动申请焦点能力的全局方法，参数：string，参数表示被申请组件的id（通用属性id设置的字符串）。  使用方法为：在任意执行语句中调用该API，指定目标组件的id为方法参数，当程序执行到该语句时，会立即给指定的目标组件申请焦点。 代码示例： 已复制// requestFocus.etsimport promptAction from '@ohos.promptAction';
@Entry@Componentstruct RequestFocusExample {  @State idList: string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'N']  @State requestId: number = 0
  build() {    Column({ space:20 }){      Row({space: 5}) {        Button("id: " + this.idList[0] + " focusable(false)")          .width(200).height(70).fontColor(Color.White)          .id(this.idList[0])          .focusable(false)        Button("id: " + this.idList[1])          .width(200).height(70).fontColor(Color.White)          .id(this.idList[1])      }      Row({space: 5}) {        Button("id: " + this.idList[2])          .width(200).height(70).fontColor(Color.White)          .id(this.idList[2])        Button("id: " + this.idList[3])          .width(200).height(70).fontColor(Color.White)          .id(this.idList[3])      }      Row({space: 5}) {        Button("id: " + this.idList[4])          .width(200).height(70).fontColor(Color.White)          .id(this.idList[4])        Button("id: " + this.idList[5])          .width(200).height(70).fontColor(Color.White)          .id(this.idList[5])      }    }.width('100%').margin({ top:20 })    .onKeyEvent((e) => {      if (e.keyCode >= 2017 && e.keyCode <= 2022) {        this.requestId = e.keyCode - 2017;      } else if (e.keyCode === 2030) {        this.requestId = 6;      } else {        return;      }      if (e.type !== KeyType.Down) {        return;      }      let res = focusControl.requestFocus(this.idList[this.requestId]);      if (res) {        promptAction.showToast({message: 'Request success'});      } else {        promptAction.showToast({message: 'Request failed'});      }    })  }} 效果：  解读：页面中共6个Button组件，其中Button-A组件设置了focusable(false)，表示其不可获焦，在外部容器的onKeyEvent中，监听按键事件，当按下A ~ F按键时，分别去申请Button A ~ F 的焦点，另外按下N键，是给当前页面上不存在的id的组件去申请焦点。  按下TAB键，由于第一个组件Button-A设置了无法获焦，那么默认第二个组件Button-B获焦，Button-B展示焦点态样式； 键盘上按下A键，申请Button-A的焦点，气泡显示Request failed，表示无法获取到焦点，焦点位置未改变； 键盘上按下B键，申请Button-B的焦点，气泡显示Request success，表示获焦到了焦点，焦点位置原本就在Button-B，位置未改变； 键盘上按下C键，申请Button-C的焦点，气泡显示Request success，表示获焦到了焦点，焦点位置从Button-B变更为Button-C； 键盘上按下D键，申请Button-D的焦点，气泡显示Request success，表示获焦到了焦点，焦点位置从Button-C变更为Button-D； 键盘上按下E键，申请Button-E的焦点，气泡显示Request success，表示获焦到了焦点，焦点位置从Button-D变更为Button-E； 键盘上按下F键，申请Button-F的焦点，气泡显示Request success，表示获焦到了焦点，焦点位置从Button-E变更为Button-F； 键盘上按下N键，申请未知组件的焦点，气泡显示Request failed，表示无法获取到焦点，焦点位置不变；   上一篇 键鼠事件 下一篇 使用手势事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。点击事件拖拽事件触摸事件触屏事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  触屏事件指当手指/手写笔在组件上按下、滑动、抬起时触发的回调事件。包括点击事件、拖拽事件和触摸事件。 图1 触摸事件原理    点击事件 点击事件是指通过手指或手写笔做出一次完整的按下和抬起动作。当发生点击事件时，会触发以下回调函数：  已复制onClick(event: (event?: ClickEvent) => void) event参数提供点击事件相对于窗口或组件的坐标位置，以及发生点击的事件源。      例如通过按钮的点击事件控制图片的显示和隐藏。     已复制@Entry@Componentstruct IfElseTransition {  @State flag: boolean = true;  @State btnMsg: string = 'show';
  build() {    Column() {      Button(this.btnMsg).width(80).height(30).margin(30)        .onClick(() => {          if (this.flag) {            this.btnMsg = 'hide';          } else {            this.btnMsg = 'show';          }          // 点击Button控制Image的显示和消失          this.flag = !this.flag;        })      if (this.flag) {        Image($r('app.media.icon')).width(200).height(200)      }    }.height('100%').width('100%')  }}   拖拽事件 拖拽事件指手指/手写笔长按组件（>=500ms），并拖拽到接收区域释放的事件。拖拽事件触发流程：    拖拽事件的触发通过长按、拖动平移判定，手指平移的距离达到5vp即可触发拖拽事件。ArkUI支持应用内、跨应用的拖拽事件。 拖拽事件提供以下接口：     接口名称 描述    onDragStart(event: (event?: DragEvent, extraParams?: string) => CustomBuilder | DragItemInfo) 拖拽启动接口。当前仅支持自定义pixelmap和自定义组件。   onDragEnter(event: (event?: DragEvent, extraParams?: string) => void) 拖拽进入组件接口。DragEvent定义拖拽发生位置，extraParmas表示用户自定义信息   onDragLeave(event: (event?: DragEvent, extraParams?: string) => void) 拖拽离开组件接口。DragEvent定义拖拽发生位置，extraParmas表示拖拽事件额外信息。   onDragMove(event: (event?: DragEvent, extraParams?: string) => void) 拖拽移动接口。DragEvent定义拖拽发生位置，extraParmas表示拖拽事件额外信息。   onDrop(event: (event?: DragEvent, extraParams?: string) => void) 拖拽释放组件接口。DragEvent定义拖拽发生位置，extraParmas表示拖拽事件额外信息。    如下是跨窗口拖拽，拖出窗口示例： 已复制import image from '@ohos.multimedia.image';
@Entry@Componentstruct Index {  @State visible: Visibility = Visibility.Visible  private pixelMapReader = undefined
  aboutToAppear() {    console.info('begin to create pixmap has info message: ')    this.createPixelMap()  }
  createPixelMap() {    let color = new ArrayBuffer(4 * 96 * 96);    var buffer = new Uint8Array(color);    for (var i = 0; i < buffer.length; i++) {      buffer[i] = (i + 1) % 255;    }    let opts = {      alphaType: 0,      editable: true,      pixelFormat: 4,      scaleMode: 1,      size: { height: 96, width: 96 }    }    const promise = image.createPixelMap(color, opts);    promise.then((data) => {      console.info('create pixmap has info message: ' + JSON.stringify(data))      this.pixelMapReader = data;    })  }
  @Builder pixelMapBuilder() {    Text('drag item')      .width('100%')      .height(100)      .fontSize(16)      .textAlign(TextAlign.Center)      .borderRadius(10)      .backgroundColor(0xFFFFFF)  }
  build() {    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {      Text('App1')        .width('40%')        .height(80)        .fontSize(20)        .margin(30)        .textAlign(TextAlign.Center)        .backgroundColor(Color.Pink)        .visibility(Visibility.Visible)
      Text('Across Window Drag This')        .width('80%')        .height(80)        .fontSize(16)        .margin(30)        .textAlign(TextAlign.Center)        .backgroundColor(Color.Pink)        .visibility(this.visible)        .onDragStart(() => {                    //启动跨窗口拖拽          console.info('Text onDrag start')          return { pixelMap: this.pixelMapReader, extraInfo: 'custom extra info.' }        })        .onDrop((event: DragEvent, extraParams: string) => {          console.info('Text onDragDrop,  ')          this.visible = Visibility.None                    //拖动结束后，使源不可见        })    }
    .width('100%')    .height('100%')  }} 跨窗口拖拽，拖入示例： 已复制@Entry@Componentstruct Index {  @State number: string[] = ['drag here']  @State text: string = ''  @State bool1: boolean = false  @State bool2: boolean = false  @State visible: Visibility = Visibility.Visible  @State visible2: Visibility = Visibility.None  scroller: Scroller = new Scroller()
  build() {    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {      Text('App2')        .width('40%')        .height(80)        .fontSize(20)        .margin(30)        .textAlign(TextAlign.Center)        .backgroundColor(Color.Pink)        .visibility(Visibility.Visible)
      List({ space: 20, initialIndex: 0 }) {        ForEach(this.number, (item) => {          ListItem() {            Text('' + item)              .width('100%')              .height(80)              .fontSize(16)              .borderRadius(10)              .textAlign(TextAlign.Center)              .backgroundColor(0xFFFFFF)          }        }, item => item)
        ListItem() {          Text('Across Window Drag This')            .width('80%')            .height(80)            .fontSize(16)            .margin(30)            .textAlign(TextAlign.Center)            .backgroundColor(Color.Pink)            .visibility(this.visible2)        }      }      .height('50%')      .width('90%')      .border({ width: 1 })      .divider({ strokeWidth: 2, color: 0xFFFFFF, startMargin: 20, endMargin: 20 })      .onDragEnter((event: DragEvent, extraParams: string) => {                         //拖拽进去组件        console.info('List onDragEnter, ' + extraParams)      })      .onDragMove((event: DragEvent, extraParams: string) => {                          //拖拽时移动        console.info('List onDragMove, ' + extraParams)      })      .onDragLeave((event: DragEvent, extraParams: string) => {                         //拖拽离开组件        console.info('List onDragLeave, ' + extraParams)      })      .onDrop((event: DragEvent, extraParams: string) => {                              //释放组件        console.info('List onDragDrop, ' + extraParams)        this.visible2 = Visibility.Visible                                              //拖拽完成使拖入目标可见      })    }    .width('100%')    .height('100%')  }}  触摸事件 当手指或手写笔在组件上触碰时，会触发不同动作所对应的事件响应，包括按下（Down）、滑动（Move）、抬起（Up）事件： 已复制onTouch(event: (event?: TouchEvent) => void)  event.type为TouchType.Down：表示手指按下。 event.type为TouchType.Up：表示手指抬起。 event.type为TouchType.Move：表示手指按住移动。  触摸事件可以同时多指触发，通过event参数可获取触发的手指位置、手指唯一标志、当前发生变化的手指和输入的设备源等信息。 已复制// xxx.ets@Entry@Componentstruct TouchExample {  @State text: string = '';  @State eventType: string = '';
  build() {    Column() {      Button('Touch').height(40).width(100)        .onTouch((event: TouchEvent) => {          if (event.type === TouchType.Down) {            this.eventType = 'Down';          }          if (event.type === TouchType.Up) {            this.eventType = 'Up';          }          if (event.type === TouchType.Move) {            this.eventType = 'Move';          }          this.text = 'TouchType:' + this.eventType + '\nDistance between touch point and touch element:\nx: '          + event.touches[0].x + '\n' + 'y: ' + event.touches[0].y + '\nComponent globalPos:('          + event.target.area.globalPosition.x + ',' + event.target.area.globalPosition.y + ')\nwidth:'          + event.target.area.width + '\nheight:' + event.target.area.height        })      Button('Touch').height(50).width(200).margin(20)        .onTouch((event: TouchEvent) => {          if (event.type === TouchType.Down) {            this.eventType = 'Down';          }          if (event.type === TouchType.Up) {            this.eventType = 'Up';          }          if (event.type === TouchType.Move) {            this.eventType = 'Move';          }          this.text = 'TouchType:' + this.eventType + '\nDistance between touch point and touch element:\nx: '          + event.touches[0].x + '\n' + 'y: ' + event.touches[0].y + '\nComponent globalPos:('          + event.target.area.globalPosition.x + ',' + event.target.area.globalPosition.y + ')\nwidth:'          + event.target.area.width + '\nheight:' + event.target.area.height        })      Text(this.text)    }.width('100%').padding(30)  }}    上一篇 使用通用事件 下一篇 键鼠事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ArkTS语言基础类库概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  ArkTS语言基础类库是HarmonyOS系统上为应用开发者提供的常用基础能力，主要包含能力如下图所示。  图1 ArkTS语言基础类库能力示意图   提供异步并发和多线程并发的能力。  支持Promise和async/await等标准的JS异步并发能力。 TaskPool为应用程序提供一个多线程的运行环境，降低整体资源的消耗、提高系统的整体性能，开发者无需关心线程实例的生命周期。 Worker支持多线程并发，支持Worker线程和宿主线程之间进行通信，开发者需要主动创建和关闭Worker线程。  提供常见的容器类库增、删、改、查的能力。 提供XML、URL、URI构造和解析的能力。  XML被设计用来传输和存储数据，是一种可扩展标记语言。语言基础类库提供了XML生成、解析与转换的能力。 URL、URI构造和解析能力：其中URI是统一资源标识符，可以唯一标识一个资源。URL为统一资源定位符，可以提供找到该资源的路径。  提供常见的字符串和二进制数据处理的能力，以及控制台打印的相关能力。  字符串编解码功能。 基于Base64的字节编码和解码功能。 提供常见的有理数操作支持，包括有理数的比较、获取分子分母等功能。 提供Scope接口用于描述一个字段的有效范围。 提供二进制数据处理的能力，常见于TCP流或文件系统操作等场景中用于处理二进制数据流。 Console提供控制台打印的能力。  提供获取进程信息和操作进程的能力。   上一篇 ArkTS语言基础类库 下一篇 并发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。管理组件拥有的状态 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    @State装饰器：组件内状态  @Prop装饰器：父子单向同步  @Link装饰器：父子双向同步  @Provide装饰器和@Consume装饰器：与后代组件双向同步  @Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化   上一篇 状态管理概述 下一篇 @State装饰器：组件内状态 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加组件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    添加常用组件  添加气泡和菜单   上一篇 改善布局性能 下一篇 添加常用组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。装饰器说明装饰器使用示例@Concurrent装饰器：校验并发函数 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在使用TaskPool时，执行的并发函数需要使用该装饰器修饰，否则无法通过相关校验。 
说明
 从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
  装饰器说明     @Concurrent并发装饰器 说明    装饰器参数 无。   使用场景 仅支持在Stage模型的工程中使用。   装饰的函数类型 允许标注async函数或普通函数。禁止标注generator、箭头函数、method。不支持类成员函数或者匿名函数。   装饰的函数内的变量类型 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量。      装饰器使用示例 已复制import taskpool from '@ohos.taskpool';
@Concurrentfunction add(num1: number, num2: number): number {  return num1 + num2;}
async function ConcurrentFunc(): Promise<void> {  try {    let task: taskpool.Task = new taskpool.Task(add, 1, 2);    console.info("taskpool res is: " + await taskpool.execute(task));  } catch (e) {    console.error("taskpool execute error is: " + e);  }}
@Entry@Componentstruct Index {  @State message: string = 'Hello World'
  build() {    Row() {      Column() {        Text(this.message)          .fontSize(50)          .fontWeight(FontWeight.Bold)          .onClick(() => {            ConcurrentFunc();          })      }      .width('100%')    }    .height('100%')  }}   上一篇 TaskPool和Worker的对比 下一篇 CPU密集型任务开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自定义组件的基本用法自定义组件的基本结构成员函数/变量自定义组件的参数规定build()函数自定义组件通用样式创建自定义组件 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。在进行 UI 界面开发时，通常不是简单的将系统组件进行组合使用，而是需要考虑代码可复用性、业务逻辑与UI分离，后续版本演进等因素。因此，将UI和部分业务逻辑封装成自定义组件是不可或缺的能力。 自定义组件具有以下特点： 可组合：允许开发者组合使用系统组件、及其属性和方法。可重用：自定义组件可以被其他组件重用，并作为不同的实例在不同的父组件或容器中使用。数据驱动UI更新：通过状态变量的改变，来驱动UI的刷新。 自定义组件的基本用法以下示例展示了自定义组件的基本用法。 已复制@Componentstruct HelloComponent {  @State message: string = 'Hello, World!';
  build() {    // HelloComponent自定义组件组合系统组件Row和Text    Row() {      Text(this.message)        .onClick(() => {          // 状态变量message的改变驱动UI刷新，UI从'Hello, World!'刷新为'Hello, ArkUI!'          this.message = 'Hello, ArkUI!';        })    }  }} 
说明
如果在另外的文件中引用该自定义组件，需要使用export关键字导出，并在使用的页面import该自定义组件。 
 HelloComponent可以在其他自定义组件中的build()函数中多次创建，实现自定义组件的重用。 已复制@Entry@Componentstruct ParentComponent {  build() {    Column() {      Text('ArkUI message')      HelloComponent({ message: 'Hello, World!' });      Divider()      HelloComponent({ message: '你好!' });    }  }} 要完全理解上面的示例，需要了解自定义组件的以下概念定义，本文将在后面的小节中介绍： 自定义组件的基本结构成员函数/变量自定义组件的参数规定build()函数自定义组件通用样式  自定义组件的基本结构struct：自定义组件基于struct实现，struct + 自定义组件名 + {...}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。
说明
自定义组件名、类名、函数名不能和系统组件名相同。 
 @Component：@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 已复制@Componentstruct MyComponent {} build()函数：build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。已复制@Componentstruct MyComponent {  build() {  }} @Entry：@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的LocalStorage的参数。
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 已复制@Entry@Componentstruct MyComponent {}   成员函数/变量自定义组件除了必须要实现build()函数外，还可以实现其他成员函数，成员函数具有以下约束：  自定义组件的成员函数为私有的，且不建议声明成静态函数 自定义组件可以包含成员变量，成员变量具有以下约束： 自定义组件的成员变量为私有的，且不建议声明成静态变量。自定义组件的成员变量本地初始化有些是可选的，有些是必选的。具体是否需要本地初始化，是否需要从父组件通过参数传递初始化子组件的成员变量，请参考状态管理。 自定义组件的参数规定从上文的示例中，我们已经了解到，可以在build方法里创建自定义组件，在创建自定义组件的过程中，根据装饰器的规则来初始化自定义组件的参数。 已复制@Componentstruct MyComponent {  private countDownFrom: number = 0;  private color: Color = Color.Blue;
  build() {  }}
@Entry@Componentstruct ParentComponent {  private someColor: Color = Color.Pink;
  build() {    Column() {      // 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor      MyComponent({ countDownFrom: 10, color: this.someColor })    }  }}  build()函数所有声明在build()函数的语言，我们统称为UI描述，UI描述需要遵循以下规则： @Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。@Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。 已复制@Entry@Componentstruct MyComponent {  build() {    // 根节点唯一且必要，必须为容器组件    Row() {      ChildComponent()     }  }}
@Componentstruct ChildComponent {  build() {    // 根节点唯一且必要，可为非容器组件    Image('test.jpg')  }} 不允许声明本地变量，反例如下。已复制build() {  // 反例：不允许声明本地变量  let a: number = 1;} 不允许在UI描述里直接使用console.info，但允许在方法或者函数里使用，反例如下。已复制build() {  // 反例：不允许console.info  console.info('print debug log');} 不允许创建本地的作用域，反例如下。已复制build() {  // 反例：不允许本地作用域  {    ...  }} 不允许调用没有用@Builder装饰的方法，允许系统组件的参数是TS方法的返回值。已复制@Componentstruct ParentComponent {  doSomeCalculations() {  }
  calcTextValue(): string {    return 'Hello World';  }
  @Builder doSomeRender() {    Text(`Hello World`)  }
  build() {    Column() {      // 反例：不能调用没有用@Builder装饰的方法      this.doSomeCalculations();      // 正例：可以调用      this.doSomeRender();      // 正例：参数可以为调用TS方法的返回值      Text(this.calcTextValue())    }  }} 不允许switch语法，如果需要使用条件判断，请使用if。反例如下。已复制build() {  Column() {    // 反例：不允许使用switch语法    switch (expression) {      case 1:        Text('...')        break;      case 2:        Image('...')        break;      default:        Text('...')        break;    }  }} 不允许使用表达式，反例如下。已复制build() {  Column() {    // 反例：不允许使用表达式    (this.aVar > 10) ? Text('...') : Image('...')  }}   自定义组件通用样式自定义组件通过“.”链式调用的形式设置通用样式。 已复制@Componentstruct MyComponent2 {  build() {    Button(`Hello World`)  }}
@Entry@Componentstruct MyComponent {  build() {    Row() {      MyComponent2()        .width(200)        .height(300)        .backgroundColor(Color.Red)    }  }} 
说明
ArkUI给自定义组件设置样式时，相当于给MyComponent2套了一个不可见的容器组件，而这些样式是设置在容器组件上的，而非直接设置给MyComponent2的Button组件。通过渲染结果我们可以很清楚的看到，背景颜色红色并没有直接生效在Button上，而是生效在Button所处的开发者不可见的容器组件上。 
   上一篇 自定义组件 下一篇 页面和自定义组件生命周期 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自定义组件 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    创建自定义组件  页面和自定义组件生命周期   上一篇 声明式UI描述 下一篇 创建自定义组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建组件无参数有参数配置属性配置事件配置子组件声明式UI描述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 ArkTS以声明方式组合和扩展组件来描述应用程序的UI，同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。 创建组件根据组件构造方法的不同，创建组件包含有参数和无参数两种方式。 
说明
创建组件时不需要new运算符。 
  无参数如果组件的接口定义没有包含必选构造参数，则组件后面的“()”不需要配置任何内容。例如，Divider组件不包含构造参数： 已复制Column() {  Text('item 1')  Divider()  Text('item 2')}  有参数如果组件的接口定义包含构造参数，则在组件后面的“()”配置相应参数。 Image组件的必选参数src。 已复制Image('https://xyz/test.jpg') Text组件的非必选参数content。 已复制// string类型的参数Text('test')// $r形式引入应用资源，可应用于多语言场景Text($r('app.string.title_value'))// 无参数形式Text() 变量或表达式也可以用于参数赋值，其中表达式返回的结果类型必须满足参数类型要求。例如，设置变量或表达式来构造Image和Text组件的参数。已复制Image(this.imagePath)Image('https://' + this.imageUrl)Text(`count: ${this.count}`)    配置属性属性方法以“.”链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。  配置Text组件的字体大小。 已复制Text('test')  .fontSize(12) 配置组件的多个属性。 已复制Image('test.jpg')  .alt('error.jpg')      .width(100)      .height(100) 除了直接传递常量参数外，还可以传递变量或表达式。 已复制Text('hello')  .fontSize(this.size)Image('test.jpg')  .width(this.count % 2 === 0 ? 100 : 200)      .height(this.offset + 100) 对于系统组件，ArkUI还为其属性预定义了一些枚举类型供开发者调用，枚举类型可以作为参数传递，但必须满足参数类型要求。 例如，可以按以下方式配置Text组件的颜色和字体样式。已复制Text('hello')  .fontSize(20)  .fontColor(Color.Red)  .fontWeight(FontWeight.Bold)   配置事件事件方法以“.”链式调用的方式配置系统组件支持的事件，建议每个事件方法单独写一行。  使用箭头函数配置组件的事件方法。 已复制Button('Click me')  .onClick(() => {    this.myText = 'ArkUI';  }) 使用匿名函数表达式配置组件的事件方法，要求使用bind，以确保函数体中的this指向当前组件。 已复制Button('add counter')  .onClick(function(){    this.counter += 2;  }.bind(this)) 使用组件的成员函数配置组件的事件方法。 已复制myClickHandler(): void {  this.counter += 2;}...Button('add counter')  .onClick(this.myClickHandler.bind(this)) 使用声明的箭头函数，可以直接调用，不需要bind this。已复制fn = () => {  console.info(`counter: ${this.counter}`)  this.counter++}...Button('add counter')  .onClick(this.fn)  配置子组件如果组件支持子组件配置，则需在尾随闭包"{...}"中为组件添加子组件的UI描述。Column、Row、Stack、Grid、List等组件都是容器组件。  以下是简单的Column组件配置子组件的示例。 已复制Column() {  Text('Hello')    .fontSize(100)  Divider()  Text(this.myText)    .fontSize(100)    .fontColor(Color.Red)} 容器组件均支持子组件配置，可以实现相对复杂的多级嵌套。 已复制Column() {  Row() {    Image('test1.jpg')      .width(100)      .height(100)    Button('click +1')      .onClick(() => {        console.info('+1 clicked!');      })  }}   上一篇 基本语法概述 下一篇 自定义组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用画布组件绘制自定义图形初始化画布组件画布组件绘制方式画布组件常用方法场景示例使用画布绘制自定义图形（Canvas） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Canvas提供画布组件，用于自定义绘制图形，开发者使用CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象在Canvas组件上进行绘制，绘制对象可以是基础形状、文本、图片等。  使用画布组件绘制自定义图形 可以由以下三种形式在画布绘制自定义图形：   使用CanvasRenderingContext2D对象在Canvas画布上绘制。已复制@Entry@Componentstruct CanvasExample1 {  //用来配置CanvasRenderingContext2D对象的参数，包括是否开启抗锯齿，true表明开启抗锯齿。  private settings: RenderingContextSettings = new RenderingContextSettings(true)  //用来创建CanvasRenderingContext2D对象，通过在canvas中调用CanvasRenderingContext2D对象来绘制。  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings)
  build() {    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {      //在canvas中调用CanvasRenderingContext2D对象。      Canvas(this.context)        .width('100%')        .height('100%')        .backgroundColor('#F5DC62')        .onReady(() => {          //可以在这里绘制内容。          this.context.strokeRect(50, 50, 200, 150);        })    }    .width('100%')    .height('100%')  }}  离屏绘制是指将需要绘制的内容先绘制在缓存区，再将其转换成图片，一次性绘制到Canvas上，加快了绘制速度。过程为：       通过transferToImageBitmap方法将离屏画布最近渲染的图像创建为一个ImageBitmap对象。 通过CanvasRenderingContext2D对象的transferFromImageBitmap方法显示给定的ImageBitmap对象。         具体使用参考OffscreenCanvasRenderingContext2D对象。       已复制@Entry@Componentstruct CanvasExample2 {//用来配置CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象的参数，包括是否开启抗锯齿。true表明开启抗锯齿  private settings: RenderingContextSettings = new RenderingContextSettings(true)  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings)//用来创建OffscreenCanvasRenderingContext2D对象，width为离屏画布的宽度，height为离屏画布的高度。通过在canvas中调用OffscreenCanvasRenderingContext2D对象来绘制。  private offContext: OffscreenCanvasRenderingContext2D = new OffscreenCanvasRenderingContext2D(600, 600, this.settings)   build() {    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {      Canvas(this.context)        .width('100%')        .height('100%')        .backgroundColor('#F5DC62')        .onReady(() =>{          //可以在这里绘制内容          this.offContext.strokeRect(50, 50, 200, 150);          //将离屏绘值渲染的图像在普通画布上显示          let image = this.offContext.transferToImageBitmap();          this.context.transferFromImageBitmap(image);        })    }    .width('100%')    .height('100%')  }}
说明
 在画布组件中，通过CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象在Canvas组件上进行绘制时调用的接口相同，另接口参数如无特别说明，单位均为vp。 
 在Canvas上加载Lottie动画时，需要先按照如下方式下载Lottie。已复制import lottie from '@ohos/lottie' 具体接口和示例请参考Lottie。   初始化画布组件 onReady(event: () => void)是Canvas组件初始化完成时的事件回调，调用该事件后，可获取Canvas组件的确定宽高，进一步使用CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象调用相关API进行图形绘制。 已复制Canvas(this.context)  .width('100%')  .height('100%')  .backgroundColor('#F5DC62')  .onReady(() => {    this.context.fillStyle = '#0097D4';    this.context.fillRect(50, 50, 100, 100);  })
    画布组件绘制方式 在Canvas组件生命周期接口onReady()调用之后，开发者可以直接使用canvas组件进行绘制。或者可以脱离Canvas组件和onready生命周期，单独定义Path2d对象构造理想的路径，并在onready调用之后使用Canvas组件进行绘制。  通过CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象直接调用相关API进行绘制。已复制Canvas(this.context)  .width('100%')  .height('100%')  .backgroundColor('#F5DC62')  .onReady(() =>{    this.context.beginPath();    this.context.moveTo(50, 50);    this.context.lineTo(280, 160);    this.context.stroke();   })  先单独定义path2d对象构造理想的路径，再通过调用CanvasRenderingContext2D对象和OffscreenCanvasRenderingContext2D对象的stroke接口或者fill接口进行绘制，具体使用可以参考Path2D对象。已复制Canvas(this.context)  .width('100%')  .height('100%')  .backgroundColor('#F5DC62')  .onReady(() =>{     let region = new Path2D();     region.arc(100, 75, 50, 0, 6.28);     this.context.stroke(region);  })     画布组件常用方法 OffscreenCanvasRenderingContext2D对象和CanvasRenderingContext2D对象提供了大量的属性和方法，可以用来绘制文本、图形，处理像素等，是Canvas组件的核心。常用接口有fill(对封闭路径进行填充）、clip(设置当前路径为剪切路径)、stroke（进行边框绘制操作）等等，同时提供了fillStyle（指定绘制的填充色）、globalAlpha（设置透明度）与strokeStyle（设置描边的颜色）等属性修改绘制内容的样式。将通过以下几个方面简单介绍画布组件常见使用方法：  基础形状绘制。               可以通过arc（绘制弧线路径）、 ellipse（绘制一个椭圆）、rect（创建矩形路径）等接口绘制基础形状。        已复制Canvas(this.context)  .width('100%')  .height('100%')  .backgroundColor('#F5DC62')  .onReady(() =>{     //绘制矩形     this.context.beginPath();     this.context.rect(100, 50, 100, 100);     this.context.stroke();     //绘制圆形     this.context.beginPath();     this.context.arc(150, 250, 50, 0, 6.28);     this.context.stroke();     //绘制椭圆     this.context.beginPath();     this.context.ellipse(150, 450, 50, 100, Math.PI * 0.25, Math.PI * 0, Math.PI * 2);     this.context.stroke();  })
     文本绘制。               可以通过fillText（绘制填充类文本）、strokeText（绘制描边类文本）等接口进行文本绘制。        已复制Canvas(this.context)  .width('100%')  .height('100%')  .backgroundColor('#F5DC62')  .onReady(() =>{     //绘制填充类文本     this.context.font = '50px sans-serif';     this.context.fillText("Hello World!", 50, 100);     //绘制描边类文本     this.context.font = '55px sans-serif';     this.context.strokeText("Hello World!", 50, 150);  })
   绘制图片和图像像素信息处理。               可以通过drawImage（图像绘制）、putImageData（使用ImageData数据填充新的矩形区域）等接口绘制图片，通过createImageData（创建新的ImageData 对象）、getPixelMap（以当前canvas指定区域内的像素创建PixelMap对象）、getImageData（以当前canvas指定区域内的像素创建ImageData对象）等接口进行图像像素信息处理。 已复制@Entry@Componentstruct GetImageData { private settings: RenderingContextSettings = new RenderingContextSettings(true) private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings) private offContext: OffscreenCanvasRenderingContext2D = new OffscreenCanvasRenderingContext2D(600, 600, this.settings) private img:ImageBitmap = new ImageBitmap("/common/images/1234.png")   build() {    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {      Canvas(this.context)        .width('100%')        .height('100%')        .backgroundColor('#F5DC62')        .onReady(() =>{          // 使用drawImage接口将图片画在（0，0）为起点，宽高130的区域          this.offContext.drawImage(this.img,0,0,130,130);          // 使用getImageData接口，获得canvas组件区域中，（50，50）为起点，宽高130范围内的绘制内容          let imagedata = this.offContext.getImageData(50,50,130,130);          // 使用putImageData接口将得到的ImageData画在起点为（150， 150）的区域中          this.offContext.putImageData(imagedata,150,150);          // 将离屏绘制的内容画到canvas组件上          let image = this.offContext.transferToImageBitmap();          this.context.transferFromImageBitmap(image);        })    }    .width('100%')    .height('100%')  }}   其他方法。Canvas中还提供其他类型的方法。渐变（CanvasGradient对象）相关的方法：createLinearGradient（创建一个线性渐变色）、createRadialGradient（创建一个径向渐变色）等。 已复制Canvas(this.context)  .width('100%')  .height('100%')  .backgroundColor('#F5DC62')  .onReady(() =>{     //创建一个径向渐变色的CanvasGradient对象     let grad = this.context.createRadialGradient(200,200,50, 200,200,200)     //为CanvasGradient对象设置渐变断点值，包括偏移和颜色     grad.addColorStop(0.0, '#E87361');     grad.addColorStop(0.5, '#FFFFF0');     grad.addColorStop(1.0, '#BDDB69');     //用CanvasGradient对象填充矩形     this.context.fillStyle = grad;     this.context.fillRect(0, 0, 400, 400);  })     场景示例  规则基础形状绘制：已复制@Entry@Componentstruct ClearRect { private settings: RenderingContextSettings = new RenderingContextSettings(true); private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);   build() {    Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {      Canvas(this.context)        .width('100%')        .height('100%')        .backgroundColor('#F5DC62')        .onReady(() =>{          // 设定填充样式，填充颜色设为蓝色          this.context.fillStyle = '#0097D4';          // 以(50, 50)为左上顶点，画一个宽高200的矩形          this.context.fillRect(50,50,200,200);          // 以(70, 70)为左上顶点，清除宽150高100的区域          this.context.clearRect(70,70,150,100);      })    }    .width('100%')    .height('100%')  }}
    不规则图形绘制。已复制@Entry@Componentstruct Path2d {  private settings: RenderingContextSettings = new RenderingContextSettings(true);  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  build() {    Row() {      Column() {        Canvas(this.context)          .width('100%')          .height('100%')          .backgroundColor('#F5DC62')          .onReady(() =>{            // 使用Path2D的接口构造一个五边形            let path = new Path2D();            path.moveTo(150, 50);            path.lineTo(50, 150);            path.lineTo(100, 250);            path.lineTo(200, 250);            path.lineTo(250, 150);            path.closePath();            // 设定填充色为蓝色            this.context.fillStyle = '#0097D4';            // 使用填充的方式，将Path2D描述的五边形绘制在canvas组件内部            this.context.fill(path);          })      }      .width('100%')    }    .height('100%')  }}     上一篇 绘制几何图形（Shape） 下一篇 使用动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Environment内置参数使用场景从UI中访问Environment参数应用逻辑使用EnvironmentEnvironment：设备环境查询 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 开发者如果需要应用程序运行的设备的环境参数，以此来作出不同的场景判断，比如多语言，暗黑模式等，需要用到Environment设备环境查询。 Environment是ArkUI框架在应用程序启动时创建的单例对象。它为AppStorage提供了一系列描述应用程序运行状态的属性。Environment的所有属性都是不可变的（即应用不可写入），所有的属性都是简单类型。 Environment内置参数 键  数据类型  描述    accessibilityEnabled  boolean  获取无障碍屏幕读取是否启用。   colorMode  ColorMode  色彩模型类型：选项为ColorMode.LIGHT: 浅色，ColorMode.DARK: 深色。   fontScale  number  字体大小比例，范围: [0.85, 1.45]。   fontWeightScale  number  字体粗细程度，范围: [0.6, 1.6]。   layoutDirection  LayoutDirection  布局方向类型：包括LayoutDirection.LTR: 从左到右，LayoutDirection.RTL: 从右到左。   languageCode  string  当前系统语言值，取值必须为小写字母, 例如zh。     使用场景 从UI中访问Environment参数使用Environment.EnvProp将设备运行的环境变量存入AppStorage中：已复制// 将设备的语言code存入AppStorage，默认值为enEnvironment.EnvProp('languageCode', 'en');  可以使用@StorageProp链接到Component中。已复制@StorageProp('languageCode') lang : string = 'en';  设备环境到Component的更新链：Environment --> AppStorage -->Component。 
说明
@StorageProp关联的环境参数可以在本地更改，但不能同步回AppStorage中，因为应用对环境变量参数是不可写的，只能在Environment中查询。 
 已复制// 将设备languageCode存入AppStorage中Environment.EnvProp('languageCode', 'en');
@Entry@Componentstruct Index {  @StorageProp('languageCode') languageCode: string = 'en';
  build() {    Row() {      Column() {        // 输出当前设备的languageCode        Text(this.languageCode)      }    }  }}  应用逻辑使用Environment已复制// 使用Environment.EnvProp将设备运行languageCode存入AppStorage中；Environment.EnvProp('languageCode', 'en');// 从AppStorage获取单向绑定的languageCode的变量const lang: SubscribedAbstractProperty<string> = AppStorage.Prop('languageCode');
if (lang.get() === 'zh') {  console.info('你好');} else {  console.info('Hello!');}   上一篇 PersistentStorage：持久化存储UI状态 下一篇 其他状态管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。交互事件概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 交互事件按照触发类型来分类，包括触屏事件、键鼠事件和焦点事件。 触屏事件：手指或手写笔在触屏上的单指或单笔操作。键鼠事件：包括外设鼠标或触控板的操作事件和外设键盘的按键事件。鼠标事件是指通过连接和使用外设鼠标/触控板操作时所响应的事件。按键事件是指通过连接和使用外设键盘操作时所响应的事件。 焦点事件：通过以上方式控制组件焦点的能力和响应的事件。 手势事件由绑定手势方法和绑定的手势组成，绑定的手势可以分为单一手势和组合手势两种类型，根据手势的复杂程度进行区分。 绑定手势方法：用于在组件上绑定单一手势或组合手势，并声明所绑定的手势的响应优先级。单一手势：手势的基本单元，是所有复杂手势的组成部分。组合手势：由多个单一手势组合而成，可以根据声明的类型将多个单一手势按照一定规则组合成组合手势，并进行使用。  上一篇 支持交互事件 下一篇 使用通用事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。支持交互事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    交互事件概述  使用通用事件  使用手势事件   上一篇 页面转场动画 下一篇 交互事件概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。装饰器使用说明语法使用规则使用场景@Extend装饰器：定义扩展组件样式 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 在前文的示例中，可以使用@Styles用于样式的扩展，在@Styles的基础上，我们提供了@Extend，用于扩展原生组件样式。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 装饰器使用说明 语法已复制@Extend(UIComponentName) function functionName { ... }  使用规则和@Styles不同，@Extend仅支持定义在全局，不支持在组件内部定义。
说明
只能在当前文件内使用，不支持export。 
 和@Styles不同，@Extend支持封装指定的组件的私有属性和私有事件和预定义相同组件的@Extend的方法。已复制// @Extend(Text)可以支持Text的私有属性fontColor@Extend(Text) function fancy () {  .fontColor(Color.Red)}// superFancyText可以调用预定义的fancy@Extend(Text) function superFancyText(size:number) {    .fontSize(size)    .fancy()}   和@Styles不同，@Extend装饰的方法支持参数，开发者可以在调用时传递参数，调用遵循TS方法传值调用。已复制// xxx.ets@Extend(Text) function fancy (fontSize: number) {  .fontColor(Color.Red)  .fontSize(fontSize)}
@Entry@Componentstruct FancyUse {  build() {    Row({ space: 10 }) {      Text('Fancy')        .fancy(16)      Text('Fancy')        .fancy(24)    }  }} @Extend装饰的方法的参数可以为function，作为Event事件的句柄。已复制@Extend(Text) function makeMeClick(onClick: () => void) {  .backgroundColor(Color.Blue)  .onClick(onClick)}
@Entry@Componentstruct FancyUse {  @State label: string = 'Hello World';
  onClickHandler() {    this.label = 'Hello ArkUI';  }
  build() {    Row({ space: 10 }) {      Text(`${this.label}`)        .makeMeClick(this.onClickHandler.bind(this))    }  }} @Extend的参数可以为状态变量，当状态变量改变时，UI可以正常的被刷新渲染。已复制@Extend(Text) function fancy (fontSize: number) {  .fontColor(Color.Red)  .fontSize(fontSize)}
@Entry@Componentstruct FancyUse {  @State fontSizeValue: number = 20  build() {    Row({ space: 10 }) {      Text('Fancy')        .fancy(this.fontSizeValue)        .onClick(() => {          this.fontSizeValue = 30        })    }  }}  使用场景以下示例声明了3个Text组件，每个Text组件均设置了fontStyle、fontWeight和backgroundColor样式。 已复制@Entry@Componentstruct FancyUse {  @State label: string = 'Hello World'
  build() {    Row({ space: 10 }) {      Text(`${this.label}`)        .fontStyle(FontStyle.Italic)        .fontWeight(100)        .backgroundColor(Color.Blue)      Text(`${this.label}`)        .fontStyle(FontStyle.Italic)        .fontWeight(200)        .backgroundColor(Color.Pink)      Text(`${this.label}`)        .fontStyle(FontStyle.Italic)        .fontWeight(300)        .backgroundColor(Color.Orange)    }.margin('20%')  }} @Extend将样式组合复用，示例如下。 已复制@Extend(Text) function fancyText(weightValue: number, color: Color) {  .fontStyle(FontStyle.Italic)  .fontWeight(weightValue)  .backgroundColor(color)} 通过@Extend组合样式后，使得代码更加简洁，增强可读性。 已复制@Entry@Componentstruct FancyUse {  @State label: string = 'Hello World'
  build() {    Row({ space: 10 }) {      Text(`${this.label}`)        .fancyText(100, Color.Blue)      Text(`${this.label}`)        .fancyText(200, Color.Pink)      Text(`${this.label}`)        .fancyText(300, Color.Orange)    }.margin('20%')  }}   上一篇 @Styles装饰器：定义组件重用样式 下一篇 stateStyles：多态样式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建绘制组件形状视口viewport自定义样式场景示例绘制几何图形（Shape） 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
  绘制组件用于在页面绘制图形，Shape组件是绘制组件的父组件，父组件中会描述所有绘制组件均支持的通用属性。具体用法请参考Shape。  创建绘制组件 绘制组件可以由以下两种形式创建：  绘制组件使用Shape作为父组件，实现类似SVG的效果。接口调用为以下形式：已复制Shape(value?: PixelMap) 该接口用于创建带有父组件的绘制组件，其中value用于设置绘制目标，可将图形绘制在指定的PixelMap对象中，若未设置，则在当前绘制目标中进行绘制。 已复制Shape() {  Rect().width(300).height(50)}    绘制组件单独使用，用于在页面上绘制指定的图形。有7种绘制类型，分别为Circle（圆形）、Ellipse（椭圆形）、Line（直线）、Polyline（折线）、Polygon（多边形）、Path（路径）、Rect（矩形）。以Circle的接口调用为例：已复制Circle(options?: {width?: string | number, height?: string | number}        该接口用于在页面绘制圆形，其中width用于设置圆形的宽度，height用于设置圆形的高度，圆形直径由宽高最小值确定。       已复制Circle({ width: 150, height: 150 })     形状视口viewport 已复制viewPort{ x?: number | string, y?: number | string, width?: number | string, height?: number | string } 形状视口viewport指定用户空间中的一个矩形，该矩形映射到为关联的 SVG 元素建立的视区边界。viewport属性的值包含x、y、width和height四个可选参数，x 和 y 表示视区的左上角坐标，width和height表示其尺寸。 以下3个示例讲解Viewport具体用法：  通过形状视口对图形进行放大与缩小。已复制// 画一个宽高都为150的圆Text('原始尺寸Circle组件')Circle({width: 75, height: 75}).fill('#E87361')
Row({space:10}) {  Column() {    // 创建一个宽高都为150的shape组件，背景色为黄色，一个宽高都为75的viewport。用一个蓝色的矩形来填充viewport，在viewport中绘制一个直径为75的圆。    // 绘制结束，viewport会根据组件宽高放大两倍    Text('shape内放大的Circle组件')    Shape() {      Rect().width('100%').height('100%').fill('#0097D4')      Circle({width: 75, height: 75}).fill('#E87361')    }    .viewPort({x: 0, y: 0, width: 75, height: 75})    .width(150)    .height(150)    .backgroundColor('#F5DC62')  }  Column() {    // 创建一个宽高都为150的shape组件，背景色为黄色，一个宽高都为300的viewport。用一个绿色的矩形来填充viewport，在viewport中绘制一个直径为75的圆。    // 绘制结束，viewport会根据组件宽高缩小两倍。    Text('Shape内缩小的Circle组件')    Shape() {      Rect().width('100%').height('100%').fill('#BDDB69')      Circle({width: 75, height: 75}).fill('#E87361')    }    .viewPort({x: 0, y: 0, width: 300, height: 300})    .width(150)    .height(150)    .backgroundColor('#F5DC62')  }}  创建一个宽高都为300的shape组件，背景色为黄色，一个宽高都为300的viewport。用一个蓝色的矩形来填充viewport，在viewport中绘制一个半径为75的圆。已复制Shape() {  Rect().width("100%").height("100%").fill("#0097D4")  Circle({ width: 150, height: 150 }).fill("#E87361")}  .viewPort({ x: 0, y: 0, width: 300, height: 300 })  .width(300)  .height(300)  .backgroundColor("#F5DC62")  创建一个宽高都为300的shape组件，背景色为黄色，创建一个宽高都为300的viewport。用一个蓝色的矩形来填充viewport，在viewport中绘制一个半径为75的圆，将viewport向右方和下方各平移150。已复制Shape() {  Rect().width("100%").height("100%").fill("#0097D4")  Circle({ width: 150, height: 150 }).fill("#E87361")}  .viewPort({ x: -150, y: -150, width: 300, height: 300 })  .width(300)  .height(300)  .backgroundColor("#F5DC62")
     自定义样式 绘制组件支持通过各种属性对组件样式进行更改。  通过fill可以设置组件填充区域颜色。已复制Path()  .width(100)  .height(100)  .commands('M150 0 L300 300 L0 300 Z')  .fill("#E87361")  通过stroke可以设置组件边框颜色。已复制Path()  .width(100)  .height(100)  .fillOpacity(0)  .commands('M150 0 L300 300 L0 300 Z')  .stroke(Color.Red)  通过strokeOpacity可以设置边框透明度。已复制Path()  .width(100)  .height(100)  .fillOpacity(0)  .commands('M150 0 L300 300 L0 300 Z')  .stroke(Color.Red)  .strokeWidth(10)  .strokeOpacity(0.2)  通过strokeLineJoin可以设置线条拐角绘制样式。拐角绘制样式分为Bevel(使用斜角连接路径段)、Miter(使用尖角连接路径段)、Round(使用圆角连接路径段)。已复制Polyline()  .width(100)  .height(100)  .fillOpacity(0)  .stroke(Color.Red)  .strokeWidth(8)  .points([[20, 0], [0, 100], [100, 90]])   // 设置折线拐角处为圆弧  .strokeLineJoin(LineJoinStyle.Round)  通过strokeMiterLimit设置斜接长度与边框宽度比值的极限值。               斜接长度表示外边框外边交点到内边交点的距离，边框宽度即strokeWidth属性的值。strokeMiterLimit取值需大于等于1，且在strokeLineJoin属性取值LineJoinStyle.Miter时生效。        已复制Polyline()  .width(100)  .height(100)  .fillOpacity(0)  .stroke(Color.Red)  .strokeWidth(10)  .points([[20, 0], [20, 100], [100, 100]])  // 设置折线拐角处为尖角  .strokeLineJoin(LineJoinStyle.Miter)  // 设置斜接长度与线宽的比值  .strokeMiterLimit(1/Math.sin(45))Polyline()  .width(100)  .height(100)  .fillOpacity(0)  .stroke(Color.Red)  .strokeWidth(10)  .points([[20, 0], [20, 100], [100, 100]])  .strokeLineJoin(LineJoinStyle.Miter)  .strokeMiterLimit(1.42)   通过antiAlias设置是否开启抗锯齿，默认值为true（开启抗锯齿）。已复制//开启抗锯齿Circle()  .width(150)  .height(200)  .fillOpacity(0)  .strokeWidth(5)  .stroke(Color.Black)  已复制//关闭抗锯齿Circle()  .width(150)  .height(200)  .fillOpacity(0)  .strokeWidth(5)  .stroke(Color.Black)  .antiAlias(false)     场景示例  在Shape的(-80, -5)点绘制一个封闭路径，填充颜色0x317AF7,线条宽度3,边框颜色红色,拐角样式锐角（默认值）。已复制@Entry@Componentstruct ShapeExample {  build() {    Column({ space: 10 }) {      Shape() {        Path().width(200).height(60).commands('M0 0 L400 0 L400 150 Z')      }      .viewPort({ x: -80, y: -5, width: 500, height: 300 })      .fill(0x317AF7)      .stroke(Color.Red)      .strokeWidth(3)      .strokeLineJoin(LineJoinStyle.Miter)      .strokeMiterLimit(5)    }.width('100%').margin({ top: 15 })  }}  绘制一个直径为150的圆，和一个直径为150、线条为红色虚线的圆环（宽高设置不一致时以短边为直径）。已复制@Entry@Componentstruct CircleExample {  build() {    Column({ space: 10 }) {      //绘制一个直径为150的圆      Circle({ width: 150, height: 150 })      //绘制一个直径为150、线条为红色虚线的圆环      Circle()        .width(150)        .height(200)        .fillOpacity(0)        .strokeWidth(3)        .stroke(Color.Red)        .strokeDashArray([1, 2])    }.width('100%')  }}     上一篇 显示图片（Image） 下一篇 使用画布绘制自定义图形（Canvas） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用手势事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    绑定手势方法  单一手势  组合手势   上一篇 焦点事件 下一篇 绑定手势方法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。gesture（常规手势绑定方法）priorityGesture（带优先级的手势绑定方法）parallelGesture（并行手势绑定方法）绑定手势方法 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 通过给各个组件绑定不同的手势事件，并设计事件的响应方式，当手势识别成功时，ArkUI框架将通过事件回调通知组件手势识别的结果。 gesture（常规手势绑定方法）已复制.gesture(gesture: GestureType, mask?: GestureMask) gesture为通用的一种手势绑定方法，可以将手势绑定到对应的组件上。 例如，可以将点击手势TapGesture通过gesture手势绑定方法绑定到Text组件上。 已复制// xxx.ets@Entry@Componentstruct Index {  build() {    Column() {      Text('Gesture').fontSize(28)        // 采用gesture手势绑定方法绑定TapGesture        .gesture(          TapGesture()            .onAction(() => {              console.info('TapGesture is onAction');            }))    }    .height(200)    .width(250)  }}  priorityGesture（带优先级的手势绑定方法）已复制.priorityGesture(gesture: GestureType, mask?: GestureMask)。 priorityGesture是带优先级的手势绑定方法，可以在组件上绑定优先识别的手势。 在默认情况下，当父组件和子组件使用gesture绑定同类型的手势时，子组件优先识别通过gesture绑定的手势。当父组件使用priorityGesture绑定与子组件同类型的手势时，父组件优先识别通过priorityGesture绑定的手势。 例如，当父组件Column和子组件Text同时绑定TapGesture手势时，父组件以带优先级手势priorityGesture的形式进行绑定时，优先响应父组件绑定的TapGesture。  已复制// xxx.ets@Entry@Componentstruct Index {  build() {    Column() {      Text('Gesture').fontSize(28)        .gesture(          TapGesture()            .onAction(() => {              console.info('Text TapGesture is onAction');            }))    }    .height(200)    .width(250)    // 设置为priorityGesture时，点击文本区域会忽略Text组件的TapGesture手势事件，优先响应父组件Column的TapGesture手势事件    .priorityGesture(      TapGesture()        .onAction(() => {          console.info('Column TapGesture is onAction');        }), GestureMask.IgnoreInternal)  }} parallelGesture（并行手势绑定方法）已复制.parallelGesture(gesture: GestureType, mask?: GestureMask) parallelGesture是并行的手势绑定方法，可以在父子组件上绑定可以同时响应的相同手势。 在默认情况下，手势事件为非冒泡事件，当父子组件绑定相同的手势时，父子组件绑定的手势事件会发生竞争，最多只有一个组件的手势事件能够获得响应。而当父组件绑定了并行手势parallelGesture时，父子组件相同的手势事件都可以触发，实现类似冒泡效果。  已复制// xxx.ets@Entry@Componentstruct Index {  build() {    Column() {      Text('Gesture').fontSize(28)        .gesture(          TapGesture()            .onAction(() => {              console.info('Text TapGesture is onAction');            }))    }    .height(200)    .width(250)    // 设置为parallelGesture时，点击文本区域会同时响应父组件Column和子组件Text的TapGesture手势事件    .parallelGesture(      TapGesture()        .onAction(() => {          console.info('Column TapGesture is onAction');        }), GestureMask.IgnoreInternal)  }} 
说明
当父组件和子组件同时绑定单击手势事件和双击手势事件时，父组件和子组件均只响应单击手势事件。 
  上一篇 使用手势事件 下一篇 单一手势 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。顺序识别并行识别互斥识别组合手势 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 组合手势由多种单一手势组合而成，通过在GestureGroup中使用不同的GestureMode来声明该组合手势的类型，支持顺序识别、并行识别和互斥识别三种类型。 已复制GestureGroup(mode:GestureMode, ...gesture:GestureType[]) mode：必选参数，为GestureMode枚举类。用于声明该组合手势的类型。gesture：必选参数，为由多个手势组合而成的数组。用于声明组合成该组合手势的各个手势。 顺序识别顺序识别组合手势对应的GestureMode为Sequence。顺序识别组合手势将按照手势的注册顺序识别手势，直到所有的手势识别成功。当顺序识别组合手势中有一个手势识别失败时，所有的手势识别失败。 以一个由长按手势和拖动手势组合而成的顺序手势为例： 在一个Column组件上绑定了translate属性，通过修改该属性可以设置组件的位置移动。然后在该组件上绑定LongPressGesture和PanGesture组合而成的Sequence组合手势。当触发LongPressGesture时，更新显示的数字。当长按后进行拖动时，根据拖动手势的回调函数，实现组件的拖动。  已复制// xxx.ets@Entry@Componentstruct Index {  @State offsetX: number = 0;  @State offsetY: number = 0;  @State count: number = 0;  @State positionX: number = 0;  @State positionY: number = 0;  @State borderStyles: BorderStyle = BorderStyle.Solid
  build() {    Column() {      Text('sequence gesture\n' + 'LongPress onAction:' + this.count + '\nPanGesture offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)        .fontSize(28)    }    // 绑定translate属性可以实现组件的位置移动    .translate({ x: this.offsetX, y: this.offsetY, z: 0 })    .height(250)    .width(300)    //以下组合手势为顺序识别，当长按手势事件未正常触发时不会触发拖动手势事件    .gesture(      // 声明该组合手势的类型为Sequence类型      GestureGroup(GestureMode.Sequence,        // 该组合手势第一个触发的手势为长按手势，且长按手势可多次响应        LongPressGesture({ repeat: true })          // 当长按手势识别成功，增加Text组件上显示的count次数          .onAction((event: GestureEvent) => {            if (event.repeat) {              this.count++;            }            console.info('LongPress onAction');          })          .onActionEnd(() => {            console.info('LongPress end');          }),        // 当长按之后进行拖动，PanGesture手势被触发        PanGesture()          .onActionStart(() => {            this.borderStyles = BorderStyle.Dashed;            console.info('pan start');          })            // 当该手势被触发时，根据回调获得拖动的距离，修改该组件的位移距离从而实现组件的移动          .onActionUpdate((event: GestureEvent) => {            this.offsetX = this.positionX + event.offsetX;            this.offsetY = this.positionY + event.offsetY;            console.info('pan update');          })          .onActionEnd(() => {            this.positionX = this.offsetX;            this.positionY = this.offsetY;            this.borderStyles = BorderStyle.Solid;          })      )    )  }}  
说明
拖拽事件是一种典型的顺序识别组合手势事件，由长按手势事件和滑动手势事件组合而成。只有先长按达到长按手势事件预设置的时间后进行滑动才会触发拖拽事件。如果长按事件未达到或者长按后未进行滑动，拖拽事件均识别失败。 
 并行识别并行识别组合手势对应的GestureMode为Parallel。并行识别组合手势中注册的手势将同时进行识别，直到所有手势识别结束。并行识别手势组合中的手势进行识别时互不影响。 以在一个Column组件上绑定点击手势和双击手势组成的并行识别手势为例，由于单击手势和双击手势是并行识别，因此两个手势可以同时进行识别，二者互不干涉。  已复制// xxx.ets@Entry@Componentstruct Index {  @State count1: number = 0;  @State count2: number = 0;
  build() {    Column() {      Text('parallel gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')        .fontSize(28)    }    .height(200)    .width(250)    // 以下组合手势为并行并别，单击手势识别成功后，若在规定时间内再次点击，双击手势也会识别成功    .gesture(      GestureGroup(GestureMode.Parallel,        TapGesture({ count: 1 })          .onAction(() => {            this.count1++;          }),        TapGesture({ count: 2 })          .onAction(() => {            this.count2++;          })      )    )  }}  
说明
当由单击手势和双击手势组成一个并行识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。 当只有单次点击时，单击手势识别成功，双击手势识别失败。 当有两次点击时，若两次点击相距时间在规定时间内（默认规定时间为300毫秒），触发两次单击事件和一次双击事件。 当有两次点击时，若两次点击相距时间超出规定时间，触发两次单击事件不触发双击事件。 
 互斥识别互斥识别组合手势对应的GestureMode为Exclusive。互斥识别组合手势中注册的手势将同时进行识别，若有一个手势识别成功，则结束手势识别，其他所有手势识别失败。 以在一个Column组件上绑定单击手势和双击手势组合而成的互斥识别组合手势为例，由于单击手势只需要一次点击即可触发而双击手势需要两次，每次的点击事件均被单击手势消费而不能积累成双击手势，所以双击手势无法触发。  已复制// xxx.ets@Entry@Componentstruct Index {  @State count1: number = 0;  @State count2: number = 0;
  build() {    Column() {      Text('parallel gesture\n' + 'tapGesture count is 1:' + this.count1 + '\ntapGesture count is 2:' + this.count2 + '\n')        .fontSize(28)    }    .height(200)    .width(250)    //以下组合手势为互斥并别，单击手势识别成功后，双击手势会识别失败    .gesture(      GestureGroup(GestureMode.Exclusive,        TapGesture({ count: 1 })          .onAction(() => {            this.count1++;          }),        TapGesture({ count: 2 })          .onAction(() => {            this.count2++;          })      )    )  }}  
说明
当由单击手势和双击手势组成一个互斥识别组合手势后，在区域内进行点击时，单击手势和双击手势将同时进行识别。 当只有单次点击时，单击手势识别成功，双击手势识别失败。 当有两次点击时，单击手势在第一次点击时即宣告识别成功，此时双击手势已经失败。即使在规定时间内进行了第二次点击，双击手势事件也不会进行响应，此时会触发单击手势事件的第二次识别成功。 
  上一篇 单一手势 下一篇 性能提升的推荐方法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。点击手势（TapGesture）长按手势（LongPressGesture）拖动手势（PanGesture）捏合手势（PinchGesture）旋转手势（RotationGesture）滑动手势（SwipeGesture）单一手势 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 点击手势（TapGesture）已复制TapGesture(value?:{count?:number; fingers?:number})  点击手势支持单次点击和多次点击，拥有两个可选参数： count：非必填参数，声明该点击手势识别的连续点击次数。默认值为1，若设置小于1的非法值会被转化为默认值。如果配置多次点击，上一次抬起和下一次按下的超时时间为300毫秒。fingers：非必填参数，用于声明触发点击的手指数量，最小值为1，最大值为10，默认值为1。当配置多指时，若第一根手指按下300毫秒内未有足够的手指数按下则手势识别失败。当实际点击手指数超过配置值时，手势识别失败。以在Text组件上绑定双击手势（count值为2的点击手势）为例：已复制// xxx.ets@Entry@Componentstruct Index {  @State value: string = "";    build() {    Column() {      Text('Click twice').fontSize(28)        .gesture(          // 绑定count为2的TapGesture          TapGesture({ count: 2 })            .onAction((event: GestureEvent) => {              this.value = JSON.stringify(event.fingerList[0]);            }))      Text(this.value)    }    .height(200)    .width(250)    .padding(20)    .border({ width: 3 })    .margin(30)  }}    长按手势（LongPressGesture）已复制LongPressGesture(value?:{fingers?:number; repeat?:boolean; duration?:number})  长按手势用于触发长按手势事件，触发长按手势的最少手指数量为1，最短长按事件为500毫秒，拥有三个可选参数： fingers：非必选参数，用于声明触发长按手势所需要的最少手指数量，最小值为1，最大值为10，默认值为1。repeat：非必选参数，用于声明是否连续触发事件回调，默认值为false。duration：非必选参数，用于声明触发长按所需的最短时间，单位为毫秒，默认值为500。 以在Text组件上绑定可以重复触发的长按手势为例： 已复制// xxx.ets@Entry@Componentstruct Index {  @State count: number = 0;
  build() {    Column() {      Text('LongPress OnAction:' + this.count).fontSize(28)        .gesture(          // 绑定可以重复触发的LongPressGesture          LongPressGesture({ repeat: true })            .onAction((event: GestureEvent) => {              if (event.repeat) {                this.count++;              }            })            .onActionEnd(() => {              this.count = 0;            })        )    }    .height(200)    .width(250)    .padding(20)    .border({ width: 3 })    .margin(30)  }}  拖动手势（PanGesture）已复制PanGesture(value?:{ fingers?:number; direction?:PanDirection; distance?:number})  拖动手势用于触发拖动手势事件，滑动达到最小滑动距离（默认值为5vp）时拖动手势识别成功，拥有三个可选参数： fingers：非必选参数，用于声明触发拖动手势所需要的最少手指数量，最小值为1，最大值为10，默认值为1。direction：非必选参数，用于声明触发拖动的手势方向，此枚举值支持逻辑与（&）和逻辑或（|）运算。默认值为Pandirection.All。distance：非必选参数，用于声明触发拖动的最小拖动识别距离，单位为vp，默认值为5。 以在Text组件上绑定拖动手势为例，可以通过在拖动手势的回调函数中修改组件的布局位置信息来实现组件的拖动： 已复制// xxx.ets@Entry@Componentstruct Index {  @State offsetX: number = 0;  @State offsetY: number = 0;  @State positionX: number = 0;  @State positionY: number = 0;
  build() {    Column() {      Text('PanGesture Offset:\nX: ' + this.offsetX + '\n' + 'Y: ' + this.offsetY)        .fontSize(28)        .height(200)        .width(300)        .padding(20)        .border({ width: 3 })          // 在组件上绑定布局位置信息        .translate({ x: this.offsetX, y: this.offsetY, z: 0 })        .gesture(          // 绑定拖动手势          PanGesture()            .onActionStart((event: GestureEvent) => {              console.info('Pan start');            })              // 当触发拖动手势时，根据回调函数修改组件的布局位置信息            .onActionUpdate((event: GestureEvent) => {              this.offsetX = this.positionX + event.offsetX;              this.offsetY = this.positionY + event.offsetY;            })            .onActionEnd(() => {              this.positionX = this.offsetX;              this.positionY = this.offsetY;            })        )    }    .height(200)    .width(250)  }}  
说明
大部分可滑动组件，如List、Grid、Scroll、Tab等组件是通过PanGesture实现滑动，在组件内部的子组件绑定拖动手势（PanGesture）或者滑动手势（SwipeGesture）会导致手势竞争。 当在子组件绑定PanGesture时，在子组件区域进行滑动仅触发子组件的PanGesture。如果需要父组件响应，需要通过修改手势绑定方法或者子组件向父组件传递消息进行实现，或者通过修改父子组件的PanGesture参数distance使得拖动更灵敏。当子组件绑定SwipeGesture时，由于PanGesture和SwipeGesture触发条件不同，需要修改PanGesture和SwipeGesture的参数以达到所需效果。 
 捏合手势（PinchGesture）已复制PinchGesture(value?:{fingers?:number; distance?:number})  捏合手势用于触发捏合手势事件，触发捏合手势的最少手指数量为2指，最大为5指，最小识别距离为5vp，拥有两个可选参数： fingers：非必选参数，用于声明触发捏合手势所需要的最少手指数量，最小值为2，最大值为5，默认值为2。distance：非必选参数，用于声明触发捏合手势的最小距离，单位为vp，默认值为5。 以在Column组件上绑定三指捏合手势为例，可以通过在捏合手势的函数回调中获取缩放比例，实现对组件的缩小或放大： 已复制// xxx.ets@Entry@Componentstruct Index {  @State scaleValue: number = 1;  @State pinchValue: number = 1;  @State pinchX: number = 0;  @State pinchY: number = 0;
  build() {    Column() {      Column() {        Text('PinchGesture scale:\n' + this.scaleValue)        Text('PinchGesture center:\n(' + this.pinchX + ',' + this.pinchY + ')')      }      .height(200)      .width(300)      .border({ width: 3 })      .margin({ top: 100 })      // 在组件上绑定缩放比例，可以通过修改缩放比例来实现组件的缩小或者放大      .scale({ x: this.scaleValue, y: this.scaleValue, z: 1 })      .gesture(        // 在组件上绑定三指触发的捏合手势        PinchGesture({ fingers: 3 })          .onActionStart((event: GestureEvent) => {            console.info('Pinch start');          })            // 当捏合手势触发时，可以通过回调函数获取缩放比例，从而修改组件的缩放比例          .onActionUpdate((event: GestureEvent) => {            this.scaleValue = this.pinchValue * event.scale;            this.pinchX = event.pinchCenterX;            this.pinchY = event.pinchCenterY;          })          .onActionEnd(() => {            this.pinchValue = this.scaleValue;            console.info('Pinch end');          })      )    }  }}  旋转手势（RotationGesture）已复制RotationGesture(value?:{fingers?:number; angle?:number})  旋转手势用于触发旋转手势事件，触发旋转手势的最少手指数量为2指，最大为5指，最小改变度数为1度，拥有两个可选参数： fingers：非必选参数，用于声明触发旋转手势所需要的最少手指数量，最小值为2，最大值为5，默认值为2。angle：非必选参数，用于声明触发旋转手势的最小改变度数，单位为deg，默认值为1。 以在Text组件上绑定旋转手势实现组件的旋转为例，可以通过在旋转手势的回调函数中获取旋转角度，从而实现组件的旋转： 已复制// xxx.ets@Entry@Componentstruct Index {  @State angle: number = 0;  @State rotateValue: number = 0;
  build() {    Column() {      Text('RotationGesture angle:' + this.angle).fontSize(28)        // 在组件上绑定旋转布局，可以通过修改旋转角度来实现组件的旋转        .rotate({ angle: this.angle })        .gesture(          RotationGesture()            .onActionStart((event: GestureEvent) => {              console.info('RotationGesture is onActionStart');            })              // 当旋转手势生效时，通过旋转手势的回调函数获取旋转角度，从而修改组件的旋转角度            .onActionUpdate((event: GestureEvent) => {              this.angle = this.rotateValue + event.angle;              console.info('RotationGesture is onActionEnd');            })              // 当旋转结束抬手时，固定组件在旋转结束时的角度            .onActionEnd(() => {              this.rotateValue = this.angle;              console.info('RotationGesture is onActionEnd');            })            .onActionCancel(() => {              console.info('RotationGesture is onActionCancel');            })        )    }    .height(200)    .width(250)  }}  滑动手势（SwipeGesture）已复制SwipeGesture(value?:{fingers?:number; direction?:SwipeDirection; speed?:number})  滑动手势用于触发滑动事件，当滑动速度大于100vp/s时可以识别成功，拥有三个可选参数： fingers：非必选参数，用于声明触发滑动手势所需要的最少手指数量，最小值为1，最大值为10，默认值为1。direction：非必选参数，用于声明触发滑动手势的方向，此枚举值支持逻辑与（&）和逻辑或（|）运算。默认值为SwipeDirection.All。speed：非必选参数，用于声明触发滑动的最小滑动识别速度，单位为vp/s，默认值为100。 以在Column组件上绑定滑动手势实现组件的旋转为例： 已复制// xxx.ets@Entry@Componentstruct Index {  @State rotateAngle: number = 0;  @State speed: number = 1;
  build() {    Column() {      Column() {        Text("SwipeGesture speed\n" + this.speed)        Text("SwipeGesture angle\n" + this.rotateAngle)      }      .border({ width: 3 })      .width(300)      .height(200)      .margin(100)      // 在Column组件上绑定旋转，通过滑动手势的滑动速度和角度修改旋转的角度      .rotate({ angle: this.rotateAngle })      .gesture(        // 绑定滑动手势且限制仅在竖直方向滑动时触发        SwipeGesture({ direction: SwipeDirection.Vertical })          // 当滑动手势触发时，获取滑动的速度和角度，实现对组件的布局参数的修改          .onAction((event: GestureEvent) => {            this.speed = event.speed;            this.rotateAngle = event.angle;          })      )    }  }}  
说明
当SwipeGesture和PanGesture同时绑定时，若二者是以默认方式或者互斥方式进行绑定时，会发生竞争。SwipeGesture的触发条件为滑动速度达到100vp/s，PanGesture的触发条件为滑动距离达到5vp，先达到触发条件的手势触发。可以通过修改SwipeGesture和PanGesture的参数以达到不同的效果。 
  上一篇 绑定手势方法 下一篇 组合手势 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。初识ArkTS语言 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。 当前，ArkTS在TS的基础上主要扩展了如下能力： 基本语法：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。状态管理：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。渲染控制：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。 未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。  上一篇 学习ArkTS语言 下一篇 基本语法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。显示图形 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    显示图片（Image）  绘制几何图形（Shape）  使用画布绘制自定义图形（Canvas）   上一篇 Tabs 下一篇 显示图片（Image） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。加载图片资源存档图类型数据源多媒体像素图显示矢量图添加属性设置图片缩放类型图片插值设置图片重复样式设置图片渲染模式设置图片解码尺寸为图片添加滤镜效果同步加载图片事件调用显示图片（Image） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  开发者经常需要在应用中显示一些图片，例如：按钮中的icon、网络图片、本地图片等。在应用中显示图片需要使用Image组件实现，Image支持多种图片格式，包括png、jpg、bmp、svg和gif，具体用法请参考Image组件。 Image通过调用接口来创建，接口调用形式如下： 已复制Image(src: string | Resource | media.PixelMap) 该接口通过图片数据源获取图片，支持本地图片和网络图片的渲染展示。其中，src是图片的数据源，加载方式请参考加载图片资源。  加载图片资源 Image支持加载存档图、多媒体像素图两种类型。   存档图类型数据源 存档图类型的数据源可以分为本地资源、网络资源、Resource资源、媒体库资源和base64。  本地资源创建文件夹，将本地图片放入ets文件夹下的任意位置。 Image组件引入本地图片路径，即可显示图片（根目录为ets文件夹）。 已复制Image('images/view.jpg').width(200) 网络资源引入网络图片需申请权限ohos.permission.INTERNET，具体申请方式请参考权限申请声明。此时，Image组件的src参数为网络图片的链接。 已复制Image('https://www.example.com/example.JPG') // 实际使用时请替换为真实地址 Resource资源使用资源格式可以跨包/跨模块引入图片，resources文件夹下的图片都可以通过$r资源接口读取到并转换到Resource格式。  图1 resources  调用方式： 已复制Image($r('app.media.icon')) 还可以将图片放在rawfile文件夹下。  图2 rawfile  调用方式： 已复制Image($rawfile('snap')) 媒体库file://data/storage支持file://路径前缀的字符串，用于访问通过媒体库提供的图片路径。  调用接口获取图库的照片url。已复制import picker from '@ohos.file.picker';
@Entry@Componentstruct Index {  @State imgDatas: string[] = [];  // 获取照片url集  getAllImg() {        let result = new Array<string>();    try {      let PhotoSelectOptions = new picker.PhotoSelectOptions();      PhotoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE;      PhotoSelectOptions.maxSelectNumber = 5;      let photoPicker = new picker.PhotoViewPicker();      photoPicker.select(PhotoSelectOptions).then((PhotoSelectResult) => {        this.imgDatas = PhotoSelectResult.photoUris;        console.info('PhotoViewPicker.select successfully, PhotoSelectResult uri: ' + JSON.stringify(PhotoSelectResult));      }).catch((err) => {        console.error(`PhotoViewPicker.select failed with. Code: ${err.code}, message: ${err.message}`);      });    } catch (err) {      console.error(`PhotoViewPicker failed with. Code: ${err.code}, message: ${err.message}`);    }  }
  // aboutToAppear中调用上述函数，获取图库的所有图片url，存在imgDatas中  async aboutToAppear() {    this.getAllImg();  }  // 使用imgDatas的url加载图片。  build() {    Column() {      Grid() {        ForEach(this.imgDatas, item => {          GridItem() {            Image(item)              .width(200)          }        }, item => JSON.stringify(item))      }    }.width('100%').height('100%')  }} 从媒体库获取的url格式通常如下。已复制Image('file://media/Photos/5').width(200)  base64路径格式为data:image/[png|jpeg|bmp|webp];base64,[base64 data]，其中[base64 data]为Base64字符串数据。 Base64格式字符串可用于存储图片的像素数据，在网页上使用较为广泛。    多媒体像素图 PixelMap是图片解码后的像素图，具体用法请参考图片开发指导。以下示例将加载的网络图片返回的数据解码成PixelMap格式，再显示在Image组件上，  创建PixelMap状态变量。已复制@State image: PixelMap = undefined; 引用多媒体。请求网络图片请求，解码编码PixelMap。  引用网络权限与媒体库权限。已复制import http from '@ohos.net.http';import ResponseCode from '@ohos.net.http';import image from '@ohos.multimedia.image'; 填写网络图片地址。已复制http.createHttp().request("https://www.example.com/xxx.png",  (error, data) => {    if (error){      console.error(`http reqeust failed with. Code: ${error.code}, message: ${error.message}`);    } else {    }  }) 将网络地址成功返回的数据，编码转码成pixelMap的图片格式。已复制let code = data.responseCode;if (ResponseCode.ResponseCode.OK === code) {  let res: any = data.result    let imageSource = image.createImageSource(res);  let options = {    alphaType: 0,                     // 透明度    editable: false,                  // 是否可编辑    pixelFormat: 3,                   // 像素格式    scaleMode: 1,                     // 缩略值    size: { height: 100, width: 100}   }  // 创建图片大小    imageSource.createPixelMap(options).then((pixelMap) => {    this.image = pixelMap  })} 显示图片。已复制Button("获取网络图片")  .onClick(() => {    this.httpRequest()  })Image(this.image).height(100).width(100)     显示矢量图 Image组件可显示矢量图（svg格式的图片），支持的svg标签为：svg、rect、circle、ellipse、path、line、polyline、polygon和animate。 svg格式的图片可以使用fillColor属性改变图片的绘制颜色。 已复制Image($r('app.media.cloud')).width(50).fillColor(Color.Blue)   图3 原始图片   图4 设置绘制颜色后的svg图片    添加属性 给Image组件设置属性可以使图片显示更灵活，达到一些自定义的效果。以下是几个常用属性的使用示例，完整属性信息详见Image。   设置图片缩放类型 通过objectFit属性使图片缩放到高度和宽度确定的框内。 已复制@Entry@Componentstruct MyComponent {  scroller: Scroller = new Scroller()
  build() {    Scroll(this.scroller) {      Row() {        Image($r('app.media.img_2')).width(200).height(150)          .border({ width: 1 })          .objectFit(ImageFit.Contain).margin(15) // 保持宽高比进行缩小或者放大，使得图片完全显示在显示边界内。          .overlay('Contain', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.ic_img_2')).width(200).height(150)          .border({ width: 1 })          .objectFit(ImageFit.Cover).margin(15)          // 保持宽高比进行缩小或者放大，使得图片两边都大于或等于显示边界。          .overlay('Cover', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.img_2')).width(200).height(150)          .border({ width: 1 })            // 自适应显示。          .objectFit(ImageFit.Auto).margin(15)          .overlay('Auto', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })      }      Row() {        Image($r('app.media.img_2')).width(200).height(150)          .border({ width: 1 })          .objectFit(ImageFit.Fill).margin(15)          // 不保持宽高比进行放大缩小，使得图片充满显示边界。          .overlay('Fill', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.img_2')).width(200).height(150)          .border({ width: 1 })          // 保持宽高比显示，图片缩小或者保持不变。          .objectFit(ImageFit.ScaleDown).margin(15)          .overlay('ScaleDown', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.img_2')).width(200).height(150)          .border({ width: 1 })          // 保持原有尺寸显示。          .objectFit(ImageFit.None).margin(15)          .overlay('None', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })      }    }  }}    图片插值 当原图分辨率较低并且放大显示时，图片会模糊出现锯齿。这时可以使用interpolation属性对图片进行插值，使图片显示得更清晰。 已复制@Entry@Componentstruct Index {  build() {    Column() {      Row() {        Image($r('app.media.grass'))          .width('40%')          .interpolation(ImageInterpolation.None)          .borderWidth(1)          .overlay("Interpolation.None", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })          .margin(10)        Image($r('app.media.grass'))          .width('40%')          .interpolation(ImageInterpolation.Low)          .borderWidth(1)          .overlay("Interpolation.Low", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })          .margin(10)      }.width('100%')      .justifyContent(FlexAlign.Center)
      Row() {        Image($r('app.media.grass'))          .width('40%')          .interpolation(ImageInterpolation.Medium)          .borderWidth(1)          .overlay("Interpolation.Medium", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })          .margin(10)        Image($r('app.media.grass'))          .width('40%')          .interpolation(ImageInterpolation.High)          .borderWidth(1)          .overlay("Interpolation.High", { align: Alignment.Bottom, offset: { x: 0, y: 20 } })          .margin(10)      }.width('100%')      .justifyContent(FlexAlign.Center)    }    .height('100%')  }}    设置图片重复样式 通过objectRepeat属性设置图片的重复样式方式，重复样式请参考ImageRepeat枚举说明。 已复制@Entry@Componentstruct MyComponent {  build() {    Column({ space: 10 }) {      Row({ space: 5 }) {        Image($r('app.media.ic_public_favor_filled_1'))          .width(110)          .height(115)          .border({ width: 1 })          .objectRepeat(ImageRepeat.XY)          .objectFit(ImageFit.ScaleDown)          // 在水平轴和竖直轴上同时重复绘制图片          .overlay('ImageRepeat.XY', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.ic_public_favor_filled_1'))          .width(110)          .height(115)          .border({ width: 1 })          .objectRepeat(ImageRepeat.Y)          .objectFit(ImageFit.ScaleDown)          // 只在竖直轴上重复绘制图片          .overlay('ImageRepeat.Y', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.ic_public_favor_filled_1'))          .width(110)          .height(115)          .border({ width: 1 })          .objectRepeat(ImageRepeat.X)          .objectFit(ImageFit.ScaleDown)          // 只在水平轴上重复绘制图片          .overlay('ImageRepeat.X', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })      }    }.height(150).width('100%').padding(8)  }}    设置图片渲染模式 通过renderMode属性设置图片的渲染模式为原色或黑白。 已复制@Entry@Componentstruct MyComponent {  build() {    Column({ space: 10 }) {      Row({ space: 50 }) {        Image($r('app.media.example'))          // 设置图片的渲染模式为原色           .renderMode(ImageRenderMode.Original)          .width(100)          .height(100)          .border({ width: 1 })            // overlay是通用属性，用于在组件上显示说明文字          .overlay('Original', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })        Image($r('app.media.example'))          // 设置图片的渲染模式为黑白          .renderMode(ImageRenderMode.Template)          .width(100)          .height(100)          .border({ width: 1 })          .overlay('Template', { align: Alignment.Bottom, offset: { x: 0, y: 20 } })      }    }.height(150).width('100%').padding({ top: 20,right: 10 })  }}    设置图片解码尺寸 通过sourceSize属性设置图片解码尺寸，降低图片的分辨率。 原图尺寸为1280*960，该示例将图片解码为150*150和400*400。 已复制@Entry@Componentstruct Index {  build() {    Column() {      Row({ space: 20 }) {        Image($r('app.media.example'))          .sourceSize({            width: 150,            height: 150          })          .objectFit(ImageFit.ScaleDown)          .width('25%')          .aspectRatio(1)          .border({ width: 1 })          .overlay('width:150 height:150', { align: Alignment.Bottom, offset: { x: 0, y: 40 } })        Image($r('app.media.example'))          .sourceSize({            width: 400,            height: 400          })          .objectFit(ImageFit.ScaleDown)          .width('25%')          .aspectRatio(1)          .border({ width: 1 })          .overlay('width:400 height:400', { align: Alignment.Bottom, offset: { x: 0, y: 40 } })      }.height(150).width('100%').padding(20)
    }  }}    为图片添加滤镜效果 通过colorFilter修改图片的像素颜色，为图片添加滤镜。 已复制@Entry@Componentstruct Index {  build() {    Column() {      Row() {        Image($r('app.media.example'))          .width('40%')          .margin(10)        Image($r('app.media.example'))          .width('40%')          .colorFilter(            [1, 1, 0, 0, 0,             0, 1, 0, 0, 0,             0, 0, 1, 0, 0,             0, 0, 0, 1, 0])          .margin(10)      }.width('100%')      .justifyContent(FlexAlign.Center)    }  }}    同步加载图片 一般情况下，图片加载流程会异步进行，以避免阻塞主线程，影响UI交互。但是特定情况下，图片刷新时会出现闪烁，这时可以使用syncLoad属性，使图片同步加载，从而避免出现闪烁。不建议图片加载较长时间时使用，会导致页面无法响应。 已复制Image($r('app.media.icon'))  .syncLoad(true)   事件调用 通过在Image组件上绑定onComplete事件，图片加载成功后可以获取图片的必要信息。如果图片加载失败，也可以通过绑定onError回调来获得结果。 已复制@Entry@Componentstruct MyComponent {  @State widthValue: number = 0  @State heightValue: number = 0  @State componentWidth: number = 0  @State componentHeight: number = 0
  build() {    Column() {      Row() {        Image($r('app.media.ic_img_2'))          .width(200)          .height(150)          .margin(15)          .onComplete(msg => {            if(msg){              this.widthValue = msg.width              this.heightValue = msg.height              this.componentWidth = msg.componentWidth              this.componentHeight = msg.componentHeight            }          })            // 图片获取失败，打印结果          .onError(() => {            console.info('load image fail')          })          .overlay('\nwidth: ' + String(this.widthValue) + ', height: ' + String(this.heightValue) + '\ncomponentWidth: ' + String(this.componentWidth) + '\ncomponentHeight: ' + String(this.componentHeight), {            align: Alignment.Bottom,            offset: { x: 0, y: 60 }          })      }    }  }}    上一篇 显示图形 下一篇 绘制几何图形（Shape） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发布局 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    布局概述  构建布局  改善布局性能   上一篇 UI开发（ArkTS声明式开发范式）概述 下一篇 布局概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述布局与约束设置排列方式设置行列数量与占比设置子组件所占行列数设置主轴方向在网格布局中显示数据设置行列间距构建可滚动的网格布局控制滚动位置性能优化创建网格（Grid/GridItem） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 网格布局是由“行”和“列”分割的单元格所组成，通过指定“项目”所在的单元格做出各种各样的布局。网格布局具有较强的页面均分能力，子组件占比控制能力，是一种重要自适应布局，其使用场景有九宫格图片展示、日历、计算器等。 ArkUI提供了Grid容器组件和子组件GridItem，用于构建网格布局。Grid用于设置网格布局相关参数，GridItem定义子组件相关特征。Grid组件支持使用条件渲染、循环渲染、懒加载等渲染控制方式生成子组件。   布局与约束 Grid组件为网格容器，其中容器内每一个条目对应一个GridItem组件，如下图所示。  图1 Grid与GridItem组件关系  
说明
 Grid的子组件必须是GridItem组件。 
 网格布局是一种二维布局。Grid组件支持自定义行列数和每行每列尺寸占比、设置子组件横跨几行或者几列，同时提供了垂直和水平布局能力。当网格容器组件尺寸发生变化时，所有子组件以及间距会等比例调整，从而实现网格布局的自适应能力。根据Grid的这些布局能力，可以构建出不同样式的网格布局，如下图所示。  图2 网格布局  如果Grid组件设置了宽高属性，则其尺寸为设置值。如果没有设置宽高属性，Grid组件的尺寸默认适应其父组件的尺寸。 Grid组件根据行列数量与占比属性的设置，可以分为三种布局情况：  行、列数量与占比同时设置：Grid只展示固定行列数的元素，其余元素不展示，且Grid不可滚动。（推荐使用该种布局方式） 只设置行、列数量与占比中的一个：元素按照设置的方向进行排布，超出的元素可通过滚动的方式展示。 行列数量与占比都不设置：元素在布局方向上排布，其行列数由布局方向、单个网格的宽高等多个属性共同决定。超出行列容纳范围的元素不展示，且Grid不可滚动。    设置排列方式   设置行列数量与占比 通过设置行列数量与尺寸占比可以确定网格布局的整体排列方式。Grid组件提供了rowsTemplate和columnsTemplate属性用于设置网格布局行列数量与尺寸占比。 rowsTemplate和columnsTemplate属性值是一个由多个空格和'数字+fr'间隔拼接的字符串，fr的个数即网格布局的行或列数，fr前面的数值大小，用于计算该行或列在网格布局宽度上的占比，最终决定该行或列的宽度。  图3 行列数量占比示例  如上图所示，构建的是一个三行三列的的网格布局，其在垂直方向上分为三等份，每行占一份；在水平方向上分为四等份，第一列占一份，第二列占两份，第三列占一份。 只要将rowsTemplate的值为'1fr 1fr 1fr'，同时将columnsTemplate的值为'1fr 2fr 1fr'，即可实现上述网格布局。 已复制Grid() {  ...}.rowsTemplate('1fr 1fr 1fr').columnsTemplate('1fr 2fr 1fr') 
说明
 当Grid组件设置了rowsTemplate或columnsTemplate时，Grid的layoutDirection、maxCount、minCount、cellLength属性不生效，属性说明可参考Grid-属性。 
   设置子组件所占行列数 除了大小相同的等比例网格布局，由不同大小的网格组成不均匀分布的网格布局场景在实际应用中十分常见，如下图所示。在Grid组件中，通过设置GridItem的rowStart、rowEnd、columnStart和columnEnd可以实现如图所示的单个网格横跨多行或多列的场景。  图4 不均匀网格布局  例如计算器的按键布局就是常见的不均匀网格布局场景。如下图，计算器中的按键“0”和“=”，按键“0”横跨第一、二两列，按键“=”横跨第五、六两行。使用Grid构建的网格布局，其行列标号从1开始，依次编号。  图5 计算器  在单个网格单元中，rowStart和rowEnd属性表示指定当前元素起始行号和终点行号，columnStart和columnEnd属性表示指定当前元素的起始列号和终点列号。 所以“0”按键横跨第一列和第二列，只要将“0”对应GridItem的columnStart和columnEnd设为1和2，将“=”对应GridItem的的rowStart和rowEnd设为5和6即可。 已复制GridItem() {  Text(key)    ...}.columnStart(1).columnEnd(2) “=”按键横跨第五行和第六行，只要将“=”对应GridItem的rowStart和rowEnd设为5和6即可。 已复制GridItem() {  Text(key)    ...}.rowStart(5).rowEnd(6)   设置主轴方向 使用Grid构建网格布局时，若没有设置行列数量与占比，可以通过layoutDirection可以设置网格布局的主轴方向，决定子组件的排列方式。此时可以结合minCount和maxCount属性来约束主轴方向上的网格数量。  图6 主轴方向示意图  当前layoutDirection设置为Row时，先从左到右排列，排满一行再排一下一行。当前layoutDirection设置为Column时，先从上到下排列，排满一列再排一下一列，如上图所示。此时，将maxCount属性设为3，表示主轴方向上最大显示的网格单元数量为3。 已复制Grid() {  ...}.maxCount(3).layoutDirection(GridDirection.Row) 
说明
 1. layoutDirection属性仅在不设置rowsTemplate和columnsTemplate时生效，此时元素在layoutDirection方向上排列。 2. 仅设置rowsTemplate时，Grid主轴为水平方向，交叉轴为垂直方向。 2. 仅设置columnsTemplate时，Grid主轴为垂直方向，交叉轴为水平方向。 
   在网格布局中显示数据 网格布局采用二维布局的方式组织其内部元素，如下图所示。  图7 通用办公服务  Grid组件可以通过二维布局的方式显示一组GridItem子组件。 已复制Grid() {  GridItem() {    Text('会议')      ...  }
  GridItem() {    Text('签到')      ...  }
  GridItem() {    Text('投票')      ...  }
  GridItem() {    Text('打印')      ...  }}.rowsTemplate('1fr 1fr').columnsTemplate('1fr 1fr') 对于内容结构相似的多个GridItem，通常更推荐使用循环渲染ForEach语句中嵌套GridItem的形式，来减少重复代码。 已复制@Componentstruct OfficeService {  @State services: Array<string> = ['会议', '投票', '签到', '打印']  ...
  build() {    Column() {      Grid() {        ForEach(this.services, service => {          GridItem() {            Text(service)              ...          }        }, service => service)      }      .rowsTemplate('1fr 1fr')      .columnsTemplate('1fr 1fr')      ...    }    ...  }}   设置行列间距 在两个网格单元之间的网格横向间距称为行间距，网格纵向间距称为列间距，如下图所示。  图8 网格的行列间距 通过Grid的rowsGap和columnsGap可以设置网格布局的行列间距。在图5所示的计算器中，行间距为15vp，列间距为10vp。 已复制Grid() {  ...}.columnsGap(10).rowsGap(15)    构建可滚动的网格布局 可滚动的网格布局常用在文件管理、购物或视频列表等页面中，如下图所示。在设置Grid的行列数量与占比时，如果仅设置行、列数量与占比中的一个，即仅设置rowsTemplate或仅设置columnsTemplate属性，网格单元按照设置的方向排列，超出Grid显示区域后，Grid拥有可滚动能力。  图9 横向可滚动网格布局  如果设置的是columnsTemplate，Grid的滚动方向为垂直方向；如果设置的是rowsTemplate，Grid的滚动方向为水平方向。 如上图所示的横向可滚动网格布局，只要设置rowsTemplate属性的值且不设置columnsTemplate属性，当内容超出Grid组件宽度时，Grid可横向滚动进行内容展示。 已复制@Componentstruct Shopping {  @State services: Array<string> = ['直播', '进口', ...]  ...
  build() {    Column({ space: 5 }) {      Grid() {        ForEach(this.services, (service: string, index) => {          GridItem() {            ...          }          .width('25%')        }, service => service)      }      .rowsTemplate('1fr 1fr') // 只设置rowsTemplate属性，当内容超出Grid区域时，可水平滚动。      .rowsGap(15)      ...    }    ...  }}   控制滚动位置 与新闻列表的返回顶部场景类似，控制滚动位置功能在网格布局中也很常用，例如下图所示日历的翻页功能。  图10 日历翻页  Grid组件初始化时，可以绑定一个Scroller对象，用于进行滚动控制，例如通过Scroller对象的scrollPage方法进行翻页。 已复制private scroller: Scroller = new Scroller() 在日历页面中，用户在点击“下一页”按钮时，应用响应点击事件，通过指定scrollPage方法的参数next为true，滚动到下一页。 已复制Column({ space: 5 }) {  Grid(this.scroller) {    ...  }  .columnsTemplate('1fr 1fr 1fr 1fr 1fr 1fr 1fr')  ...  Row({space: 20}) {   Button('上一页')     .onClick(() => {       this.scroller.scrollPage({         next: false       })     })
   Button('下一页')     .onClick(() => {       this.scroller.scrollPage({         next: true       })     }) }}...   性能优化 与长列表的处理类似，循环渲染适用于数据量较小的布局场景，当构建具有大量网格项的可滚动网格布局时，推荐使用数据懒加载方式实现按需迭代加载数据，从而提升列表性能。 关于按需加载优化的具体实现可参考数据懒加载章节中的示例。 当使用懒加载方式渲染网格时，为了更好的滚动体验，减少滑动时出现白块，Grid组件中也可通过cachedCount属性设置GridItem的预加载数量，只在懒加载LazyForEach中生效。       设置预加载数量后，会在Grid显示区域前后各缓存cachedCount*列数个GridItem，超出显示和缓存范围的GridItem会被释放。      已复制Grid() {  LazyForEach(this.dataSource, item => {    GridItem() {      ...    }  })}.cachedCount(3)  
说明
 cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。 
   上一篇 创建列表（List） 下一篇 创建轮播（Swiper） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述布局与约束布局约束开发布局设置主轴方向设置交叉轴布局在列表中显示数据迭代列表内容自定义列表样式设置内容间距添加分隔线添加滚动条支持分组列表添加粘性标题控制滚动位置响应滚动位置响应列表项侧滑给列表项添加标记下拉刷新与上拉加载编辑列表新增列表项删除列表项长列表的处理相关实例创建列表（List） 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
   概述 列表是一种复杂的容器，当列表项达到一定数量，内容超过屏幕大小时，可以自动提供滚动功能。它适合用于呈现同类数据类型或数据类型集，例如图片和文本。在列表中显示数据集合是许多应用程序中的常见要求（如通讯录、音乐列表、购物清单等）。 使用列表可以轻松高效地显示结构化、可滚动的信息。通过在List组件中按垂直或者水平方向线性排列子组件ListItemGroup或ListItem，为列表中的行或列提供单个视图，或使用ForEach迭代一组行或列，或混合任意数量的单个视图和ForEach结构，构建一个列表。List组件支持使用条件渲染、循环渲染、懒加载等渲染控制方式生成子组件。   布局与约束 列表作为一种容器，会自动按其滚动方向排列子组件，向列表中添加组件或从列表中移除组件会重新排列子组件。 如下图所示，在垂直列表中，List按垂直方向自动排列ListItemGroup或ListItem。 ListItemGroup用于列表数据的分组展示，其子组件也是ListItem。ListItem表示单个列表项，可以包含单个子组件。  图1 List、ListItemGroup和ListItem组件关系  
说明
 List的子组件必须是ListItemGroup或ListItem，ListItem和ListItemGroup必须配合List来使用。 
   布局 List除了提供垂直和水平布局能力、超出屏幕时可以滚动的自适应延伸能力之外，还提供了自适应交叉轴方向上排列个数的布局能力。 利用垂直布局能力可以构建单列或者多列垂直滚动列表，如下图所示。  图2 垂直滚动列表（左：单列；右：多列）  利用水平布局能力可以是构建单行或多行水平滚动列表，如下图所示。  图3 水平滚动列表（左：单行；右：多行）    约束 列表的主轴方向是指子组件列的排列方向，也是列表的滚动方向。垂直于主轴的轴称为交叉轴，其方向与主轴方向相互垂直。 如下图所示，垂直列表的主轴是垂直方向，交叉轴是水平方向。水平列表的主轴是水平方向，交叉轴是垂直方向。  图4 列表的主轴与交叉轴  如果List组件主轴或交叉轴方向设置了尺寸，则其对应方向上的尺寸为设置值。 如果List组件主轴方向没有设置尺寸，当List子组件主轴方向总尺寸小于List的父组件尺寸时，List主轴方向尺寸自动适应子组件的总尺寸。 如下图所示，一个垂直列表B没有设置高度时，其父组件A高度为200vp，若其所有子组件C的高度总和为150vp，则此时列表B的高度为150vp。  图5 列表主轴高度约束示例1（A: List的父组件; B: List组件; C: List的所有子组件）  如果子组件主轴方向总尺寸超过List父组件尺寸时，List主轴方向尺寸适应List的父组件尺寸。 如下图所示，同样是没有设置高度的垂直列表B，其父组件A高度为200vp，若其所有子组件C的高度总和为300vp，则此时列表B的高度为200vp。  图6 列表主轴高度约束示例2（A: List的父组件; B: List组件; C: List的所有子组件）  List组件交叉轴方向在没有设置尺寸时，其尺寸默认自适应父组件尺寸。   开发布局   设置主轴方向 List组件主轴默认是垂直方向，即默认情况下不需要手动设置List方向，就可以构建一个垂直滚动列表。 若是水平滚动列表场景，将List的listDirection属性设置为Axis.Horizontal即可实现。listDirection默认为Axis.Vertical，即主轴默认是垂直方向。 已复制List() {  ...}.listDirection(Axis.Horizontal)   设置交叉轴布局 List组件的交叉轴布局可以通过lanes和alignListItem属性进行设置，lanes属性用于确定交叉轴排列的列表项数量，alignListItem用于设置子组件在交叉轴方向的对齐方式。 List组件的lanes属性通常用于在不同尺寸的设备自适应构建不同行数或列数的列表。lanes属性的取值类型是"number | LengthConstrain"，即整数或者LengthConstrain类型。以垂直列表为例，如果将lanes属性设为2，表示构建的是一个两列的垂直列表，如图2中右图所示。lanes的默认值为1，即默认情况下，垂直列表的列数是1。 已复制List() {  ...}.lanes(2) 当其取值为LengthConstrain类型时，表示会根据LengthConstrain与List组件的尺寸自适应决定行或列数。 已复制List() {  ...}.lanes({ minLength: 200, maxLength: 300 }) 例如，假设在垂直列表中设置了lanes的值为{ minLength: 200, maxLength: 300 }。此时，  当List组件宽度为300vp时，由于minLength为200vp，此时列表为一列。 当List组件宽度变化至400vp时，符合两倍的minLength，则此时列表自适应为两列。  同样以垂直列表为例，当alignListItem属性设置为ListItemAlign.Center表示列表项在水平方向上居中对齐。alignListItem的默认值是ListItemAlign.Start，即列表项在列表交叉轴方向上默认按首部对齐。 已复制List() {  ...}.alignListItem(ListItemAlign.Center)   在列表中显示数据 列表视图垂直或水平显示项目集合，在行或列超出屏幕时提供滚动功能，使其适合显示大型数据集合。在最简单的列表形式中，List静态地创建其列表项ListItem的内容。  图7 城市列表 已复制@Componentstruct CityList {  build() {    List() {      ListItem() {        Text('北京').fontSize(24)      }
      ListItem() {        Text('杭州').fontSize(24)      }
      ListItem() {        Text('上海').fontSize(24)      }    }    .backgroundColor('#FFF1F3F5')    .alignListItem(ListItemAlign.Center)  }}  由于在ListItem中只能有一个根节点组件，不支持以平铺形式使用多个组件。因此，若列表项是由多个组件元素组成的，则需要将这多个元素组合到一个容器组件内或组成一个自定义组件。  图8 联系人列表项示例  如上图所示，联系人列表的列表项中，每个联系人都有头像和名称。此时，需要将Image和Text封装到一个Row容器内。 已复制List() {  ListItem() {    Row() {      Image($r('app.media.iconE'))        .width(40)        .height(40)        .margin(10)
      Text('小明')        .fontSize(20)    }  }
  ListItem() {    Row() {      Image($r('app.media.iconF'))        .width(40)        .height(40)        .margin(10)
      Text('小红')        .fontSize(20)    }  }}   迭代列表内容 通常更常见的是，应用通过数据集合动态地创建列表。使用循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件，降低代码复杂度。 ArkTS通过ForEach提供了组件的循环渲染能力。以简单形式的联系人列表为例，将联系人名称和头像数据以Contact类结构存储到contacts数组，使用ForEach中嵌套ListItem的形式来代替多个平铺的、内容相似的ListItem，从而减少重复代码。 已复制import util from '@ohos.util';
class Contact {  key: string = util.generateRandomUUID(true);  name: string;  icon: Resource;
  constructor(name: string, icon: Resource) {    this.name = name;    this.icon = icon;  }}
@Entry@Componentstruct SimpleContacts {  private contacts = [    new Contact('小明', $r("app.media.iconA")),    new Contact('小红', $r("app.media.iconB")),    ...  ]
  build() {    List() {      ForEach(this.contacts, (item: Contact) => {        ListItem() {          Row() {            Image(item.icon)              .width(40)              .height(40)              .margin(10)            Text(item.name).fontSize(20)          }          .width('100%')          .justifyContent(FlexAlign.Start)        }      }, item => item.key)    }    .width('100%')  }} 在List组件中，ForEach除了可以用来循环渲染ListItem，也可以用来循环渲染ListItemGroup。ListItemGroup的循环渲染详细使用请参见支持分组列表。   自定义列表样式   设置内容间距 在初始化列表时，如需在列表项之间添加间距，可以使用space参数。例如，在每个列表项之间沿主轴方向添加10vp的间距： 已复制List({ space: 10 }) {  ...}   添加分隔线 分隔线用来将界面元素隔开，使单个元素更加容易识别。如下图所示，当列表项左边有图标（如蓝牙图标），由于图标本身就能很好的区分，此时分隔线从图标之后开始显示即可。  图9 设置列表分隔线样式  List提供了divider属性用于给列表项之间添加分隔线。在设置divider属性时，可以通过strokeWidth和color属性设置分隔线的粗细和颜色。 startMargin和endMargin属性分别用于设置分隔线距离列表侧边起始端的距离和距离列表侧边结束端的距离。 已复制List() {  ...}.divider({  strokeWidth: 1,  startMargin: 60,  endMargin: 10,  color: '#ffe9f0f0'}) 此示例表示从距离列表侧边起始端60vp开始到距离结束端10vp的位置，画一条粗细为1vp的分割线，可以实现图9设置列表分隔线的样式。 
说明
 1. 分隔线的宽度会使ListItem之间存在一定间隔，当List设置的内容间距小于分隔线宽度时，ListItem之间的间隔会使用分隔线的宽度。 2. 当List存在多列时，分割线的startMargin和endMargin作用于每一列上。 3. List组件的分隔线画在两个ListItem之间，第一个ListItem上方和最后一个ListItem下方不会绘制分隔线。 
   添加滚动条 当列表项高度（宽度）超出屏幕高度（宽度）时，列表可以沿垂直（水平)方向滚动。在页面内容很多时，若用户需快速定位，可拖拽滚动条，如下图所示。  图10 列表的滚动条  在使用List组件时，可通过scrollBar属性控制列表滚动条的显示。scrollBar的取值类型为BarState，当取值为BarState.Auto表示按需显示滚动条。此时，当触摸到滚动条区域时显示控件，可上下拖拽滚动条快速浏览内容，拖拽时会变粗。若不进行任何操作，2秒后滚动条自动消失。 已复制List() {  ...}.scrollBar(BarState.Auto)   支持分组列表 在列表中支持数据的分组展示，可以使列表显示结构清晰，查找方便，从而提高使用效率。分组列表在实际应用中十分常见，如下图所示联系人列表。  图11 联系人分组列表  在List组件中使用ListItemGroup对项目进行分组，可以构建二维列表。 在List组件中可以直接使用一个或者多个ListItemGroup组件，ListItemGroup的宽度默认充满List组件。在初始化ListItemGroup时，可通过header参数设置列表分组的头部组件。 已复制@Componentstruct ContactsList {  ...    @Builder itemHead(text: string) {    // 列表分组的头部组件，对应联系人分组A、B等位置的组件    Text(text)      .fontSize(20)      .backgroundColor('#fff1f3f5')      .width('100%')      .padding(5)  }
  build() {    List() {      ListItemGroup({ header: this.itemHead('A') }) {        // 循环渲染分组A的ListItem        ...      }      ...
      ListItemGroup({ header: this.itemHead('B') }) {        // 循环渲染分组B的ListItem        ...      }      ...    }  }} 如果多个ListItemGroup结构类似，可以将多个分组的数据组成数组，然后使用ForEach对多个分组进行循环渲染。例如在联系人列表中，将每个分组的联系人数据contacts（可参考迭代列表内容章节）和对应分组的标题title数据进行组合，定义为数组contactsGroups。 已复制contactsGroups: object[] = [  {    title: 'A',    contacts: [      new Contact('艾佳', $r('app.media.iconA')),      new Contact('安安', $r('app.media.iconB')),      new Contact('Angela', $r('app.media.iconC')),    ],  },  {    title: 'B',    contacts: [      new Contact('白叶', $r('app.media.iconD')),      new Contact('伯明', $r('app.media.iconE')),    ],  },  ...] 然后在ForEach中对contactsGroups进行循环渲染，即可实现多个分组的联系人列表。 已复制List() {  // 循环渲染ListItemGroup，contactsGroups为多个分组联系人contacts和标题title的数据集合  ForEach(this.contactsGroups, item => {    ListItemGroup({ header: this.itemHead(item.title) }) {      // 循环渲染ListItem      ForEach(item.contacts, contact => {        ListItem() {          ...        }      }, item => item.key)    }    ...  })}   添加粘性标题 粘性标题是一种常见的标题模式，常用于定位字母列表的头部元素。如下图所示，在联系人列表中滚动A部分时，B部分开始的头部元素始终处于A的下方。而在开始滚动B部分时，B的头部会固定在屏幕顶部，直到所有B的项均完成滚动后，才被后面的头部替代。 粘性标题不仅有助于阐明列表中数据的表示形式和用途，还可以帮助用户在大量信息中进行数据定位，从而避免用户在标题所在的表的顶部与感兴趣区域之间反复滚动。  图12 粘性标题  List组件的sticky属性配合ListItemGroup组件使用，用于设置ListItemGroup中的头部组件是否呈现吸顶效果或者尾部组件是否呈现吸底效果。 通过给List组件设置sticky属性为StickyStyle.Header，即可实现列表的粘性标题效果。如果需要支持吸底效果，可以通过footer参数初始化ListItemGroup的底部组件，并将sticky属性设置为StickyStyle.Footer。 已复制@Componentstruct ContactsList {  // 定义分组联系人数据集合contactsGroups数组  ...   @Builder itemHead(text: string) {    // 列表分组的头部组件，对应联系人分组A、B等位置的组件    Text(text)      .fontSize(20)      .backgroundColor('#fff1f3f5')      .width('100%')      .padding(5)  }
  build() {    List() {      // 循环渲染ListItemGroup，contactsGroups为多个分组联系人contacts和标题title的数据集合      ForEach(this.contactsGroups, item => {        ListItemGroup({ header: this.itemHead(item.title) }) {          // 循环渲染ListItem          ForEach(item.contacts, contact => {            ListItem() {              ...            }          }, item => item.key)        }        ...      })    }    .sticky(StickyStyle.Header)  // 设置吸顶，实现粘性标题效果  }}   控制滚动位置 控制滚动位置在实际应用中十分常见，例如当新闻页列表项数量庞大，用户滚动列表到一定位置时，希望快速滚动到列表底部或返回列表顶部。此时，可以通过控制滚动位置来实现列表的快速定位，如下图所示。  图13 返回列表顶部  List组件初始化时，可以通过scroller参数绑定一个Scroller对象，进行列表的滚动控制。例如，用户在新闻应用中，点击新闻页面底部的返回顶部按钮时，就可以通过Scroller对象的scrollToIndex方法使列表滚动到指定的列表项索引位置。 首先，需要创建一个Scroller的对象listScroller。 已复制private listScroller: Scroller = new Scroller(); 然后，通过将listScroller用于初始化List组件的scroller参数，完成listScroller与列表的绑定。在需要跳转的位置指定scrollToIndex的参数为0，表示返回列表顶部。 已复制Stack({ alignContent: Alignment.BottomEnd }) {  // 将listScroller用于初始化List组件的scroller参数，完成listScroller与列表的绑定。  List({ space: 20, scroller: this.listScroller }) {    ...  }  ...
  Button() {    ...  }  .onClick(() => {    // 点击按钮时，指定跳转位置，返回列表顶部    this.listScroller.scrollToIndex(0)  })  ...}   响应滚动位置 许多应用需要监听列表的滚动位置变化并作出响应。例如，在联系人列表滚动时，如果跨越了不同字母开头的分组，则侧边字母索引栏也需要更新到对应的字母位置。 除了字母索引之外，滚动列表结合多级分类索引在应用开发过程中也很常见，例如购物应用的商品分类页面，多级分类也需要监听列表的滚动位置。  图14 字母索引响应联系人列表滚动  如上图所示，当联系人列表从A滚动到B时，右侧索引栏也需要同步从选中A状态变成选中B状态。此场景可以通过监听List组件的onScrollIndex事件来实现，右侧索引栏需要使用字母表索引组件AlphabetIndexer。 在列表滚动时，根据列表此时所在的索引值位置firstIndex，重新计算字母索引栏对应字母的位置selectedIndex。由于AlphabetIndexer组件通过selected属性设置了选中项索引值，当selectedIndex变化时会触发AlphabetIndexer组件重新渲染，从而显示为选中对应字母的状态。 已复制...const alphabets = ['#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',  'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
@Entry@Componentstruct ContactsList {  @State selectedIndex: number = 0;  private listScroller: Scroller = new Scroller();  ...
  build() {    Stack({ alignContent: Alignment.End }) {      List({ scroller: this.listScroller }) {        ...      }      .onScrollIndex((firstIndex: number) => {          this.selectedIndex = firstIndex        // 根据列表滚动到的索引值，重新计算对应联系人索引栏的位置this.selectedIndex        ...      })      ...
      // 字母表索引组件      AlphabetIndexer({ arrayValue: alphabets, selected: 0 })        .selected(this.selectedIndex)      ...    }  }} 
说明
 计算索引值时，ListItemGroup作为一个整体占一个索引值，不计算ListItemGroup内部ListItem的索引值。 
   响应列表项侧滑 侧滑菜单在许多应用中都很常见。例如，通讯类应用通常会给消息列表提供侧滑删除功能，即用户可以通过向左侧滑列表的某一项，再点击删除按钮删除消息，如下图所示。  图15 侧滑删除列表项 ListItem的swipeAction属性可用于实现列表项的左右滑动功能。swipeAction属性方法初始化时有必填参数SwipeActionOptions，其中，start参数表示设置列表项右滑时起始端滑出的组件，end参数表示设置列表项左滑时尾端滑出的组件。  在消息列表中，end参数表示设置ListItem左滑时尾端划出自定义组件，即删除按钮。在初始化end方法时，将滑动列表项的索引传入删除按钮组件，当用户点击删除按钮时，可以根据索引值来删除列表项对应的数据，从而实现侧滑删除功能。 已复制@Entry@Componentstruct MessageList {  @State messages: object[] = [    // 初始化消息列表数据    ...  ];
  @Builder itemEnd(index: number) {    // 侧滑后尾端出现的组件    Button({ type: ButtonType.Circle }) {      Image($r('app.media.ic_public_delete_filled'))        .width(20)        .height(20)    }    .onClick(() => {      this.messages.splice(index, 1);    })    ...  }
  build() {    ...      List() {        ForEach(this.messages, (item, index) => {          ListItem() {            ...          }          .swipeAction({ end: this.itemEnd(index) }) // 设置侧滑属性        }, item => item.id.toString())      }    ...  }}   给列表项添加标记 添加标记是一种无干扰性且直观的方法，用于显示通知或将注意力集中到应用内的某个区域。例如，当消息列表接收到新消息时，通常对应的联系人头像的右上方会出现标记，提示有若干条未读消息，如下图所示。  图16 给列表项添加标记  在ListItem中使用Badge组件可实现给列表项添加标记功能。Badge是可以附加在单个组件上用于信息标记的容器组件。 在消息列表中，若希望在联系人头像右上角添加标记，可在实现消息列表项ListItem的联系人头像时，将头像Image组件作为Badge的子组件。 在Badge组件中，count和position参数用于设置需要展示的消息数量和提示点显示位置，还可以通过style参数灵活设置标记的样式。 已复制Badge({  count: 1,  position: BadgePosition.RightTop,  style: { badgeSize: 16, badgeColor: '#FA2A2D' }}) {  // Image组件实现消息联系人头像  ...}...   下拉刷新与上拉加载 页面的下拉刷新与上拉加载功能在移动应用中十分常见，例如，新闻页面的内容刷新和加载。这两种操作的原理都是通过响应用户的触摸事件，在顶部或者底部显示一个刷新或加载视图，完成后再将此视图隐藏。 以下拉刷新为例，其实现主要分成三步：  监听手指按下事件，记录其初始位置的值。 监听手指按压移动事件，记录并计算当前移动的位置与初始值的差值，大于0表示向下移动，同时设置一个允许移动的最大值。 监听手指抬起事件，若此时移动达到最大值，则触发数据加载并显示刷新视图，加载完成后将此视图隐藏。  下拉刷新与上拉加载的具体实现可参考相关实例中新闻数据加载。若开发者希望快速实现此功能，也可使用三方组件PullToRefresh。   编辑列表 列表的编辑模式用途十分广泛，常见于待办事项管理、文件管理、备忘录的记录管理等应用场景。在列表的编辑模式下，新增和删除列表项是最基础的功能，其核心是对列表项对应的数据集合进行数据添加和删除。 下面以待办事项管理为例，介绍如何快速实现新增和删除列表项功能。   新增列表项 如下图所示，当用户点击添加按钮时，提供用户新增列表项内容选择或填写的交互界面，用户点击确定后，列表中新增对应的项目。  图17 新增待办  添加列表项功能实现主要流程如下：  定义列表项数据结构和初始化列表数据，构建列表整体布局和列表项。         以待办事项管理为例，首先定义待办数据结构：        已复制import util from '@ohos.util';
export class ToDo {  key: string = util.generateRandomUUID(true);  name: string;
  constructor(name: string) {    this.name = name;  }}          然后，初始化待办列表数据和可选事项：        已复制@State toDoData: ToDo[] = [];private availableThings: string[] = ['读书', '运动', '旅游', '听音乐', '看电影', '唱歌'];  最后，构建列表布局和列表项： 已复制List({ space: 10 }) {  ForEach(this.toDoData, (toDoItem) => {    ListItem() {      ...    }  }, toDoItem => toDoItem.key)}  提供新增列表项入口，即给新增按钮添加点击事件。 响应用户确定新增事件，更新列表数据。         待办事项管理示例的步骤2和步骤3功能实现如下：        已复制Text('+')  .onClick(() => {    TextPickerDialog.show({      range: this.availableThings,      onAccept: (value: TextPickerResult) => {         this.toDoData.push(new ToDo(this.availableThings[value.index])); // 新增列表项数据toDoData      },    })  })      删除列表项 如下图所示，当用户长按列表项进入删除模式时，提供用户删除列表项选择的交互界面，用户勾选完成后点击删除按钮，列表中删除对应的项目。  图18 长按删除待办事项  删除列表项功能实现主要流程如下：  列表的删除功能一般进入编辑模式后才可使用，所以需要提供编辑模式的入口。         以待办列表为例，通过监听列表项的长按事件，当用户长按列表项时，进入编辑模式。        已复制// ToDoListItem.ets
Flex({ justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {  ...}.gesture(GestureGroup(GestureMode.Exclusive,  LongPressGesture()    .onAction(() => {      if (!this.isEditMode) {        this.isEditMode = true; //进入编辑模式        this.selectedItems.push(this.toDoItem); // 记录长按时选中的列表项      }    })  ))   需要响应用户的选择交互，记录要删除的列表项数据。         在待办列表中，通过勾选框的勾选或取消勾选，响应用户勾选列表项变化，记录所有选择的列表项。        已复制// ToDoListItem.ets
if (this.isEditMode) {  Checkbox()    .onChange((isSelected) => {      if (isSelected) {        this.selectedItems.push(this.toDoItem) // 勾选时，记录选中的列表项      } else {        let index = this.selectedItems.indexOf(this.toDoItem)        if (index !== -1) {          this.selectedItems.splice(index, 1) // 取消勾选时，则将此项从selectedItems中删除        }      }    })    ...}   需要响应用户点击删除按钮事件，删除列表中对应的选项。已复制// ToDoList.ets
Button('删除')  .onClick(() => {    // 删除选中的列表项对应的toDoData数据    let leftData = this.toDoData.filter((item) => {      return this.selectedItems.find((selectedItem) => selectedItem !== item);    })
    this.toDoData = leftData;    this.isEditMode = false;  })  ...     长列表的处理 循环渲染适用于短列表，当构建具有大量列表项的长列表时，如果直接采用循环渲染方式，会一次性加载所有的列表元素，会导致页面启动时间过长，影响用户体验。因此，推荐使用数据懒加载（LazyForEach）方式实现按需迭代加载数据，从而提升列表性能。 关于长列表按需加载优化的具体实现可参考数据懒加载章节中的示例。 当使用懒加载方式渲染列表时，为了更好的列表滚动体验，减少列表滑动时出现白块，List组件提供了cachedCount参数用于设置列表项缓存数，只在懒加载LazyForEach中生效。 已复制List() {  LazyForEach(this.dataSource, item => {    ListItem() {      ...    }  })}.cachedCount(3) 以垂直列表为例：  若懒加载是用于ListItem，当列表为单列模式时，会在List显示的ListItem前后各缓存cachedCount个ListItem；若是多列模式下，会在List显示的ListItem前后各缓存cachedCount*列数个ListItem。 若懒加载是用于ListItemGroup，无论单列模式还是多列模式，都是在List显示的ListItem前后各缓存cachedCount个ListItemGroup。  
说明
  cachedCount的增加会增大UI的CPU、内存开销。使用时需要根据实际情况，综合性能和用户体验进行调整。 列表使用数据懒加载时，除了显示区域的列表项和前后缓存的列表项，其他列表项会被销毁。  
   相关实例 如需详细了解ArkUI中列表的创建与使用，请参考以下示例：  新闻数据加载    上一篇 媒体查询（mediaquery） 下一篇 创建网格（Grid/GridItem） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。布局与约束循环播放自动轮播导航点样式页面切换方式轮播方向每页显示多个子页面创建轮播（Swiper） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Swiper组件提供滑动轮播显示的能力。Swiper本身是一个容器组件，当设置了多个子组件后，可以对这些子组件进行轮播显示。通常，在一些应用首页显示推荐的内容时，需要用到轮播显示的能力。  布局与约束 Swiper作为一个容器组件，在自身尺寸属性未被设置时，会自动根据子组件的大小设置自身的尺寸。如果开发者对Swiper组件设置了固定的尺寸，则在轮播显示过程中均以该尺寸生效；否则，在轮播过程中，会根据子组件的大小自动调整自身的尺寸。   循环播放 通过loop属性控制是否循环播放，该属性默认值为true。 当loop为true时，在显示第一页或最后一页时，可以继续往前切换到前一页或者往后切换到后一页。如果loop为false，则在第一页或最后一页时，无法继续向前或者向后切换页面。       loop为true：      已复制...private swiperController: SwiperController = new SwiperController()...Swiper(this.swiperController) {  Text("0")    .width('90%')    .height('100%')    .backgroundColor(Color.Gray)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("1")    .width('90%')    .height('100%')    .backgroundColor(Color.Green)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("2")    .width('90%')    .height('100%')    .backgroundColor(Color.Blue)    .textAlign(TextAlign.Center)    .fontSize(30)}.loop(true)         loop为false：      已复制Swiper(this.swiperController) {  Text("0")    .width('90%')    .height('100%')    .backgroundColor(Color.Gray)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("1")    .width('90%')    .height('100%')    .backgroundColor(Color.Green)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("2")    .width('90%')    .height('100%')    .backgroundColor(Color.Blue)    .textAlign(TextAlign.Center)    .fontSize(30)}.loop(false)     自动轮播 Swiper通过设置autoPlay属性，控制是否自动轮播子组件。该属性默认值为false。 autoPlay为true时，会自动切换播放子组件，子组件与子组件之间的播放间隔通过interval属性设置。interval属性默认值为3000，单位毫秒。       autoPlay为true：      已复制Swiper(this.swiperController) {  Text("0")    .width('90%')    .height('100%')    .backgroundColor(Color.Gray)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("1")    .width('90%')    .height('100%')    .backgroundColor(Color.Green)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("2")    .width('90%')    .height('100%')    .backgroundColor(Color.Pink)    .textAlign(TextAlign.Center)    .fontSize(30)}.loop(true).autoPlay(true).interval(1000)     导航点样式 Swiper提供了默认的导航点样式，导航点默认显示在Swiper下方居中位置，开发者也可以通过indicatorStyle属性自定义导航点的位置和样式。 通过indicatorStyle属性，开发者可以设置导航点相对于Swiper组件上下左右四个方位的位置，同时也可以设置每个导航点的尺寸、颜色、蒙层和被选中导航点的颜色。       导航点使用默认样式：      已复制Swiper(this.swiperController) {  Text("0")    .width('90%')    .height('100%')    .backgroundColor(Color.Gray)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("1")    .width('90%')    .height('100%')    .backgroundColor(Color.Green)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("2")    .width('90%')    .height('100%')    .backgroundColor(Color.Pink)    .textAlign(TextAlign.Center)    .fontSize(30)}         自定义导航点样式（示例：导航点直径设为30VP，左边距为0，导航点颜色设为红色）：      已复制Swiper(this.swiperController) {  Text("0")    .width('90%')    .height('100%')    .backgroundColor(Color.Gray)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("1")    .width('90%')    .height('100%')    .backgroundColor(Color.Green)    .textAlign(TextAlign.Center)    .fontSize(30)
  Text("2")    .width('90%')    .height('100%')    .backgroundColor(Color.Pink)    .textAlign(TextAlign.Center)    .fontSize(30)}.indicatorStyle({  size: 30,  left: 0,  color: Color.Red})     页面切换方式 Swiper支持三种页面切换方式：手指滑动、点击导航点和通过控制器。       通过控制器切换页面：      已复制@Entry@Componentstruct SwiperDemo {  private swiperController: SwiperController = new SwiperController();
  build() {    Column({ space: 5 }) {      Swiper(this.swiperController) {        Text("0")          .width(250)          .height(250)          .backgroundColor(Color.Gray)          .textAlign(TextAlign.Center)          .fontSize(30)        Text("1")          .width(250)          .height(250)          .backgroundColor(Color.Green)          .textAlign(TextAlign.Center)          .fontSize(30)        Text("2")          .width(250)          .height(250)          .backgroundColor(Color.Pink)          .textAlign(TextAlign.Center)          .fontSize(30)      }      .indicator(true)
      Row({ space: 12 }) {        Button('showNext')          .onClick(() => {            this.swiperController.showNext(); // 通过controller切换到后一页          })        Button('showPrevious')          .onClick(() => {            this.swiperController.showPrevious(); // 通过controller切换到前一页          })      }.margin(5)    }.width('100%')    .margin({ top: 5 })  }}     轮播方向 Swiper支持水平和垂直方向上进行轮播，主要通过vertical属性控制。 当vertical为true时，表示在垂直方向上进行轮播；为false时，表示在水平方向上进行轮播。vertical默认值为false。       设置水平方向上轮播：     已复制Swiper(this.swiperController) {  ...}.indicator(true).vertical(false)        设置垂直方向轮播：     已复制Swiper(this.swiperController) {  ...}.indicator(true).vertical(true)    每页显示多个子页面 Swiper支持在一个页面内同时显示多个子组件，通过displayCount属性设置。       设置一个页面内显示两个子组件：      已复制Swiper(this.swiperController) {  Text("0")    .width(250)    .height(250)    .backgroundColor(Color.Gray)    .textAlign(TextAlign.Center)    .fontSize(30)  Text("1")    .width(250)    .height(250)    .backgroundColor(Color.Green)    .textAlign(TextAlign.Center)    .fontSize(30)  Text("2")    .width(250)    .height(250)    .backgroundColor(Color.Pink)    .textAlign(TextAlign.Center)    .fontSize(30)  Text("3")    .width(250)    .height(250)    .backgroundColor(Color.Blue)    .textAlign(TextAlign.Center)    .fontSize(30)}.indicator(true).displayCount(2)     上一篇 创建网格（Grid/GridItem） 下一篇 改善布局性能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。构建布局 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    线性布局（Row/Column）  层叠布局（Stack）  弹性布局（Flex）  相对布局（RelativeContainer）  栅格布局（GridRow/GridCol）  媒体查询（mediaquery）  创建列表（List）  创建网格（Grid/GridItem）  创建轮播（Swiper）   上一篇 布局概述 下一篇 线性布局（Row/Column） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述基本概念布局方向布局换行主轴对齐方式交叉轴对齐方式容器组件设置交叉轴对齐子组件设置交叉轴对齐内容对齐自适应拉伸相关实例弹性布局（Flex） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 弹性布局（Flex）提供更加有效的方式对容器中的子元素进行排列、对齐和分配剩余空间。容器默认存在主轴与交叉轴，子元素默认沿主轴排列，子元素在主轴方向的尺寸称为主轴尺寸，在交叉轴方向的尺寸称为交叉轴尺寸。弹性布局在开发场景中用例特别多，比如页面头部导航栏的均匀分布、页面框架的搭建、多行数据的排列等等。   图1 主轴为水平方向的Flex容器示意图   基本概念  主轴：Flex组件布局方向的轴线，子元素默认沿着主轴排列。主轴开始的位置称为主轴起始点，结束位置称为主轴结束点。 交叉轴：垂直于主轴方向的轴线。交叉轴开始的位置称为交叉轴起始点，结束位置称为交叉轴结束点。    布局方向 在弹性布局中，容器的子元素可以按照任意方向排列。通过设置参数direction，可以决定主轴的方向，从而控制子组件的排列方向。  图2 弹性布局方向图   FlexDirection.Row（默认值）：主轴为水平方向，子组件从起始端沿着水平方向开始排布。 已复制Flex({ direction: FlexDirection.Row }) {  Text('1').width('33%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('33%').height(50).backgroundColor(0xD2B48C)  Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.height(70).width('90%').padding(10).backgroundColor(0xAFEEEE)  FlexDirection.RowReverse：主轴为水平方向，子组件从终点端沿着FlexDirection. Row相反的方向开始排布。 已复制Flex({ direction: FlexDirection.RowReverse }) {  Text('1').width('33%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('33%').height(50).backgroundColor(0xD2B48C)  Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.height(70).width('90%').padding(10).backgroundColor(0xAFEEEE)  FlexDirection.Column：主轴为垂直方向，子组件从起始端沿着垂直方向开始排布。 已复制Flex({ direction: FlexDirection.Column }) {  Text('1').width('100%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('100%').height(50).backgroundColor(0xD2B48C)  Text('3').width('100%').height(50).backgroundColor(0xF5DEB3)}.height(70).width('90%').padding(10).backgroundColor(0xAFEEEE)  FlexDirection.ColumnReverse：主轴为垂直方向，子组件从终点端沿着FlexDirection. Column相反的方向开始排布。 已复制Flex({ direction: FlexDirection.ColumnReverse }) {  Text('1').width('100%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('100%').height(50).backgroundColor(0xD2B48C)  Text('3').width('100%').height(50).backgroundColor(0xF5DEB3)}.height(70).width('90%').padding(10).backgroundColor(0xAFEEEE)     布局换行 弹性布局分为单行布局和多行布局。默认情况下，Flex容器中的子元素都排在一条线（又称“轴线”）上。wrap属性控制当子元素主轴尺寸之和大于容器主轴尺寸时，Flex是单行布局还是多行布局。在多行布局时，通过交叉轴方向，确认新行堆叠方向。  FlexWrap. NoWrap（默认值）：不换行。如果子组件的宽度总和大于父元素的宽度，则子组件会被压缩宽度。 已复制Flex({ wrap: FlexWrap.NoWrap }) {  Text('1').width('50%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('50%').height(50).backgroundColor(0xD2B48C)  Text('3').width('50%').height(50).backgroundColor(0xF5DEB3)} .width('90%').padding(10).backgroundColor(0xAFEEEE)  FlexWrap. Wrap：换行，每一行子组件按照主轴方向排列。 已复制Flex({ wrap: FlexWrap.Wrap }) {  Text('1').width('50%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('50%').height(50).backgroundColor(0xD2B48C)  Text('3').width('50%').height(50).backgroundColor(0xD2B48C)} .width('90%').padding(10).backgroundColor(0xAFEEEE)  FlexWrap. WrapReverse：换行，每一行子组件按照主轴反方向排列。 已复制Flex({ wrap: FlexWrap.WrapReverse}) {  Text('1').width('50%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('50%').height(50).backgroundColor(0xD2B48C)  Text('3').width('50%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding(10).backgroundColor(0xAFEEEE)     主轴对齐方式 通过justifyContent参数设置在主轴方向的对齐方式。    FlexAlign.Start（默认值）：子组件在主轴方向起始端对齐， 第一个子组件与父元素边沿对齐，其他元素与前一个元素对齐。 已复制Flex({ justifyContent: FlexAlign.Start }) {    Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)  Text('2').width('20%').height(50).backgroundColor(0xD2B48C)      Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding({ top: 10, bottom: 10 }).backgroundColor(0xAFEEEE)  FlexAlign.Center：子组件在主轴方向居中对齐。 已复制Flex({ justifyContent: FlexAlign.Center }) {    Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)    Text('2').width('20%').height(50).backgroundColor(0xD2B48C)     Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding({ top: 10, bottom: 10 }).backgroundColor(0xAFEEEE)  FlexAlign.End：子组件在主轴方向终点端对齐, 最后一个子组件与父元素边沿对齐，其他元素与后一个元素对齐。 已复制Flex({ justifyContent: FlexAlign.End }) {    Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)    Text('2').width('20%').height(50).backgroundColor(0xD2B48C)     Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding({ top: 10, bottom: 10 }).backgroundColor(0xAFEEEE)  FlexAlign.SpaceBetween：Flex主轴方向均匀分配弹性元素，相邻子组件之间距离相同。第一个子组件和最后一个子组件与父元素边沿对齐。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween }) {    Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)    Text('2').width('20%').height(50).backgroundColor(0xD2B48C)     Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding({ top: 10, bottom: 10 }).backgroundColor(0xAFEEEE)  FlexAlign.SpaceAround：Flex主轴方向均匀分配弹性元素，相邻子组件之间距离相同。第一个子组件到主轴起始端的距离和最后一个子组件到主轴终点端的距离是相邻元素之间距离的一半。 已复制Flex({ justifyContent: FlexAlign.SpaceAround }) {    Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)    Text('2').width('20%').height(50).backgroundColor(0xD2B48C)     Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding({ top: 10, bottom: 10 }).backgroundColor(0xAFEEEE)  FlexAlign.SpaceEvenly：Flex主轴方向元素等间距布局，相邻子组件之间的间距、第一个子组件与主轴起始端的间距、最后一个子组件到主轴终点端的间距均相等。 已复制Flex({ justifyContent: FlexAlign.SpaceEvenly }) {    Text('1').width('20%').height(50).backgroundColor(0xF5DEB3)    Text('2').width('20%').height(50).backgroundColor(0xD2B48C)     Text('3').width('20%').height(50).backgroundColor(0xF5DEB3)}.width('90%').padding({ top: 10, bottom: 10 }).backgroundColor(0xAFEEEE)    交叉轴对齐方式 容器和子元素都可以设置交叉轴对齐方式，且子元素设置的对齐方式优先级较高。   容器组件设置交叉轴对齐 可以通过Flex组件的alignItems参数设置子组件在交叉轴的对齐方式。   ItemAlign.Auto：使用Flex容器中默认配置。 已复制Flex({ alignItems: ItemAlign.Auto }) {    Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)    Text('2').width('33%').height(40).backgroundColor(0xD2B48C)    Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.size({ width: '90%', height: 80 }).padding(10).backgroundColor(0xAFEEEE)  ItemAlign.Start：交叉轴方向首部对齐。 已复制Flex({ alignItems: ItemAlign.Start }) {    Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)    Text('2').width('33%').height(40).backgroundColor(0xD2B48C)    Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.size({ width: '90%', height: 80 }).padding(10).backgroundColor(0xAFEEEE)  ItemAlign.Center：交叉轴方向居中对齐。 已复制Flex({ alignItems: ItemAlign.Center }) {    Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)    Text('2').width('33%').height(40).backgroundColor(0xD2B48C)    Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.size({ width: '90%', height: 80 }).padding(10).backgroundColor(0xAFEEEE)  ItemAlign.End：交叉轴方向底部对齐。 已复制Flex({ alignItems: ItemAlign.End }) {    Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)    Text('2').width('33%').height(40).backgroundColor(0xD2B48C)    Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.size({ width: '90%', height: 80 }).padding(10).backgroundColor(0xAFEEEE)  ItemAlign.Stretch：交叉轴方向拉伸填充，在未设置尺寸时，拉伸到容器尺寸。 已复制Flex({ alignItems: ItemAlign.Stretch }) {    Text('1').width('33%').backgroundColor(0xF5DEB3)    Text('2').width('33%').backgroundColor(0xD2B48C)    Text('3').width('33%').backgroundColor(0xF5DEB3)}.size({ width: '90%', height: 80 }).padding(10).backgroundColor(0xAFEEEE)  ItemAlign. Baseline：交叉轴方向文本基线对齐。 已复制Flex({ alignItems: ItemAlign.Baseline }) {    Text('1').width('33%').height(30).backgroundColor(0xF5DEB3)    Text('2').width('33%').height(40).backgroundColor(0xD2B48C)    Text('3').width('33%').height(50).backgroundColor(0xF5DEB3)}.size({ width: '90%', height: 80 }).padding(10).backgroundColor(0xAFEEEE)    子组件设置交叉轴对齐 子组件的alignSelf属性也可以设置子组件在父容器交叉轴的对齐格式，且会覆盖Flex布局容器中alignItems配置。如下例所示：  已复制Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Center }) { // 容器组件设置子组件居中  Text('alignSelf Start').width('25%').height(80)    .alignSelf(ItemAlign.Start)    .backgroundColor(0xF5DEB3)  Text('alignSelf Baseline')    .alignSelf(ItemAlign.Baseline)    .width('25%')    .height(80)    .backgroundColor(0xD2B48C)  Text('alignSelf Baseline').width('25%').height(100)    .backgroundColor(0xF5DEB3)    .alignSelf(ItemAlign.Baseline)  Text('no alignSelf').width('25%').height(100)    .backgroundColor(0xD2B48C)  Text('no alignSelf').width('25%').height(100)    .backgroundColor(0xF5DEB3)
}.width('90%').height(220).backgroundColor(0xAFEEEE)  上例中，Flex容器中alignItems设置交叉轴子组件的对齐方式为居中，子组件自身设置了alignSelf属性的情况，覆盖父组件的alignItems值，表现为alignSelf的定义。  内容对齐 可以通过alignContent参数设置子组件各行在交叉轴剩余空间内的对齐方式，只在多行的flex布局中生效，可选值有：  FlexAlign.Start：子组件各行与交叉轴起点对齐。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.Start }) {  Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('2').width('60%').height(20).backgroundColor(0xD2B48C)  Text('3').width('40%').height(20).backgroundColor(0xD2B48C)  Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('5').width('20%').height(20).backgroundColor(0xD2B48C)}.width('90%').height(100).backgroundColor(0xAFEEEE)            FlexAlign.Center：子组件各行在交叉轴方向居中对齐。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.Center }) {  Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('2').width('60%').height(20).backgroundColor(0xD2B48C)  Text('3').width('40%').height(20).backgroundColor(0xD2B48C)  Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('5').width('20%').height(20).backgroundColor(0xD2B48C)}.width('90%').height(100).backgroundColor(0xAFEEEE)            FlexAlign.End：子组件各行与交叉轴终点对齐。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.End }) {  Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('2').width('60%').height(20).backgroundColor(0xD2B48C)  Text('3').width('40%').height(20).backgroundColor(0xD2B48C)  Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('5').width('20%').height(20).backgroundColor(0xD2B48C)}.width('90%').height(100).backgroundColor(0xAFEEEE)            FlexAlign.SpaceBetween：子组件各行与交叉轴两端对齐，各行间垂直间距平均分布。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.SpaceBetween }) {  Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('2').width('60%').height(20).backgroundColor(0xD2B48C)  Text('3').width('40%').height(20).backgroundColor(0xD2B48C)  Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('5').width('20%').height(20).backgroundColor(0xD2B48C)}.width('90%').height(100).backgroundColor(0xAFEEEE)            FlexAlign.SpaceAround：子组件各行间距相等，是元素首尾行与交叉轴两端距离的两倍。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.SpaceAround }) {  Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('2').width('60%').height(20).backgroundColor(0xD2B48C)  Text('3').width('40%').height(20).backgroundColor(0xD2B48C)  Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('5').width('20%').height(20).backgroundColor(0xD2B48C)}.width('90%').height(100).backgroundColor(0xAFEEEE)            FlexAlign.SpaceEvenly: 子组件各行间距，子组件首尾行与交叉轴两端距离都相等。 已复制Flex({ justifyContent: FlexAlign.SpaceBetween, wrap: FlexWrap.Wrap, alignContent: FlexAlign.SpaceEvenly }) {  Text('1').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('2').width('60%').height(20).backgroundColor(0xD2B48C)  Text('3').width('40%').height(20).backgroundColor(0xD2B48C)  Text('4').width('30%').height(20).backgroundColor(0xF5DEB3)  Text('5').width('20%').height(20).backgroundColor(0xD2B48C)}.width('90%').height(100).backgroundColor(0xAFEEEE)               自适应拉伸 在弹性布局父组件尺寸不够大的时候，通过子组件的下面几个属性设置其在父容器的占比，达到自适应布局能力。  flexBasis：设置子组件在父容器主轴方向上的基准尺寸。如果设置了该值，则子项占用的空间为设置的值；如果没设置该属性，那子项的空间为width/height的值。 已复制Flex() {  Text('flexBasis("auto")')    .flexBasis('auto') // 未设置width以及flexBasis值为auto，内容自身宽度    .height(100)    .backgroundColor(0xF5DEB3)  Text('flexBasis("auto")' + ' width("40%")')    .width('40%')    .flexBasis('auto') //设置width以及flexBasis值auto，使用width的值    .height(100)    .backgroundColor(0xD2B48C)
  Text('flexBasis(100)') // 未设置width以及flexBasis值为100，宽度为100vp    .fontSize(15)    .flexBasis(100)    .height(100)    .backgroundColor(0xF5DEB3)
  Text('flexBasis(100)')    .fontSize(15)    .flexBasis(100)    .width(200) // flexBasis值为100，覆盖width的设置值，宽度为100vp    .height(100)    .backgroundColor(0xD2B48C)}.width('90%').height(120).padding(10).backgroundColor(0xAFEEEE)            flexGrow：设置父容器的剩余空间分配给此属性所在组件的比例。用于“瓜分”父组件的剩余空间。        已复制Flex() {Text('flexGrow(2)')  .flexGrow(2)   .width(100)  .height(100)  .backgroundColor(0xF5DEB3)
Text('flexGrow(3)')  .flexGrow(3)  .width(100)  .height(100)  .backgroundColor(0xD2B48C)
Text('no flexGrow')  .width(100)   .height(100)  .backgroundColor(0xF5DEB3)}.width(420).height(120).padding(10).backgroundColor(0xAFEEEE)   父容器宽度420vp，三个子元素原始宽度为100vp，左右padding为20vp，总和320vp，剩余空间100vp根据flexGrow值的占比分配给子元素，未设置flexGrow的子元素不参与“瓜分”。 第一个元素以及第二个元素以2:3分配剩下的100vp。第一个元素为100vp+100vp*2/5=140vp，第二个元素为100vp+100vp*3/5=160vp。   flexShrink: 当父容器空间不足时，子组件的压缩比例。 已复制Flex({ direction: FlexDirection.Row }) {  Text('flexShrink(3)')    .fontSize(15)    .flexShrink(3)    .width(200)    .height(100)    .backgroundColor(0xF5DEB3)
  Text('no flexShrink')    .width(200)    .height(100)    .backgroundColor(0xD2B48C)
  Text('flexShrink(2)')    .flexShrink(2)    .width(200)    .height(100)    .backgroundColor(0xF5DEB3)}.width(400).height(120).padding(10).backgroundColor(0xAFEEEE)      相关实例 使用弹性布局，可以实现子组件沿水平方向排列，两端对齐，子组件间距平分，竖直方向上子组件居中的效果。 已复制@Entry  @Componentstruct FlexExample {  build() {    Column() {      Column({ space: 5 }) {        Flex({ direction: FlexDirection.Row, wrap: FlexWrap.NoWrap, justifyContent: FlexAlign.SpaceBetween, alignItems: ItemAlign.Center }) {          Text('1').width('30%').height(50).backgroundColor(0xF5DEB3)          Text('2').width('30%').height(50).backgroundColor(0xD2B48C)          Text('3').width('30%').height(50).backgroundColor(0xF5DEB3)        }        .height(70)        .width('90%')        .backgroundColor(0xAFEEEE)      }.width('100%').margin({ top: 5 })    }.width('100%')  }}    上一篇 层叠布局（Stack） 下一篇 相对布局（RelativeContainer） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述栅格容器GridRow栅格系统断点布局的总列数排列方向子组件间距子组件GridColspanoffsetorder栅格组件的嵌套使用栅格布局（GridRow/GridCol） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 栅格布局是一种通用的辅助定位工具，对移动设备的界面设计有较好的借鉴作用。主要优势包括：  提供可循的规律：栅格布局可以为布局提供规律性的结构，解决多尺寸多设备的动态布局问题。通过将页面划分为等宽的列数和行数，可以方便地对页面元素进行定位和排版。 统一的定位标注：栅格布局可以为系统提供一种统一的定位标注，保证不同设备上各个模块的布局一致性。这可以减少设计和开发的复杂度，提高工作效率。 灵活的间距调整方法：栅格布局可以提供一种灵活的间距调整方法，满足特殊场景布局调整的需求。通过调整列与列之间和行与行之间的间距，可以控制整个页面的排版效果。 自动换行和自适应：栅格布局可以完成一对多布局的自动换行和自适应。当页面元素的数量超出了一行或一列的容量时，他们会自动换到下一行或下一列，并且在不同的设备上自适应排版，使得页面布局更加灵活和适应性强。  GridRow为栅格容器组件，需与栅格子组件GridCol在栅格布局场景中联合使用。   栅格容器GridRow   栅格系统断点 栅格系统以设备的水平宽度（屏幕密度像素值，单位vp）作为断点依据，定义设备的宽度类型，形成了一套断点规则。开发者可根据需求在不同的断点区间实现不同的页面布局效果。 栅格系统默认断点将设备宽度分为xs、sm、md、lg四类，尺寸范围如下：     断点名称 取值范围（vp） 设备描述    xs [0, 320） 最小宽度类型设备。   sm [320, 520) 小宽度类型设备。   md [520, 840) 中等宽度类型设备。   lg [840, +∞) 大宽度类型设备。    在GridRow栅格组件中，允许开发者使用breakpoints自定义修改断点的取值范围，最多支持6个断点，除了默认的四个断点外，还可以启用xl，xxl两个断点，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备的布局设置。     断点名称 设备描述    xs 最小宽度类型设备。   sm 小宽度类型设备。   md 中等宽度类型设备。   lg 大宽度类型设备。   xl 特大宽度类型设备。   xxl 超大宽度类型设备。     针对断点位置，开发者根据实际使用场景，通过一个单调递增数组设置。由于breakpoints最多支持六个断点，单调递增数组长度最大为5。 已复制breakpoints: {value: ['100vp', '200vp']} 表示启用xs、sm、md共3个断点，小于100vp为xs，100vp-200vp为sm，大于200vp为md。 已复制breakpoints: {value: ['320vp', '520vp', '840vp', '1080vp']} 表示启用xs、sm、md、lg、xl共5个断点，小于320vp为xs，320vp-520vp为sm，520vp-840vp为md，840vp-1080vp为lg，大于1080vp为xl。 栅格系统通过监听窗口或容器的尺寸变化进行断点，通过reference设置断点切换参考物。 考虑到应用可能以非全屏窗口的形式显示，以应用窗口宽度为参照物更为通用。  例如，使用栅格的默认列数12列，通过断点设置将应用宽度分成六个区间，在各区间中，每个栅格子元素占用的列数均不同。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown];...GridRow({  breakpoints: {    value: ['200vp', '300vp', '400vp', '500vp', '600vp'],    reference: BreakpointsReference.WindowSize  }}) {   ForEach(this.bgColors, (color, index) => {     GridCol({       span: {         xs: 2, // 在最小宽度类型设备上，栅格子组件占据的栅格容器2列。         sm: 3, // 在小宽度类型设备上，栅格子组件占据的栅格容器3列。         md: 4, // 在中等宽度类型设备上，栅格子组件占据的栅格容器4列。         lg: 6, // 在大宽度类型设备上，栅格子组件占据的栅格容器6列。         xl: 8, // 在特大宽度类型设备上，栅格子组件占据的栅格容器8列。         xxl: 12 // 在超大宽度类型设备上，栅格子组件占据的栅格容器12列。       }     }) {       Row() {         Text(`${index}`)       }.width("100%").height('50vp')     }.backgroundColor(color)   })}                                                                         布局的总列数 GridRow中通过columns设置栅格布局的总列数。  columns默认值为12，即在未设置columns时，任何断点下，栅格布局被分成12列。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown,Color.Red, Color.Orange, Color.Yellow, Color.Green];...GridRow() {  ForEach(this.bgColors, (item, index) => {    GridCol() {      Row() {        Text(`${index + 1}`)      }.width('100%').height('50')    }.backgroundColor(item)  })}             当columns为自定义值，栅格布局在任何尺寸设备下都被分为columns列。下面分别设置栅格布局列数为4和8，子元素默认占一列，效果如下： 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown];@State currentBp: string = 'unknown';...Row() {  GridRow({ columns: 4 }) {    ForEach(this.bgColors, (item, index) => {      GridCol() {        Row() {          Text(`${index + 1}`)        }.width('100%').height('50')      }.backgroundColor(item)    })  }  .width('100%').height('100%')  .onBreakpointChange((breakpoint) => {    this.currentBp = breakpoint  })}.height(160).border({ color: Color.Blue, width: 2 }).width('90%')
Row() {  GridRow({ columns: 8 }) {    ForEach(this.bgColors, (item, index) => {      GridCol() {        Row() {          Text(`${index + 1}`)        }.width('100%').height('50')      }.backgroundColor(item)    })  }  .width('100%').height('100%')  .onBreakpointChange((breakpoint) => {    this.currentBp = breakpoint  })}.height(160).border({ color: Color.Blue, width: 2 }).width('90%')  当columns类型为GridRowColumnOption时，支持下面六种不同尺寸（xs, sm, md, lg, xl, xxl）设备的总列数设置，各个尺寸下数值可不同。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown]GridRow({ columns: { sm: 4, md: 8 }, breakpoints: { value: ['200vp', '300vp', '400vp', '500vp', '600vp'] } }) {  ForEach(this.bgColors, (item, index) => {    GridCol() {      Row() {        Text(`${index + 1}`)      }.width('100%').height('50')    }.backgroundColor(item)  })}  若只设置sm, md的栅格总列数，则较小的尺寸使用默认columns值12，较大的尺寸使用前一个尺寸的columns。这里只设置sm:4, md:8，则较小尺寸的xs:12，较大尺寸的参照md的设置，lg:8, xl:8, xxl:8。    排列方向 栅格布局中，可以通过设置GridRow的direction属性来指定栅格子组件在栅格容器中的排列方向。该属性可以设置为GridRowDirection.Row（从左往右排列）或GridRowDirection.RowReverse（从右往左排列），以满足不同的布局需求。通过合理的direction属性设置，可以使得页面布局更加灵活和符合设计要求。  子组件默认从左往右排列。 已复制GridRow({ direction: GridRowDirection.Row }){}  子组件从右往左排列。 已复制GridRow({ direction: GridRowDirection.RowReverse }){}     子组件间距 GridRow中通过gutter属性设置子元素在水平和垂直方向的间距。  当gutter类型为number时，同时设置栅格子组件间水平和垂直方向边距且相等。下例中，设置子组件水平与垂直方向距离相邻元素的间距为10。 已复制 GridRow({ gutter: 10 }){}  当gutter类型为GutterOption时，单独设置栅格子组件水平垂直边距，x属性为水平方向间距，y为垂直方向间距。 已复制GridRow({ gutter: { x: 20, y: 50 } }){}     子组件GridCol GridCol组件作为GridRow组件的子组件，通过给GridCol传参或者设置属性两种方式，设置span（占用列数），offset（偏移列数），order（元素序号）的值。  设置span。 已复制GridCol({ span: 2 }){}GridCol({ span: { xs: 1, sm: 2, md: 3, lg: 4 } }){}GridCol(){}.span(2)GridCol(){}.span({ xs: 1, sm: 2, md: 3, lg: 4 }) 设置offset。 已复制GridCol({ offset: 2 }){}GridCol({ offset: { xs: 2, sm: 2, md: 2, lg: 2 } }){}GridCol(){}.offset(2)GridCol(){}.offset({ xs: 1, sm: 2, md: 3, lg: 4 })  设置order。 已复制GridCol({ order: 2 }){}GridCol({ order: { xs: 1, sm: 2, md: 3, lg: 4 } }){}GridCol(){}.order(2)GridCol(){}.order({ xs: 1, sm: 2, md: 3, lg: 4 })    span 子组件占栅格布局的列数，决定了子组件的宽度，默认为1。  当类型为number时，子组件在所有尺寸设备下占用的列数相同。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown];...GridRow({ columns: 8 }) {  ForEach(this.bgColors, (color, index) => {    GridCol({ span: 2 }) {            Row() {        Text(`${index}`)      }.width('100%').height('50vp')              }    .backgroundColor(color)  })}                  当类型为GridColColumnOption时，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备中子组件所占列数设置,各个尺寸下数值可不同。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown];...GridRow({ columns: 8 }) {  ForEach(this.bgColors, (color, index) => {    GridCol({ span: { xs: 1, sm: 2, md: 3, lg: 4 } }) {            Row() {        Text(`${index}`)      }.width('100%').height('50vp')              }    .backgroundColor(color)  })}                     offset 栅格子组件相对于前一个子组件的偏移列数，默认为0。  当类型为number时，子组件偏移相同列数。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown];...GridRow() {  ForEach(this.bgColors, (color, index) => {    GridCol({ offset: 2 }) {            Row() {        Text('' + index)      }.width('100%').height('50vp')              }    .backgroundColor(color)  })}                  栅格默认分成12列，每一个子组件默认占1列，偏移2列，每个子组件及间距共占3列，一行放四个子组件。 当类型为GridColColumnOption时，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备中子组件所占列数设置,各个尺寸下数值可不同。 已复制@State bgColors: Color[] = [Color.Red, Color.Orange, Color.Yellow, Color.Green, Color.Pink, Color.Grey, Color.Blue, Color.Brown];...
GridRow() {  ForEach(this.bgColors, (color, index) => {    GridCol({ offset: { xs: 1, sm: 2, md: 3, lg: 4 } }) {            Row() {        Text('' + index)      }.width('100%').height('50vp')              }    .backgroundColor(color)  })}                      order 栅格子组件的序号，决定子组件排列次序。当子组件不设置order或者设置相同的order, 子组件按照代码顺序展示。当子组件设置不同的order时，order较小的组件在前，较大的在后。 当子组件部分设置order，部分不设置order时，未设置order的子组件依次排序靠前，设置了order的子组件按照数值从小到大排列。  当类型为number时，子组件在任何尺寸下排序次序一致。 已复制GridRow() {  GridCol({ order: 4 }) {    Row() {      Text('1')    }.width('100%').height('50vp')  }.backgroundColor(Color.Red)  GridCol({ order: 3 }) {    Row() {      Text('2')    }.width('100%').height('50vp')  }.backgroundColor(Color.Orange)  GridCol({ order: 2 }) {    Row() {      Text('3')    }.width('100%').height('50vp')  }.backgroundColor(Color.Yellow)  GridCol({ order: 1 }) {    Row() {      Text('4')    }.width('100%').height('50vp')  }.backgroundColor(Color.Green)}              当类型为GridColColumnOption时，支持六种不同尺寸（xs, sm, md, lg, xl, xxl）设备中子组件排序次序设置。在xs设备中，子组件排列顺序为1234；sm为2341，md为3412，lg为2431。 已复制GridRow() {  GridCol({ order: { xs:1, sm:5, md:3, lg:7}}) {    Row() {      Text('1')    }.width('100%').height('50vp')  }.backgroundColor(Color.Red)  GridCol({ order: { xs:2, sm:2, md:6, lg:1} }) {    Row() {      Text('2')    }.width('100%').height('50vp')  }.backgroundColor(Color.Orange)  GridCol({ order: { xs:3, sm:3, md:1, lg:6} }) {    Row() {      Text('3')    }.width('100%').height('50vp')  }.backgroundColor(Color.Yellow)  GridCol({ order: { xs:4, sm:4, md:2, lg:5} }) {    Row() {      Text('4')    }.width('100%').height('50vp')  }.backgroundColor(Color.Green)}      栅格组件的嵌套使用 栅格组件也可以嵌套使用，完成一些复杂的布局。 以下示例中，栅格把整个空间分为12份。第一层GridRow嵌套GridCol，分为中间大区域以及“footer”区域。第二层GridRow嵌套GridCol，分为“left”和“right”区域。子组件空间按照上一层父组件的空间划分，粉色的区域是屏幕空间的12列，绿色和蓝色的区域是父组件GridCol的12列，依次进行空间的划分。  已复制@Entry@Componentstruct GridRowExample {  build() {    GridRow() {      GridCol({ span: { sm: 12 } }) {        GridRow() {          GridCol({ span: { sm: 2 } }) {            Row() {              Text('left').fontSize(24)            }            .justifyContent(FlexAlign.Center)            .height('90%')          }.backgroundColor('#ff41dbaa')
          GridCol({ span: { sm: 10 } }) {            Row() {              Text('right').fontSize(24)            }            .justifyContent(FlexAlign.Center)            .height('90%')          }.backgroundColor('#ff4168db')        }        .backgroundColor('#19000000')        .height('100%')      }
      GridCol({ span: { sm: 12 } }) {        Row() {          Text('footer').width('100%').textAlign(TextAlign.Center)        }.width('100%').height('10%').backgroundColor(Color.Pink)      }    }.width('100%').height(300)  }}  综上所述，栅格组件提供了丰富的自定义能力，功能异常灵活和强大。只需要明确栅格在不同断点下的Columns、Margin、Gutter及span等参数，即可确定最终布局，无需关心具体的设备类型及设备状态（如横竖屏）等。  上一篇 相对布局（RelativeContainer） 下一篇 媒体查询（mediaquery） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述基本概念布局子元素在排列方向上的间距Column容器内排列方向上的间距Row容器内排列方向上的间距布局子元素在交叉轴上的对齐方式Column容器内子元素在水平方向上的排列Row容器内子元素在垂直方向上的排列布局子元素在主轴上的排列方式Column容器内子元素在垂直方向上的排列Row容器内子元素在水平方向上的排列自适应拉伸自适应缩放自适应延伸线性布局（Row/Column） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 线性布局（LinearLayout）是开发中最常用的布局，通过线性容器Row和Column构建。线性布局是其他布局的基础，其子元素在线性方向上（水平方向和垂直方向）依次排列。线性布局的排列方向由所选容器组件决定，Column容器内子元素按照垂直方向排列，Row容器内子元素按照水平方向排列。根据不同的排列方向，开发者可选择使用Row或Column容器创建线性布局。   图1 Column容器内子元素排列示意图   图2 Row容器内子元素排列示意图    基本概念  布局容器：具有布局能力的容器组件，可以承载其他元素作为其子元素，布局容器会对其子元素进行尺寸计算和布局排列。 布局子元素：布局容器内部的元素。 主轴：线性布局容器在布局方向上的轴线，子元素默认沿主轴排列。Row容器主轴为水平方向，Column容器主轴为垂直方向。 交叉轴：垂直于主轴方向的轴线。Row容器交叉轴为垂直方向，Column容器交叉轴为水平方向。 间距：布局子元素的间距。    布局子元素在排列方向上的间距 在布局容器内，可以通过space属性设置排列方向上子元素的间距，使各子元素在排列方向上有等间距效果。   Column容器内排列方向上的间距  图3 Column容器内排列方向的间距图   已复制Column({ space: 20 }) {  Text('space: 20').fontSize(15).fontColor(Color.Gray).width('90%')  Row().width('90%').height(50).backgroundColor(0xF5DEB3)  Row().width('90%').height(50).backgroundColor(0xD2B48C)  Row().width('90%').height(50).backgroundColor(0xF5DEB3)}.width('100%')   Row容器内排列方向上的间距  图4 Row容器内排列方向的间距图  已复制Row({ space: 35 }) {  Text('space: 35').fontSize(15).fontColor(Color.Gray)  Row().width('10%').height(150).backgroundColor(0xF5DEB3)  Row().width('10%').height(150).backgroundColor(0xD2B48C)  Row().width('10%').height(150).backgroundColor(0xF5DEB3)}.width('90%')    布局子元素在交叉轴上的对齐方式 在布局容器内，可以通过alignItems属性设置子元素在交叉轴（排列方向的垂直方向）上的对齐方式。且在各类尺寸屏幕中，表现一致。其中，交叉轴为垂直方向时，取值为VerticalAlign类型，水平方向取值为HorizontalAlign。 alignSelf属性用于控制单个子元素在容器交叉轴上的对齐方式，其优先级高于alignItems属性，如果设置了alignSelf属性，则在单个子元素上会覆盖alignItems属性。   Column容器内子元素在水平方向上的排列  图5 Column容器内子元素在水平方向上的排列图   HorizontalAlign.Start：子元素在水平方向左对齐。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').alignItems(HorizontalAlign.Start).backgroundColor('rgb(242,242,242)')  HorizontalAlign.Center：子元素在水平方向居中对齐。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').alignItems(HorizontalAlign.Center).backgroundColor('rgb(242,242,242)')  HorizontalAlign.End：子元素在水平方向右对齐。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').alignItems(HorizontalAlign.End).backgroundColor('rgb(242,242,242)')     Row容器内子元素在垂直方向上的排列  图6 Row容器内子元素在垂直方向上的排列图   VerticalAlign.Top：子元素在垂直方向顶部对齐。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).alignItems(VerticalAlign.Top).backgroundColor('rgb(242,242,242)')  VerticalAlign.Center：子元素在垂直方向居中对齐。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).alignItems(VerticalAlign.Center).backgroundColor('rgb(242,242,242)')  VerticalAlign.Bottom：子元素在垂直方向底部对齐。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).alignItems(VerticalAlign.Bottom).backgroundColor('rgb(242,242,242)')     布局子元素在主轴上的排列方式 在布局容器内，可以通过justifyContent属性设置子元素在容器主轴上的排列方式。可以从主轴起始位置开始排布，也可以从主轴结束位置开始排布，或者均匀分割主轴的空间。   Column容器内子元素在垂直方向上的排列  图7 Column容器内子元素在垂直方向上的排列图   justifyContent(FlexAlign.Start)：元素在垂直方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Start)  justifyContent(FlexAlign.Center)：元素在垂直方向中心对齐，第一个元素与行首的距离与最后一个元素与行尾距离相同。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Center)  justifyContent(FlexAlign.End)：元素在垂直方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.End)  justifyContent(FlexAlign.SpaceBetween)：垂直方向均匀分配元素，相邻元素之间距离相同。第一个元素与行首对齐，最后一个元素与行尾对齐。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceBetween)  justifyContent(FlexAlign.SpaceAround)：垂直方向均匀分配元素，相邻元素之间距离相同。第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceAround)  justifyContent(FlexAlign.SpaceEvenly)：垂直方向均匀分配元素，相邻元素之间的距离、第一个元素与行首的间距、最后一个元素到行尾的间距都完全一样。已复制Column({}) {  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)
  Column() {  }.width('80%').height(50).backgroundColor(0xD2B48C)
  Column() {  }.width('80%').height(50).backgroundColor(0xF5DEB3)}.width('100%').height(300).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceEvenly)     Row容器内子元素在水平方向上的排列  图8 Row容器内子元素在水平方向上的排列图   justifyContent(FlexAlign.Start)：元素在水平方向方向首端对齐，第一个元素与行首对齐，同时后续的元素与前一个对齐。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Start)  justifyContent(FlexAlign.Center)：元素在水平方向方向中心对齐，第一个元素与行首的距离与最后一个元素与行尾距离相同。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.Center)  justifyContent(FlexAlign.End)：元素在水平方向方向尾部对齐，最后一个元素与行尾对齐，其他元素与后一个对齐。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.End)  justifyContent(FlexAlign.SpaceBetween)：水平方向方向均匀分配元素，相邻元素之间距离相同。第一个元素与行首对齐，最后一个元素与行尾对齐。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceBetween)  justifyContent(FlexAlign.SpaceAround)：水平方向方向均匀分配元素，相邻元素之间距离相同。第一个元素到行首的距离和最后一个元素到行尾的距离是相邻元素之间距离的一半。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceAround)  justifyContent(FlexAlign.SpaceEvenly)：水平方向方向均匀分配元素，相邻元素之间的距离、第一个元素与行首的间距、最后一个元素到行尾的间距都完全一样。已复制Row({}) {  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)
  Column() {  }.width('20%').height(30).backgroundColor(0xD2B48C)
  Column() {  }.width('20%').height(30).backgroundColor(0xF5DEB3)}.width('100%').height(200).backgroundColor('rgb(242,242,242)').justifyContent(FlexAlign.SpaceEvenly)     自适应拉伸 在线性布局下，常用空白填充组件Blank，在容器主轴方向自动填充空白空间，达到自适应拉伸效果。Row和Column作为容器，只需要添加宽高为百分比，当屏幕宽高发生变化时，会产生自适应效果。 已复制@Entry@Componentstruct BlankExample {  build() {    Column() {      Row() {        Text('Bluetooth').fontSize(18)        Blank()        Toggle({ type: ToggleType.Switch, isOn: true })      }.backgroundColor(0xFFFFFF).borderRadius(15).padding({ left: 12 }).width('100%')    }.backgroundColor(0xEFEFEF).padding(20).width('100%')  }}  图9 竖屏   图10 横屏    自适应缩放 自适应缩放是指子组件随容器尺寸的变化而按照预设的比例自动调整尺寸，适应各种不同大小的设备。在线性布局中，可以使用以下两种方法实现自适应缩放。   父容器尺寸确定时，使用layoutWeight属性设置子组件和兄弟元素在主轴上的权重，忽略元素本身尺寸设置，使它们在任意尺寸的设备下自适应占满剩余空间。已复制@Entry@Componentstruct layoutWeightExample {  build() {    Column() {      Text('1:2:3').width('100%')      Row() {        Column() {          Text('layoutWeight(1)')            .textAlign(TextAlign.Center)        }.layoutWeight(1).backgroundColor(0xF5DEB3).height('100%')
        Column() {          Text('layoutWeight(2)')            .textAlign(TextAlign.Center)        }.layoutWeight(2).backgroundColor(0xD2B48C).height('100%')
        Column() {          Text('layoutWeight(3)')            .textAlign(TextAlign.Center)        }.layoutWeight(3).backgroundColor(0xF5DEB3).height('100%')
      }.backgroundColor(0xffd306).height('30%')
      Text('2:5:3').width('100%')      Row() {        Column() {          Text('layoutWeight(2)')            .textAlign(TextAlign.Center)        }.layoutWeight(2).backgroundColor(0xF5DEB3).height('100%')
        Column() {          Text('layoutWeight(5)')            .textAlign(TextAlign.Center)        }.layoutWeight(5).backgroundColor(0xD2B48C).height('100%')
        Column() {          Text('layoutWeight(3)')            .textAlign(TextAlign.Center)        }.layoutWeight(3).backgroundColor(0xF5DEB3).height('100%')      }.backgroundColor(0xffd306).height('30%')    }  }}  图11 横屏    图12 竖屏   父容器尺寸确定时，使用百分比设置子组件和兄弟元素的宽度，使他们在任意尺寸的设备下保持固定的自适应占比。已复制@Entry@Componentstruct WidthExample {  build() {    Column() {      Row() {        Column() {          Text('left width 20%')            .textAlign(TextAlign.Center)        }.width('20%').backgroundColor(0xF5DEB3).height('100%')
        Column() {          Text('center width 50%')            .textAlign(TextAlign.Center)        }.width('50%').backgroundColor(0xD2B48C).height('100%')
        Column() {          Text('right width 30%')            .textAlign(TextAlign.Center)        }.width('30%').backgroundColor(0xF5DEB3).height('100%')      }.backgroundColor(0xffd306).height('30%')    }  }}  图13 横屏   图14 竖屏    自适应延伸 自适应延伸是指在不同尺寸设备下，当页面的内容超出屏幕大小而无法完全显示时，可以通过滚动条进行拖动展示。这种方法适用于线性布局中内容无法一屏展示的场景。通常有以下两种实现方式。  在List中添加滚动条：当List子项过多一屏放不下时，可以将每一项子元素放置在不同的组件中，通过滚动条进行拖动展示。可以通过scrollBar属性设置滚动条的常驻状态，edgeEffect属性设置拖动到内容最末端的回弹效果。 使用Scroll组件：在线性布局中，开发者可以进行垂直方向或者水平方向的布局。当一屏无法完全显示时，可以在Column或Row组件的外层包裹一个可滚动的容器组件Scroll来实现可滑动的线性布局。               垂直方向布局中使用Scroll组件：        已复制@Entry@Componentstruct ScrollExample {  scroller: Scroller = new Scroller();  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  build() {    Scroll(this.scroller) {      Column() {        ForEach(this.arr, (item) => {          Text(item.toString())            .width('90%')            .height(150)            .backgroundColor(0xFFFFFF)            .borderRadius(15)            .fontSize(16)            .textAlign(TextAlign.Center)            .margin({ top: 10 })        }, item => item)      }.width('100%')    }    .backgroundColor(0xDCDCDC)    .scrollable(ScrollDirection.Vertical) // 滚动方向为垂直方向    .scrollBar(BarState.On) // 滚动条常驻显示    .scrollBarColor(Color.Gray) // 滚动条颜色    .scrollBarWidth(10) // 滚动条宽度    .edgeEffect(EdgeEffect.Spring) // 滚动到边沿后回弹  }}   水平方向布局中使用Scroll组件： 已复制@Entry@Componentstruct ScrollExample {  scroller: Scroller = new Scroller();  private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  build() {    Scroll(this.scroller) {      Row() {        ForEach(this.arr, (item) => {          Text(item.toString())            .height('90%')            .width(150)            .backgroundColor(0xFFFFFF)            .borderRadius(15)            .fontSize(16)            .textAlign(TextAlign.Center)            .margin({ left: 10 })        })      }.height('100%')    }    .backgroundColor(0xDCDCDC)    .scrollable(ScrollDirection.Horizontal) // 滚动方向为水平方向    .scrollBar(BarState.On) // 滚动条常驻显示    .scrollBarColor(Color.Gray) // 滚动条颜色    .scrollBarWidth(10) // 滚动条宽度    .edgeEffect(EdgeEffect.Spring) // 滚动到边沿后回弹  }}     上一篇 构建布局 下一篇 层叠布局（Stack） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述引入与使用流程媒体查询条件语法规则媒体类型（media-type）媒体逻辑操作（media-logic-operations）媒体特征（media-feature）场景示例媒体查询（mediaquery） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 媒体查询作为响应式设计的核心，在移动设备上应用十分广泛。媒体查询可根据不同设备类型或同设备不同状态修改应用的样式。媒体查询常用于下面两种场景：  针对设备和应用的属性信息（比如显示区域、深浅色、分辨率），设计出相匹配的布局。 当屏幕发生动态改变时（比如分屏、横竖屏切换），同步更新应用的页面布局。    引入与使用流程 媒体查询通过mediaquery模块接口，设置查询条件并绑定回调函数，在对应的条件的回调函数里更改页面布局或者实现业务逻辑，实现页面的响应式设计。具体步骤如下： 首先导入媒体查询模块。 已复制import mediaquery from '@ohos.mediaquery'; 通过matchMediaSync接口设置媒体查询条件，保存返回的条件监听句柄listener。例如监听横屏事件： 已复制let listener = mediaquery.matchMediaSync('(orientation: landscape)'); 给条件监听句柄listener绑定回调函数onPortrait，当listener检测设备状态变化时执行回调函数。在回调函数内，根据不同设备状态更改页面布局或者实现业务逻辑。 已复制onPortrait(mediaQueryResult) {  if (mediaQueryResult.matches) {    // do something here  } else {    // do something here  }}
listener.on('change', onPortrait);   媒体查询条件 媒体查询条件由媒体类型、逻辑操作符、媒体特征组成，其中媒体类型可省略，逻辑操作符用于连接不同媒体类型与媒体特征，其中，媒体特征要使用“()”包裹且可以有多个。具体规则如下：   语法规则 语法规则包括媒体类型（media-type）、媒体逻辑操作（media-logic-operations）和媒体特征（media-feature）。 已复制[media-type] [media-logic-operations] [(media-feature)] 例如：  screen and (round-screen: true) ：表示当设备屏幕是圆形时条件成立。 (max-height: 800) ：表示当高度小于等于800vp时条件成立。 (height <= 800) ：表示当高度小于等于800vp时条件成立。 screen and (device-type: tv) or (resolution < 2) ：表示包含多个媒体特征的多条件复杂语句查询，当设备类型为tv或设备分辨率小于2时条件成立。    媒体类型（media-type）     类型 说明    screen 按屏幕相关参数进行媒体查询。      媒体逻辑操作（media-logic-operations） 媒体逻辑操作符：and、or、not、only用于构成复杂媒体查询，也可以通过comma（, ）将其组合起来，详细解释说明如下表。    表1 媒体逻辑操作符          类型 说明    and 将多个媒体特征（Media Feature）以“与”的方式连接成一个媒体查询，只有当所有媒体特征都为true，查询条件成立。另外，它还可以将媒体类型和媒体功能结合起来。例如：screen and (device-type: wearable) and (max-height: 600) 表示当设备类型是智能穿戴且应用的最大高度小于等于600个像素单位时成立。   or 将多个媒体特征以“或”的方式连接成一个媒体查询，如果存在结果为true的媒体特征，则查询条件成立。例如：screen and (max-height: 1000) or (round-screen: true) 表示当应用高度小于等于1000个像素单位或者设备屏幕是圆形时，条件成立。   not 取反媒体查询结果，媒体查询结果不成立时返回true，否则返回false。例如：not screen and (min-height: 50) and (max-height: 600) 表示当应用高度小于50个像素单位或者大于600个像素单位时成立。 使用not运算符时必须指定媒体类型。   only 当整个表达式都匹配时，才会应用选择的样式，可以应用在防止某些较早的版本的浏览器上产生歧义的场景。一些较早版本的浏览器对于同时包含了媒体类型和媒体特征的语句会产生歧义，比如：screen and (min-height: 50)。老版本浏览器会将这句话理解成screen，从而导致仅仅匹配到媒体类型（screen），就应用了指定样式，使用only可以很好地规避这种情况。 使用only时必须指定媒体类型。   comma（, ） 将多个媒体特征以“或”的方式连接成一个媒体查询，如果存在结果为true的媒体特征，则查询条件成立。其效果等同于or运算符。例如：screen and (min-height: 1000), (round-screen: true) 表示当应用高度大于等于1000个像素单位或者设备屏幕是圆形时，条件成立。    媒体范围操作符包括<=，>=，<，>，详细解释说明如下表。    表2 媒体逻辑范围操作符          类型 说明    <= 小于等于，例如：screen and (height <= 50)。   >= 大于等于，例如：screen and (height >= 600)。   < 小于，例如：screen and (height < 50)。   > 大于，例如：screen and (height > 600)。      媒体特征（media-feature） 媒体特征包括应用显示区域的宽高、设备分辨率以及设备的宽高等属性，详细说明如下表。    表3 媒体特征说明表          类型 说明    height 应用页面可绘制区域的高度。   min-height 应用页面可绘制区域的最小高度。   max-height 应用页面可绘制区域的最大高度。   width 应用页面可绘制区域的宽度。   min-width 应用页面可绘制区域的最小宽度。   max-width 应用页面可绘制区域的最大宽度。   resolution 设备的分辨率，支持dpi，dppx和dpcm单位。其中： - dpi表示每英寸中物理像素个数，1dpi ≈ 0.39dpcm； - dpcm表示每厘米上的物理像素个数，1dpcm ≈ 2.54dpi； - dppx表示每个px中的物理像素数（此单位按96px = 1英寸为基准，与页面中的px单位计算方式不同），1dppx = 96dpi。   min-resolution 设备的最小分辨率。   max-resolution 设备的最大分辨率。   orientation 屏幕的方向。 可选值： - orientation: portrait（设备竖屏）； - orientation: landscape（设备横屏）。   device-height 设备的高度。   min-device-height 设备的最小高度。   max-device-height 设备的最大高度。   device-width 设备的宽度。   device-type 设备的类型。 可选值：default、tablet。   min-device-width 设备的最小宽度。   max-device-width 设备的最大宽度。   round-screen 屏幕类型，圆形屏幕为true，非圆形屏幕为false。   dark-mode 系统为深色模式时为true，否则为false。      场景示例 下例中使用媒体查询，实现屏幕横竖屏切换时，给页面文本应用添加不同的内容和样式。 Stage模型下的示例： 已复制import mediaquery from '@ohos.mediaquery';import window from '@ohos.window';import common from '@ohos.app.ability.common';
let portraitFunc = null;
@Entry@Componentstruct MediaQueryExample {  @State color: string = '#DB7093';  @State text: string = 'Portrait';  // 当设备横屏时条件成立  listener = mediaquery.matchMediaSync('(orientation: landscape)');
  // 当满足媒体查询条件时，触发回调  onPortrait(mediaQueryResult) {    if (mediaQueryResult.matches) { // 若设备为横屏状态，更改相应的页面布局      this.color = '#FFD700';      this.text = 'Landscape';    } else {      this.color = '#DB7093';      this.text = 'Portrait';    }  }
  aboutToAppear() {    // 绑定当前应用实例    portraitFunc = this.onPortrait.bind(this);    // 绑定回调函数    this.listener.on('change', portraitFunc);  }
  // 改变设备横竖屏状态函数  private changeOrientation(isLandscape: boolean) {    // 获取UIAbility实例的上下文信息    let context = getContext(this) as common.UIAbilityContext;    // 调用该接口手动改变设备横竖屏状态    window.getLastWindow(context).then((lastWindow) => {      lastWindow.setPreferredOrientation(isLandscape ? window.Orientation.LANDSCAPE : window.Orientation.PORTRAIT)    });  }
  build() {    Column({ space: 50 }) {      Text(this.text).fontSize(50).fontColor(this.color)      Text('Landscape').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)        .onClick(() => {          this.changeOrientation(true);        })      Text('Portrait').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)        .onClick(() => {          this.changeOrientation(false);        })    }    .width('100%').height('100%')  }} FA模型下的示例： 已复制import mediaquery from '@ohos.mediaquery';import featureAbility from '@ohos.ability.featureAbility';
let portraitFunc = null;
@Entry@Componentstruct MediaQueryExample {  @State color: string = '#DB7093';  @State text: string = 'Portrait';  listener = mediaquery.matchMediaSync('(orientation: landscape)'); // 当设备横屏时条件成立
  onPortrait(mediaQueryResult) { // 当满足媒体查询条件时，触发回调    if (mediaQueryResult.matches) { // 若设备为横屏状态，更改相应的页面布局      this.color = '#FFD700';      this.text = 'Landscape';    } else {      this.color = '#DB7093';      this.text = 'Portrait';    }  }
  aboutToAppear() {    portraitFunc = this.onPortrait.bind(this); // 绑定当前应用实例    this.listener.on('change', portraitFunc); //绑定回调函数  }
  build() {    Column({ space: 50 }) {      Text(this.text).fontSize(50).fontColor(this.color)      Text('Landscape').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)        .onClick(() => {          let context = featureAbility.getContext();          context.setDisplayOrientation(0); //调用该接口手动改变设备横竖屏状态        })      Text('Portrait').fontSize(50).fontColor(this.color).backgroundColor(Color.Orange)        .onClick(() => {          let context = featureAbility.getContext();          context.setDisplayOrientation(1); //调用该接口手动改变设备横竖屏状态        })    }    .width('100%').height('100%')  }}  图1 竖屏   图2 横屏     上一篇 栅格布局（GridRow/GridCol） 下一篇 创建列表（List） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。布局结构布局元素的组成如何选择布局布局位置对子元素的约束布局概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  组件按照布局的要求依次排列，构成应用的页面。在声明式UI中，所有的页面都是由自定义组件构成，开发者可以根据自己的需求，选择合适的布局进行页面开发。 布局指用特定的组件或者属性来管理用户页面所放置UI组件的大小和位置。在实际的开发过程中，需要遵守以下流程保证整体的布局效果：  确定页面的布局结构。 分析页面中的元素构成。 选用适合的布局容器组件或属性控制页面中各个元素的位置和大小约束。   布局结构 布局的结构通常是分层级的，代表了用户界面中的整体架构。一个常见的页面结构如下所示：  图1 常见页面结构图  为实现上述效果，开发者需要在页面中声明对应的元素。其中，Page表示页面的根节点，Column/Row等元素为系统组件。针对不同的页面结构，ArkUI提供了不同的布局组件来帮助开发者实现对应布局的效果，例如Row用于实现线性布局。   布局元素的组成 布局相关的容器组件可形成对应的布局效果。例如，List组件可构成线性布局。  图2 布局元素组成图    组件区域（蓝区方块）：组件区域表明组件的大小，width、height属性设置该区域的大小。 组件内容区（黄色方块）：组件区域大小减去组件的border值，组件内容区大小会作为组件内容（或者子组件）进行大小测算时的布局测算限制。 组件内容（绿色方块）：组件内容本身占用的大小，比如文本内容占用的大小。组件内容和组件内容区不一定匹配，比如设置了固定的width和height，此时组件内容的大小就是设置的width和height减去padding和border值，但文本内容则是通过文本布局引擎测算后得到的大小，可能出现文本真实大小小于设置的组件内容区大小。当组件内容和组件内容区大小不一致时，align属性生效，定义组件内容在组件内容区的对齐方式，如居中对齐。 组件布局边界（虚线部分）：组件通过margin属性设置外边距时，组件布局边界就是组件区域加上margin的大小。    如何选择布局 声明式UI提供了以下9种常见布局，开发者可根据实际应用场景选择合适的布局进行页面开发。     布局 应用场景    线性布局（Row、Column） 如果布局内子元素超过1个，且能够以某种方式线性排列时优先考虑此布局。   层叠布局（Stack） 组件需要有堆叠效果时优先考虑此布局，层叠布局的堆叠效果不会占用或影响其他同容器内子组件的布局空间。例如Panel作为子组件弹出时将其他组件覆盖更为合理，则优先考虑在外层使用堆叠布局。   弹性布局（Flex） 弹性布局是与线性布局类似的布局方式。区别在于弹性布局默认能够使子组件压缩或拉伸。在子组件需要计算拉伸或压缩比例时优先使用此布局，可使得多个容器内子组件能有更好的视觉上的填充容器效果。   相对布局（RelativeContainer） 相对布局是在二维空间中的布局方式，不需要遵循线性布局的规则，布局方式更为自由。通过在子组件上设置锚点规则（AlignRules）使子组件能够将自己在横轴、纵轴中的位置与容器或容器内其他子组件的位置对齐。设置的锚点规则可以天然支持子元素压缩、拉伸，堆叠或形成多行效果。在页面元素分布复杂或通过线性布局会使容器嵌套层数过深时推荐使用。   栅格布局（GridRow、GridCol） 栅格是多设备场景下通用的辅助定位工具，通过将空间分割为有规律的栅格。栅格不同于网格布局固定的空间划分，它可以实现不同设备下不同的布局，空间划分更随心所欲，从而显著降低适配不同屏幕尺寸的设计及开发成本，使得整体设计和开发流程更有秩序和节奏感，同时也保证多设备上应用显示的协调性和一致性，提升用户体验。推荐手机、大屏、平板等不同设备，内容相同但布局不同时使用。   媒体查询（@ohos.mediaquery） 媒体查询可根据不同设备类型或同设备不同状态修改应用的样式。例如根据设备和应用的不同属性信息设计不同的布局，以及屏幕发生动态改变时更新应用的页面布局。   列表（List） 使用列表可以轻松高效地显示结构化、可滚动的信息。在ArkUI中，列表具有垂直和水平布局能力和自适应交叉轴方向上排列个数的布局能力，超出屏幕时可以滚动。列表适合用于呈现同类数据类型或数据类型集，例如图片和文本。   网格（Grid） 网格布局具有较强的页面均分能力，子组件占比控制能力，是一种重要自适应布局。网格布局可以控制元素所占的网格数量、设置子组件横跨几行或者几列，当网格容器尺寸发生变化时，所有子组件以及间距等比例调整。推荐在需要按照固定比例或者均匀分配空间的布局场景下使用，例如计算器、相册、日历等。   轮播（Swiper） 轮播组件通常用于实现广告轮播、图片预览、可滚动应用等。      布局位置 position、offset等属性影响了布局容器相对于自身或其他组件的位置。     定位能力 使用场景 实现方式    绝对定位 对于不同尺寸的设备，使用绝对定位的适应性会比较差，在屏幕的适配上有缺陷。 使用position实现绝对定位，设置元素左上角相对于父容器左上角偏移位置。在布局容器中，设置该属性不影响父容器布局，仅在绘制时进行位置调整。   相对定位 相对定位不脱离文档流，即原位置依然保留，不影响元素本身的特性，仅相对于原位置进行偏移。 使用offset可以实现相对定位，设置元素相对于自身的偏移量。设置该属性，不影响父容器布局，仅在绘制时进行位置调整。      对子元素的约束     对子元素的约束能力 使用场景 实现方式    拉伸 容器组件尺寸发生变化时，增加或减小的空间全部分配给容器组件内指定区域。 flexGrow和flexShrink属性：  flexGrow基于父容器的剩余空间分配来控制组件拉伸。 flexShrink设置父容器的压缩尺寸来控制组件压缩。    缩放 子组件的宽高按照预设的比例，随容器组件发生变化，且变化过程中子组件的宽高比不变。 aspectRatio属性指定当前组件的宽高比来控制缩放，公式为：aspectRatio=width/height。   占比 占比能力是指子组件的宽高按照预设的比例，随父容器组件发生变化。 基于通用属性的两种实现方式： 1. 将子组件的宽高设置为父组件宽高的百分比。 2. layoutWeight属性，使得子元素自适应占满剩余空间。   隐藏 隐藏能力是指容器组件内的子组件，按照其预设的显示优先级，随容器组件尺寸变化显示或隐藏，其中相同显示优先级的子组件同时显示或隐藏。  通过displayPriority属性来控制页面的显示和隐藏。      上一篇 开发布局 下一篇 构建布局 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景一场景二场景三如何优化Flex的布局性能改善布局性能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Flex为采用弹性布局的容器。容器内部的所有子元素，会自动参与弹性布局。子元素默认沿主轴排列，子元素在主轴方向的尺寸称为主轴尺寸。 在单行布局场景下，容器里子组件的主轴尺寸长度总和可能存在不等于容器主轴尺寸长度的情况。例如，三个子组件的宽均为200px，容器宽为500px，当第一个子组件和第二个子组件布局完成后，为了显示第三个子组件，需要给第二个子组件和第三个子组件设置压缩属性flexShrink，此时第二个子组件会被再布局一次，导致布局效率下降。  场景一 所有子组件未设置displayPriority属性（或displayPriority设置为默认值1）和layoutWeight属性（或layoutWeight设置为默认值0）时，所有子组件先按序布局一次。   第一次布局子组件主轴尺寸长度总和等于容器主轴尺寸长度，不需要二次布局。 第一次布局子组件主轴尺寸长度总和小于容器主轴尺寸长度，且包含设置有效的flexGrow属性的子组件，设置有效的flexGrow属性的子组件会触发二次布局，拉伸布局填满容器。 第一次布局子组件主轴尺寸长度总和大于容器主轴尺寸长度，且包含设置有效的flexShrink属性（flex子组件默认值为1，为有效值）的子组件，设置有效的flexShrink属性的子组件会触发二次布局，压缩布局填满容器。   场景二  子组件存在设置displayPriority属性，不存在设置layoutWeight属性。 根据displayPriority从大到小顺序，布局每组同displayPriority值的子组件，直到子组件主轴尺寸长度总和最大且不超过容器主轴尺寸长度，舍弃未布局的低优先级displayPriority（可能存在一组临界displayPriority值的子组件布局但未使用的情况）。  第一次布局子组件主轴尺寸长度总和等于容器主轴尺寸长度，不需要二次布局。 第一次布局子组件主轴尺寸长度总和小于容器主轴尺寸长度，且包含设置有效的flexGrow属性的子组件，设置有效的flexGrow属性的子组件会触发二次布局，拉伸布局填满容器。   场景三 子组件中存在设置layoutWeight属性。 根据displayPriority从大到小顺序，对设置displayPriority相同值的子组件且不设置layoutWeight属性的子组件进行布局，直到子组件主轴尺寸长度的总和最大且不超过容器主轴尺寸长度。如果子组件主轴尺寸长度的总和超过了容器主轴尺寸长度，舍弃未布局的低优先级displayPriority，可能存在一组临界displayPriority值的子组件布局但未使用的情况。 剩余空间按设置layoutWeight属性的子组件的layoutWeight比例填满容器。   两次遍历都只布局一次组件，不会触发二次布局。   如何优化Flex的布局性能  使用Column/Row代替Flex。 大小不需要变更的子组件主动设置flexShrink属性值为0。 优先使用layoutWeight属性替代flexGrow属性和flexShrink属性。 子组件主轴长度分配设置为最常用场景的布局结果，使子组件主轴长度总和等于Flex容器主轴长度。    上一篇 创建轮播（Swiper） 下一篇 添加组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。