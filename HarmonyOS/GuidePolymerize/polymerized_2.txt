您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述基本概念设置依赖关系锚点设置设置相对于锚点的对齐位置场景实例相对布局（RelativeContainer） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 RelativeContainer为采用相对布局的容器，支持容器内部的子元素设置相对位置关系。子元素支持指定兄弟元素作为锚点，也支持指定父容器作为锚点，基于锚点做相对位置布局。下图是一个RelativeContainer的概念图，图中的虚线表示位置的依赖关系。   图1 相对布局示意图   子元素并不完全是上图中的依赖关系。比如，Item4可以以Item2为依赖锚点，也可以以RelativeContainer父容器为依赖锚点。  基本概念  锚点：通过锚点设置当前元素基于哪个元素确定位置。 对齐方式：通过对齐方式，设置当前元素是基于锚点的上中下对齐，还是基于锚点的左中右对齐。    设置依赖关系   锚点设置 锚点设置是指设置子元素相对于父元素或兄弟元素的位置依赖关系。在水平方向上，可以设置left、middle、right的锚点。在竖直方向上，可以设置top、center、bottom的锚点。为了明确定义锚点，必须为RelativeContainer及其子元素设置ID，用于指定锚点信息。ID默认为“__container__”，其余子元素的ID通过id属性设置。未设置ID的子元素在RelativeContainer中不会显示。 
说明
 在使用锚点时要注意子元素的相对位置关系，避免出现错位或遮挡的情况。 
  RelativeContainer父组件为锚点，__container__代表父容器的id。已复制RelativeContainer() {  Row()    // 添加其他属性    .alignRules({      top: { anchor: '__container__', align: VerticalAlign.Top },      left: { anchor: '__container__', align: HorizontalAlign.Start }    })    .id("row1")
  Row()    ...    .alignRules({      top: { anchor: '__container__', align: VerticalAlign.Top },      right: { anchor: '__container__', align: HorizontalAlign.End }    })    .id("row2")}...  以子元素为锚点。已复制RelativeContainer() {  ...  top: { anchor: 'row1', align: VerticalAlign.Bottom },  ...}.width(300).height(300).margin({ left: 20 }).border({ width: 2, color: '#6699FF' })     设置相对于锚点的对齐位置 设置了锚点之后，可以通过align设置相对于锚点的对齐位置。 在水平方向上，对齐位置可以设置为HorizontalAlign.Start、HorizontalAlign.Center、HorizontalAlign.End。  在竖直方向上，对齐位置可以设置为VerticalAlign.Top、VerticalAlign.Center、VerticalAlign.Bottom。    场景实例 相对布局内的子元素相对灵活，只要在RelativeContainer容器内，均可以通过alignRules进行相应的位置移动。 已复制@Entry@Componentstruct Index {  build() {    Row() {      RelativeContainer() {        Row()          .width(100)          .height(100)          .backgroundColor('#FF3333')          .alignRules({            top: { anchor: '__container__', align: VerticalAlign.Top },  //以父容器为锚点，竖直方向顶头对齐            middle: { anchor: '__container__', align: HorizontalAlign.Center }  //以父容器为锚点，水平方向居中对齐          })          .id('row1')  //设置锚点为row1
        Row() {          Image($r('app.media.icon'))        }        .height(100).width(100)        .alignRules({          top: { anchor: 'row1', align: VerticalAlign.Bottom },  //以row1组件为锚点，竖直方向底端对齐          left: { anchor: 'row1', align: HorizontalAlign.Start }  //以row1组件为锚点，水平方向开头对齐        })        .id('row2')  //设置锚点为row2
        Row()          .width(100)          .height(100)          .backgroundColor('#FFCC00')          .alignRules({            top: { anchor: 'row2', align: VerticalAlign.Top }          })          .id('row3')  //设置锚点为row3
        Row()          .width(100)          .height(100)          .backgroundColor('#FF9966')          .alignRules({            top: { anchor: 'row2', align: VerticalAlign.Top },            left: { anchor: 'row2', align: HorizontalAlign.End },          })          .id('row4')  //设置锚点为row4
        Row()          .width(100)          .height(100)          .backgroundColor('#FF66FF')          .alignRules({            top: { anchor: 'row2', align: VerticalAlign.Bottom },            middle: { anchor: 'row2', align: HorizontalAlign.Center }          })          .id('row5')  //设置锚点为row5      }      .width(300).height(300)      .border({ width: 2, color: '#6699FF' })    }    .height('100%').margin({ left: 30 })  }}    上一篇 弹性布局（Flex） 下一篇 栅格布局（GridRow/GridCol） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述开发布局对齐方式Z序控制场景示例层叠布局（Stack） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述 层叠布局（StackLayout）用于在屏幕上预留一块区域来显示组件中的元素，提供元素可以重叠的布局。层叠布局通过Stack容器组件实现位置的固定定位与层叠，容器中的子元素（子组件）依次入栈，后一个子元素覆盖前一个子元素，子元素可以叠加，也可以设置位置。 层叠布局具有较强的页面层叠、位置定位能力，其使用场景有广告、卡片层叠效果等。 如图1，Stack作为容器，容器内的子元素（子组件）的顺序为Item1->Item2->Item3。   图1 层叠布局   开发布局 Stack组件为容器组件，容器内可包含各种子组件。其中子组件默认进行居中堆叠。子元素被约束在Stack下，进行自己的样式定义以及排列。  已复制Column(){  Stack({ }) {    Column(){}.width('90%').height('100%').backgroundColor('#ff58b87c')    Text('text').width('60%').height('60%').backgroundColor('#ffc3f6aa')    Button('button').width('30%').height('30%').backgroundColor('#ff8ff3eb').fontColor('#000')  }.width('100%').height(150).margin({ top: 50 })}   对齐方式 Stack组件通过alignContent参数实现位置的相对移动。如图2所示，支持九种对齐方式。  图2 Stack容器内元素的对齐方式    Z序控制 Stack容器中兄弟组件显示层级关系可以通过Z序控制的zIndex属性改变。zIndex值越大，显示层级越高，即zIndex值大的组件会覆盖在zIndex值小的组件上方。       在层叠布局中，如果后面子元素尺寸大于前面子元素尺寸，则前面子元素完全隐藏。      已复制Stack({ alignContent: Alignment.BottomStart }) {  Column() {    Text('Stack子元素1').textAlign(TextAlign.End).fontSize(20)  }.width(100).height(100).backgroundColor(0xffd306)
  Column() {    Text('Stack子元素2').fontSize(20)  }.width(150).height(150).backgroundColor(Color.Pink)
  Column() {    Text('Stack子元素3').fontSize(20)  }.width(200).height(200).backgroundColor(Color.Grey)}.margin({ top: 100 }).width(350).height(350).backgroundColor(0xe0e0e0)   上图中，最后的子元素3的尺寸大于前面的所有子元素，所以，前面两个元素完全隐藏。改变子元素1，子元素2的zIndex属性后，可以将元素展示出来。 已复制Stack({ alignContent: Alignment.BottomStart }) {  Column() {    Text('Stack子元素1').fontSize(20)  }.width(100).height(100).backgroundColor(0xffd306).zIndex(2)
  Column() {    Text('Stack子元素2').fontSize(20)  }.width(150).height(150).backgroundColor(Color.Pink).zIndex(1)
  Column() {    Text('Stack子元素3').fontSize(20)  }.width(200).height(200).backgroundColor(Color.Grey)}.margin({ top: 100 }).width(350).height(350).backgroundColor(0xe0e0e0)    场景示例 使用层叠布局快速搭建手机页面显示模型。 已复制@Entry@Componentstruct StackSample {  private arr: string[] = ['APP1', 'APP2', 'APP3', 'APP4', 'APP5', 'APP6', 'APP7', 'APP8'];
  build() {    Stack({ alignContent: Alignment.Bottom }) {      Flex({ wrap: FlexWrap.Wrap }) {        ForEach(this.arr, (item) => {          Text(item)            .width(100)            .height(100)            .fontSize(16)            .margin(10)            .textAlign(TextAlign.Center)            .borderRadius(10)            .backgroundColor(0xFFFFFF)        }, item => item)      }.width('100%').height('100%')
      Flex({ justifyContent: FlexAlign.SpaceAround, alignItems: ItemAlign.Center }) {        Text('联系人').fontSize(16)        Text('设置').fontSize(16)        Text('短信').fontSize(16)      }      .width('50%')      .height(50)      .backgroundColor('#16302e2e')      .margin({ bottom: 15 })      .borderRadius(15)    }.width('100%').height('100%').backgroundColor('#CFD0CF')  }}    上一篇 线性布局（Row/Column） 下一篇 弹性布局（Flex） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用显式动画产生布局更新动画使用属性动画产生布局更新动画布局更新动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  显式动画（animateTo）和属性动画（animation）是ArkUI提供的最基础和常用的动画功能。在布局属性（如尺寸属性、位置属性）发生变化时，可以通过属性动画或显式动画，按照动画参数过渡到新的布局参数状态。     动画类型 特点    显式动画 闭包内的变化均会触发动画，包括由数据变化引起的组件的增删、组件属性的变化等，可以做较为复杂的动画。   属性动画 动画设置简单，属性变化时自动触发动画。     使用显式动画产生布局更新动画 显式动画的接口为： 已复制animateTo(value: AnimateParam, event: () => void): void 第一个参数指定动画参数，第二个参数为动画的闭包函数。 以下是使用显式动画产生布局更新动画的示例。示例中，当Column组件的alignItems属性改变后，其子组件的布局位置结果发生变化。只要该属性是在animateTo的闭包函数中修改的，那么由其引起的所有变化都会按照animateTo的动画参数执行动画过渡到终点值。 已复制@Entry@Componentstruct LayoutChange {  // 用于控制Column的alignItems属性  @State itemAlign: HorizontalAlign = HorizontalAlign.Start;  allAlign: HorizontalAlign[] = [HorizontalAlign.Start, HorizontalAlign.Center, HorizontalAlign.End];  alignIndex: number = 0;
  build() {    Column() {      Column({ space: 10 }) {        Button("1").width(100).height(50)        Button("2").width(100).height(50)        Button("3").width(100).height(50)      }      .margin(20)      .alignItems(this.itemAlign)      .borderWidth(2)      .width("90%")      .height(200)
      Button("click").onClick(() => {        // 动画时长为1000ms，曲线为EaseInOut        animateTo({ duration: 1000, curve: Curve.EaseInOut }, () => {          this.alignIndex = (this.alignIndex + 1) % this.allAlign.length;          // 在闭包函数中修改this.itemAlign参数，使Column容器内部孩子的布局方式变化，使用动画过渡到新位置          this.itemAlign = this.allAlign[this.alignIndex];        });      })    }    .width("100%")    .height("100%")  }}   除直接改变布局方式外，也可直接修改组件的宽、高、位置。 已复制@Entry@Componentstruct LayoutChange2 {  @State myWidth: number = 100;  @State myHeight: number = 50;  // 标志位，true和false分别对应一组myWidth、myHeight值  @State flag: boolean = false;
  build() {    Column({ space: 10 }) {      Button("text")        .type(ButtonType.Normal)        .width(this.myWidth)        .height(this.myHeight)        .margin(20)      Button("area: click me")        .fontSize(12)        .margin(20)        .onClick(() => {          animateTo({ duration: 1000, curve: Curve.Ease }, () => {            // 动画闭包中根据标志位改变控制第一个Button宽高的状态变量，使第一个Button做宽高动画            if (this.flag) {              this.myWidth = 100;              this.myHeight = 50;            } else {              this.myWidth = 200;              this.myHeight = 100;            }            this.flag = !this.flag;          });        })    }    .width("100%")    .height("100%")  }} 在第二个Button的点击事件中，使用animateTo函数，在闭包中修改this.myWidth和this.myHeight状态变量，而这两个状态变量分别为第一个Button的宽、高属性值，所以第一个Button做了宽高动画。效果如下图。  与此同时，第二个Button也产生了一个位置动画。这是由于第一个Button的宽高变化后，引起了Column内部其他组件的布局结果也发生了变化，第二个Button的布局发生变化也是由于闭包内改变第一个Button的宽高造成的。 如果不希望第二个Button有动画效果，有两种方式可以实现。一种是给做第一个Button外面再加一个容器，使其动画前后的大小都在容器的范围内，这样第二个Button的位置不会被第一个Button的位置所影响。修改后的核心代码如下。 已复制Column({ space: 10 }) {  Column() {    // Button放在足够大的容器内，使其不影响更外层的组件位置    Button("text")      .type(ButtonType.Normal)      .width(this.myWidth)      .height(this.myHeight)  }  .margin(20)  .width(200)  .height(100)
  Button("area: click me")    .fontSize(12)    .onClick(() => {      animateTo({ duration: 1000, curve: Curve.Ease }, () => {        // 动画闭包中根据标志位改变控制第一个Button宽高的状态变量，使第一个Button做宽高动画        if (this.flag) {          this.myWidth = 100;          this.myHeight = 50;        } else {          this.myWidth = 200;          this.myHeight = 100;        }        this.flag = !this.flag;      });    })}.width("100%").height("100%")  另一种方式是给第二个Button添加布局约束，如position的位置约束，使其位置不被第一个Button的宽高影响。核心代码如下： 已复制Column({ space: 10 }) {  Button("text")    .type(ButtonType.Normal)    .width(this.myWidth)    .height(this.myHeight)    .margin(20)
  Button("area: click me")    .fontSize(12)    // 配置position属性固定，使自己的布局位置不被第一个Button的宽高影响    .position({ x: "30%", y: 200 })    .onClick(() => {      animateTo({ duration: 1000, curve: Curve.Ease }, () => {        // 动画闭包中根据标志位改变控制第一个Button宽高的状态变量，使第一个Button做宽高动画        if (this.flag) {          this.myWidth = 100;          this.myHeight = 50;        } else {          this.myWidth = 200;          this.myHeight = 100;        }        this.flag = !this.flag;      });    })}.width("100%").height("100%")  使用属性动画产生布局更新动画 显式动画把要执行动画的属性的修改放在闭包函数中触发动画，而属性动画则无需使用闭包，把animation属性加在要做属性动画的组件的属性后即可。 属性动画的接口为： 已复制animation(value: AnimateParam) 其入参为动画参数。想要组件随某个属性值的变化而产生动画，此属性需要加在animation属性之前。有的属性变化不希望通过animation产生属性动画，可以放在animation之后。上面显式动画的示例很容易改为用属性动画实现。例如：  已复制@Entry@Componentstruct LayoutChange2 {  @State myWidth: number = 100;  @State myHeight: number = 50;  @State flag: boolean = false;  @State myColor: Color = Color.Blue;
  build() {    Column({ space: 10 }) {      Button("text")        .type(ButtonType.Normal)        .width(this.myWidth)        .height(this.myHeight)        // animation只对其上面的type、width、height属性生效，时长为1000ms，曲线为Ease        .animation({ duration: 1000, curve: Curve.Ease })        // animation对下面的backgroundColor、margin属性不生效        .backgroundColor(this.myColor)        .margin(20)        
      Button("area: click me")        .fontSize(12)        .onClick(() => {          // 改变属性值，配置了属性动画的属性会进行动画过渡          if (this.flag) {            this.myWidth = 100;            this.myHeight = 50;            this.myColor = Color.Blue;          } else {            this.myWidth = 200;            this.myHeight = 100;            this.myColor = Color.Pink;          }          this.flag = !this.flag;        })    }  }} 上述示例中，第一个button上的animation属性，只对写在animation之前的type、width、height属性生效，而对写在animation之后的backgroundColor、margin属性无效。运行结果是width、height属性会按照animation的动画参数执行动画，而backgroundColor会直接跳变，不会产生动画。效果如下图：   
说明
 1. 使用属性动画时，会按照指定的属性动画参数执行动画。每个组件可为自己的属性配置不同参数的属性动画。 2. 显式动画会对动画闭包前后造成的所有界面差异执行动画，且使用同一动画参数，适用于统一执行的场景。此外，显式动画也可以用于一些非属性变量造成的动画，如if/else的条件，ForEach使用的数组元素的删减。 3. 如果一个属性配置了属性动画，且在显式动画闭包中改变该属性值，属性动画优先生效，会使用属性动画的动画参数。 
  上一篇 页面内的动画 下一篇 组件内转场动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述限制条件装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现观察变化框架行为使用场景简单类型和类对象类型的@Link数组类型的@Link@Link装饰器：父子双向同步 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 概述@Link装饰的变量与其父组件中的数据源共享相同的值。  限制条件@Link装饰器不能在@Entry装饰的自定义组件中使用。  装饰器使用规则说明 @Link变量装饰器  说明    装饰器参数  无   同步类型  双向同步。 父组件中@State, @StorageLink和@Link 和子组件@Link可以建立双向数据同步，反之亦然。   允许装饰的变量类型  Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。 类型必须被指定，且和双向绑定状态变量的类型相同。 不支持any，不支持简单类型和复杂类型的联合类型，不允许使用undefined和null。 
说明
不支持Length、ResourceStr、ResourceColor类型，Length、ResourceStr、ResourceColor为简单类型和复杂类型的联合类型。 
   被装饰变量的初始值  无，禁止本地初始化。      变量的传递/访问规则说明 传递/访问  说明    从父组件初始化和更新  必选。与父组件@State, @StorageLink和@Link 建立双向绑定。允许父组件中@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp装饰变量初始化子组件@Link。 从API version 9开始，@Link子组件从父组件初始化@State的语法为Comp({ aLink: this.aState })。同样Comp({aLink: $aState})也支持。   用于初始化子组件  允许，可用于初始化常规变量、@State、@Link、@Prop、@Provide。   是否支持组件外访问  私有，只能在所属组件内访问。     图1 初始化规则图示    观察变化和行为表现 观察变化当装饰的数据类型为boolean、string、number类型时，可以同步观察到数值的变化，示例请参考简单类型和类对象类型的@Link。当装饰的数据类型为class或者Object时，可以观察到赋值和属性赋值的变化，即Object.keys(observedObject)返回的所有属性，示例请参考简单类型和类对象类型的@Link。当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化，示例请参考数组类型的@Link。  框架行为@Link装饰的变量和其所属的自定义组件共享生命周期。 为了了解@Link变量初始化和更新机制，有必要先了解父组件和拥有@Link变量的子组件的关系，初始渲染和双向更新的流程（以父组件为@State为例）。 初始渲染：执行父组件的build()函数后将创建子组件的新实例。初始化过程如下：必须指定父组件中的@State变量，用于初始化子组件的@Link变量。子组件的@Link变量值与其父组件的数据源变量保持同步（双向数据同步）。父组件的@State状态变量包装类通过构造函数传给子组件，子组件的@Link包装类拿到父组件的@State的状态变量后，将当前@Link包装类this指针注册给父组件的@State变量。 @Link的数据源的更新：即父组件中状态变量更新，引起相关子组件的@Link的更新。处理步骤：通过初始渲染的步骤可知，子组件@Link包装类把当前this指针注册给父组件。父组件@State变量变更后，会遍历更新所有依赖它的系统组件（elementid）和状态变量（比如@Link包装类）。通知@Link包装类更新后，子组件中所有依赖@Link状态变量的系统组件（elementId）都会被通知更新。以此实现父组件对子组件的状态数据同步。 @Link的更新：当子组件中@Link更新后，处理步骤如下（以父组件为@State为例）：@Link更新后，调用父组件的@State包装类的set方法，将更新后的数值同步回父组件。子组件@Link和父组件@State分别遍历依赖的系统组件，进行对应的UI的更新。以此实现子组件@Link同步回父组件@State。   使用场景 简单类型和类对象类型的@Link以下示例中，点击父组件ShufflingContainer中的“Parent View: Set yellowButton”和“Parent View: Set GreenButton”，可以从父组件将变化同步给子组件。 1.点击子组件GreenButton和YellowButton中的Button，子组件会发生相应变化，将变化同步给父组件。因为@Link是双向同步，会将变化同步给@State。 2.当点击父组件ShufflingContainer中的Button时，@State变化，也会同步给@Link，子组件也会发生对应的刷新。 已复制class GreenButtonState {  width: number = 0;
  constructor(width: number) {    this.width = width;  }}
@Componentstruct GreenButton {  @Link greenButtonState: GreenButtonState;
  build() {    Button('Green Button')      .width(this.greenButtonState.width)      .height(40)      .backgroundColor('#64bb5c')      .fontColor('#FFFFFF，90%')      .onClick(() => {        if (this.greenButtonState.width < 700) {          // 更新class的属性，变化可以被观察到同步回父组件          this.greenButtonState.width += 60;        } else {          // 更新class，变化可以被观察到同步回父组件          this.greenButtonState = new GreenButtonState(180);        }      })  }}
@Componentstruct YellowButton {  @Link yellowButtonState: number;
  build() {    Button('Yellow Button')      .width(this.yellowButtonState)      .height(40)      .backgroundColor('#f7ce00')      .fontColor('#FFFFFF，90%')      .onClick(() => {        // 子组件的简单类型可以同步回父组件        this.yellowButtonState += 40.0;      })  }}
@Entry@Componentstruct ShufflingContainer {  @State greenButtonState: GreenButtonState = new GreenButtonState(180);  @State yellowButtonProp: number = 180;
  build() {    Column() {      Flex({ direction: FlexDirection.Column, alignItems: ItemAlign.Center }) {        // 简单类型从父组件@State向子组件@Link数据同步        Button('Parent View: Set yellowButton')          .width(312)          .height(40)          .margin(12)          .fontColor('#FFFFFF，90%')          .onClick(() => {            this.yellowButtonProp = (this.yellowButtonProp < 700) ? this.yellowButtonProp + 40 : 100;          })        // class类型从父组件@State向子组件@Link数据同步        Button('Parent View: Set GreenButton')          .width(312)          .height(40)          .margin(12)          .fontColor('#FFFFFF，90%')          .onClick(() => {            this.greenButtonState.width = (this.greenButtonState.width < 700) ? this.greenButtonState.width + 100 : 100;          })        // class类型初始化@Link        GreenButton({ greenButtonState: $greenButtonState }).margin(12)        // 简单类型初始化@Link        YellowButton({ yellowButtonState: $yellowButtonProp }).margin(12)      }    }  }}   数组类型的@Link已复制@Componentstruct Child {  @Link items: number[];
  build() {    Column() {      Button(`Button1: push`)        .margin(12)        .width(312)        .height(40)        .fontColor('#FFFFFF，90%')        .onClick(() => {          this.items.push(this.items.length + 1);        })      Button(`Button2: replace whole item`)        .margin(12)        .width(312)        .height(40)        .fontColor('#FFFFFF，90%')        .onClick(() => {          this.items = [100, 200, 300];        })    }  }}
@Entry@Componentstruct Parent {  @State arr: number[] = [1, 2, 3];
  build() {    Column() {      Child({ items: $arr })        .margin(12)      ForEach(this.arr,        (item: number) => {          Button(`${item}`)            .margin(12)            .width(312)            .height(40)            .backgroundColor('#11a2a2a2')            .fontColor('#e6000000')        },        (item: ForEachInterface) => item.toString()      )    }  }}  上文所述，ArkUI框架可以观察到数组元素的添加，删除和替换。在该示例中@State和@Link的类型是相同的number[]，不允许将@Link定义成number类型（@Link item : number），并在父组件中用@State数组中每个数据项创建子组件。如果要使用这个场景，可以参考@Prop和@Observed。   上一篇 @Prop装饰器：父子单向同步 下一篇 @Provide装饰器和@Consume装饰器：与后代组件双向同步 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述限制条件@LocalStorageProp装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现@LocalStorageLink装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现使用场景应用逻辑使用LocalStorage从UI内部使用LocalStorage@LocalStorageProp和LocalStorage单向同步的简单场景@LocalStorageLink和LocalStorage双向同步的简单场景兄弟节点之间同步状态变量将LocalStorage实例从UIAbility共享到一个或多个视图LocalStorage：页面级UI状态存储 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  LocalStorage是页面级的UI状态存储，通过@Entry装饰器接收的参数可以在页面内共享同一个LocalStorage实例。LocalStorage也可以在UIAbility实例内，在页面间共享状态。 本文仅介绍LocalStorage使用场景和相关的装饰器：@LocalStorageProp和@LocalStorageLink。 
说明
 本模块从API version 9开始支持。 
  概述 LocalStorage是ArkTS为构建页面级别状态变量提供存储的内存内“数据库”。  应用程序可以创建多个LocalStorage实例，LocalStorage实例可以在页面内共享，也可以通过GetShared接口，实现跨页面、UIAbility实例内共享。 组件树的根节点，即被@Entry装饰的@Component，可以被分配一个LocalStorage实例，此组件的所有子组件实例将自动获得对该LocalStorage实例的访问权限； 被@Component装饰的组件最多可以访问一个LocalStorage实例和AppStorage，未被@Entry装饰的组件不可被独立分配LocalStorage实例，只能接受父组件通过@Entry传递来的LocalStorage实例。一个LocalStorage实例在组件树上可以被分配给多个组件。 LocalStorage中的所有属性都是可变的。  应用程序决定LocalStorage对象的生命周期。当应用释放最后一个指向LocalStorage的引用时，比如销毁最后一个自定义组件，LocalStorage将被JS Engine垃圾回收。 LocalStorage根据与@Component装饰的组件的同步类型不同，提供了两个装饰器：  @LocalStorageProp：@LocalStorageProp装饰的变量和与LocalStorage中给定属性建立单向同步关系。 @LocalStorageLink：@LocalStorageLink装饰的变量和在@Component中创建与LocalStorage中给定属性建立双向同步关系。    限制条件  LocalStorage创建后，命名属性的类型不可更改。后续调用Set时必须使用相同类型的值。 LocalStorage是页面级存储，GetShared接口仅能获取当前Stage通过windowStage.loadContent传入的LocalStorage实例，否则返回undefined。例子可见将LocalStorage实例从UIAbility共享到一个或多个视图。    @LocalStorageProp 在上文中已经提到，如果要建立LocalStorage和自定义组件的联系，需要使用@LocalStorageProp和@LocalStorageLink装饰器。使用@LocalStorageProp(key)/@LocalStorageLink(key)装饰组件内的变量，key标识了LocalStorage的属性。  当自定义组件初始化的时候，@LocalStorageProp(key)/@LocalStorageLink(key)装饰的变量会通过给定的key，绑定LocalStorage对应的属性，完成初始化。本地初始化是必要的，因为无法保证LocalStorage一定存在给定的key（这取决于应用逻辑是否在组件初始化之前在LocalStorage实例中存入对应的属性）。 
说明
 从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 @LocalStorageProp(key)是和LocalStorage中key对应的属性建立单向数据同步，我们允许本地改变的发生，但是对于@LocalStorageProp，本地的修改永远不会同步回LocalStorage中，相反，如果LocalStorage给定key的属性发生改变，改变会被同步给@LocalStorageProp，并覆盖掉本地的修改。  装饰器使用规则说明     @LocalStorageProp变量装饰器 说明    装饰器参数 key：常量字符串，必填（字符串需要有引号）。   允许装饰的变量类型 Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化和行为表现。 类型必须被指定，且必须和LocalStorage中对应属性相同。不支持any，不允许使用undefined和null。   同步类型 单向同步：从LocalStorage的对应属性到组件的状态变量。组件本地的修改是允许的，但是LocalStorage中给定的属性一旦发生变化，将覆盖本地的修改。   被装饰变量的初始值 必须指定，如果LocalStorage实例中不存在属性，则作为初始化默认值，并存入LocalStorage中。      变量的传递/访问规则说明     传递/访问 说明    从父节点初始化和更新 禁止，@LocalStorageProp不支持从父节点初始化，只能从LocalStorage中key对应的属性初始化，如果没有对应key的话，将使用本地默认值初始化。   初始化子节点 支持，可用于初始化@State、@Link、@Prop、@Provide。   是否支持组件外访问 否。     图1 @LocalStorageProp初始化规则图示       观察变化和行为表现 观察变化   当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。 当装饰的数据类型为class或者Object时，可以观察到赋值和属性赋值的变化，即Object.keys(observedObject)返回的所有属性。 当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。  框架行为  当@LocalStorageProp(key)装饰的数值改变被观察到时，修改不会被同步回LocalStorage对应属性键值key的属性中。 当前@LocalStorageProp(key)单向绑定的数据会被修改，即仅限于当前组件的私有成员变量改变，其他的绑定该key的数据不会同步改变。 当@LocalStorageProp(key)装饰的数据本身是状态变量，它的改变虽然不会同步回LocalStorage中，但是会引起所属的自定义组件的重新渲染。 当LocalStorage中key对应的属性发生改变时，会同步给所有@LocalStorageProp(key)装饰的数据，@LocalStorageProp(key)本地的修改将被覆盖。   @LocalStorageLink 如果我们需要将自定义组件的状态变量的更新同步回LocalStorage，就需要用到@LocalStorageLink。 @LocalStorageLink(key)是和LocalStorage中key对应的属性建立双向数据同步：  本地修改发生，该修改会被写回LocalStorage中； LocalStorage中的修改发生后，该修改会被同步到所有绑定LocalStorage对应key的属性上，包括单向（@LocalStorageProp和通过prop创建的单向绑定变量）、双向（@LocalStorageLink和通过link创建的双向绑定变量）变量。    装饰器使用规则说明     @LocalStorageLink变量装饰器 说明    装饰器参数 key：常量字符串，必填（字符串需要有引号）。   允许装饰的变量类型 Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化和行为表现。 类型必须被指定，且必须和LocalStorage中对应属性相同。不支持any，不允许使用undefined和null。   同步类型 双向同步：从LocalStorage的对应属性到自定义组件，从自定义组件到LocalStorage对应属性。   被装饰变量的初始值 必须指定，如果LocalStorage实例中不存在属性，则作为初始化默认值，并存入LocalStorage中。      变量的传递/访问规则说明     传递/访问 说明    从父节点初始化和更新 禁止，@LocalStorageLink不支持从父节点初始化，只能从LocalStorage中key对应的属性初始化，如果没有对应key的话，将使用本地默认值初始化。   初始化子节点 支持，可用于初始化@State、@Link、@Prop、@Provide。   是否支持组件外访问 否。      图2 @LocalStorageLink初始化规则图示     观察变化和行为表现 观察变化   当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。 当装饰的数据类型为class或者Object时，可以观察到赋值和属性赋值的变化，即Object.keys(observedObject)返回的所有属性。 当装饰的对象是array时，可以观察到数组添加、删除、更新数组单元的变化。  框架行为  当@LocalStorageLink(key)装饰的数值改变被观察到时，修改将被同步回LocalStorage对应属性键值key的属性中。 LocalStorage中属性键值key对应的数据一旦改变，属性键值key绑定的所有的数据（包括双向@LocalStorageLink和单向@LocalStorageProp）都将同步修改。 当@LocalStorageLink(key)装饰的数据本身是状态变量，它的改变不仅仅会同步回LocalStorage中，还会引起所属的自定义组件的重新渲染。   使用场景   应用逻辑使用LocalStorage 已复制let storage = new LocalStorage({ 'PropA': 47 }); // 创建新实例并使用给定对象初始化let propA = storage.get('PropA') // propA == 47let link1 = storage.link('PropA'); // link1.get() == 47let link2 = storage.link('PropA'); // link2.get() == 47let prop = storage.prop('PropA'); // prop.get() = 47link1.set(48); // two-way sync: link1.get() == link2.get() == prop.get() == 48prop.set(1); // one-way sync: prop.get()=1; but link1.get() == link2.get() == 48link1.set(49); // two-way sync: link1.get() == link2.get() == prop.get() == 49   从UI内部使用LocalStorage 除了应用程序逻辑使用LocalStorage，还可以借助LocalStorage相关的两个装饰器@LocalStorageProp和@LocalStorageLink，在UI组件内部获取到LocalStorage实例中存储的状态变量。 本示例以@LocalStorageLink为例，展示了：  使用构造函数创建LocalStorage实例storage； 使用@Entry装饰器将storage添加到CompA顶层组件中； @LocalStorageLink绑定LocalStorage对给定的属性，建立双向数据同步。已复制// 创建新实例并使用给定对象初始化let storage = new LocalStorage({ 'PropA': 47 });
@Componentstruct Child {  // @LocalStorageLink变量装饰器与LocalStorage中的'PropA'属性建立双向绑定  @LocalStorageLink('PropA') storLink2: number = 1;
  build() {    Button(`Child from LocalStorage ${this.storLink2}`)      // 更改将同步至LocalStorage中的'PropA'以及Parent.storLink1      .onClick(() => this.storLink2 += 1)  }}// 使LocalStorage可从@Component组件访问@Entry(storage)@Componentstruct CompA {  // @LocalStorageLink变量装饰器与LocalStorage中的'PropA'属性建立双向绑定  @LocalStorageLink('PropA') storLink1: number = 1;
  build() {    Column({ space: 15 }) {      Button(`Parent from LocalStorage ${this.storLink1}`) // initial value from LocalStorage will be 47, because 'PropA' initialized already        .onClick(() => this.storLink1 += 1)      // @Component子组件自动获得对CompA LocalStorage实例的访问权限。      Child()    }  }}    @LocalStorageProp和LocalStorage单向同步的简单场景 在下面的示例中，CompA 组件和Child组件分别在本地创建了与storage的'PropA'对应属性的单向同步的数据，我们可以看到：  CompA中对this.storProp1的修改，只会在CompA中生效，并没有同步回storage； Child组件中，Text绑定的storProp2 依旧显示47。已复制// 创建新实例并使用给定对象初始化let storage = new LocalStorage({ 'PropA': 47 });// 使LocalStorage可从@Component组件访问@Entry(storage)@Componentstruct CompA {  // @LocalStorageProp变量装饰器与LocalStorage中的'PropA'属性建立单向绑定  @LocalStorageProp('PropA') storProp1: number = 1;
  build() {    Column({ space: 15 }) {      // 点击后从47开始加1，只改变当前组件显示的storProp1，不会同步到LocalStorage中      Button(`Parent from LocalStorage ${this.storProp1}`)        .onClick(() => this.storProp1 += 1)      Child()    }  }}
@Componentstruct Child {  // @LocalStorageProp变量装饰器与LocalStorage中的'PropA'属性建立单向绑定  @LocalStorageProp('PropA') storProp2: number = 2;
  build() {    Column({ space: 15 }) {      // 当CompA改变时，当前storProp2不会改变，显示47      Text(`Parent from LocalStorage ${this.storProp2}`)    }  }}    @LocalStorageLink和LocalStorage双向同步的简单场景 下面的示例展示了@LocalStorageLink装饰的数据和LocalStorage双向同步的场景 已复制// 构造LocalStorage实例let storage = new LocalStorage({ 'PropA': 47 });// 调用link（api9以上）接口构造'PropA'的双向同步数据，linkToPropA 是全局变量let linkToPropA = storage.link('PropA');
@Entry(storage)@Componentstruct CompA {
  // @LocalStorageLink('PropA')在CompA自定义组件中创建'PropA'的双向同步数据，初始值为47，因为在构造LocalStorage已经给“PropA”设置47  @LocalStorageLink('PropA') storLink: number = 1;
  build() {    Column() {      Text(`incr @LocalStorageLink variable`)        // 点击“incr @LocalStorageLink variable”，this.storLink加1，改变同步回storage，全局变量linkToPropA也会同步改变 
        .onClick(() => this.storLink += 1)
      // 并不建议在组件内使用全局变量linkToPropA.get()，因为可能会有生命周期不同引起的错误。      Text(`@LocalStorageLink: ${this.storLink} - linkToPropA: ${linkToPropA.get()}`)    }  }}   兄弟节点之间同步状态变量 下面的示例展示了通过@LocalStorageLink双向同步兄弟节点之间的状态。 先看Parent自定义组件中发生的变化：  点击“playCount ${this.playCount} dec by 1”，this.playCount减1，修改同步回LocalStorage中，Child组件中的playCountLink绑定的组件会同步刷新； 点击“countStorage ${this.playCount} incr by 1”，调用LocalStorage的set接口，更新LocalStorage中“countStorage”对应的属性，Child组件中的playCountLink绑定的组件会同步刷新； Text组件“playCount in LocalStorage for debug ${storage.get<number>('countStorage')}”没有同步刷新，因为storage.get<number>('countStorage')返回的是常规变量，常规变量的更新并不会引起Text组件的重新渲染。  Child自定义组件中的变化：  playCountLink的刷新会同步回LocalStorage，并且引起兄弟组件和父组件相应的刷新。已复制let storage = new LocalStorage({ countStorage: 1 });
@Componentstruct Child {  // 子组件实例的名字  label: string = 'no name';  // 和LocalStorage中“countStorage”的双向绑定数据  @LocalStorageLink('countStorage') playCountLink: number = 0;
  build() {    Row() {      Text(this.label)        .width(50).height(60).fontSize(12)      Text(`playCountLink ${this.playCountLink}: inc by 1`)        .onClick(() => {          this.playCountLink += 1;        })        .width(200).height(60).fontSize(12)    }.width(300).height(60)  }}
@Entry(storage)@Componentstruct Parent {  @LocalStorageLink('countStorage') playCount: number = 0;
  build() {    Column() {      Row() {        Text('Parent')          .width(50).height(60).fontSize(12)        Text(`playCount ${this.playCount} dec by 1`)          .onClick(() => {            this.playCount -= 1;          })          .width(250).height(60).fontSize(12)      }.width(300).height(60)
      Row() {        Text('LocalStorage')          .width(50).height(60).fontSize(12)        Text(`countStorage ${this.playCount} incr by 1`)          .onClick(() => {            storage.set<number>('countStorage', 1 + storage.get<number>('countStorage'));          })          .width(250).height(60).fontSize(12)      }.width(300).height(60)
      Child({ label: 'ChildA' })      Child({ label: 'ChildB' })
      Text(`playCount in LocalStorage for debug ${storage.get<number>('countStorage')}`)        .width(300).height(60).fontSize(12)    }  }}    将LocalStorage实例从UIAbility共享到一个或多个视图 上面的实例中，LocalStorage的实例仅仅在一个@Entry装饰的组件和其所属的子组件（一个页面）中共享，如果希望其在多个视图中共享，可以在所属UIAbility中创建LocalStorage实例，并调用windowStage.loadContent。 已复制// EntryAbility.tsimport UIAbility from '@ohos.app.ability.UIAbility';import window from '@ohos.window';
export default class EntryAbility extends UIAbility {para:Record<string, number> = { 'PropA': 47 };storage: LocalStorage = new LocalStorage(this.para);
onWindowStageCreate(windowStage: window.WindowStage) {windowStage.loadContent('pages/Index', this.storage);}} 
说明
 在UI页面通过GetShared接口获取在通过loadContent共享的LocalStorage实例。 LocalStorage.GetShared只在模拟器或者实机上才有效，不能在Preview预览器中使用。 
  在下面的用例中，Index页面中的propA通过GetShared()方法获取到共享的LocalStorage实例。点击Button跳转到Page页面，点击Change propA改变propA的值，back回Index页面后，页面中propA的值也同步修改。 已复制// index.etsimport router from '@ohos.router';
// 通过getShared接口获取stage共享的LocalStorage实例let storage = LocalStorage.GetShared()@Entry(storage)@Componentstruct Index {  // can access LocalStorage instance using   // @LocalStorageLink/Prop decorated variables  @LocalStorageLink('PropA') propA: number = 1;  build() {    Row() {      Column() {        Text(`${this.propA}`)          .fontSize(50)          .fontWeight(FontWeight.Bold)        Button("To Page")          .onClick(() => {            router.pushUrl({              url:'pages/Page'            })          })      }      .width('100%')    }    .height('100%')  }}
// Page.etsimport router from '@ohos.router';
let storage = LocalStorage.GetShared()@Entry(storage)@Componentstruct Page {  @LocalStorageLink('PropA') propA: number = 2;
  build() {    Row() {      Column() {        Text(`${this.propA}`)          .fontSize(50)          .fontWeight(FontWeight.Bold)
        Button("Change propA")          .onClick(() => {            this.propA = 100;          })
        Button("Back Index")          .onClick(() => {            router.back()          })      }      .width('100%')    }  }} 
说明
 对于开发者更建议使用这个方式来构建LocalStorage的实例，并且在创建LocalStorage实例的时候就写入默认值，因为默认值可以作为运行异常的备份，也可以用作页面的单元测试。 
  上一篇 管理应用拥有的状态概述 下一篇 AppStorage：应用全局的UI状态存储 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。组件导航 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    Navigation  Tabs   上一篇 页面路由（router） 下一篇 Navigation 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。设置页面显示模式设置标题栏模式设置菜单栏设置工具栏Navigation 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Navigation组件一般作为页面的根容器，包括单页面、分栏和自适应三种显示模式。同时，Navigation提供了属性来设置页面的标题栏、工具栏、导航栏等。 Navigation组件的页面包含主页和内容页。主页由标题栏、内容区和工具栏组成，可在内容区中使用NavRouter子组件实现导航栏功能。内容页主要显示NavDestination子组件中的内容。 NavRouter是配合Navigation使用的特殊子组件，默认提供点击响应处理，不需要开发者自定义点击事件逻辑。NavRouter有且仅有两个子组件，其中第二个子组件必须是NavDestination。NavDestination是配合NavRouter使用的特殊子组件，用于显示Navigation组件的内容页。当开发者点击NavRouter组件时，会跳转到对应的NavDestination内容区。  设置页面显示模式 Navigation组件通过mode属性设置页面的显示模式。  自适应模式Navigation组件默认为自适应模式，此时mode属性为NavigationMode.Auto。自适应模式下，当设备宽度大于520vp时，Navigation组件采用分栏模式，反之采用单页面模式。 已复制Navigation() {  ...}.mode(NavigationMode.Auto)   单页面模式        图1 单页面布局示意图   将mode属性设置为NavigationMode.Stack，Navigation组件即可设置为单页面显示模式。 已复制Navigation() {  ...}.mode(NavigationMode.Stack)  分栏模式        图2 分栏布局示意图  将mode属性设置为NavigationMode.Split，Navigation组件即可设置为分栏显示模式。 已复制@Entry@Componentstruct NavigationExample {  private arr: number[] = [1, 2, 3];
  build() {    Column() {      Navigation() {        TextInput({ placeholder: 'search...' })          .width("90%")          .height(40)          .backgroundColor('#FFFFFF')
        List({ space: 12 }) {          ForEach(this.arr, (item) => {            ListItem() {              NavRouter() {                Text("NavRouter" + item)                  .width("100%")                  .height(72)                  .backgroundColor('#FFFFFF')                  .borderRadius(24)                  .fontSize(16)                  .fontWeight(500)                  .textAlign(TextAlign.Center)                NavDestination() {                  Text("NavDestinationContent" + item)                }                .title("NavDestinationTitle" + item)              }            }          }, item => item)        }        .width("90%")        .margin({ top: 12 })      }      .title("主标题")      .mode(NavigationMode.Split)      .menus([        {value: "", icon: "./image/ic_public_search.svg", action: ()=> {}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=> {}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=> {}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=> {}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=> {}}      ])      .toolBar({items: [        {value: "func", icon: "./image/ic_public_highlights.svg", action: ()=> {}},        {value: "func", icon: "./image/ic_public_highlights.svg", action: ()=> {}},        {value: "func", icon: "./image/ic_public_highlights.svg", action: ()=> {}}      ]})    }    .height('100%')    .width('100%')    .backgroundColor('#F1F3F5')  }}     设置标题栏模式 标题栏在界面顶部，用于呈现界面名称和操作入口，Navigation组件通过titleMode属性设置标题栏模式。  Mini模式               普通型标题栏，用于一级页面不需要突出标题的场景。         图3 Mini模式标题栏  已复制Navigation() {  ...}.titleMode(NavigationTitleMode.Mini)     Full模式强调型标题栏，用于一级页面需要突出标题的场景。  图4 Full模式标题栏  已复制Navigation() {  ...}.titleMode(NavigationTitleMode.Full)   设置菜单栏 菜单栏位于Navigation组件的右上角，开发者可以通过menus属性进行设置。menus支持Array<NavigationMenuItem>和CustomBuilder两种参数类型。使用Array<NavigationMenuItem>类型时，竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。  图5 设置了3个图标的菜单栏  已复制Navigation() {  ...}.menus([{value: "", icon: "./image/ic_public_search.svg", action: ()=>{}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=>{}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=>{}}])   图6 设置了4个图标的菜单栏  已复制Navigation() {  ...}.menus([{value: "", icon: "./image/ic_public_search.svg", action: ()=>{}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=>{}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=>{}},        {value: "", icon: "./image/ic_public_add.svg", action: ()=>{}}])  设置工具栏 工具栏位于Navigation组件的底部，开发者可以通过toolBar属性进行设置。   图7 工具栏  已复制Navigation() {  ...}.toolBar({items:[        {value: "func", icon: "./image/ic_public_highlights.svg", action: ()=>{}},        {value: "func", icon: "./image/ic_public_highlights.svg", action: ()=>{}},        {value: "func", icon: "./image/ic_public_highlights.svg", action: ()=>{}}]})  上一篇 组件导航 下一篇 Tabs 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本布局底部导航顶部导航侧边导航限制导航栏的滑动切换固定导航栏滚动导航栏自定义导航栏切换至指定页签滑动切换导航栏Tabs 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  当页面信息较多时，为了让用户能够聚焦于当前显示的内容，需要对页面内容进行分类，提高页面空间利用率。Tabs组件可以在一个页面内快速实现视图内容的切换，一方面提升查找信息的效率，另一方面精简用户单次获取到的信息量。  基本布局       Tabs组件的页面组成包含两个部分，分别是TabContent和TabBar。TabContent是内容页，TabBar是导航页签栏，页面结构如下图所示，根据不同的导航类型，布局会有区别，可以分为底部导航、顶部导航、侧边导航，其导航栏分别位于底部、顶部和侧边。       图1 Tabs组件布局示意图    
说明
  TabContent组件不支持设置通用宽度属性，其宽度默认撑满Tabs父组件。 TabContent组件不支持设置通用高度属性，其高度由Tabs父组件高度与TabBar组件高度决定。  
 Tabs使用花括号包裹TabContent，如图2，其中TabContent显示相应的内容页。  图2 Tabs与TabContent使用   每一个TabContent对应的内容需要有一个页签，可以通过TabContent的tabBar属性进行配置。在如下TabContent组件上设置属性tabBar，可以设置其对应页签中的内容，tabBar作为内容的页签。 已复制 TabContent() {   Text('首页的内容').fontSize(30) }.tabBar('首页') 设置多个内容时，需在Tabs内按照顺序放置。 已复制Tabs() {  TabContent() {    Text('首页的内容').fontSize(30)  }  .tabBar('首页')
  TabContent() {    Text('推荐的内容').fontSize(30)  }  .tabBar('推荐')
  TabContent() {    Text('发现的内容').fontSize(30)  }  .tabBar('发现')    TabContent() {    Text('我的内容').fontSize(30)  }  .tabBar("我的")}  底部导航 底部导航是应用中最常见的一种导航方式。底部导航位于应用一级页面的底部，用户打开应用，能够分清整个应用的功能分类，以及页签对应的内容，并且其位于底部更加方便用户单手操作。底部导航一般作为应用的主导航形式存在，其作用是将用户关心的内容按照功能进行分类，迎合用户使用习惯，方便在不同模块间的内容切换。   图3 底部导航栏  导航栏位置使用Tabs的参数barPosition进行设置，默认情况下，导航栏位于顶部，参数默认值为Start。设置为底部导航需要在Tabs传递参数，设置barPosition为End。 已复制Tabs({ barPosition: BarPosition.End }) {  // TabContent的内容：首页、发现、推荐、我的  ...}  顶部导航 当内容分类较多，用户对不同内容的浏览概率相差不大，需要经常快速切换时，一般采用顶部导航模式进行设计，作为对底部导航内容的进一步划分，常见一些资讯类应用对内容的分类为关注、视频、数码，或者手机的主题应用中对主题进行进一步划分为图片、视频、字体等。  图4 顶部导航栏  Tabs组件默认的barPosition参数为Start，即顶部导航模式。 已复制Tabs({ barPosition: BarPosition.Start }) {  // TabContent的内容:关注、视频、游戏、数码、科技、体育、影视  ...}   侧边导航 侧边导航是手机应用较为少见的一种导航模式，更多适用于平板横屏界面，用于对应用进行导航操作，由于用户的视觉习惯是从左到右，侧边导航栏默认为左侧侧边栏。   图5 侧边导航栏  实现侧边导航栏需要设置Tabs的属性vertical为true。在底部导航和顶部导航实现中，其默认值为false，表明内容页和导航栏垂直方向排列。 已复制Tabs({ barPosition: BarPosition.Start }) {  // TabContent的内容:首页、发现、推荐、我的  ...}.vertical(true).barWidth(100).barHeight(200) 
说明
  vertical为false时，tabbar宽度会默认撑满屏幕的宽度，需要设置barWidth为合适值。 vertical为true时，tabbar的高度会默认实际内容高度，需要设置barHeight为合适值。  
  限制导航栏的滑动切换       默认情况下，导航栏都支持滑动切换，在一些内容信息量需要进行多级分类的页面，如支持底部导航+顶部导航组合的情况下，底部导航栏的滑动效果与顶部导航出现冲突，此时需要限制底部导航的滑动，避免引起不好的用户体验。       图6 限制底部导航栏滑动    控制滑动切换的属性为scrollable，默认值为true，表示可以滑动，若要限制滑动切换页签则需要设置为false。 已复制Tabs({ barPosition: BarPosition.End }) {  TabContent(){    Column(){      Tabs(){        // 顶部导航栏内容        ...      }    }    .backgroundColor('#ff08a8f1')    .width('100%')  }  .tabBar('首页')
  // 其他TabContent内容：发现、推荐、我的  ...}.scrollable(false)  固定导航栏 当内容分类较为固定且不具有拓展性时，例如底部导航内容分类一般固定，分类数量一般在3-5个，此时使用固定导航栏。固定导航栏不可滚动，无法被拖拽滚动，内容均分tabBar的宽度。   图7 固定导航栏  Tabs的属性barMode是控制导航栏是否可以滚动，默认值为Fixed。 已复制Tabs({ barPosition: BarPosition.End }) {  // TabContent的内容：首页、发现、推荐、我的  ...}.barMode(BarMode.Fixed)  滚动导航栏 滚动导航栏可以用于顶部导航栏或者侧边导航栏的设置，内容分类较多，屏幕宽度无法容纳所有分类页签的情况下，需要使用可滚动的导航栏，支持用户点击和滑动来加载隐藏的页签内容。   图8 可滚动导航栏  滚动导航栏需要设置Tabs组件的barMode属性，默认情况下其值为Fixed，表示为固定导航栏，设置为Scrollable即可设置为可滚动导航栏。 已复制Tabs({ barPosition: BarPosition.Start }) {  // TabContent的内容：关注、视频、游戏、数码、科技、体育、影视、人文、艺术、自然、军事  ...}.barMode(BarMode.Scrollable)  自定义导航栏 对于底部导航栏，一般作为应用主页面功能区分，为了更好的用户体验，会组合文字以及对应语义图标表示页签内容，这种情况下，需要自定义导航页签的样式。   图9 自定义导航栏图  系统默认情况下采用了下划线标志当前活跃的页签，而自定义导航栏需要自行实现相应的样式，用于区分当前活跃页签和未活跃页签。 设置自定义导航栏需要使用tabBar的参数，以其支持的CustomBuilder的方式传入自定义的函数组件样式。例如这里声明TabBuilder的自定义函数组件，传入参数包括页签文字title，对应位置index，以及选中状态和未选中状态的图片资源。通过当前活跃的currentIndex和页签对应的targetIndex匹配与否，决定UI显示的样式。 已复制@Builder TabBuilder(title: string, targetIndex: number, selectedImg: Resource, normalImg: Resource) {  Column() {    Image(this.currentIndex === targetIndex ? selectedImg : normalImg)      .size({ width: 25, height: 25 })    Text(title)      .fontColor(this.currentIndex === targetIndex ? '#1698CE' : '#6B6B6B')  }  .width('100%')  .height(50)  .justifyContent(FlexAlign.Center)} 在TabContent对应tabBar属性中传入自定义函数组件，并传递相应的参数。 已复制TabContent() {  Column(){    Text('我的内容')    }  .width('100%')  .height('100%')  .backgroundColor('#007DFF')}.tabBar(this.TabBuilder('我的', 0, $r('app.media.mine_selected'), $r('app.media.mine_normal')))  切换至指定页签 在不使用自定义导航栏时，系统默认的Tabs会实现切换逻辑。在使用了自定义导航栏后，切换页签的逻辑需要手动实现。即用户点击对应页签时，屏幕需要显示相应的内容页。   图10 使用自定义导航栏实现切换指定页签  切换指定页签需要使用TabsController，TabsController是Tabs组件的控制器，用于控制Tabs组件进行页签切换。通过TabsController的changeIndex方法来实现跳转至指定索引值对应的TabContent内容。 已复制private tabsController : TabsController = new TabsController()@State currentIndex:number = 0;
@Builder TabBuilder(title: string, targetIndex: number) {  Column() {    Text(title)      .fontColor(this.currentIndex === targetIndex ? '#1698CE' : '#6B6B6B')  }  ...  .onClick(() => {    this.currentIndex = targetIndex;    this.tabsController.changeIndex(this.currentIndex);  })} 使用自定义导航栏时，在tabBar属性中传入对应的@Builder，并传入相应的参数。 已复制Tabs({ barPosition: BarPosition.End, controller: this.tabsController }) {  TabContent(){    ...  }.tabBar(this.TabBuilder('首页',0))
  TabContent(){    ...  }.tabBar(this.TabBuilder('发现',1))
  TabContent(){    ...  }.tabBar(this.TabBuilder('推荐',2))
  TabContent(){    ...  }  .tabBar(this.TabBuilder('我的',3))}  滑动切换导航栏 在不使用自定义导航栏的情况下，Tabs默认会实现tabBar与TabContent的切换联动。但在使用了自定义导航栏后，使用TabsController可以实现点击页签与页面内容的联动，但不能实现滑动页面时，页面内容对应页签的联动。即用户在使用滑动屏幕切换页面内容时，页签栏需要同步切换至内容对应的页签。   图11 滑动切换时页签内容不联动  此时需要使用Tabs提供的onChange事件方法，监听索引index的变化，并将其当前活跃的index值传递给currentIndex，实现页签内容的切换。 已复制Tabs({ barPosition: BarPosition.End, controller: this.tabsController }) {  TabContent() {    ...  }.tabBar(this.TabBuilder('首页', 0))
  TabContent() {    ...  }.tabBar(this.TabBuilder('发现', 1))
  TabContent() {    ...  }.tabBar(this.TabBuilder('推荐', 2))
  TabContent() {    ...  }  .tabBar(this.TabBuilder('我的', 3))}.onChange((index) => {  this.currentIndex = index})  图12 内容与页签联动   上一篇 Navigation 下一篇 显示图形 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述限制条件装饰器说明变量的传递/访问规则说明观察变化和行为表现观察的变化框架行为使用场景嵌套对象对象数组二维数组@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 上文所述的装饰器仅能观察到第一层的变化，但是在实际应用开发中，应用会根据开发需要，封装自己的数据模型。对于多层嵌套的情况，比如二维数组，或者数组项class，或者class的属性是class，他们的第二层的属性变化是无法观察到的。这就引出了@Observed/@ObjectLink装饰器。 
说明
从API version 9开始，这两个装饰器支持在ArkTS卡片中使用。 
 概述@ObjectLink和@Observed类装饰器用于在涉及嵌套对象或数组的场景中进行双向数据同步： 被@Observed装饰的类，可以被观察到属性的变化；子组件中@ObjectLink装饰器装饰的状态变量用于接收@Observed装饰的类的实例，和父组件中对应的状态变量建立双向数据绑定。这个实例可以是数组中的被@Observed装饰的项，或者是class object中的属性，这个属性同样也需要被@Observed装饰。单独使用@Observed是没有任何作用的，需要搭配@ObjectLink或者@Prop使用。  限制条件使用@Observed装饰class会改变class原始的原型链，@Observed和其他类装饰器装饰同一个class可能会带来问题。@ObjectLink装饰器不能在@Entry装饰的自定义组件中使用。  装饰器说明 @Observed类装饰器  说明    装饰器参数  无   类装饰器  装饰class。需要放在class的定义前，使用new创建类对象。     @ObjectLink变量装饰器  说明    装饰器参数  无   同步类型  不与父组件中的任何类型同步变量。   允许装饰的变量类型  必须为被@Observed装饰的class实例，必须指定类型。 不支持简单类型，可以使用@Prop。 @ObjectLink的属性是可以改变的，但是变量的分配是不允许的，也就是说这个装饰器装饰变量是只读的，不能被改变。   被装饰变量的初始值  不允许。     @ObjectLink装饰的数据为可读示例。 已复制// 允许@ObjectLink装饰的数据属性赋值this.objLink.a= ...// 不允许@ObjectLink装饰的数据自身赋值this.objLink= ... 
说明
@ObjectLink装饰的变量不能被赋值，如果要使用赋值操作，请使用@Prop。 @Prop装饰的变量和数据源的关系是是单向同步，@Prop装饰的变量在本地拷贝了数据源，所以它允许本地更改，如果父组件中的数据源有更新，@Prop装饰的变量本地的修改将被覆盖；@ObjectLink装饰的变量和数据源的关系是双向同步，@ObjectLink装饰的变量相当于指向数据源的指针。如果一旦发生@ObjectLink装饰的变量的赋值，则同步链将被打断。 
  变量的传递/访问规则说明 @ObjectLink传递/访问  说明    从父组件初始化  必须指定。 初始化@ObjectLink装饰的变量必须同时满足以下场景： 类型必须是@Observed装饰的class。初始化的数值需要是数组项，或者class的属性。同步源的class或者数组必须是@State，@Link，@Provide，@Consume或者@ObjectLink装饰的数据。 同步源是数组项的示例请参考对象数组。初始化的class的示例请参考嵌套对象。   与源对象同步  双向。   可以初始化子组件  允许，可用于初始化常规变量、@State、@Link、@Prop、@Provide      图1 初始化规则图示  观察变化和行为表现 观察的变化@Observed装饰的类，如果其属性为非简单类型，比如class、Object或者数组，也需要被@Observed装饰，否则将观察不到其属性的变化。 已复制class ClassA {  public c: number;
  constructor(c: number) {    this.c = c;  }}
@Observedclass ClassB {  public a: ClassA;  public b: number;
  constructor(a: ClassA, b: number) {    this.a = a;    this.b = b;  }} 以上示例中，ClassB被@Observed装饰，其成员变量的赋值的变化是可以被观察到的，但对于ClassA，没有被@Observed装饰，其属性的修改不能被观察到。 已复制@ObjectLink b: ClassB
// 赋值变化可以被观察到this.b.a = new ClassA(5)this.b.b = 5
// ClassA没有被@Observed装饰，其属性的变化观察不到this.b.a.c = 5 @ObjectLink：@ObjectLink只能接收被@Observed装饰class的实例，可以观察到： 其属性的数值的变化，其中属性是指Object.keys(observedObject)返回的所有属性，示例请参考嵌套对象。 如果数据源是数组，则可以观察到数组item的替换，如果数据源是class，可观察到class的属性的变化，示例请参考对象数组。  框架行为初始渲染：@Observed装饰的class的实例会被不透明的代理对象包装，代理了class上的属性的setter和getter方法子组件中@ObjectLink装饰的从父组件初始化，接收被@Observed装饰的class的实例，@ObjectLink的包装类会将自己注册给@Observed class。 属性更新：当@Observed装饰的class属性改变时，会走到代理的setter和getter，然后遍历依赖它的@ObjectLink包装类，通知数据更新。  使用场景 嵌套对象以下是嵌套类对象的数据结构。 已复制// objectLinkNestedObjects.etslet NextID: number = 1;
@Observedclass ClassA {  public id: number;  public c: number;
  constructor(c: number) {    this.id = NextID++;    this.c = c;  }}
@Observedclass ClassB {  public a: ClassA;
  constructor(a: ClassA) {    this.a = a;  }}  以下组件层次结构呈现的是嵌套类对象的数据结构。已复制@Componentstruct ViewA {  label: string = 'ViewA1';  @ObjectLink a: ClassA;
  build() {    Row() {      Button(`ViewA [${this.label}] this.a.c=${this.a.c} +1`)        .onClick(() => {          this.a.c += 1;        })    }  }}
@Entry@Componentstruct ViewB {  @State b: ClassB = new ClassB(new ClassA(0));
  build() {    Column() {      // in low version,DevEco may throw a warning,but it does not matter.      // you can still compile and run.      ViewA({ label: 'ViewA #1', a: this.b.a })      ViewA({ label: 'ViewA #2', a: this.b.a })
      Button(`ViewB: this.b.a.c+= 1`)        .onClick(() => {          this.b.a.c += 1;        })      Button(`ViewB: this.b.a = new ClassA(0)`)        .onClick(() => {          this.b.a = new ClassA(0);        })      Button(`ViewB: this.b = new ClassB(ClassA(0))`)        .onClick(() => {          this.b = new ClassB(new ClassA(0));        })    }  }}  ViewB中的事件句柄： this.b.a = new ClassA(0) 和this.b = new ClassB(new ClassA(0))： 对@State装饰的变量b和其属性的修改。this.b.a.c = ... ：该变化属于第二层的变化，@State无法观察到第二层的变化，但是ClassA被@Observed装饰，ClassA的属性c的变化可以被@ObjectLink观察到。 ViewA中的事件句柄： this.a.c += 1：对@ObjectLink变量a的修改，将触发Button组件的刷新。@ObjectLink和@Prop不同，@ObjectLink不拷贝来自父组件的数据源，而是在本地构建了指向其数据源的引用。@ObjectLink变量是只读的，this.a = new ClassA(...)是不允许的，因为一旦赋值操作发生，指向数据源的引用将被重置，同步将被打断。 对象数组对象数组是一种常用的数据结构。以下示例展示了数组对象的用法。 已复制let NextID: number = 1;
@Observedclass ClassA {  public id: number;  public c: number;
  constructor(c: number) {    this.id = NextID++;    this.c = c;  }}@Componentstruct ViewA {  // 子组件ViewA的@ObjectLink的类型是ClassA  @ObjectLink a: ClassA;  label: string = 'ViewA1';
  build() {    Row() {      Button(`ViewA [${this.label}] this.a.c = ${this.a.c} +1`)        .onClick(() => {          this.a.c += 1;        })    }  }}
@Entry@Componentstruct ViewB {  // ViewB中有@State装饰的ClassA[]  @State arrA: ClassA[] = [new ClassA(0), new ClassA(0)];
  build() {    Column() {      ForEach(this.arrA,        (item) => {          ViewA({ label: `#${item.id}`, a: item })        },        (item) => item.id.toString()      )      // 使用@State装饰的数组的数组项初始化@ObjectLink，其中数组项是被@Observed装饰的ClassA的实例      ViewA({ label: `ViewA this.arrA[first]`, a: this.arrA[0] })      ViewA({ label: `ViewA this.arrA[last]`, a: this.arrA[this.arrA.length-1] })
      Button(`ViewB: reset array`)        .onClick(() => {          this.arrA = [new ClassA(0), new ClassA(0)];        })      Button(`ViewB: push`)        .onClick(() => {          this.arrA.push(new ClassA(0))        })      Button(`ViewB: shift`)        .onClick(() => {          this.arrA.shift()        })      Button(`ViewB: chg item property in middle`)        .onClick(() => {          this.arrA[Math.floor(this.arrA.length / 2)].c = 10;        })      Button(`ViewB: chg item property in middle`)        .onClick(() => {          this.arrA[Math.floor(this.arrA.length / 2)] = new ClassA(11);        })    }  }} this.arrA[Math.floor(this.arrA.length/2)] = new ClassA(..) ：该状态变量的改变触发2次更新：ForEach：数组项的赋值导致ForEach的itemGenerator被修改，因此数组项被识别为有更改，ForEach的item builder将执行，创建新的ViewA组件实例。ViewA({ label: `ViewA this.arrA[last]`, a: this.arrA[this.arrA.length-1] })：上述更改改变了数组中第二个元素，所以绑定this.arrA[1]的ViewA将被更新； this.arrA.push(new ClassA(0)) ： 将触发2次不同效果的更新：ForEach：新添加的ClassA对象对于ForEach是未知的itemGenerator，ForEach的item builder将执行，创建新的ViewA组件实例。ViewA({ label: `ViewA this.arrA[last]`, a: this.arrA[this.arrA.length-1] })：数组的最后一项有更改，因此引起第二个ViewA的实例的更改。对于ViewA({ label: `ViewA this.arrA[first]`, a: this.arrA[0] })，数组的更改并没有触发一个数组项更改的改变，所以第一个ViewA不会刷新。 this.arrA[Math.floor(this.arrA.length/2)].c：@State无法观察到第二层的变化，但是ClassA被@Observed装饰，ClassA的属性的变化将被@ObjectLink观察到。  二维数组使用@Observed观察二维数组的变化。可以声明一个被@Observed装饰的继承Array的子类。 已复制@Observedclass StringArray extends Array<String> {} 使用new StringArray()来构造StringArray的实例，new运算符使得@Observed生效，@Observed观察到StringArray的属性变化。 声明一个从Array扩展的类class StringArray extends Array<String> {}，并创建StringArray的实例。@Observed装饰的类需要使用new运算符来构建class实例。 已复制@Observedclass StringArray extends Array<String> {}
@Componentstruct ItemPage {  @ObjectLink itemArr: StringArray;
  build() {    Row() {      Text('ItemPage')        .width(100).height(100)
      ForEach(this.itemArr,        item => {          Text(item)            .width(100).height(100)        },        item => item      )    }  }}
@Entry@Componentstruct IndexPage {  @State arr: Array<StringArray> = [new StringArray(), new StringArray(), new StringArray()];
  build() {    Column() {      ItemPage({ itemArr: this.arr[0] })      ItemPage({ itemArr: this.arr[1] })      ItemPage({ itemArr: this.arr[2] })
      Divider()
      ForEach(this.arr,        itemArr => {          ItemPage({ itemArr: itemArr })        },        itemArr => itemArr[0]      )
      Divider()
      Button('update')        .onClick(() => {          console.error('Update all items in arr');          if (this.arr[0][0] !== undefined) {            // 正常情况下需要有一个真实的ID来与ForEach一起使用，但此处没有            // 因此需要确保推送的字符串是唯一的。            this.arr[0].push(`${this.arr[0].slice(-1).pop()}${this.arr[0].slice(-1).pop()}`);            this.arr[1].push(`${this.arr[1].slice(-1).pop()}${this.arr[1].slice(-1).pop()}`);            this.arr[2].push(`${this.arr[2].slice(-1).pop()}${this.arr[2].slice(-1).pop()}`);          } else {            this.arr[0].push('Hello');            this.arr[1].push('World');            this.arr[2].push('!');          }        })    }  }}   上一篇 @Provide装饰器和@Consume装饰器：与后代组件双向同步 下一篇 管理应用拥有的状态 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。其他状态管理 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    其他状态管理概述  @Watch装饰器：状态变量更改通知  $$语法：内置组件双向同步   上一篇 Environment：设备环境查询 下一篇 其他状态管理概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。其他状态管理概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 除了前面章节提到的组件状态管理和应用状态管理，ArkTS还提供了@Watch和$$来为开发者提供更多功能： @Watch用于监听状态变量的变化。$$运算符：给内置组件提供TS变量的引用，使得TS变量和内置组件的内部状态保持同步。  上一篇 其他状态管理 下一篇 @Watch装饰器：状态变量更改通知 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。自定义组件的创建和渲染流程自定义组件重新渲染自定义组件的删除页面和自定义组件生命周期 更新时间: 2024-03-25 11:20 毫无帮助帮助不大一般很好非常好
分享
  在开始之前，我们先明确自定义组件和页面的关系：  自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用，可以调用组件的生命周期。 页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。  页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：  onPageShow：页面每次显示时触发一次，包括路由过程、应用进入前台等场景。 onPageHide：页面每次隐藏时触发一次，包括路由过程、应用进入后台等场景。 onBackPress：当用户点击返回按钮时触发。  组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：  aboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。 aboutToDisappear：在自定义组件析构销毁之前执行。不允许在aboutToDisappear函数中改变状态变量，特别是@Link变量的修改可能会导致应用程序行为不稳定。  生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（页面）生命周期。    根据上面的流程图，我们从自定义组件的初始创建、重新渲染和删除来详细解释。  自定义组件的创建和渲染流程  自定义组件的创建：自定义组件的实例由ArkUI框架创建。 初始化自定义组件的成员变量：通过本地默认值或者构造方法传递参数来初始化自定义组件的成员变量，初始化顺序为成员变量的定义顺序。 如果开发者定义了aboutToAppear，则执行aboutToAppear方法。 在首次渲染的时候，执行build方法渲染系统组件，如果子组件为自定义组件，则创建自定义组件的实例。在首次渲染的过程中，框架会记录状态变量和组件的映射关系，当状态变量改变时，驱动其相关的组件刷新。   当应用在后台启动时，此时应用进程并没有销毁，所以仅需要执行onPageShow。  自定义组件重新渲染 当事件句柄被触发（比如设置了点击事件，即触发点击事件）改变了状态变量时，或者LocalStorage / AppStorage中的属性更改，并导致绑定的状态变量更改其值时：   框架观察到了变化，将启动重新渲染。 根据框架持有的两个map（自定义组件的创建和渲染流程中第4步），框架可以知道该状态变量管理了哪些UI组件，以及这些UI组件对应的更新函数。执行这些UI组件的更新函数，实现最小化更新。   自定义组件的删除 如果if组件的分支改变，或者ForEach循环渲染中数组的个数改变，组件将被删除：   在删除组件之前，将调用其aboutToDisappear生命周期函数，标记着该节点将要被销毁。ArkUI的节点删除机制是：后端节点直接从组件树上摘下，后端节点被销毁，对前端节点解引用，前端节点已经没有引用时，将被JS虚拟机垃圾回收。 自定义组件和它的变量将被删除，如果其有同步的变量，比如@Link、@Prop、@StorageLink，将从同步源上取消注册。  不建议在生命周期aboutToDisappear内使用async await，如果在生命周期的aboutToDisappear使用异步操作（Promise或者回调方法），自定义组件将被保留在Promise的闭包中，直到回调方法被执行完，这个行为阻止了自定义组件的垃圾回收。 以下示例展示了生命周期的调用时机： 已复制// Index.etsimport router from '@ohos.router';
@Entry@Componentstruct MyComponent {  @State showChild: boolean = true;
  // 只有被@Entry装饰的组件才可以调用页面的生命周期  onPageShow() {    console.info('Index onPageShow');  }  // 只有被@Entry装饰的组件才可以调用页面的生命周期  onPageHide() {    console.info('Index onPageHide');  }
  // 只有被@Entry装饰的组件才可以调用页面的生命周期  onBackPress() {    console.info('Index onBackPress');  }
  // 组件生命周期  aboutToAppear() {    console.info('MyComponent aboutToAppear');  }
  // 组件生命周期  aboutToDisappear() {    console.info('MyComponent aboutToDisappear');  }
  build() {    Column() {      // this.showChild为true，创建Child子组件，执行Child aboutToAppear      if (this.showChild) {        Child()      }      // this.showChild为false，删除Child子组件，执行Child aboutToDisappear      Button('delete Child').onClick(() => {        this.showChild = false;      })      // push到Page2页面，执行onPageHide      Button('push to next page')        .onClick(() => {          router.pushUrl({ url: 'pages/Page2' });        })    }
  }}
@Componentstruct Child {  @State title: string = 'Hello World';  // 组件生命周期  aboutToDisappear() {    console.info('[lifeCycle] Child aboutToDisappear')  }  // 组件生命周期  aboutToAppear() {    console.info('[lifeCycle] Child aboutToAppear')  }
  build() {    Text(this.title).fontSize(50).onClick(() => {      this.title = 'Hello ArkUI';    })  }} 以上示例中，Index页面包含两个自定义组件，一个是被@Entry装饰的MyComponent，也是页面的入口组件，即页面的根节点；一个是Child，是MyComponent的子组件。只有@Entry装饰的节点才可以使页面级别的生命周期方法生效，所以MyComponent中声明了当前Index页面的页面生命周期函数。MyComponent和其子组件Child也同时也声明了组件的生命周期函数。  应用冷启动的初始化流程为：MyComponent aboutToAppear --> MyComponent build --> Child aboutToAppear --> Child build --> Child build执行完毕 --> MyComponent build执行完毕 --> Index onPageShow。 点击“delete Child”，if绑定的this.showChild变成false，删除Child组件，会执行Child aboutToDisappear方法。   点击“push to next page”，调用router.pushUrl接口，跳转到另外一个页面，当前Index页面隐藏，执行页面生命周期Index onPageHide。此处调用的是router.pushUrl接口，Index页面被隐藏，并没有销毁，所以只调用onPageHide。跳转到新页面后，执行初始化新页面的生命周期的流程。 如果调用的是router.replaceUrl，则当前Index页面被销毁，执行的生命周期流程将变为：Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。上文已经提到，组件的销毁是从组件树上直接摘下子树，所以先调用父组件的aboutToDisappear，再调用子组件的aboutToDisappear，然后执行初始化新页面的生命周期流程。 点击返回按钮，触发页面生命周期Index onBackPress，且触发返回一个页面后会导致当前Index页面被销毁。 最小化应用或者应用进入后台，触发Index onPageHide。当前Index页面没有被销毁，所以并不会执行组件的aboutToDisappear。应用回到前台，执行Index onPageShow。   退出应用，执行Index onPageHide --> MyComponent aboutToDisappear --> Child aboutToDisappear。   上一篇 创建自定义组件 下一篇 @Builder装饰器：自定义构建函数 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。type配置为RouteType.Nonetype配置为RouteType.Push或RouteType.Pop禁用某页面的页面转场场景示例页面转场动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  两个页面间发生跳转，一个页面消失，另一个页面出现，这时可以配置各自页面的页面转场参数实现自定义的页面转场效果。页面转场效果写在pageTransition函数中，通过PageTransitionEnter和PageTransitionExit指定页面进入和退出的动画效果。 PageTransitionEnter的接口为： 已复制PageTransitionEnter({type?: RouteType,duration?: number,curve?: Curve | string,delay?: number}) PageTransitionExit的接口为： 已复制PageTransitionExit({type?: RouteType,duration?: number,curve?: Curve | string,delay?: number}) 上述接口定义了PageTransitionEnter和PageTransitionExit组件，可通过slide、translate、scale、opacity属性定义不同的页面转场效果。对于PageTransitionEnter而言，这些效果表示入场时起点值，对于PageTransitionExit而言，这些效果表示退场的终点值，这一点与组件转场transition配置方法类似。此外，PageTransitionEnter提供了onEnter接口进行自定义页面入场动画的回调，PageTransitionExit提供了onExit接口进行自定义页面退场动画的回调。 上述接口中的参数type，表示路由生效的类型，这一点开发者容易混淆其含义。页面转场的两个页面，必定有一个页面退出，一个页面进入。如果通过router.pushUrl操作从页面A跳转到页面B，则页面A退出，做页面退场动画，页面B进入，做页面入场动画。如果通过router.back操作从页面B返回到页面A，则页面B退出，做页面退场动画，页面A进入，做页面入场动画。即页面的PageTransitionEnter既可能是由于新增页面(push，入栈)引起的新页面的入场动画，也可能是由于页面返回(back，或pop，出栈)引起的页面栈中老页面的入场动画，为了能区分这两种形式的入场动画，提供了type参数，这样开发者能完全定义所有类型的页面转场效果。  type配置为RouteType.None type为RouteType.None表示对页面栈的push、pop操作均生效，type的默认值为RouteType.None。 已复制// page ApageTransition() {  // 定义页面进入时的效果，从左侧滑入，时长为1200ms，无论页面栈发生push还是pop操作均可生效  PageTransitionEnter({ type: RouteType.None, duration: 1200 })    .slide(SlideEffect.Left)  // 定义页面退出时的效果，向左侧滑出，时长为1000ms，无论页面栈发生push还是pop操作均可生效  PageTransitionExit({ type: RouteType.None, duration: 1000 })    .slide(SlideEffect.Left)}  已复制// page BpageTransition() {  // 定义页面进入时的效果，从右侧滑入，时长为1000ms，无论页面栈发生push还是pop操作均可生效  PageTransitionEnter({ type: RouteType.None, duration: 1000 })    .slide(SlideEffect.Right)  // 定义页面退出时的效果，向右侧滑出，时长为1200ms，无论页面栈发生push还是pop操作均可生效  PageTransitionExit({ type: RouteType.None, duration: 1200 })    .slide(SlideEffect.Right)} 假设页面栈为标准实例模式，即页面栈中允许存在重复的页面。可能会有4种场景，对应的页面转场效果如下表。     路由操作 页面A转场效果 页面B转场效果    router.pushUrl，从页面A跳转到新增的页面B 页面退出，PageTransitionExit生效，向左侧滑出屏幕 页面进入，PageTransitionEnter生效，从右侧滑入屏幕   router.back，从页面B返回到页面A 页面进入，PageTransitionEnter生效，从左侧滑入屏幕 页面退出，PageTransitionExit生效，向右侧滑出屏幕   router.pushUrl，从页面B跳转到新增的页面A 页面进入，PageTransitionEnter生效，从左侧滑入屏幕 页面退出，PageTransitionExit生效，向右侧滑出屏幕   router.back，从页面A返回到页面B 页面退出，PageTransitionExit生效，向左侧滑出屏幕 页面进入，PageTransitionEnter生效，从右侧滑入屏幕    如果希望pushUrl进入的页面总是从右侧滑入，back时退出的页面总是从右侧滑出，则上表中的第3、4种情况不满足要求，那么需要完整的定义4个页面转场效果。  type配置为RouteType.Push或RouteType.Pop type为RouteType.Push表示仅对页面栈的push操作生效，type为RouteType.Pop表示仅对页面栈的pop操作生效。 已复制// page ApageTransition() {  // 定义页面进入时的效果，从右侧滑入，时长为1200ms，页面栈发生push操作时该效果才生效  PageTransitionEnter({ type: RouteType.Push, duration: 1200 })    .slide(SlideEffect.Right)  // 定义页面进入时的效果，从左侧滑入，时长为1200ms，页面栈发生pop操作时该效果才生效  PageTransitionEnter({ type: RouteType.Pop, duration: 1200 })    .slide(SlideEffect.Left)  // 定义页面退出时的效果，向左侧滑出，时长为1000ms，页面栈发生push操作时该效果才生效  PageTransitionExit({ type: RouteType.Push, duration: 1000 })    .slide(SlideEffect.Left)  // 定义页面退出时的效果，向右侧滑出，时长为1000ms，页面栈发生pop操作时该效果才生效  PageTransitionExit({ type: RouteType.Pop, duration: 1000 })    .slide(SlideEffect.Right)}  已复制// page BpageTransition() {  // 定义页面进入时的效果，从右侧滑入，时长为1000ms，页面栈发生push操作时该效果才生效  PageTransitionEnter({ type: RouteType.Push, duration: 1000 })    .slide(SlideEffect.Right)  // 定义页面进入时的效果，从左侧滑入，时长为1000ms，页面栈发生pop操作时该效果才生效  PageTransitionEnter({ type: RouteType.Pop, duration: 1000 })    .slide(SlideEffect.Left)  // 定义页面退出时的效果，向左侧滑出，时长为1200ms，页面栈发生push操作时该效果才生效  PageTransitionExit({ type: RouteType.Push, duration: 1200 })    .slide(SlideEffect.Left)  // 定义页面退出时的效果，向右侧滑出，时长为1200ms，页面栈发生pop操作时该效果才生效  PageTransitionExit({ type: RouteType.Pop, duration: 1200 })    .slide(SlideEffect.Right)} 以上代码则完整的定义了所有可能的页面转场样式。假设页面栈为标准实例模式，即页面栈中允许存在重复的页面。可能会有4种场景，对应的页面转场效果如下表。     路由操作 页面A转场效果 页面B转场效果    router.pushUrl，从页面A跳转到新增的页面B 页面退出，PageTransitionExit且type为RouteType.Push的转场样式生效，向左侧滑出屏幕 页面进入，PageTransitionEnter且type为RouteType.Push的转场样式生效，从右侧滑入屏幕   router.back，从页面B返回到页面A 页面进入，PageTransitionEnter且type为RouteType.Pop的转场样式生效，从左侧滑入屏幕 页面退出，PageTransitionExit且type为RouteType.Pop的转场样式生效，向右侧滑出屏幕   router.pushUrl，从页面B跳转到新增的页面A 页面进入，PageTransitionEnter且type为RouteType.Push的转场样式生效，从右侧滑入屏幕 页面退出，PageTransitionExit且type为RouteType.Push的转场样式生效，向左侧滑出屏幕   router.back，从页面A返回到页面B 页面退出，PageTransitionExit且type为RouteType.Pop的转场样式生效，向右侧滑出屏幕 页面进入，PageTransitionEnter且type为RouteType.Pop的转场样式生效，从左侧滑入屏幕    
说明
 1. 由于每个页面的页面转场样式都可由开发者独立配置，而页面转场涉及到两个页面，开发者应考虑两个页面的页面转场效果的衔接，如时长尽量保持一致。 2. 如果没有定义匹配的页面转场样式，则该页面使用系统默认的页面转场样式。 
  禁用某页面的页面转场 已复制pageTransition() {  PageTransitionEnter({ type: RouteType.None, duration: 0 })  PageTransitionExit({ type: RouteType.None, duration: 0 })}  通过设置页面转场的时长为0，可使该页面无页面转场动画。  场景示例 下面介绍定义了所有的四种页面转场样式的页面转场动画示例。  已复制// PageTransitionSrc1import router from '@ohos.router';@Entry@Componentstruct PageTransitionSrc1 {  build() {    Column() {      Image($r('app.media.mountain'))        .width('90%')        .height('80%')        .objectFit(ImageFit.Fill)        .syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成        .margin(30)
      Row({ space: 10 }) {        Button("pushUrl")          .onClick(() => {            // 路由到下一个页面，push操作            router.pushUrl({ url: 'pages/myTest/pageTransitionDst1' });          })        Button("back")          .onClick(() => {            // 返回到上一页面，相当于pop操作            router.back();          })      }.justifyContent(FlexAlign.Center)    }    .width("100%").height("100%")    .alignItems(HorizontalAlign.Center)  }
  pageTransition() {    // 定义页面进入时的效果，从右侧滑入，时长为1000ms，页面栈发生push操作时该效果才生效    PageTransitionEnter({ type: RouteType.Push, duration: 1000 })      .slide(SlideEffect.Right)    // 定义页面进入时的效果，从左侧滑入，时长为1000ms，页面栈发生pop操作时该效果才生效    PageTransitionEnter({ type: RouteType.Pop, duration: 1000 })      .slide(SlideEffect.Left)    // 定义页面退出时的效果，向左侧滑出，时长为1000ms，页面栈发生push操作时该效果才生效    PageTransitionExit({ type: RouteType.Push, duration: 1000 })      .slide(SlideEffect.Left)    // 定义页面退出时的效果，向右侧滑出，时长为1000ms，页面栈发生pop操作时该效果才生效    PageTransitionExit({ type: RouteType.Pop, duration: 1000 })      .slide(SlideEffect.Right)  }}  已复制// PageTransitionDst1import router from '@ohos.router';@Entry@Componentstruct PageTransitionDst1 {  build() {    Column() {      Image($r('app.media.forest'))        .width('90%')        .height('80%')        .objectFit(ImageFit.Fill)        .syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成        .margin(30)
      Row({ space: 10 }) {        Button("pushUrl")          .onClick(() => {            // 路由到下一页面，push操作            router.pushUrl({ url: 'pages/myTest/pageTransitionSrc1' });          })        Button("back")          .onClick(() => {            // 返回到上一页面，相当于pop操作            router.back();          })      }.justifyContent(FlexAlign.Center)    }    .width("100%").height("100%")    .alignItems(HorizontalAlign.Center)  }
  pageTransition() {    // 定义页面进入时的效果，从右侧滑入，时长为1000ms，页面栈发生push操作时该效果才生效    PageTransitionEnter({ type: RouteType.Push, duration: 1000 })      .slide(SlideEffect.Right)    // 定义页面进入时的效果，从左侧滑入，时长为1000ms，页面栈发生pop操作时该效果才生效    PageTransitionEnter({ type: RouteType.Pop, duration: 1000 })      .slide(SlideEffect.Left)    // 定义页面退出时的效果，向左侧滑出，时长为1000ms，页面栈发生push操作时该效果才生效    PageTransitionExit({ type: RouteType.Push, duration: 1000 })      .slide(SlideEffect.Left)    // 定义页面退出时的效果，向右侧滑出，时长为1000ms，页面栈发生pop操作时该效果才生效    PageTransitionExit({ type: RouteType.Pop, duration: 1000 })      .slide(SlideEffect.Right)  }}   下面介绍使用了type为None的页面转场动画示例。 已复制// PageTransitionSrc2import router from '@ohos.router';@Entry@Componentstruct PageTransitionSrc2 {  build() {    Column() {      Image($r('app.media.mountain'))        .width('90%')        .height('80%')        .objectFit(ImageFit.Fill)        .syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成        .margin(30)
      Row({ space: 10 }) {        Button("pushUrl")          .onClick(() => {            // 路由到下一页面，push操作            router.pushUrl({ url: 'pages/myTest/pageTransitionDst2' });          })        Button("back")          .onClick(() => {            // 返回到上一页面，相当于pop操作            router.back();          })      }.justifyContent(FlexAlign.Center)    }    .width("100%").height("100%")    .alignItems(HorizontalAlign.Center)  }
  pageTransition() {    // 定义页面进入时的效果，从左侧滑入，时长为1000ms，无论页面栈发生push还是pop操作均可生效    PageTransitionEnter({ duration: 1000 })      .slide(SlideEffect.Left)    // 定义页面退出时的效果，相对于正常页面位置x方向平移100vp，y方向平移100vp，透明度变为0，时长为1200ms，无论页面栈发生push还是pop操作均可生效    PageTransitionExit({ duration: 1200 })      .translate({ x: 100.0, y: 100.0 })      .opacity(0)  }} 已复制// PageTransitionDst2import router from '@ohos.router';@Entry@Componentstruct PageTransitionDst2 {  build() {    Column() {      Image($r('app.media.forest'))        .width('90%')        .height('80%')        .objectFit(ImageFit.Fill)        .syncLoad(true) // 同步加载图片，使页面出现时图片已经加载完成        .margin(30)
      Row({ space: 10 }) {        Button("pushUrl")          .onClick(() => {            // 路由到下一页面，push操作            router.pushUrl({ url: 'pages/myTest/pageTransitionSrc2' });          })        Button("back")          .onClick(() => {            // 返回到上一页面，相当于pop操作            router.back();          })      }.justifyContent(FlexAlign.Center)    }    .width("100%").height("100%")    .alignItems(HorizontalAlign.Center)  }
  pageTransition() {    // 定义页面进入时的效果，从左侧滑入，时长为1200ms，无论页面栈发生push还是pop操作均可生效    PageTransitionEnter({ duration: 1200 })      .slide(SlideEffect.Left)    // 定义页面退出时的效果，相对于正常页面位置x方向平移100vp，y方向平移100vp，透明度变为0，时长为1000ms，无论页面栈发生push还是pop操作均可生效    PageTransitionExit({ duration: 1000 })      .translate({ x: 100.0, y: 100.0 })      .opacity(0)  }}    上一篇 放大缩小视图 下一篇 支持交互事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述限制条件支持的接口PersistPropDeletePropPersistPropsKeys使用场景从AppStorage中访问PersistentStorage初始化的属性在PersistentStorage之前访问AppStorage中的属性在PersistentStorage之后访问AppStorage中的属性PersistentStorage：持久化存储UI状态 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 前两个小节介绍的LocalStorage和AppStorage都是运行时的内存，但是在应用退出再次启动后，依然能保存选定的结果，是应用开发中十分常见的现象，这就需要用到PersistentStorage。 PersistentStorage是应用程序中的可选单例对象。此对象的作用是持久化存储选定的AppStorage属性，以确保这些属性在应用程序重新启动时的值与应用程序关闭时的值相同。 概述PersistentStorage将选定的AppStorage属性保留在设备磁盘上。应用程序通过API，以决定哪些AppStorage属性应借助PersistentStorage持久化。UI和业务逻辑不直接访问PersistentStorage中的属性，所有属性访问都是对AppStorage的访问，AppStorage中的更改会自动同步到PersistentStorage。 PersistentStorage和AppStorage中的属性建立双向同步。应用开发通常通过AppStorage访问PersistentStorage，另外还有一些接口可以用于管理持久化属性，但是业务逻辑始终是通过AppStorage获取和设置属性的。  限制条件PersistentStorage允许的类型和值有： number, string, boolean, enum 等简单类型。可以被JSON.stringify()和JSON.parse()重构的对象。例如Date, Map, Set等内置类型则不支持，以及对象的属性方法不支持持久化。 PersistentStorage不允许的类型和值有： 不支持嵌套对象（对象数组，对象的属性是对象等）。因为目前框架无法检测AppStorage中嵌套对象（包括数组）值的变化，所以无法写回到PersistentStorage中。不支持undefined 和 null 。 持久化数据是一个相对缓慢的操作，应用程序应避免以下情况： 持久化大型数据集。持久化经常变化的变量。 PersistentStorage的持久化变量最好是小于2kb的数据，不要大量的数据持久化，因为PersistentStorage写入磁盘的操作是同步的，大量的数据本地化读写会同步在UI线程中执行，影响UI渲染性能。如果开发者需要存储大量的数据，建议使用数据库api。 PersistentStorage只能在UI页面内使用，否则将无法持久化数据。  支持的接口 PersistPropstatic PersistProp<T>(key: string, defaultValue: T): void 将AppStorage中key对应的属性持久化到文件中。该接口的调用通常在访问AppStorage之前。 确定属性的类型和值的顺序如下： 如果PersistentStorage文件中存在key对应的属性，在AppStorage中创建对应的propName，并用在PersistentStorage中找到的key的属性初始化。如果PersistentStorage文件中没有查询到key对应的属性，则在AppStorage中查找key对应的属性。如果找到key对应的属性，则将该属性持久化。如果AppStorage也没查找到key对应的属性，则在AppStorage中创建key对应的属性。用defaultValue初始化其值，并将该属性持久化。 根据上述的初始化流程，如果AppStorage中有该属性，则会使用其值，覆盖掉PersistentStorage文件中的值。由于AppStorage是内存内数据，该行为会导致数据丧失持久化能力。 参数： 参数名  类型  必填  参数描述    key  string  是  属性名。   defaultValue  T  是  在PersistentStorage和AppStorage未查询到时，则使用默认值初始化初始化它。不允许为undefined和null。     示例： 已复制PersistentStorage.PersistProp('highScore', '0');  DeletePropstatic DeleteProp(key: string): void 将key对应的属性从PersistentStorage删除，后续AppStorage的操作，对PersistentStorage不会再有影响。 参数： 参数名  类型  必填  参数描述    key  string  是  PersistentStorage中的属性名。     示例： 已复制PersistentStorage.DeleteProp('highScore');  PersistPropsstatic PersistProps(properties: {key: string, defaultValue: any;}[]): void 行为和PersistProp类似，不同在于可以一次性持久化多个数据，适合在应用启动的时候初始化。 参数： 参数名  类型  必填  参数描述    key  string  是  属性名。   properties  {key: string, defaultValue: any}[]  是  持久化数组，启动key为属性名，defaultValue为默认值。规则同PersistProp。     示例： 已复制PersistentStorage.PersistProps([{ key: 'highScore', defaultValue: '0' }, { key: 'wightScore', defaultValue: '1' }]);  Keysstatic Keys(): Array<string> 返回所有持久化属性的key的数组。 返回值： 类型  描述    Array<string>  返回所有持久化属性的key的数组。     示例： 已复制let keys: Array<string> = PersistentStorage.Keys();  使用场景 从AppStorage中访问PersistentStorage初始化的属性初始化PersistentStorage：已复制PersistentStorage.PersistProp('aProp', 47); 在AppStorage获取对应属性：已复制AppStorage.Get('aProp'); // returns 47 或在组件内部定义： 已复制@StorageLink('aProp') aProp: number = 48;  完整代码如下： 已复制PersistentStorage.PersistProp('aProp', 47);
@Entry@Componentstruct Index {  @State message: string = 'Hello World'  @StorageLink('aProp') aProp: number = 48
  build() {    Row() {      Column() {        Text(this.message)        // 应用退出时会保存当前结果。重新启动后，会显示上一次的保存结果        Text(`${this.aProp}`)          .onClick(() => {            this.aProp += 1;          })      }    }  }} 
说明
当前持久化存储在API9模拟器上暂不支持。 
 新应用安装后首次启动运行：调用PersistProp初始化PersistentStorage，首先查询在PersistentStorage本地文件中是否存在“aProp”，查询结果为不存在，因为应用是第一次安装。接着查询属性“aProp”在AppStorage中是否存在，依旧不存在。在AppStorge中创建名为“aProp”的number类型属性，属性初始值是定义的默认值47。PersistentStorage将属性“aProp”和值47写入磁盘，AppStorage中“aProp”对应的值和其后续的更改将被持久化。在Index组件中创建状态变量@StorageLink('aProp') aProp，和AppStorage中“aProp”双向绑定，在创建的过程中会在AppStorage中查找，成功找到“aProp”，所以使用其在AppStorage找到的值47。  图1 PersistProp初始化流程   触发点击事件后：状态变量@StorageLink('aProp') aProp改变，触发Text组件重新刷新。@StorageLink装饰的变量是和AppStorage中建立双向同步的，所以@StorageLink('aProp') aProp的变化会被同步回AppStorage中。AppStorage中“aProp”属性的改变会同步到所有绑定该“aProp”的单向或者双向变量，在本示例中没有其他的绑定“aProp”的变量。因为“aProp”对应的属性已经被持久化，所以在AppStorage中“aProp”的改变会触发PersistentStorage将新的改变写入本地磁盘。 后续启动应用：执行PersistentStorage.PersistProp('aProp', 47)，在首先查询在PersistentStorage本地文件查询“aProp”属性，成功查询到。将在PersistentStorage查询到的值写入AppStorage中。在Index组件里，@StorageLink绑定的“aProp”为PersistentStorage写入AppStorage中的值，即为上一次退出应用存入的值。   在PersistentStorage之前访问AppStorage中的属性该示例为反例。在调用PersistentStorage.PersistProp或者PersistProps之前使用接口访问AppStorage中的属性是错误的，因为这样的调用顺序会丢失上一次应用程序运行中的属性值： 已复制let aProp = AppStorage.SetOrCreate('aProp', 47);PersistentStorage.PersistProp('aProp', 48); 应用在非首次运行时，先执行AppStorage.SetOrCreate('aProp', 47)：属性“aProp”在AppStorage中创建，其类型为number，其值设置为指定的默认值47。“aProp”是持久化的属性，所以会被写回PersistentStorage磁盘中，PersistentStorage存储的上次退出应用的值丢失。 PersistentStorage.PersistProp('aProp', 48)：在PersistentStorage中查找到“aProp”，值为刚刚使用AppStorage接口写入的47。  在PersistentStorage之后访问AppStorage中的属性开发者可以先判断是否需要覆盖上一次保存在PersistentStorage中的值，如果需要覆盖，再调用AppStorage的接口进行修改，如果不需要覆盖，则不调用AppStorage的接口。 已复制PersistentStorage.PersistProp('aProp', 48);if (AppStorage.Get('aProp') > 50) {    // 如果PersistentStorage存储的值超过50，设置为47    AppStorage.SetOrCreate('aProp',47);} 示例代码在读取PersistentStorage储存的数据后判断“aProp”的值是否大于50，如果大于50的话使用AppStorage的接口设置为47。   上一篇 AppStorage：应用全局的UI状态存储 下一篇 Environment：设备环境查询 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。添加气泡和菜单 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    气泡提示（Popup）  菜单（Menu）   上一篇 XComponent 下一篇 气泡提示（Popup） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建默认样式的菜单创建自定义样式的菜单@Builder开发菜单内的内容bindMenu属性绑定组件创建支持右键或长按的菜单菜单（Menu） 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
  Menu是菜单接口，一般用于鼠标右键弹窗、点击弹窗等。具体用法请参考Menu控制。  创建默认样式的菜单 菜单需要调用bindMenu接口来实现。bindMenu响应绑定组件的点击事件，绑定组件后手势点击对应组件后即可弹出。  已复制Button('click for Menu')  .bindMenu([  {    value: 'Menu1',    action: () => {      console.info('handle Menu1 select')    }  }       ])   创建自定义样式的菜单 当默认样式不满足开发需求时，可使用@Builder自定义菜单内容。可通过bindMenu接口进行菜单的自定义。   @Builder开发菜单内的内容 已复制@State select: boolean = trueprivate iconStr: ResourceStr = $r("app.media.view_list_filled")private iconStr2: ResourceStr = $r("app.media.view_list_filled")@BuilderSubMenu() {  Menu() {    MenuItem({ content: "复制", labelInfo: "Ctrl+C" })    MenuItem({ content: "粘贴", labelInfo: "Ctrl+V" })  }}
@BuilderMyMenu(){  Menu() {    MenuItem({ startIcon: $r("app.media.icon"), content: "菜单选项" })    MenuItem({ startIcon: $r("app.media.icon"), content: "菜单选项" }).enabled(false)    MenuItem({      startIcon: this.iconStr,      content: "菜单选项",      endIcon: $r("app.media.arrow_right_filled"),      // 当builder参数进行配置时，表示与menuItem项绑定了子菜单。鼠标hover在该菜单项时，会显示子菜单。      builder: this.SubMenu,    })    MenuItemGroup({ header: '小标题' }) {      MenuItem({ content: "菜单选项" })        .selectIcon(true)        .selected(this.select)        .onChange((selected) => {       console.info("menuItem select" + selected);       this.iconStr2 = $r("app.media.icon");        })      MenuItem({        startIcon: $r("app.media.view_list_filled"),        content: "菜单选项",        endIcon: $r("app.media.arrow_right_filled"),        builder: this.SubMenu.bind(this)      })    }    MenuItem({      startIcon: this.iconStr2,      content: "菜单选项",      endIcon: $r("app.media.arrow_right_filled")    })  }}     bindMenu属性绑定组件 已复制Button('click for Menu')  .bindMenu(this.MyMenu)    创建支持右键或长按的菜单 通过bindContextMenu接口进行菜单的自定义及菜单弹出的触发方式：右键或长按。使用bindContextMenu弹出的菜单项是在独立子窗口内的，可显示在应用窗口外部。   @Builder开发菜单内的内容与上文写法相同。 确认菜单的弹出方式，使用bindContextMenu属性绑定组件。示例中为右键弹出菜单。已复制Button('click for Menu')  .bindContextMenu(this.MyMenu, ResponseType.RightClick)   上一篇 气泡提示（Popup） 下一篇 设置页面路由和组件导航 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。文本提示气泡添加气泡状态变化的事件带按钮的提示气泡自定义气泡气泡提示（Popup） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Popup属性可绑定在组件上显示气泡弹窗提示，设置弹窗内容、交互逻辑和显示状态。主要用于屏幕录制、信息弹出提醒等显示状态。 气泡分为两种类型，一种是系统提供的气泡PopupOptions，一种是开发者可以自定义的气泡CustomPopupOptions。其中PopupOptions为系统提供的气泡，通过配置primaryButton、secondaryButton来设置带按钮的气泡。CustomPopupOptions通过配置builder参数来设置自定义的气泡。  文本提示气泡 文本提示气泡常用于只展示带有文本的信息提示，不带有任何交互的场景。Popup属性需绑定组件，当bindPopup属性中参数show为true的时候会弹出气泡提示。 在Button组件上绑定Popup属性，每次点击Button按钮，handlePopup会切换布尔值，当其为true时，触发bindPopup弹出气泡。  已复制@Entry@Componentstruct PopupExample {  @State handlePopup: boolean = false   build() {    Column() {      Button('PopupOptions')        .onClick(() => {          this.handlePopup = !this.handlePopup        })        .bindPopup(this.handlePopup, {          message: 'This is a popup with PopupOptions',        })    }.width('100%').padding({ top: 5 })  }}   添加气泡状态变化的事件 通过onStateChange参数为气泡添加状态变化的事件回调，可以判断当前气泡的显示状态。 已复制@Entry@Componentstruct PopupExample {  @State handlePopup: boolean = false
  build() {    Column() {      Button('PopupOptions')        .onClick(() => {          this.handlePopup = !this.handlePopup        })        .bindPopup(this.handlePopup, {          message: 'This is a popup with PopupOptions',          onStateChange: (e)=> { // 返回当前的气泡状态            if (!e.isVisible) {              this.handlePopup = false            }          }        })    }.width('100%').padding({ top: 5 })  }}    带按钮的提示气泡 通过primaryButton、secondaryButton属性为气泡最多设置两个Button按钮，通过此按钮进行简单的交互，开发者可以通过配置action参数来设置想要触发的操作。 已复制@Entry@Componentstruct PopupExample22 {  @State handlePopup: boolean = false
  build() {    Column() {      Button('PopupOptions').margin({ top: 200 })        .onClick(() => {          this.handlePopup = !this.handlePopup        })        .bindPopup(this.handlePopup, {          message: 'This is a popup with PopupOptions',          primaryButton: {            value: 'Confirm',            action: () => {              this.handlePopup = !this.handlePopup              console.info('confirm Button click')            }          },          secondaryButton: {            value: 'Cancel',            action: () => {              this.handlePopup = !this.handlePopup            }          },          onStateChange: (e) => {            if (!e.isVisible) {              this.handlePopup = false            }          }        })    }.width('100%').padding({ top: 5 })  }}    自定义气泡 开发者可以使用构建器CustomPopupOptions创建自定义气泡，@Builder中可以放自定义的内容。除此之外，还可以通过popupColor等参数控制气泡样式。 已复制@Entry@Componentstruct Index {  @State customPopup: boolean = false  // popup构造器定义弹框内容  @Builder popupBuilder() {    Row({ space: 2 }) {      Image($r("app.media.icon")).width(24).height(24).margin({ left: 5 })      Text('This is Custom Popup').fontSize(15)    }.width(200).height(50).padding(5)  }  build() {    Column() {      Button('CustomPopupOptions')        .position({x:100,y:200})        .onClick(() => {          this.customPopup = !this.customPopup        })        .bindPopup(this.customPopup, {          builder: this.popupBuilder, // 气泡的内容          placement:Placement.Bottom, // 气泡的弹出位置          popupColor:Color.Pink, // 气泡的背景色          onStateChange: (e) => {            console.info(JSON.stringify(e.isVisible))            if (!e.isVisible) {              this.customPopup = false            }          }        })    }    .height('100%')  }}  使用者通过配置placement参数将弹出的气泡放到需要提示的位置。弹窗构造器会触发弹出提示信息，来引导使用者完成操作，也让使用者有更好的UI体验。  已复制@Entry@Componentstruct Index {  @State customPopup: boolean = false  // popup构造器定义弹框内容  @Builder popupBuilder() {    Row({ space: 2 }) {      Image('/images/shengWhite.png').width(30).objectFit(ImageFit.Contain)      Column(){        Text('控制人生').fontSize(14).fontWeight(900).fontColor(Color.White).width('100%')        Text('想要跟唱时，数千万歌曲任你选择，人声随心调整。').fontSize(12).fontColor('#ffeeeeee').width('100%')      }    }.width(230).height(80).padding(5)  }  build() {    Row() {      Text('我要K歌')      Image('/images/sheng.png').width(35).objectFit(ImageFit.Contain)        .onClick(() => {          this.customPopup = !this.customPopup        })        .bindPopup(this.customPopup, {          builder: this.popupBuilder,        })    }    .margin(20)    .height('100%')  }}  上一篇 添加气泡和菜单 下一篇 菜单（Menu） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述限制条件装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现观察变化框架行为使用场景父组件@State到子组件@Prop简单数据类型同步父组件@State数组项到子组件@Prop简单数据类型同步从父组件中的@State类对象属性到@Prop简单类型的同步@Prop本地初始化不和父组件同步@Prop装饰器：父子单向同步 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 @Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 概述@Prop装饰的变量和父组件建立单向的同步关系： @Prop变量允许在本地修改，但修改后的变化不会同步回父组件。当父组件中的数据源更改时，与之相关的@Prop装饰的变量都会自动更新。如果子组件已经在本地修改了@Prop装饰的相关变量值，而在父组件中对应的@State装饰的变量被修改后，子组件本地修改的@Prop装饰的相关变量值将被覆盖。  限制条件@Prop装饰器不能在@Entry装饰的自定义组件中使用。  装饰器使用规则说明 @Prop变量装饰器  说明    装饰器参数  无   同步类型  单向同步：对父组件状态变量值的修改，将同步给子组件@Prop装饰的变量，子组件@Prop变量的修改不会同步到父组件的状态变量上   允许装饰的变量类型  string、number、boolean、enum类型。 不支持any，不允许使用undefined和null。 必须指定类型。 在父组件中，传递给@Prop装饰的值不能为undefined或者null，反例如下所示。 CompA ({ aProp: undefined }) CompA ({ aProp: null }) @Prop和数据源类型需要相同，有以下三种情况（数据源以@State为例）： @Prop装饰的变量和父组件状态变量类型相同，即@Prop : S和@State : S，示例请参考父组件@State到子组件@Prop简单数据类型同步。当父组件的状态变量为数组时，@Prop装饰的变量和父组件状态变量的数组项类型相同，即@Prop : S和@State : Array<S>，示例请参考父组件@State数组中的项到子组件@Prop简单数据类型同步；当父组件状态变量为Object或者class时，@Prop装饰的变量和父组件状态变量的属性类型相同，即@Prop : S和@State : { propA: S }，示例请参考从父组件中的@State类对象属性到@Prop简单类型的同步。   被装饰变量的初始值  允许本地初始化。      变量的传递/访问规则说明 传递/访问  说明    从父组件初始化  如果本地有初始化，则是可选的。没有的话，则必选，支持父组件中的常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp去初始化子组件中的@Prop变量。   用于初始化子组件  @Prop支持去初始化子组件中的常规变量、@State、@Link、@Prop、@Provide。   是否支持组件外访问  @Prop装饰的变量是私有的，只能在组件内访问。      图1 初始化规则图示   观察变化和行为表现 观察变化@Prop装饰的数据可以观察到以下变化。 当装饰的类型是允许的类型，即string、number、boolean、enum类型都可以观察到的赋值变化；已复制// 简单类型@Prop count: number;// 赋值的变化可以被观察到this.count = 1;  对于@State和@Prop的同步场景： 使用父组件中@State变量的值初始化子组件中的@Prop变量。当@State变量变化时，该变量值也会同步更新至@Prop变量。@Prop装饰的变量的修改不会影响其数据源@State装饰变量的值。除了@State，数据源也可以用@Link或@Prop装饰，对@Prop的同步机制是相同的。数据源和@Prop变量的类型需要相同。  框架行为要理解@Prop变量值初始化和更新机制，有必要了解父组件和拥有@Prop变量的子组件初始渲染和更新流程。 初始渲染：执行父组件的build()函数将创建子组件的新实例，将数据源传递给子组件；初始化子组件@Prop装饰的变量。 更新：子组件@Prop更新时，更新仅停留在当前子组件，不会同步回父组件；当父组件的数据源更新时，子组件的@Prop装饰的变量将被来自父组件的数据源重置，所有@Prop装饰的本地的修改将被父组件的更新覆盖。   
说明
@Prop装饰的数据更新依赖其所属自定义组件的重新渲染，所以在应用进入后台后，@Prop无法刷新，推荐使用@Link代替。 
 使用场景 父组件@State到子组件@Prop简单数据类型同步 以下示例是@State到子组件@Prop简单数据同步，父组件ParentComponent的状态变量countDownStartValue初始化子组件CountDownComponent中@Prop装饰的count，点击“Try again”，count的修改仅保留在CountDownComponent，不会同步给父组件ParentComponent。 ParentComponent的状态变量countDownStartValue的变化将重置CountDownComponent的count。 已复制@Componentstruct CountDownComponent {  @Prop count: number;  costOfOneAttempt: number = 1;
  build() {    Column() {      if (this.count > 0) {        Text(`You have ${this.count} Nuggets left`)      } else {        Text('Game over!')      }      // @Prop装饰的变量不会同步给父组件      Button(`Try again`).onClick(() => {        this.count -= this.costOfOneAttempt;      })    }  }}
@Entry@Componentstruct ParentComponent {  @State countDownStartValue: number = 10;
  build() {    Column() {      Text(`Grant ${this.countDownStartValue} nuggets to play.`)      // 父组件的数据源的修改会同步给子组件      Button(`+1 - Nuggets in New Game`).onClick(() => {        this.countDownStartValue += 1;      })      // 父组件的修改会同步给子组件      Button(`-1  - Nuggets in New Game`).onClick(() => {        this.countDownStartValue -= 1;      })
      CountDownComponent({ count: this.countDownStartValue, costOfOneAttempt: 2 })    }  }} 在上面的示例中： CountDownComponent子组件首次创建时其@Prop装饰的count变量将从父组件@State装饰的countDownStartValue变量初始化；按“+1”或“-1”按钮时，父组件的@State装饰的countDownStartValue值会变化，这将触发父组件重新渲染，在父组件重新渲染过程中会刷新使用countDownStartValue状态变量的UI组件并单向同步更新CountDownComponent子组件中的count值；更新count状态变量值也会触发CountDownComponent的重新渲染，在重新渲染过程中，评估使用count状态变量的if语句条件（this.count > 0），并执行true分支中的使用count状态变量的UI组件相关描述来更新Text组件的UI显示；当按下子组件CountDownComponent的“Try again”按钮时，其@Prop变量count将被更改，但是count值的更改不会影响父组件的countDownStartValue值；父组件的countDownStartValue值会变化时，父组件的修改将覆盖掉子组件CountDownComponent中count本地的修改。 父组件@State数组项到子组件@Prop简单数据类型同步 父组件中@State如果装饰的数组，其数组项也可以初始化@Prop。以下示例中父组件Index中@State装饰的数组arr，将其数组项初始化子组件Child中@Prop装饰的value。 已复制@Componentstruct Child {  @Prop value: number;
  build() {    Text(`${this.value}`)      .fontSize(50)      .onClick(()=>{this.value++})  }}
@Entry@Componentstruct Index {  @State arr: number[] = [1,2,3];
  build() {    Row() {      Column() {        Child({value: this.arr[0]})        Child({value: this.arr[1]})        Child({value: this.arr[2]})
        Divider().height(5)
        ForEach(this.arr,           item => {            Child({'value': item} as Record<string, number>)          },           item => item.toString()        )        Text('replace entire arr')        .fontSize(50)        .onClick(()=>{          // 两个数组都包含项“3”。          this.arr = this.arr[0] == 1 ? [3,4,5] : [1,2,3];        })      }    }  }} 初始渲染创建6个子组件实例，每个@Prop装饰的变量初始化都在本地拷贝了一份数组项。子组件onclick事件处理程序会更改局部变量值。 如果点击界面上的“1”六次、“2”五次、“3”四次，将所有变量的本地取值都变为“7”。 已复制777----777 单击replace entire arr后，屏幕将显示以下信息，为什么？ 已复制345----745 在子组件Child中做的所有的修改都不会同步回父组件Index组件，所以即使6个组件显示都为7，但在父组件Index中，this.arr保存的值依旧是[1,2,3]。点击replace entire arr，this.arr[0] == 1成立，将this.arr赋值为[3, 4, 5]；因为this.arr[0]已更改，Child({value: this.arr[0]})组件将this.arr[0]更新同步到实例@Prop装饰的变量。Child({value: this.arr[1]})和Child({value: this.arr[2]})的情况也类似。 this.arr的更改触发ForEach更新，this.arr更新的前后都有数值为3的数组项：[3, 4, 5] 和[1, 2, 3]。根据diff算法，数组项“3”将被保留，删除“1”和“2”的数组项，添加为“4”和“5”的数组项。这就意味着，数组项“3”的组件不会重新生成，而是将其移动到第一位。所以“3”对应的组件不会更新，此时“3”对应的组件数值为“7”，ForEach最终的渲染结果是“7”，“4”，“5”。 从父组件中的@State类对象属性到@Prop简单类型的同步如果图书馆有一本图书和两位用户，每位用户都可以将图书标记为已读，此标记行为不会影响其它读者用户。从代码角度讲，对@Prop图书对象的本地更改不会同步给图书馆组件中的@State图书对象。 已复制class Book {  public title: string;  public pages: number;  public readIt: boolean = false;
  constructor(title: string, pages: number) {    this.title = title;    this.pages = pages;  }}
@Componentstruct ReaderComp {  @Prop title: string;  @Prop readIt: boolean;
  build() {    Row() {      Text(this.title)      Text(`... ${this.readIt ? 'I have read' : 'I have not read it'}`)        .onClick(() => this.readIt = true)    }  }}
@Entry@Componentstruct Library {  @State book: Book = new Book('100 secrets of C++', 765);
  build() {    Column() {      ReaderComp({ title: this.book.title, readIt: this.book.readIt })      ReaderComp({ title: this.book.title, readIt: this.book.readIt })    }  }}  @Prop本地初始化不和父组件同步为了支持@Component装饰的组件复用场景，@Prop支持本地初始化，这样可以让@Prop是否与父组件建立同步关系变得可选。当且仅当@Prop有本地初始化时，从父组件向子组件传递@Prop的数据源才是可选的。 下面的示例中，子组件包含两个@Prop变量： @Prop customCounter没有本地初始化，所以需要父组件提供数据源去初始化@Prop，并当父组件的数据源变化时，@Prop也将被更新；@Prop customCounter2有本地初始化，在这种情况下，@Prop依旧允许但非强制父组件同步数据源给@Prop。已复制@Componentstruct MyComponent {  @Prop customCounter: number;  @Prop customCounter2: number = 5;
  build() {    Column() {      Row() {        Text(`From Main: ${this.customCounter}`).fontColor('#ff6b6565').margin({ left: -110, top: 12 })      }
      Row() {        Button('Click to change locally !')          .width(288)          .height(40)          .margin({ left: 30, top: 12 })          .fontColor('#FFFFFF，90%')          .onClick(() => {            this.customCounter2++          })      }
      Row() {        Text(`Custom Local: ${this.customCounter2}`).fontColor('#ff6b6565').margin({ left: -110, top: 12 })      }    }  }}
@Entry@Componentstruct MainProgram {  @State mainCounter: number = 10;
  build() {    Column() {      Row() {        Column() {          // customCounter必须从父组件初始化，因为MyComponent的customCounter成员变量缺少本地初始化；此处，customCounter2可以不做初始化。          MyComponent({ customCounter: this.mainCounter })          // customCounter2也可以从父组件初始化，父组件初始化的值会覆盖子组件customCounter2的本地初始化的值          MyComponent({ customCounter: this.mainCounter, customCounter2: this.mainCounter })        }      }
      Row() {        Column() {          Button('Click to change number')            .width(288)            .height(40)            .margin({ left: 30, top: 12 })            .fontColor('#FFFFFF，90%')            .onClick(() => {              this.mainCounter++            })        }      }    }  }}     上一篇 @State装饰器：组件内状态 下一篇 @Link装饰器：父子双向同步 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述装饰器说明变量的传递/访问规则说明观察变化和行为表现观察变化框架行为使用场景@Provide装饰器和@Consume装饰器：与后代组件双向同步 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 @Provide和@Consume，应用于与后代组件的双向数据同步，应用于状态数据在多个层级之间传递的场景。不同于上文提到的父子组件之间通过命名参数机制传递，@Provide和@Consume摆脱参数传递机制的束缚，实现跨层级传递。 其中@Provide装饰的变量是在祖先节点中，可以理解为被“提供”给后代的状态变量。@Consume装饰的变量是在后代组件中，去“消费（绑定）”祖先节点提供的变量。 
说明
从API version 9开始，这两个装饰器支持在ArkTS卡片中使用。 
 概述@Provide/@Consume装饰的状态变量有以下特性： @Provide装饰的状态变量自动对其所有后代组件可用，即该变量被“provide”给他的后代组件。由此可见，@Provide的方便之处在于，开发者不需要多次在组件之间传递变量。后代通过使用@Consume去获取@Provide提供的变量，建立在@Provide和@Consume之间的双向数据同步，与@State/@Link不同的是，前者可以在多层级的父子组件之间传递。@Provide和@Consume可以通过相同的变量名或者相同的变量别名绑定，变量类型必须相同。 已复制// 通过相同的变量名绑定@Provide a: number = 0;@Consume a: number;
// 通过相同的变量别名绑定@Provide('a') b: number = 0;@Consume('a') c: number;  @Provide和@Consume通过相同的变量名或者相同的变量别名绑定时，@Provide修饰的变量和@Consume修饰的变量是一对多的关系。不允许在同一个自定义组件内，包括其子组件中声明多个同名或者同别名的@Provide装饰的变量。 装饰器说明@State的规则同样适用于@Provide，差异为@Provide还作为多层后代的同步源。 @Provide变量装饰器  说明    装饰器参数  别名：常量字符串，可选。 如果指定了别名，则通过别名来绑定变量；如果未指定别名，则通过变量名绑定变量。   同步类型  双向同步。 从@Provide变量到所有@Consume变量以及相反的方向的数据同步。双向同步的操作与@State和@Link的组合相同。   允许装饰的变量类型  Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。 不支持any，不支持简单类型和复杂类型的联合类型，不允许使用undefined和null。 必须指定类型。@Provide变量的@Consume变量的类型必须相同。 
说明
不支持Length、ResourceStr、ResourceColor类型，Length、ResourceStr、ResourceColor为简单类型和复杂类型的联合类型。 
   被装饰变量的初始值  必须指定。     @Consume变量装饰器  说明    装饰器参数  别名：常量字符串，可选。 如果提供了别名，则必须有@Provide的变量和其有相同的别名才可以匹配成功；否则，则需要变量名相同才能匹配成功。   同步类型  双向：从@Provide变量（具体请参见@Provide）到所有@Consume变量，以及相反的方向。双向同步操作与@State和@Link的组合相同。   允许装饰的变量类型  Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。 不支持any，不允许使用undefined和null。 必须指定类型。@Provide变量的@Consume变量的类型必须相同。 
说明
@Consume装饰的变量，在其父节点或者祖先节点上，必须有对应的属性和别名的@Provide装饰的变量。 
   被装饰变量的初始值  无，禁止本地初始化。      变量的传递/访问规则说明 @Provide传递/访问  说明    从父组件初始化和更新  可选，允许父组件中常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp装饰的变量装饰变量初始化子组件@Provide。   用于初始化子组件  允许，可用于初始化@State、@Link、@Prop、@Provide。   和父组件同步  否。   和后代组件同步  和@Consume双向同步。   是否支持组件外访问  私有，仅可以在所属组件内访问。     图1 @Provide初始化规则图示  @Consume传递/访问  说明    从父组件初始化和更新  禁止。通过相同的变量名和alias（别名）从@Provide初始化。   用于初始化子组件  允许，可用于初始化@State、@Link、@Prop、@Provide。   和祖先组件同步  和@Provide双向同步。   是否支持组件外访问  私有，仅可以在所属组件内访问     图2 @Consume初始化规则图示  观察变化和行为表现 观察变化当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。当装饰的数据类型为class或者Object的时候，可以观察到赋值和属性赋值的变化（属性为Object.keys(observedObject)返回的所有属性）。当装饰的对象是array的时候，可以观察到数组的添加、删除、更新数组单元。  框架行为初始渲染：@Provide装饰的变量会以map的形式，传递给当前@Provide所属组件的所有子组件；子组件中如果使用@Consume变量，则会在map中查找是否有该变量名/alias（别名）对应的@Provide的变量，如果查找不到，框架会抛出JS ERROR;在初始化@Consume变量时，和@State/@Link的流程类似，@Consume变量会保存在map中查找到的@Provide变量，并把自己注册给@Provide。 当@Provide装饰的数据变化时：通过初始渲染的步骤可知，子组件@Consume已把自己注册给父组件。父组件@Provide变量变更后，会遍历更新所有依赖它的系统组件（elementid）和状态变量（@Consume）；通知@Consume更新后，子组件所有依赖@Consume的系统组件（elementId）都会被通知更新。以此实现@Provide对@Consume状态数据同步。 当@Consume装饰的数据变化时：通过初始渲染的步骤可知，子组件@Consume持有@Provide的实例。在@Consume更新后调用@Provide的更新方法，将更新的数值同步回@Provide，以此实现@Consume向@Provide的同步更新。   使用场景在下面的示例是与后代组件双向同步状态@Provide和@Consume场景。当分别点击CompA和CompD组件内Button时，reviewVotes 的更改会双向同步在CompA和CompD中。  已复制@Componentstruct CompD {  // @Consume装饰的变量通过相同的属性名绑定其祖先组件CompA内的@Provide装饰的变量  @Consume reviewVotes: number;
  build() {    Column() {      Text(`reviewVotes(${this.reviewVotes})`)      Button(`reviewVotes(${this.reviewVotes}), give +1`)        .onClick(() => this.reviewVotes += 1)    }    .width('50%')  }}
@Componentstruct CompC {  build() {    Row({ space: 5 }) {      CompD()      CompD()    }  }}
@Componentstruct CompB {  build() {    CompC()  }}
@Entry@Componentstruct CompA {  // @Provide装饰的变量reviewVotes由入口组件CompA提供其后代组件  @Provide reviewVotes: number = 0;
  build() {    Column() {      Button(`reviewVotes(${this.reviewVotes}), give +1`)        .onClick(() => this.reviewVotes += 1)      CompB()    }  }}  上一篇 @Link装饰器：父子双向同步 下一篇 @Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。渲染控制 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    渲染控制概述  if/else：条件渲染  ForEach：循环渲染  LazyForEach：数据懒加载   上一篇 $$语法：内置组件双向同步 下一篇 渲染控制概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口描述键值生成规则组件创建规则首次渲染非首次渲染使用场景数据源不变数据源数组项发生变化数据源数组项子属性变化使用建议不推荐案例渲染结果非预期渲染性能降低ForEach：循环渲染 更新时间: 2024-03-27 16:53 毫无帮助帮助不大一般很好非常好
分享
  ForEach接口基于数组类型数据来进行循环渲染，需要与容器组件配合使用，且接口返回的组件应当是允许包含在ForEach父容器组件中的子组件。例如，ListItem组件要求ForEach的父容器组件必须为List组件。 
说明
 从API version 9开始，该接口支持在ArkTS卡片中使用。 
  接口描述 已复制ForEach(  arr: Array,  itemGenerator: (item: any, index: number) => void,  keyGenerator?: (item: any, index: number) => string)     参数名 参数类型 必填 参数描述    arr Array<any> 是 数据源，为Array类型的数组。 说明： - 可以设置为空数组，此时不会创建子组件。 - 可以设置返回值为数组类型的函数，例如arr.slice(1, 3)，但设置的函数不应改变包括数组本身在内的任何状态变量，例如不应使用Array.splice(),Array.sort()或Array.reverse()这些会改变原数组的函数。   itemGenerator (item: any, index: number) => void 是 组件生成函数。 - 为数组中的每个元素创建对应的组件。 - item参数：arr数组中的数据项。 - index参数（可选）：arr数组中的数据项索引。 说明： - 组件的类型必须是ForEach的父容器所允许的。例如，ListItem组件要求ForEach的父容器组件必须为List组件。   keyGenerator (item: any, index: number) => string 否 键值生成函数。 - 为数据源arr的每个数组项生成唯一且持久的键值。函数返回值为开发者自定义的键值生成规则。 - item参数：arr数组中的数据项。- index参数（可选）：arr数组中的数据项索引。 说明： - 如果函数缺省，框架默认的键值生成函数为(item: T, index: number) => { return index + '__' + JSON.stringify(item); } - 键值生成函数不应改变任何组件状态。    
说明
  ForEach的itemGenerator函数可以包含if/else条件渲染逻辑。另外，也可以在if/else条件渲染语句中使用ForEach组件。 在初始化渲染时，ForEach会加载数据源的所有数据，并为每个数据项创建对应的组件，然后将其挂载到渲染树上。如果数据源非常大或有特定的性能需求，建议使用LazyForEach组件。  
   键值生成规则 在ForEach循环渲染过程中，系统会为每个数组元素生成一个唯一且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建一个新的组件。 ForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: any, index: number) => { return index + '__' + JSON.stringify(item); }。 ArkUI框架对于ForEach的键值生成有一套特定的判断规则，这主要与itemGenerator函数的第二个参数index以及keyGenerator函数的第二个参数index有关，具体的键值生成规则判断逻辑如下图所示。  图1 ForEach键值生成规则  
说明
 ArkUI框架会对重复的键值发出警告。在UI更新的场景下，如果出现重复的键值，框架可能无法正常工作，具体请参见渲染结果非预期。 
   组件创建规则 在确定键值生成规则后，ForEach的第二个参数itemGenerator函数会根据键值生成规则为数据源的每个数组项创建组件。组件的创建包括两种情况：ForEach首次渲染和ForEach非首次渲染。   首次渲染 在ForEach首次渲染时，会根据前述键值生成规则为数据源的每个数组项生成唯一键值，并创建相应的组件。 已复制@Entry@Componentstruct Parent {  @State simpleList: Array<string> = ['one', 'two', 'three'];
  build() {    Row() {      Column() {        ForEach(this.simpleList, (item: string) => {          ChildItem({ 'item': item } as Record<string, string>)        }, (item: string) => item)      }      .width('100%')      .height('100%')    }    .height('100%')    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ChildItem {  @Prop item: string;
  build() {    Text(this.item)      .fontSize(50)  }} 运行效果如下图所示。  图2 ForEach数据源不存在相同值案例首次渲染运行效果图  在上述代码中，键值生成规则是keyGenerator函数的返回值item。在ForEach渲染循环时，为数据源数组项依次生成键值one、two和three，并创建对应的ChildItem组件渲染到界面上。 当不同数组项按照键值生成规则生成的键值相同时，框架的行为是未定义的。例如，在以下代码中，ForEach渲染相同的数据项two时，只创建了一个ChildItem组件，而没有创建多个具有相同键值的组件。 已复制@Entry@Componentstruct Parent {  @State simpleList: Array<string> = ['one', 'two', 'two', 'three'];
  build() {    Row() {      Column() {        ForEach(this.simpleList, (item: string) => {          ChildItem({ 'item': item } as Record<string, string>)        }, (item: string) => item)      }      .width('100%')      .height('100%')    }    .height('100%')    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ChildItem {  @Prop item: string;
  build() {    Text(this.item)      .fontSize(50)  }} 运行效果如下图所示。  图3 ForEach数据源存在相同值案例首次渲染运行效果图  在该示例中，最终键值生成规则为item。当ForEach遍历数据源simpleList，遍历到索引为1的two时，按照最终键值生成规则生成键值为two的组件并进行标记。当遍历到索引为2的two时，按照最终键值生成规则当前项的键值也为two，此时不再创建新的组件。   非首次渲染 在ForEach组件进行非首次渲染时，它会检查新生成的键值是否在上次渲染中已经存在。如果键值不存在，则会创建一个新的组件；如果键值存在，则不会创建新的组件，而是直接渲染该键值所对应的组件。例如，在以下的代码示例中，通过点击事件修改了数组的第三项值为"new three"，这将触发ForEach组件进行非首次渲染。 已复制@Entry@Componentstruct Parent {  @State simpleList: Array<string> = ['one', 'two', 'three'];
  build() {    Row() {      Column() {        Text('点击修改第3个数组项的值')          .fontSize(24)          .fontColor(Color.Red)          .onClick(() => {            this.simpleList[2] = 'new three';          })
        ForEach(this.simpleList, (item: string) => {          ChildItem({ 'item': item } as Record<string, string>)            .margin({ top: 20 })        }, (item: string) => item)      }      .justifyContent(FlexAlign.Center)      .width('100%')      .height('100%')    }    .height('100%')    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ChildItem {  @Prop item: string;
  build() {    Text(this.item)      .fontSize(30)  }} 运行效果如下图所示。  图4 ForEach非首次渲染案例运行效果图  从本例可以看出@State 能够监听到简单数据类型数组数据源 simpleList 数组项的变化。  当 simpleList 数组项发生变化时，会触发 ForEach 进行重新渲染。 ForEach 遍历新的数据源 ['one', 'two', 'new three']，并生成对应的键值one、two和new three。 其中，键值one和two在上次渲染中已经存在，所以 ForEach 复用了对应的组件并进行了渲染。对于第三个数组项 "new three"，由于其通过键值生成规则 item 生成的键值new three在上次渲染中不存在，因此 ForEach 为该数组项创建了一个新的组件。    使用场景 ForEach组件在开发过程中的主要应用场景包括：数据源不变、数据源数组项发生变化（如插入、删除操作）、数据源数组项子属性变化。   数据源不变 在数据源保持不变的场景中，数据源可以直接采用基本数据类型。例如，在页面加载状态时，可以使用骨架屏列表进行渲染展示。 已复制@Entry@Componentstruct ArticleList {  @State simpleList: Array<number> = [1, 2, 3, 4, 5];
  build() {    Column() {      ForEach(this.simpleList, (item: string) => {        ArticleSkeletonView()          .margin({ top: 20 })      }, (item: string) => item)    }    .padding(20)    .width('100%')    .height('100%')  }}
@Builderfunction textArea(width: number | Resource | string = '100%', height: number | Resource | string = '100%') {  Row()    .width(width)    .height(height)    .backgroundColor('#FFF2F3F4')}
@Componentstruct ArticleSkeletonView {  build() {    Row() {      Column() {        textArea(80, 80)      }      .margin({ right: 20 })
      Column() {        textArea('60%', 20)        textArea('50%', 20)      }      .alignItems(HorizontalAlign.Start)      .justifyContent(FlexAlign.SpaceAround)      .height('100%')    }    .padding(20)    .borderRadius(12)    .backgroundColor('#FFECECEC')    .height(120)    .width('100%')    .justifyContent(FlexAlign.SpaceBetween)  }} 运行效果如下图所示。  图5 骨架屏运行效果图  在本示例中，采用数据项item作为键值生成规则，由于数据源simpleList的数组项各不相同，因此能够保证键值的唯一性。   数据源数组项发生变化 在数据源数组项发生变化的场景下，例如进行数组插入、删除操作或者数组项索引位置发生交换时，数据源应为对象数组类型，并使用对象的唯一ID作为最终键值。例如，当在页面上通过手势上滑加载下一页数据时，会在数据源数组尾部新增新获取的数据项，从而使得数据源数组长度增大。 已复制class Article {  id: string;  title: string;  brief: string;
  constructor(id: string, title: string, brief: string) {    this.id = id;    this.title = title;    this.brief = brief;  }}
@Entry@Componentstruct ArticleListView {  @State isListReachEnd: boolean = false;  @State articleList: Array<Article> = [    new Article('001', '第1篇文章', '文章简介内容'),    new Article('002', '第2篇文章', '文章简介内容'),    new Article('003', '第3篇文章', '文章简介内容'),    new Article('004', '第4篇文章', '文章简介内容'),    new Article('005', '第5篇文章', '文章简介内容'),    new Article('006', '第6篇文章', '文章简介内容')  ]
  loadMoreArticles() {    this.articleList.push(new Article('007', '加载的新文章', '文章简介内容'));  }
  build() {    Column({ space: 5 }) {      List() {        ForEach(this.articleList, (item: Article) => {          ListItem() {            ArticleCard({ article: item })              .margin({ top: 20 })          }        }, (item: Article) => item.id)      }      .onReachEnd(() => {        this.isListReachEnd = true;      })      .parallelGesture(        PanGesture({ direction: PanDirection.Up, distance: 80 })          .onActionStart(() => {            if (this.isListReachEnd) {              this.loadMoreArticles();              this.isListReachEnd = false;            }          })      )      .padding(20)      .scrollBar(BarState.Off)    }    .width('100%')    .height('100%')    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ArticleCard {  @Prop article: Article;
  build() {    Row() {      Image($r('app.media.icon'))        .width(80)        .height(80)        .margin({ right: 20 })
      Column() {        Text(this.article.title)          .fontSize(20)          .margin({ bottom: 8 })        Text(this.article.brief)          .fontSize(16)          .fontColor(Color.Gray)          .margin({ bottom: 8 })      }      .alignItems(HorizontalAlign.Start)      .width('80%')      .height('100%')    }    .padding(20)    .borderRadius(12)    .backgroundColor('#FFECECEC')    .height(120)    .width('100%')    .justifyContent(FlexAlign.SpaceBetween)  }} 初始运行效果（左图）和手势上滑加载后效果（右图）如下图所示。  图6 数据源数组项变化案例运行效果图  在本示例中，ArticleCard组件作为ArticleListView组件的子组件，通过@Prop装饰器接收一个Article对象，用于渲染文章卡片。  当列表滚动到底部时，如果手势滑动距离超过指定的80，将触发loadMoreArticle()函数。此函数会在articleList数据源的尾部添加一个新的数据项，从而增加数据源的长度。 数据源被@State装饰器修饰，ArkUI框架能够感知到数据源长度的变化，并触发ForEach进行重新渲染。    数据源数组项子属性变化 当数据源的数组项为对象数据类型，并且只修改某个数组项的属性值时，由于数据源为复杂数据类型，ArkUI框架无法监听到@State装饰器修饰的数据源数组项的属性变化，从而无法触发ForEach的重新渲染。为实现ForEach重新渲染，需要结合@Observed和@ObjectLink装饰器使用。例如，在文章列表卡片上点击“点赞”按钮，从而修改文章的点赞数量。 已复制@Observedclass Article {  id: string;  title: string;  brief: string;  isLiked: boolean;  likesCount: number;
  constructor(id: string, title: string, brief: string, isLiked: boolean, likesCount: number) {    this.id = id;    this.title = title;    this.brief = brief;    this.isLiked = isLiked;    this.likesCount = likesCount;  }}
@Entry@Componentstruct ArticleListView {  @State articleList: Array<Article> = [    new Article('001', '第0篇文章', '文章简介内容', false, 100),    new Article('002', '第1篇文章', '文章简介内容', false, 100),    new Article('003', '第2篇文章', '文章简介内容', false, 100),    new Article('004', '第4篇文章', '文章简介内容', false, 100),    new Article('005', '第5篇文章', '文章简介内容', false, 100),    new Article('006', '第6篇文章', '文章简介内容', false, 100),  ];
  build() {    List() {      ForEach(this.articleList, (item: Article) => {        ListItem() {          ArticleCard({            article: item          })            .margin({ top: 20 })        }      }, (item: Article) => item.id)    }    .padding(20)    .scrollBar(BarState.Off)    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ArticleCard {  @ObjectLink article: Article;
  handleLiked() {    this.article.isLiked = !this.article.isLiked;    this.article.likesCount = this.article.isLiked ? this.article.likesCount + 1 : this.article.likesCount - 1;  }
  build() {    Row() {      Image($r('app.media.icon'))        .width(80)        .height(80)        .margin({ right: 20 })
      Column() {        Text(this.article.title)          .fontSize(20)          .margin({ bottom: 8 })        Text(this.article.brief)          .fontSize(16)          .fontColor(Color.Gray)          .margin({ bottom: 8 })
        Row() {          Image(this.article.isLiked ? $r('app.media.iconLiked') : $r('app.media.iconUnLiked'))            .width(24)            .height(24)            .margin({ right: 8 })          Text(this.article.likesCount.toString())            .fontSize(16)        }        .onClick(() => this.handleLiked())        .justifyContent(FlexAlign.Center)      }      .alignItems(HorizontalAlign.Start)      .width('80%')      .height('100%')    }    .padding(20)    .borderRadius(12)    .backgroundColor('#FFECECEC')    .height(120)    .width('100%')    .justifyContent(FlexAlign.SpaceBetween)  }} 上述代码的初始运行效果（左图）和点击第1个文章卡片上的点赞图标后的运行效果（右图）如下图所示。  图7 数据源数组项子属性变化案例运行效果图  在本示例中，Article类被@Observed装饰器修饰。父组件ArticleListView传入Article对象实例给子组件ArticleCard，子组件使用@ObjectLink装饰器接收该实例。  当点击第1个文章卡片上的点赞图标时，会触发ArticleCard组件的handleLiked函数。该函数修改第1个卡片对应组件里article实例的isLiked和likesCount属性值。 由于子组件ArticleCard中的article使用了@ObjectLink装饰器，父子组件共享同一份article数据。因此，父组件中articleList的第1个数组项的isLiked和likedCounts数值也会同步修改。 当父组件监听到数据源数组项属性值变化时，会触发ForEach重新渲染。 在此处，ForEach键值生成规则为数组项的id属性值。当ForEach遍历新数据源时，数组项的id均没有变化，不会新建组件。 渲染第1个数组项对应的ArticleCard组件时，读取到的isLiked和likesCount为修改后的新值。    使用建议  尽量避免在最终的键值生成规则中包含数据项索引index，以防止出现渲染结果非预期和渲染性能降低。如果业务确实需要使用index，例如列表需要通过index进行条件渲染，开发者需要接受ForEach在改变数据源后重新创建组件所带来的性能损耗。 为满足键值的唯一性，对于对象数据类型，建议使用对象数据中的唯一id作为键值。 基本数据类型的数据项没有唯一ID属性。如果使用基本数据类型本身作为键值，必须确保数组项无重复。因此，对于数据源会发生变化的场景，建议将基本数据类型数组转化为具备唯一ID属性的对象数据类型数组，再使用ID属性作为键值生成规则。    不推荐案例 开发者在使用ForEach的过程中，若对于键值生成规则的理解不够充分，可能会出现错误的使用方式。错误使用一方面会导致功能层面问题，例如渲染结果非预期，另一方面会导致性能层面问题，例如渲染性能降低。   渲染结果非预期 在本示例中，通过设置ForEach的第三个参数KeyGenerator函数，自定义键值生成规则为数据源的索引index的字符串类型值。当点击父组件Parent中“在第1项后插入新项”文本组件后，界面会出现非预期的结果。 已复制@Entry@Componentstruct Parent {  @State simpleList: Array<string> = ['one', 'two', 'three'];
  build() {    Column() {      Button() {        Text('在第1项后插入新项').fontSize(30)      }      .onClick(() => {        this.simpleList.splice(1, 0, 'new item');      })
      ForEach(this.simpleList, (item: string) => {        ChildItem({ 'item': item } as Record<string, string>)      }, (item: string, index: number) => index.toString())    }    .justifyContent(FlexAlign.Center)    .width('100%')    .height('100%')    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ChildItem {  @Prop item: string;
  build() {    Text(this.item)      .fontSize(30)  }} 上述代码的初始渲染效果（左图）和点击“在第1项后插入新项”文本组件后的渲染效果（右图）如下图所示。  图8 渲染结果非预期运行效果图  ForEach在首次渲染时，创建的键值依次为"0"、"1"、"2"。 插入新项后，数据源simpleList变为['one', 'new item', 'two', 'three']，框架监听到@State装饰的数据源长度变化触发ForEach重新渲染。 ForEach依次遍历新数据源，遍历数据项"one"时生成键值"0"，存在相同键值，因此不创建新组件。继续遍历数据项"new item"时生成键值"1"，存在相同键值，因此不创建新组件。继续遍历数据项"two"生成键值"2"，存在相同键值，因此不创建新组件。最后遍历数据项"three"时生成键值"3"，不存在相同键值，创建内容为"three"的新组件并渲染。 从以上可以看出，当最终键值生成规则包含index时，期望的界面渲染结果为['one', 'new item', 'two', 'three']，而实际的渲染结果为['one', 'two', 'three', 'three']，渲染结果不符合开发者预期。因此，开发者在使用ForEach时应尽量避免最终键值生成规则中包含index。   渲染性能降低 在本示例中，ForEach的第三个参数KeyGenerator函数处于缺省状态。根据上述键值生成规则，此例使用框架默认的键值生成规则，即最终键值为字符串index + '__' + JSON.stringify(item)。当点击“在第1项后插入新项”文本组件后，ForEach将需要为第2个数组项以及其后的所有项重新创建组件。 已复制@Entry@Componentstruct Parent {  @State simpleList: Array<string> = ['one', 'two', 'three'];
  build() {    Column() {      Button() {        Text('在第1项后插入新项').fontSize(30)      }      .onClick(() => {        this.simpleList.splice(1, 0, 'new item');        console.log(`[onClick]: simpleList is ${JSON.stringify(this.simpleList)}`);      })
      ForEach(this.simpleList, (item: string) => {        ChildItem({ 'item': item } as Record<string, string>)      })    }    .justifyContent(FlexAlign.Center)    .width('100%')    .height('100%')    .backgroundColor(0xF1F3F5)  }}
@Componentstruct ChildItem {  @Prop item: string;
  aboutToAppear() {    console.log(`[aboutToAppear]: item is ${this.item}`);  }
  build() {    Text(this.item)      .fontSize(50)  }} 以上代码的初始渲染效果（左图）和点击"在第1项后插入新项"文本组件后的渲染效果（右图）如下所示。  图9 渲染性能降低案例运行效果图  点击“在第1项后插入新项”文本组件后，IDE的日志打印结果如下所示。  图10 插入新项后渲染效果 插入新项后，ForEach为new item、 two、 three三个数组项创建了对应的组件ChildItem，并执行了组件的aboutToAppear()生命周期函数。这是因为：  在ForEach首次渲染时，创建的键值依次为0__one、1__two、2__three。 插入新项后，数据源simpleList变为['one', 'new item', 'two', 'three']，ArkUI框架监听到@State装饰的数据源长度变化触发ForEach重新渲染。 ForEach依次遍历新数据源，遍历数据项one时生成键值0__one，键值已存在，因此不创建新组件。继续遍历数据项new item时生成键值1__new item，不存在相同键值，创建内容为new item的新组件并渲染。继续遍历数据项two生成键值2__two，不存在相同键值，创建内容为two的新组件并渲染。最后遍历数据项three时生成键值3__three，不存在相同键值，创建内容为three的新组件并渲染。  尽管此示例中界面渲染的结果符合预期，但每次插入一条新数组项时，ForEach都会为从该数组项起后面的所有数组项全部重新创建组件。当数据源数据量较大或组件结构复杂时，由于组件无法得到复用，将导致性能体验不佳。因此，除非必要，否则不推荐将第三个参数KeyGenerator函数处于缺省状态，以及在键值生成规则中包含数据项索引index。    上一篇 if/else：条件渲染 下一篇 LazyForEach：数据懒加载 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用规则更新机制使用场景使用if进行条件渲染if ... else ...语句和子组件状态嵌套if语句if/else：条件渲染 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，使用if、else和else if渲染对应状态下的UI内容。 
说明
从API version 9开始，该接口支持在ArkTS卡片中使用。 
 使用规则支持if、else和else if语句。if、else if后跟随的条件语句可以使用状态变量。允许在容器组件内使用，通过条件渲染语句构建不同的子组件。条件渲染语句在涉及到组件的父子关系时是“透明”的，当父组件和子组件之间存在一个或多个if语句时，必须遵守父组件关于子组件使用的规则。每个分支内部的构建函数必须遵循构建函数的规则，并创建一个或多个组件。无法创建组件的空构建函数会产生语法错误。某些容器组件限制子组件的类型或数量，将条件渲染语句用于这些组件内时，这些限制将同样应用于条件渲染语句内创建的组件。例如，Grid容器组件的子组件仅支持GridItem组件，在Grid内使用条件渲染语句时，条件渲染语句内仅允许使用GridItem组件。  更新机制当if、else if后跟随的状态判断中使用的状态变量值变化时，条件渲染语句会进行更新，更新步骤如下： 评估if和else if的状态判断条件，如果分支没有变化，无需执行以下步骤。如果分支有变化，则执行2、3步骤：删除此前构建的所有子组件。执行新分支的构造函数，将获取到的组件添加到if父容器中。如果缺少适用的else分支，则不构建任何内容。 条件可以包括Typescript表达式。对于构造函数中的表达式，此类表达式不得更改应用程序状态。  使用场景 使用if进行条件渲染已复制@Entry@Componentstruct ViewA {  @State count: number = 0;
  build() {    Column() {      Text(`count=${this.count}`)
      if (this.count > 0) {        Text(`count is positive`)          .fontColor(Color.Green)      }
      Button('increase count')        .onClick(() => {          this.count++;        })
      Button('decrease count')        .onClick(() => {          this.count--;        })    }  }} if语句的每个分支都包含一个构建函数。此类构建函数必须创建一个或多个子组件。在初始渲染时，if语句会执行构建函数，并将生成的子组件添加到其父组件中。 每当if或else if条件语句中使用的状态变量发生变化时，条件语句都会更新并重新评估新的条件值。如果条件值评估发生了变化，这意味着需要构建另一个条件分支。此时ArkUI框架将： 删除所有以前渲染的（早期分支的）组件。执行新分支的构造函数，将生成的子组件添加到其父组件中。 在以上示例中，如果count从0增加到1，那么if语句更新，条件count > 0将重新评估，评估结果将从false更改为true。因此，将执行条件为真分支的构造函数，创建一个Text组件，并将它添加到父组件Column中。如果后续count更改为0，则Text组件将从Column组件中删除。由于没有else分支，因此不会执行新的构造函数。  if ... else ...语句和子组件状态以下示例包含if ... else ...语句与拥有@State装饰变量的子组件。 已复制@Componentstruct CounterView {  @State counter: number = 0;  label: string = 'unknown';
  build() {    Row() {      Text(`${this.label}`)      Button(`counter ${this.counter} +1`)        .onClick(() => {          this.counter += 1;        })    }  }}
@Entry@Componentstruct MainView {  @State toggle: boolean = true;
  build() {    Column() {      if (this.toggle) {        CounterView({ label: 'CounterView #positive' })      } else {        CounterView({ label: 'CounterView #negative' })      }      Button(`toggle ${this.toggle}`)        .onClick(() => {          this.toggle = !this.toggle;        })    }  }} CounterView（label为 'CounterView #positive'）子组件在初次渲染时创建。此子组件携带名为counter的状态变量。当修改CounterView.counter状态变量时，CounterView（label为 'CounterView #positive'）子组件重新渲染时并保留状态变量值。当MainView.toggle状态变量的值更改为false时，MainView父组件内的if语句将更新，随后将删除CounterView（label为 'CounterView #positive'）子组件。与此同时，将创建新的CounterView（label为 'CounterView #negative'）实例。而它自己的counter状态变量设置为初始值0。 
说明
CounterView（label为 'CounterView #positive'）和CounterView（label为 'CounterView #negative'）是同一自定义组件的两个不同实例。if分支的更改，不会更新现有子组件，也不会保留状态。 
 以下示例展示了条件更改时，若需要保留counter值所做的修改。 已复制@Componentstruct CounterView {  @Link counter: number;  label: string = 'unknown';
  build() {    Row() {      Text(`${this.label}`)      Button(`counter ${this.counter} +1`)        .onClick(() => {          this.counter += 1;        })    }  }}
@Entry@Componentstruct MainView {  @State toggle: boolean = true;  @State counter: number = 0;
  build() {    Column() {      if (this.toggle) {        CounterView({ counter: $counter, label: 'CounterView #positive' })      } else {        CounterView({ counter: $counter, label: 'CounterView #negative' })      }      Button(`toggle ${this.toggle}`)        .onClick(() => {          this.toggle = !this.toggle;        })    }  }} 此处，@State counter变量归父组件所有。因此，当CounterView组件实例被删除时，该变量不会被销毁。CounterView组件通过@Link装饰器引用状态。状态必须从子级移动到其父级（或父级的父级），以避免在条件内容或重复内容被销毁时丢失状态。  嵌套if语句条件语句的嵌套对父组件的相关规则没有影响。 已复制@Entry@Componentstruct CompA {  @State toggle: boolean = false;  @State toggleColor: boolean = false;
  build() {    Column() {      Text('Before')        .fontSize(15)      if (this.toggle) {        Text('Top True, positive 1 top')          .backgroundColor('#aaffaa').fontSize(20)        // 内部if语句        if (this.toggleColor) {          Text('Top True, Nested True, positive COLOR  Nested ')            .backgroundColor('#00aaaa').fontSize(15)        } else {          Text('Top True, Nested False, Negative COLOR  Nested ')            .backgroundColor('#aaaaff').fontSize(15)        }      } else {        Text('Top false, negative top level').fontSize(20)          .backgroundColor('#ffaaaa')        if (this.toggleColor) {          Text('positive COLOR  Nested ')            .backgroundColor('#00aaaa').fontSize(15)        } else {          Text('Negative COLOR  Nested ')            .backgroundColor('#aaaaff').fontSize(15)        }      }      Text('After')        .fontSize(15)      Button('Toggle Outer')        .onClick(() => {          this.toggle = !this.toggle;        })      Button('Toggle Inner')        .onClick(() => {          this.toggleColor = !this.toggleColor;        })    }  }}   上一篇 渲染控制概述 下一篇 ForEach：循环渲染 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口描述IDataSource类型说明DataChangeListener类型说明使用限制键值生成规则组件创建规则首次渲染非首次渲染常见使用问题LazyForEach：数据懒加载 更新时间: 2024-03-25 11:20 毫无帮助帮助不大一般很好非常好
分享
 LazyForEach从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。当在滚动容器中使用了LazyForEach，框架会根据滚动容器可视区域按需创建组件，当组件滑出可视区域外时，框架会进行组件销毁回收以降低内存占用。 接口描述已复制LazyForEach(    dataSource: IDataSource,             // 需要进行数据迭代的数据源    itemGenerator: (item: any, index: number) => void,  // 子组件生成函数    keyGenerator?: (item: any, index: number) => string // 键值生成函数): void 参数： 参数名  参数类型  必填  参数描述    dataSource  IDataSource  是  LazyForEach数据源，需要开发者实现相关接口。   itemGenerator  (item: any， index:number) => void  是  子组件生成函数，为数组中的每一个数据项创建一个子组件。 说明： item是当前数据项，index是数据项索引值。 itemGenerator的函数体必须使用大括号{...}。itemGenerator每次迭代只能并且必须生成一个子组件。itemGenerator中可以使用if语句，但是必须保证if语句每个分支都会创建一个相同类型的子组件。itemGenerator中不允许使用ForEach和LazyForEach语句。   keyGenerator  (item: any, index:number) => string  否  键值生成函数，用于给数据源中的每一个数据项生成唯一且固定的键值。当数据项在数组中的位置更改时，其键值不得更改，当数组中的数据项被新项替换时，被替换项的键值和新项的键值必须不同。键值生成器的功能是可选的，但是，为了使开发框架能够更好地识别数组更改，提高性能，建议提供。如将数组反向时，如果没有提供键值生成器，则LazyForEach中的所有节点都将重建。 说明： item是当前数据项，index是数据项索引值。 数据源中的每一个数据项生成的键值不能重复。      IDataSource类型说明已复制interface IDataSource {    totalCount(): number; // 获得数据总数    getData(index: number): Object; // 获取索引值对应的数据    registerDataChangeListener(listener: DataChangeListener): void; // 注册数据改变的监听器    unregisterDataChangeListener(listener: DataChangeListener): void; // 注销数据改变的监听器} 接口声明  参数类型  说明    totalCount(): number  -  获得数据总数。   getData(index: number): any  number  获取索引值index对应的数据。 index：获取数据对应的索引值。   registerDataChangeListener(listener:DataChangeListener): void  DataChangeListener  注册数据改变的监听器。 listener：数据变化监听器   unregisterDataChangeListener(listener:DataChangeListener): void  DataChangeListener  注销数据改变的监听器。 listener：数据变化监听器      DataChangeListener类型说明已复制interface DataChangeListener {    onDataReloaded(): void; // 重新加载数据完成后调用    onDataAdded(index: number): void; // 添加数据完成后调用    onDataMoved(from: number, to: number): void; // 数据移动起始位置与数据移动目标位置交换完成后调用    onDataDeleted(index: number): void; // 删除数据完成后调用    onDataChanged(index: number): void; // 改变数据完成后调用    onDataAdd(index: number): void; // 添加数据完成后调用    onDataMove(from: number, to: number): void; // 数据移动起始位置与数据移动目标位置交换完成后调用    onDataDelete(index: number): void; // 删除数据完成后调用    onDataChange(index: number): void; // 改变数据完成后调用} 接口声明  参数类型  说明    onDataReloaded(): void  -  通知组件重新加载所有数据。 键值没有变化的数据项会使用原先的子组件，键值发生变化的会重建子组件。   onDataAdd(index: number): void8+  number  通知组件index的位置有数据添加。 index：数据添加位置的索引值。   onDataMove(from: number, to: number): void8+  from: number, to: number  通知组件数据有移动。 from: 数据移动起始位置，to: 数据移动目标位置。 说明： 数据移动前后键值要保持不变，如果键值有变化，应使用删除数据和新增数据接口。   onDataDelete(index: number):void8+  number  通知组件删除index位置的数据并刷新LazyForEach的展示内容。 index：数据删除位置的索引值。 说明： 需要保证dataSource中的对应数据已经在调用onDataDelete前删除，否则页面渲染将出现未定义的行为。   onDataChange(index: number): void8+  number  通知组件index的位置有数据有变化。 index：数据变化位置的索引值。   onDataAdded(index: number):void(deprecated)  number  通知组件index的位置有数据添加。 从API 8开始，建议使用onDataAdd。 index：数据添加位置的索引值。   onDataMoved(from: number, to: number): void(deprecated)  from: number, to: number  通知组件数据有移动。 从API 8开始，建议使用onDataMove。 from: 数据移动起始位置，to: 数据移动目标位置。 将from和to位置的数据进行交换。 说明： 数据移动前后键值要保持不变，如果键值有变化，应使用删除数据和新增数据接口。   onDataDeleted(index: number):void(deprecated)  number  通知组件删除index位置的数据并刷新LazyForEach的展示内容。 从API 8开始，建议使用onDataDelete。 index：数据删除位置的索引值。   onDataChanged(index: number): void(deprecated)  number  通知组件index的位置有数据有变化。 从API 8开始，建议使用onDataChange。 index：数据变化监听器。      使用限制LazyForEach必须在容器组件内使用，仅有List、Grid、Swiper以及WaterFlow组件支持数据懒加载（可配置cachedCount属性，即只加载可视部分以及其前后少量数据用于缓冲），其他组件仍然是一次性加载所有的数据。LazyForEach在每次迭代中，必须创建且只允许创建一个子组件。生成的子组件必须是允许包含在LazyForEach父容器组件中的子组件。允许LazyForEach包含在if/else条件渲染语句中，也允许LazyForEach中出现if/else条件渲染语句。键值生成器必须针对每个数据生成唯一的值，如果键值相同，将导致键值相同的UI组件渲染出现问题。LazyForEach必须使用DataChangeListener对象来进行更新，第一个参数dataSource使用状态变量时，状态变量改变不会触发LazyForEach的UI刷新。为了高性能渲染，通过DataChangeListener对象的onDataChange方法来更新UI时，需要生成不同于原来的键值来触发组件刷新。  键值生成规则在LazyForEach循环渲染过程中，系统会为每个item生成一个唯一且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建一个新的组件。 LazyForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: any, index: number) => { return viewId + '-' + index.toString(); }, viewId在编译器转换过程中生成，同一个LazyForEach组件内其viewId是一致的。  组件创建规则在确定键值生成规则后，LazyForEach的第二个参数itemGenerator函数会根据键值生成规则为数据源的每个数组项创建组件。组件的创建包括两种情况：LazyForEach首次渲染和LazyForEach非首次渲染。  首次渲染生成不同键值 在LazyForEach首次渲染时，会根据上述键值生成规则为数据源的每个数组项生成唯一键值，并创建相应的组件。 已复制// Basic implementation of IDataSource to handle data listenerclass BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  // 该方法为框架侧调用，为LazyForEach组件向其数据源处添加listener监听  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  // 该方法为框架侧调用，为对应的LazyForEach组件在数据源处去除listener监听  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  // 通知LazyForEach组件需要重载所有子组件  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  // 通知LazyForEach组件需要在index对应索引处添加子组件  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  // 通知LazyForEach组件在index对应索引处数据有变化，需要重建该子组件  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  // 通知LazyForEach组件需要在index对应索引处删除该子组件  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource();     aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }      }, (item: string) => item)    }.cachedCount(5)  }} 在上述代码中，键值生成规则是keyGenerator函数的返回值item。在LazyForEach循环渲染时，其为数据源数组项依次生成键值Hello 0、Hello 1 ... Hello 20，并创建对应的ListItem子组件渲染到界面上。 运行效果如下图所示。 图1 LazyForEach正常首次渲染  键值相同时错误渲染 当不同数据项生成的键值相同时，框架的行为是不可预测的。例如，在以下代码中，LazyForEach渲染的数据项键值均相同，在滑动过程中，LazyForEach会对划入划出当前页面的子组件进行预加载，而新建的子组件和销毁的原子组件具有相同的键值，框架可能存在取用缓存错误的情况，导致子组件渲染有问题。 已复制class BasicDataSource implements IDataSource { private listeners: DataChangeListener[] = []; private originDataArray: string[] = [];
 public totalCount(): number {   return 0; }
 public getData(index: number): string {   return this.originDataArray[index]; }
 registerDataChangeListener(listener: DataChangeListener): void {   if (this.listeners.indexOf(listener) < 0) {     console.info('add listener');     this.listeners.push(listener);   } }
 unregisterDataChangeListener(listener: DataChangeListener): void {   const pos = this.listeners.indexOf(listener);   if (pos >= 0) {     console.info('remove listener');     this.listeners.splice(pos, 1);   } }
 notifyDataReload(): void {   this.listeners.forEach(listener => {     listener.onDataReloaded();   }) }
 notifyDataAdd(index: number): void {   this.listeners.forEach(listener => {     listener.onDataAdd(index);   }) }
 notifyDataChange(index: number): void {   this.listeners.forEach(listener => {     listener.onDataChange(index);   }) }
 notifyDataDelete(index: number): void {   this.listeners.forEach(listener => {     listener.onDataDelete(index);   }) }}
class MyDataSource extends BasicDataSource { private dataArray: string[] = [];
 public totalCount(): number {   return this.dataArray.length; }
 public getData(index: number): string {   return this.dataArray[index]; }
 public addData(index: number, data: string): void {   this.dataArray.splice(index, 0, data);   this.notifyDataAdd(index); }
 public pushData(data: string): void {   this.dataArray.push(data);   this.notifyDataAdd(this.dataArray.length - 1); }}
@Entry@Componentstruct MyComponent { private data: MyDataSource = new MyDataSource();
 aboutToAppear() {   for (let i = 0; i <= 20; i++) {     this.data.pushData(`Hello ${i}`)   } }
 build() {   List({ space: 3 }) {     LazyForEach(this.data, (item: string) => {       ListItem() {         Row() {           Text(item).fontSize(50)             .onAppear(() => {               console.info("appear:" + item)             })         }.margin({ left: 10, right: 10 })       }     }, (item: string) => 'same key')   }.cachedCount(5) }} 运行效果如下图所示。可以看到Hello 0在滑动过程中被错误渲染为Hello 13。 图2 LazyForEach存在相同键值   非首次渲染当LazyForEach数据源发生变化，需要再次渲染时，开发者应根据数据源的变化情况调用listener对应的接口，通知LazyForEach做相应的更新，各使用场景如下。 添加数据 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          // 点击追加子组件          this.data.pushData(`Hello ${this.data.totalCount()}`);        })      }, (item: string) => item)    }.cachedCount(5)  }} 当我们点击LazyForEach的子组件时，首先调用数据源data的pushData方法，该方法会在数据源末尾添加数据并调用notifyDataAdd方法。在notifyDataAdd方法内会又调用listener.onDataAdd方法，该方法会通知LazyForEach在该处有数据添加，LazyForEach便会在该索引处新建子组件。 运行效果如下图所示。 图3 LazyForEach添加数据  删除数据 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }    public deleteData(index: number): void {    this.dataArray.splice(index, 1);    this.notifyDataDelete(index);  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string, index: number) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          // 点击删除子组件          this.data.deleteData(this.data.dataArray.indexOf(item));        })      }, (item: string) => item)    }.cachedCount(5)  }} 当我们点击LazyForEach的子组件时，首先调用数据源data的deleteData方法，该方法会删除数据源对应索引处的数据并调用notifyDataDelete方法。在notifyDataDelete方法内会又调用listener.onDataDelete方法，该方法会通知LazyForEach在该处有数据删除，LazyForEach便会在该索引处删除对应子组件。 运行效果如下图所示。 图4 LazyForEach删除数据  改变单个数据 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }    public deleteData(index: number): void {    this.dataArray.splice(index, 1);    this.notifyDataDelete(index);  }    public changeData(index: number, data: string): void {    this.dataArray.splice(index, 1, data);    this.notifyDataChange(index);  }}
@Entry@Componentstruct MyComponent {  private moved: number[] = [];  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string, index: number) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          this.data.changeData(index, item + '00');        })      }, (item: string) => item)    }.cachedCount(5)  }} 当我们点击LazyForEach的子组件时，首先改变当前数据，然后调用数据源data的changeData方法，在该方法内会调用notifyDataChange方法。在notifyDataChange方法内会又调用listener.onDataChange方法，该方法通知LazyForEach组件该处有数据发生变化，LazyForEach便会在对应索引处重建子组件。 运行效果如下图所示。 图5 LazyForEach改变单个数据  改变多个数据 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }    public deleteData(index: number): void {    this.dataArray.splice(index, 1);    this.notifyDataDelete(index);  }    public changeData(index: number): void {    this.notifyDataChange(index);  }      public reloadData(): void {    this.notifyDataReload();  }      public modifyAllData(): void {    this.dataArray = this.dataArray.map((item: string) => {        return item + '0';    })  }}
@Entry@Componentstruct MyComponent {  private moved: number[] = [];  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string, index: number) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          this.data.modifyAllData();          this.data.reloadData();        })      }, (item: string) => item)    }.cachedCount(5)  }} 当我们点击LazyForEach的子组件时，首先调用data的modifyAllData方法改变了数据源中的所有数据，然后调用数据源的reloadData方法，在该方法内会调用notifyDataReload方法。在notifyDataReload方法内会又调用listener.onDataReloaded方法，通知LazyForEach需要重建所有子节点。LazyForEach会将原所有数据项和新所有数据项一一做键值比对，若有相同键值则使用缓存，若键值不同则重新构建。 运行效果如下图所示。 图6 LazyForEach改变多个数据  改变数据子属性 若仅靠LazyForEach的刷新机制，当item变化时若想更新子组件，需要将原来的子组件全部销毁再重新构建，在子组件结构较为复杂的情况下，靠改变键值去刷新渲染性能较低。因此框架提供了@Observed与@ObjectLink机制进行深度观测，可以做到仅刷新使用了该属性的组件，提高渲染性能。开发者可根据其自身业务特点选择使用哪种刷新方式。 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: StringData[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): StringData {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: StringData[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): StringData {    return this.dataArray[index];  }
  public addData(index: number, data: StringData): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: StringData): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }}
@Observedclass StringData {  message: string;  constructor(message: string) {    this.message = message;  }  }
@Entry@Componentstruct MyComponent {  private moved: number[] = [];  @State data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(new StringData(`Hello ${i}`));    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: StringData, index: number) => {        ListItem() {          ChildComponent({data: item})        }        .onClick(() => {          item.message += '0';        })      }, (item: StringData, index: number) => index.toString())    }.cachedCount(5)  }}
@Componentstruct ChildComponent {  @ObjectLink data: StringData  build() {    Row() {      Text(this.data.message).fontSize(50)        .onAppear(() => {          console.info("appear:" + this.data.message)        })    }.margin({ left: 10, right: 10 })  }} 此时点击LazyForEach子组件改变item.message时，重渲染依赖的是ChildComponent的@ObjectLink成员变量对其子属性的监听，此时框架只会刷新Text(this.data.message)，不会去重建整个ListItem子组件。 图7 LazyForEach改变数据子属性   常见使用问题渲染结果非预期已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }    public deleteData(index: number): void {    this.dataArray.splice(index, 1);    this.notifyDataDelete(index);  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string, index: number) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          // 点击删除子组件          this.data.deleteData(index);        })      }, (item: string) => item)    }.cachedCount(5)  }} 图8  LazyForEach删除数据非预期  当我们多次点击子组件时，会发现删除的并不一定是我们点击的那个子组件。原因是当我们删除了某一个子组件后，位于该子组件对应的数据项之后的各数据项，其index均应减1，但实际上后续的数据项对应的子组件仍然使用的是最初分配的index，其itemGenerator中的index并没有发生变化，所以删除结果和预期不符。 修复代码如下所示。 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: string[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): string {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: string[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): string {    return this.dataArray[index];  }
  public addData(index: number, data: string): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: string): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }    public deleteData(index: number): void {    this.dataArray.splice(index, 1);    this.notifyDataDelete(index);  }      public reloadData(): void {    this.notifyDataReload();  }}
@Entry@Componentstruct MyComponent {  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(`Hello ${i}`)    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: string, index: number) => {        ListItem() {          Row() {            Text(item).fontSize(50)              .onAppear(() => {                console.info("appear:" + item)              })          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          // 点击删除子组件          this.data.deleteData(index);          // 重置所有子组件的index索引          this.data.reloadData();        })      }, (item: string, index: number) => item + index.toString())    }.cachedCount(5)  }} 在删除一个数据项后调用reloadData方法，重建后面的数据项，以达到更新index索引的目的。 图9  修复LazyForEach删除数据非预期  重渲染时图片闪烁已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: StringData[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): StringData {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: StringData[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): StringData {    return this.dataArray[index];  }
  public addData(index: number, data: StringData): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: StringData): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }      public reloadData(): void {    this.notifyDataReload();  }}
class StringData {  message: string;  imgSrc: Resource;  constructor(message: string, imgSrc: Resource) {      this.message = message;      this.imgSrc = imgSrc;  }  }
@Entry@Componentstruct MyComponent {  private moved: number[] = [];  private data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: StringData, index: number) => {        ListItem() {          Column() {            Text(item.message).fontSize(50)              .onAppear(() => {                console.info("appear:" + item.message)              })            Image(item.imgSrc)              .width(500)              .height(200)          }.margin({ left: 10, right: 10 })        }        .onClick(() => {          item.message += '00';          this.data.reloadData();        })      }, (item: StringData, index: number) => JSON.stringify(item))    }.cachedCount(5)  }} 图10  LazyForEach仅改变文字但是图片闪烁问题  在我们点击ListItem子组件时，我们只改变了数据项的message属性，但是LazyForEach的刷新机制会导致整个ListItem被重建。由于Image组件是异步刷新，所以视觉上图片会发生闪烁。为了解决这种情况我们应该使用@ObjectLink和@Observed去单独刷新使用了item.message的Text组件。 修复代码如下所示。 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: StringData[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): StringData {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: StringData[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): StringData {    return this.dataArray[index];  }
  public addData(index: number, data: StringData): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: StringData): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }}
@Observedclass StringData {  message: string;  imgSrc: Resource;  constructor(message: string, imgSrc: Resource) {      this.message = message;      this.imgSrc = imgSrc;  }  }
@Entry@Componentstruct MyComponent {  @State data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(new StringData(`Hello ${i}`, $r('app.media.img')));    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: StringData, index: number) => {        ListItem() {          ChildComponent({data: item})        }        .onClick(() => {          item.message += '0';        })      }, (item: StringData, index: number) => index.toString())    }.cachedCount(5)  }}
@Componentstruct ChildComponent {  @ObjectLink data: StringData  build() {    Column() {      Text(this.data.message).fontSize(50)        .onAppear(() => {          console.info("appear:" + this.data.message)        })      Image(this.data.imgSrc)        .width(500)        .height(200)    }.margin({ left: 10, right: 10 })  }} 图11  修复LazyForEach仅改变文字但是图片闪烁问题  @ObjectLink属性变化UI未更新已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: StringData[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): StringData {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: StringData[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): StringData {    return this.dataArray[index];  }
  public addData(index: number, data: StringData): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: StringData): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }}
@Observedclass StringData {  message: NestedString;  constructor(message: NestedString) {    this.message = message;  }  }
@Observedclass NestedString {  message: string;  constructor(message: string) {    this.message = message;  }  }
@Entry@Componentstruct MyComponent {  private moved: number[] = [];  @State data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: StringData, index: number) => {        ListItem() {          ChildComponent({data: item})        }        .onClick(() => {          item.message.message += '0';        })      }, (item: StringData, index: number) => item.toString() + index.toString())    }.cachedCount(5)  }}
@Componentstruct ChildComponent {  @ObjectLink data: StringData  build() {    Row() {      Text(this.data.message.message).fontSize(50)        .onAppear(() => {          console.info("appear:" + this.data.message.message)        })    }.margin({ left: 10, right: 10 })  }} 图12  ObjectLink属性变化后UI未更新  @ObjectLink装饰的成员变量仅能监听到其子属性的变化，再深入嵌套的属性便无法观测到了，因此我们只能改变它的子属性去通知对应组件重新渲染，具体请查看@ObjectLink与@Observed的详细使用方法和限制条件。 修复代码如下所示。 已复制class BasicDataSource implements IDataSource {  private listeners: DataChangeListener[] = [];  private originDataArray: StringData[] = [];
  public totalCount(): number {    return 0;  }
  public getData(index: number): StringData {    return this.originDataArray[index];  }
  registerDataChangeListener(listener: DataChangeListener): void {    if (this.listeners.indexOf(listener) < 0) {      console.info('add listener');      this.listeners.push(listener);    }  }
  unregisterDataChangeListener(listener: DataChangeListener): void {    const pos = this.listeners.indexOf(listener);    if (pos >= 0) {      console.info('remove listener');      this.listeners.splice(pos, 1);    }  }
  notifyDataReload(): void {    this.listeners.forEach(listener => {      listener.onDataReloaded();    })  }
  notifyDataAdd(index: number): void {    this.listeners.forEach(listener => {      listener.onDataAdd(index);    })  }
  notifyDataChange(index: number): void {    this.listeners.forEach(listener => {      listener.onDataChange(index);    })  }
  notifyDataDelete(index: number): void {    this.listeners.forEach(listener => {      listener.onDataDelete(index);    })  }}
class MyDataSource extends BasicDataSource {  private dataArray: StringData[] = [];
  public totalCount(): number {    return this.dataArray.length;  }
  public getData(index: number): StringData {    return this.dataArray[index];  }
  public addData(index: number, data: StringData): void {    this.dataArray.splice(index, 0, data);    this.notifyDataAdd(index);  }
  public pushData(data: StringData): void {    this.dataArray.push(data);    this.notifyDataAdd(this.dataArray.length - 1);  }}
@Observedclass StringData {  message: NestedString;  constructor(message: NestedString) {    this.message = message;  }  }
@Observedclass NestedString {  message: string;  constructor(message: string) {    this.message = message;  }  }
@Entry@Componentstruct MyComponent {  private moved: number[] = [];  @State data: MyDataSource = new MyDataSource();
  aboutToAppear() {    for (let i = 0; i <= 20; i++) {      this.data.pushData(new StringData(new NestedString(`Hello ${i}`)));    }  }
  build() {    List({ space: 3 }) {      LazyForEach(this.data, (item: StringData, index: number) => {        ListItem() {          ChildComponent({data: item})        }        .onClick(() => {          item.message = new NestedString(item.message.message + '0');        })      }, (item: StringData, index: number) => item.toString() + index.toString())    }.cachedCount(5)  }}
@Componentstruct ChildComponent {  @ObjectLink data: StringData  build() {    Row() {      Text(this.data.message.message).fontSize(50)        .onAppear(() => {          console.info("appear:" + this.data.message.message)        })    }.margin({ left: 10, right: 10 })  }} 图13  修复ObjectLink属性变化后UI更新     上一篇 ForEach：循环渲染 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。渲染控制概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 ArkUI通过自定义组件的build()函数和@builder装饰器中的声明式UI描述语句构建相应的UI。在声明式描述语句中开发者除了使用系统组件外，还可以使用渲染控制语句来辅助UI的构建，这些渲染控制语句包括控制组件是否显示的条件渲染语句，基于数组数据快速生成组件的循环渲染语句以及针对大数据量场景的数据懒加载语句。  上一篇 渲染控制 下一篇 if/else：条件渲染 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。页面跳转页面返回页面返回前增加一个询问框系统默认询问框自定义询问框页面路由（router） 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  页面路由指在应用程序中实现不同页面之间的跳转和数据传递。HarmonyOS提供了Router模块，通过不同的url地址，可以方便地进行页面路由，轻松地访问不同的页面。本文将从页面跳转、页面返回和页面返回前增加一个询问框几个方面介绍Router模块提供的功能。  页面跳转 页面跳转是开发过程中的一个重要组成部分。在使用应用程序时，通常需要在不同的页面之间跳转，有时还需要将数据从一个页面传递到另一个页面。  图1 页面跳转  Router模块提供了两种跳转模式，分别是router.pushUrl()和router.replaceUrl()。这两种模式决定了目标页是否会替换当前页。  router.pushUrl()：目标页不会替换当前页，而是压入页面栈。这样可以保留当前页的状态，并且可以通过返回键或者调用router.back()方法返回到当前页。 router.replaceUrl()：目标页会替换当前页，并销毁当前页。这样可以释放当前页的资源，并且无法返回到当前页。  
说明
 页面栈的最大容量为32个页面。如果超过这个限制，可以调用router.clear()方法清空历史页面栈，释放内存空间。 
 同时，Router模块提供了两种实例模式，分别是Standard和Single。这两种模式决定了目标url是否会对应多个实例。  Standard：标准实例模式，也是默认情况下的实例模式。每次调用该方法都会新建一个目标页，并压入栈顶。 Single：单实例模式。即如果目标页的url在页面栈中已经存在同url页面，则离栈顶最近的同url页面会被移动到栈顶，并重新加载；如果目标页的url在页面栈中不存在同url页面，则按照标准模式跳转。  在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。 已复制import router from '@ohos.router';  场景一：有一个主页（Home）和一个详情页（Detail），希望从主页点击一个商品，跳转到详情页。同时，需要保留主页在页面栈中，以便返回时恢复状态。这种场景下，可以使用pushUrl()方法，并且使用Standard实例模式（或者省略）。 已复制// 在Home页面中function onJumpClick(): void {  router.pushUrl({    url: 'pages/Detail' // 目标url  }, router.RouterMode.Standard, (err) => {    if (err) {      console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);      return;    }    console.info('Invoke pushUrl succeeded.');  });} 
说明
 标准实例模式下，router.RouterMode.Standard参数可以省略。 
 场景二：有一个登录页（Login）和一个个人中心页（Profile），希望从登录页成功登录后，跳转到个人中心页。同时，销毁登录页，在返回时直接退出应用。这种场景下，可以使用replaceUrl()方法，并且使用Standard实例模式（或者省略）。 已复制// 在Login页面中function onJumpClick(): void {  router.replaceUrl({    url: 'pages/Profile' // 目标url  }, router.RouterMode.Standard, (err) => {    if (err) {      console.error(`Invoke replaceUrl failed, code is ${err.code}, message is ${err.message}`);      return;    }    console.info('Invoke replaceUrl succeeded.');  })} 
说明
 标准实例模式下，router.RouterMode.Standard参数可以省略。 
 场景三：有一个设置页（Setting）和一个主题切换页（Theme），希望从设置页点击主题选项，跳转到主题切换页。同时，需要保证每次只有一个主题切换页存在于页面栈中，在返回时直接回到设置页。这种场景下，可以使用pushUrl()方法，并且使用Single实例模式。 已复制// 在Setting页面中function onJumpClick(): void {  router.pushUrl({    url: 'pages/Theme' // 目标url  }, router.RouterMode.Single, (err) => {    if (err) {      console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);      return;    }    console.info('Invoke pushUrl succeeded.');  });} 场景四：有一个搜索结果列表页（SearchResult）和一个搜索结果详情页（SearchDetail），希望从搜索结果列表页点击某一项结果，跳转到搜索结果详情页。同时，如果该结果已经被查看过，则不需要再新建一个详情页，而是直接跳转到已经存在的详情页。这种场景下，可以使用replaceUrl()方法，并且使用Single实例模式。 已复制// 在SearchResult页面中function onJumpClick(): void {  router.replaceUrl({    url: 'pages/SearchDetail' // 目标url  }, router.RouterMode.Single, (err) => {    if (err) {      console.error(`Invoke replaceUrl failed, code is ${err.code}, message is ${err.message}`);      return;    }    console.info('Invoke replaceUrl succeeded.');})}  以上是不带参数传递的场景。 如果需要在跳转时传递一些数据给目标页，则可以在调用Router模块的方法时，添加一个params属性，并指定一个对象作为参数。例如： 已复制class DataModelInfo {  age: number;}
class DataModel {  id: number;  info: DataModelInfo;}
function onJumpClick(): void {  // 在Home页面中  let paramsInfo: DataModel = {    id: 123,    info: {      age: 20    }  };
  router.pushUrl({    url: 'pages/Detail', // 目标url    params: paramsInfo // 添加params属性，传递自定义参数  }, (err) => {    if (err) {      console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`);      return;    }    console.info('Invoke pushUrl succeeded.');  })} 在目标页中，可以通过调用Router模块的getParams()方法来获取传递过来的参数。例如： 已复制const params = router.getParams(); // 获取传递过来的参数对象const id = params['id']; // 获取id属性的值const age = params['info'].age; // 获取age属性的值   页面返回 当用户在一个页面完成操作后，通常需要返回到上一个页面或者指定页面，这就需要用到页面返回功能。在返回的过程中，可能需要将数据传递给目标页，这就需要用到数据传递功能。  图2 页面返回  在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。 已复制import router from '@ohos.router'; 可以使用以下几种方式进行页面返回：  方式一：返回到上一个页面。 已复制router.back(); 这种方式会返回到上一个页面，即上一个页面在页面栈中的位置。但是，上一个页面必须存在于页面栈中才能够返回，否则该方法将无效。 方式二：返回到指定页面。 已复制router.back({  url: 'pages/Home'}); 这种方式可以返回到指定页面，需要指定目标页的路径。目标页必须存在于页面栈中才能够返回。 方式三：返回到指定页面，并传递自定义参数信息。 已复制router.back({  url: 'pages/Home',  params: {    info: '来自Home页'  }}); 这种方式不仅可以返回到指定页面，还可以在返回的同时传递自定义参数信息。这些参数信息可以在目标页中通过调用router.getParams()方法进行获取和解析。  在目标页中，在需要获取参数的位置调用router.getParams()方法即可，例如在onPageShow()生命周期回调中： 已复制onPageShow() {  const params = router.getParams(); // 获取传递过来的参数对象  const info = params['info']; // 获取info属性的值} 
说明
 当使用router.back()方法返回到指定页面时，原栈顶页面（包括）到指定页面（不包括）之间的所有页面栈都将从栈中弹出并销毁。 另外，如果使用router.back()方法返回到原来的页面，原页面不会被重复创建，因此使用@State声明的变量不会重复声明，也不会触发页面的aboutToAppear()生命周期回调。如果需要在原页面中使用返回页面传递的自定义参数，可以在需要的位置进行参数解析。例如，在onPageShow()生命周期回调中进行参数解析。 
   页面返回前增加一个询问框 在开发应用时，为了避免用户误操作或者丢失数据，有时候需要在用户从一个页面返回到另一个页面之前，弹出一个询问框，让用户确认是否要执行这个操作。 本文将从系统默认询问框和自定义询问框两个方面来介绍如何实现页面返回前增加一个询问框的功能。  图3 页面返回前增加一个询问框    系统默认询问框 为了实现这个功能，可以使用页面路由Router模块提供的两个方法：router.showAlertBeforeBackPage()和router.back()来实现这个功能。 在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。 已复制import router from '@ohos.router'; 如果想要在目标界面开启页面返回询问框，需要在调用router.back()方法之前，通过调用router.showAlertBeforeBackPage()方法设置返回询问框的信息。例如，在支付页面中定义一个返回按钮的点击事件处理函数： 已复制// 定义一个返回按钮的点击事件处理函数function onBackClick(): void {  // 调用router.showAlertBeforeBackPage()方法，设置返回询问框的信息  try {    router.showAlertBeforeBackPage({      message: '您还没有完成支付，确定要返回吗？' // 设置询问框的内容    });  } catch (err) {    console.error(`Invoke showAlertBeforeBackPage failed, code is ${err.code}, message is ${err.message}`);  }
  // 调用router.back()方法，返回上一个页面  router.back();} 其中，router.showAlertBeforeBackPage()方法接收一个对象作为参数，该对象包含以下属性：  message：string类型，表示询问框的内容。如果调用成功，则会在目标界面开启页面返回询问框；如果调用失败，则会抛出异常，并通过err.code和err.message获取错误码和错误信息。 当用户点击“返回”按钮时，会弹出确认对话框，询问用户是否确认返回。选择“取消”将停留在当前页目标页；选择“确认”将触发router.back()方法，并根据参数决定如何执行跳转。    自定义询问框 自定义询问框的方式，可以使用弹窗或者自定义弹窗实现。这样可以让应用界面与系统默认询问框有所区别，提高应用的用户体验度。本文以弹窗为例，介绍如何实现自定义询问框。 在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。 已复制import router from '@ohos.router'; 在事件回调中，调用弹窗的promptAction.showDialog()方法： 已复制function onBackClick() {  // 弹出自定义的询问框  promptAction.showDialog({    message: '您还没有完成支付，确定要返回吗？',    buttons: [      {        text: '取消',        color: '#FF0000'      },      {        text: '确认',        color: '#0099FF'      }    ]  }).then((result) => {    if (result.index === 0) {      // 用户点击了“取消”按钮      console.info('User canceled the operation.');    } else if (result.index === 1) {      // 用户点击了“确认”按钮      console.info('User confirmed the operation.');      // 调用router.back()方法，返回上一个页面      router.back();    }  }).catch((err) => {    console.error(`Invoke showDialog failed, code is ${err.code}, message is ${err.message}`);  })} 当用户点击“返回”按钮时，会弹出自定义的询问框，询问用户是否确认返回。选择“取消”将停留在当前页目标页；选择“确认”将触发router.back()方法，并根据参数决定如何执行跳转。   上一篇 设置页面路由和组件导航 下一篇 组件导航 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。设置页面路由和组件导航 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    页面路由（router）  组件导航   上一篇 菜单（Menu） 下一篇 页面路由（router） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用springCurve使用springMotion和responsiveSpringMotion弹簧曲线动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  ArkUI提供了预置动画曲线，指定了动画属性从起始值到终止值的变化规律，如Linear、Ease、EaseIn等。同时，ArkUI也提供了由弹簧振子物理模型产生的弹簧曲线。通过弹簧曲线，开发者可以设置超过设置的终止值，在终止值附近震荡，直至最终停下来的效果。弹簧曲线的动画效果比其他曲线具有更强的互动性、可玩性。 弹簧曲线的接口包括两类，一类是springCurve，另一类是springMotion和responsiveSpringMotion，这两种方式都可以产生弹簧曲线。  使用springCurve springCurve的接口为： 已复制springCurve(velocity: number, mass: number, stiffness: number, damping: number) 构造参数包括初速度，弹簧系统的质量、刚度、阻尼。构建springCurve时，可指定质量为1，根据springCurve中的参数说明，调节刚度、阻尼两个参数，达到想要的震荡效果。  已复制import curves from '@ohos.curves';@Entry@Componentstruct SpringTest {  @State translateX: number = 0;
  private jumpWithSpeed(speed: number) {    this.translateX = -1;    animateTo({ duration: 2000, curve: curves.springCurve(speed, 1, 1, 1.2) }, () => {      // 以指定初速度进行x方向的平移的弹簧动画      this.translateX = 0;    })  }
  build() {    Column() {      Button("button")        .fontSize(14)        .width(100)        .height(50)        .margin(30)        .translate({ x: this.translateX })      Row({space:50}) {        Button("jump 50").fontSize(14)          .onClick(() => {            // 以初速度50的弹簧曲线进行平移            this.jumpWithSpeed(50);          })        Button("jump 200").fontSize(14)          .onClick(() => {            // 以初速度200的弹簧曲线进行平移            this.jumpWithSpeed(200);          })      }.margin(30)    }.height('100%').width('100%')  }}  以上示例中，点击不同的按钮，给定springCurve的不同初速度，button会有“弹性”的到达指定位置，且button的振幅随着速度的增大而变大。另外也可以修改springCurve的质量、刚度、阻尼参数，达到想要的弹性的程度。 
说明
 速度只是放大了振荡的效果，但系统能否产生振荡的效果，取决于弹簧振子本身的物理参数，即质量、刚度、阻尼三个参数。刚度越小、阻尼越大，springCurve的“弹性”越弱，振荡效果越弱。随着刚度减小或阻尼变大，达到过阻尼状态后，无论速度为多大，都不会有在终点值附近振荡的效果。 
  使用springMotion和responsiveSpringMotion springMotion的接口为： 已复制springMotion(response?: number, dampingFraction?: number, overlapDuration?: number) responsiveSpringMotion的接口为： 已复制responsiveSpringMotion(response?: number, dampingFraction?: number, overlapDuration?: number) 它们的构造参数包括弹簧自然振动周期、阻尼系数、弹性动画衔接时长这三个可选参数，参数的含义请参考其文档。  使用springMotion和responsiveSpringMotion曲线时，duration不生效，适合于跟手动画。 已复制import curves from '@ohos.curves';
@Entry@Componentstruct SpringMotionTest {  @State positionX: number = 100;  @State positionY: number = 100;  diameter: number = 50;
  build() {    Column() {      Row() {        Circle({ width: this.diameter, height: this.diameter })          .fill(Color.Blue)          .position({ x: this.positionX, y: this.positionY })          .onTouch((event: TouchEvent) => {            if (event.type === TouchType.Move) {              // 跟手过程，使用responsiveSpringMotion曲线              animateTo({ curve: curves.responsiveSpringMotion() }, () => {                // 减去半径，以使球的中心运动到手指位置                this.positionX = event.touches[0].screenX - this.diameter / 2;                this.positionY = event.touches[0].screenY - this.diameter / 2;                console.info(`move, animateTo x:${this.positionX}, y:${this.positionY}`);              })            } else if (event.type === TouchType.Up) {              // 离手时，使用springMotion曲线              animateTo({ curve: curves.springMotion() }, () => {                this.positionX = 100;                this.positionY = 100;                console.info(`touchUp, animateTo x:100, y:100`);              })            }          })      }      .width("100%").height("80%")      .clip(true) // 如果球超出父组件范围，使球不可见      .backgroundColor(Color.Orange)
      Flex({ direction: FlexDirection.Row, alignItems: ItemAlign.Start, justifyContent: FlexAlign.Center }) {        Text("拖动小球").fontSize(16)      }      .width("100%")
      Row() {        Text('点击位置: [x: ' + Math.round(this.positionX) + ', y:' + Math.round(this.positionY) + ']').fontSize(16)      }      .padding(10)      .width("100%")    }.height('100%').width('100%')  }} 以上代码是跟手动画的一个示例。通过在onTouch事件中，捕捉触摸的位置，改变组件的translate或者position属性，使其在跟手过程中运动到触摸位置，松手后回到原位置。跟手动画的效果如下：  跟手过程推荐使用responsiveSpringMotion曲线，松手过程推荐使用springMotion曲线。跟手过程随着手的位置变化会被多次触发，所以会接连启动多次responsiveSpringMotion动画，松手时启动一次springMotion动画。跟手、松手过程在对同一对象的同一属性上执行动画，且使用了springMotion或responsiveSpringMotion曲线，每次新启动的动画会继承上次动画使用的速度，实现平滑过渡。 
说明
 1. springCurve可以设置初速度，单一属性存在多个动画时不会互相影响，观察到的是多个动画效果的叠加。 2. springMotion虽然内部有速度机制，但不可由开发者设置。在单一属性存在多个动画时，后一动画会取代前一动画，并继承前一动画的速度。 
  上一篇 组件内转场动画 下一篇 页面间的动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述装饰器使用规则说明变量的传递/访问规则说明观察变化和行为表现观察变化框架行为使用场景装饰简单类型的变量装饰class对象类型的变量@State装饰器：组件内状态 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 @State装饰的变量，或称为状态变量，一旦变量拥有了状态属性，就和自定义组件的渲染绑定起来。当状态改变时，UI会发生对应的渲染改变。 在状态变量相关装饰器中，@State是最基础的，使变量拥有状态属性的装饰器，它也是大部分状态变量的数据源。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 概述@State装饰的变量，与声明式范式中的其他被装饰变量一样，是私有的，只能从组件内部访问，在声明时必须指定其类型和本地初始化。初始化也可选择使用命名参数机制从父组件完成初始化。 @State装饰的变量拥有以下特点： @State装饰的变量与子组件中的@Prop装饰变量之间建立单向数据同步，与@Link、@ObjectLink装饰变量之间建立双向数据同步。@State装饰的变量生命周期与其所属自定义组件的生命周期相同。  装饰器使用规则说明 @State变量装饰器  说明    装饰器参数  无   同步类型  不与父组件中任何类型的变量同步。   允许装饰的变量类型  Object、class、string、number、boolean、enum类型，以及这些类型的数组。嵌套类型的场景请参考观察变化。 类型必须被指定。 不支持any，不支持简单类型和复杂类型的联合类型，不允许使用undefined和null。 
说明
建议不要装饰Date类型，应用可能会产生异常行为。 不支持Length、ResourceStr、ResourceColor类型，Length、ResourceStr、ResourceColor为简单类型和复杂类型的联合类型。 
   被装饰变量的初始值  必须本地初始化。      变量的传递/访问规则说明 传递/访问  说明    从父组件初始化  可选，从父组件初始化或者本地初始化。如果从父组件初始化将会覆盖本地初始化。 支持父组件中常规变量、@State、@Link、@Prop、@Provide、@Consume、@ObjectLink、@StorageLink、@StorageProp、@LocalStorageLink和@LocalStorageProp装饰的变量，初始化子组件的@State。   用于初始化子组件  @State装饰的变量支持初始化子组件的常规变量、@State、@Link、@Prop、@Provide。   是否支持组件外访问  不支持，只能在组件内访问。     图1 初始化规则图示    观察变化和行为表现并不是状态变量的所有更改都会引起UI的刷新，只有可以被框架观察到的修改才会引起UI刷新。本小节将介绍什么样的修改才能被观察到，以及观察到变化后，框架的是怎么引起UI刷新的，即框架的行为表现是什么。  观察变化当装饰的数据类型为boolean、string、number类型时，可以观察到数值的变化。已复制// for simple type@State count: number = 0;// value changing can be observedthis.count = 1; 当装饰的数据类型为class或者Object时，可以观察到自身的赋值的变化，和其属性赋值的变化，即Object.keys(observedObject)返回的所有属性。例子如下。声明ClassA和Model类。已复制class ClassA {  public value: string;
  constructor(value: string) {    this.value = value;  }}
class Model {  public value: string;  public name: ClassA;  constructor(value: string, a: ClassA) {    this.value = value;    this.name = a;  }}  @State装饰的类型是Model 已复制// class类型@State title: Model = new Model('Hello', new ClassA('World')); 对@State装饰变量的赋值。 已复制// class类型赋值this.title = new Model('Hi', new ClassA('ArkUI')); 对@State装饰变量的属性赋值。 已复制// class属性的赋值this.title.value = 'Hi'; 嵌套属性的赋值观察不到。 已复制// 嵌套的属性赋值观察不到this.title.name.value = 'ArkUI'; 当装饰的对象是array时，可以观察到数组本身的赋值和添加、删除、更新数组的变化。例子如下。声明Model类。 已复制class Model {  public value: number;  constructor(value: number) {    this.value = value;  }} @State装饰的对象为Model类型数组时。 已复制@State title: Model[] = [new Model(11), new Model(1)]; 数组自身的赋值可以观察到。 已复制this.title = [new Model(2)]; 数组项的赋值可以观察到。 已复制this.title[0] = new Model(2); 删除数组项可以观察到。 已复制this.title.pop(); 新增数组项可以观察到。 已复制this.title.push(new Model(12)); 数组项中属性的赋值观察不到。 已复制this.title[0].value = 6;   框架行为当状态变量被改变时，查询依赖该状态变量的组件；执行依赖该状态变量的组件的更新方法，组件更新渲染；和该状态变量不相关的组件或者UI描述不会发生重新渲染，从而实现页面渲染的按需更新。  使用场景 装饰简单类型的变量以下示例为@State装饰的简单类型，count被@State装饰成为状态变量，count的改变引起Button组件的刷新： 当状态变量count改变时，查询到只有Button组件关联了它；执行Button组件的更新方法，实现按需刷新。 已复制@Entry@Componentstruct MyComponent {  @State count: number = 0;
  build() {    Button(`click times: ${this.count}`)      .onClick(() => {        this.count += 1;      })  }}  装饰class对象类型的变量自定义组件MyComponent定义了被@State装饰的状态变量count和title，其中title的类型为自定义类Model。如果count或title的值发生变化，则查询MyComponent中使用该状态变量的UI组件，并进行重新渲染。 EntryComponent中有多个MyComponent组件实例，第一个MyComponent内部状态的更改不会影响第二个MyComponent。 已复制class Model {  public value: string;
  constructor(value: string) {    this.value = value;  }}
@Entry@Componentstruct EntryComponent {  build() {    Column() {      // 此处指定的参数都将在初始渲染时覆盖本地定义的默认值，并不是所有的参数都需要从父组件初始化      MyComponent({ count: 1, increaseBy: 2 })        .width(300)      MyComponent({ title: new Model('Hello World 2'), count: 7 })    }  }}
@Componentstruct MyComponent {  @State title: Model = new Model('Hello World');  @State count: number = 0;  private increaseBy: number = 1;
  build() {    Column() {      Text(`${this.title.value}`)        .margin(10)      Button(`Click to change title`)        .onClick(() => {          // @State变量的更新将触发上面的Text组件内容更新          this.title.value = this.title.value === 'Hello ArkUI' ? 'Hello World' : 'Hello ArkUI';        })        .width(300)        .margin(10)
      Button(`Click to increase count = ${this.count}`)        .onClick(() => {          // @State变量的更新将触发该Button组件的内容更新          this.count += this.increaseBy;        })        .width(300)        .margin(10)    }  }}    从该示例中，我们可以了解到@State变量首次渲染的初始化流程： 使用默认的本地初始化：已复制@State title: Model = new Model('Hello World');@State count: number = 0; 对于@State来说，命名参数机制传递的值并不是必选的，如果没有命名参数传值，则使用本地初始化的默认值：已复制MyComponent({ count: 1, increaseBy: 2 })   上一篇 管理组件拥有的状态 下一篇 @Prop装饰器：父子单向同步 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。状态管理 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
    状态管理概述  管理组件拥有的状态  管理应用拥有的状态  其他状态管理   上一篇 stateStyles：多态样式 下一篇 状态管理概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念装饰器总览其他状态管理功能状态管理概述 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 在前文的描述中，我们构建的页面多为静态界面。如果希望构建一个动态的、有交互的界面，就需要引入“状态”的概念。 图1 效果图 上面的示例中，用户与应用程序的交互触发了文本状态变更，状态变更引起了UI渲染，UI从“Hello World”变更为“Hello ArkUI”。 在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。 自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。   View(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。State：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。 基本概念状态变量：被状态装饰器装饰的变量，状态变量值的改变会引起UI的渲染更新。示例：@State num: number = 1,其中，@State是状态装饰器，num是状态变量。常规变量：没有被状态装饰器装饰的变量，通常应用于辅助计算。它的改变永远不会引起UI的刷新。以下示例中increaseBy变量为常规变量。数据源/同步源：状态变量的原始来源，可以同步给不同的状态数据。通常意义为父组件传给子组件的数据。以下示例中数据源为count: 1。命名参数机制：父组件通过指定参数传递给子组件的状态变量，为父子传递同步参数的主要手段。示例：CompA: ({ aProp: this.aProp })。从父组件初始化：父组件使用命名参数机制，将指定参数传递给子组件。子组件初始化的默认值在有父组件传值的情况下，会被覆盖。示例：已复制@Componentstruct MyComponent {  @State count: number = 0;  private increaseBy: number = 1;
  build() {  }}
@Componentstruct Parent {  build() {    Column() {      // 从父组件初始化，覆盖本地定义的默认值      MyComponent({ count: 1, increaseBy: 2 })    }  }} 初始化子节点：父组件中状态变量可以传递给子组件，初始化子组件对应的状态变量。示例同上。本地初始化：在变量声明的时候赋值，作为变量的默认值。示例：@State count: number = 0。  装饰器总览ArkUI提供了多种装饰器，通过使用这些装饰器，状态变量不仅可以观察在组件内的改变，还可以在不同组件层级间传递，比如父子组件、跨组件层级，也可以观察全局范围内的变化。根据状态变量的影响范围，将所有的装饰器可以大致分为：  管理组件拥有状态的装饰器：组件级别的状态管理，可以观察组件内变化，和不同组件层级的变化，但需要唯一观察同一个组件树上，即同一个页面内。管理应用拥有状态的装饰器：应用级别的状态管理，可以观察不同页面，甚至不同UIAbility的状态变化，是应用内全局的状态管理。 从数据的传递形式和同步类型层面看，装饰器也可分为： 只读的单向传递；可变更的双向传递。 图示如下，具体装饰器的介绍，可详见管理组件拥有的状态和管理应用拥有的状态。开发者可以灵活地利用这些能力来实现数据和UI的联动。   上图中，Components部分的装饰器为组件级别的状态管理，Application部分为应用的状态管理。开发者可以通过@StorageLink/@LocalStorageLink实现应用和组件状态的双向同步，通过@StorageProp/@LocalStorageProp实现应用和组件状态的单向同步。 管理组件拥有的状态，即图中Components级别的状态管理： @State：@State装饰的变量拥有其所属组件的状态，可以作为其子组件单向和双向同步的数据源。当其数值改变时，会引起相关组件的渲染刷新。@Prop：@Prop装饰的变量可以和父组件建立单向同步关系，@Prop装饰的变量是可变的，但修改不会同步回父组件。@Link：@Link装饰的变量和父组件构建双向同步关系的状态变量，父组件会接受来自@Link装饰的变量的修改的同步，父组件的更新也会同步给@Link装饰的变量。@Provide/@Consume：@Provide/@Consume装饰的变量用于跨组件层级（多层组件）同步状态变量，可以不需要通过参数命名机制传递，通过alias（别名）或者属性名绑定。@Observed：@Observed装饰class，需要观察多层嵌套场景的class需要被@Observed装饰。单独使用@Observed没有任何作用，需要和@ObjectLink、@Prop连用。@ObjectLink：@ObjectLink装饰的变量接收@Observed装饰的class的实例，应用于观察多层嵌套场景，和父组件的数据源构建双向同步。
说明
仅@Observed/@ObjectLink可以观察嵌套场景，其他的状态变量仅能观察第一层，详情见各个装饰器章节的“观察变化和行为表现”小节。 
  管理应用拥有的状态，即图中Application级别的状态管理： AppStorage是应用程序中的一个特殊的单例LocalStorage对象，是应用级的数据库，和进程绑定，通过@StorageProp和@StorageLink装饰器可以和组件联动。AppStorage是应用状态的“中枢”，将需要与组件（UI）交互的数据存入AppStorage，比如持久化数据PersistentStorage和环境变量Environment。UI再通过AppStorage提供的装饰器或者API接口，访问这些数据。框架还提供了LocalStorage，AppStorage是LocalStorage特殊的单例。LocalStorage是应用程序声明的应用状态的内存“数据库”，通常用于页面级的状态共享，通过@LocalStorageProp和@LocalStorageLink装饰器可以和UI联动。 其他状态管理功能@Watch用于监听状态变量的变化。  $$运算符：给内置组件提供TS变量的引用，使得TS变量和内置组件的内部状态保持同步。  上一篇 状态管理 下一篇 管理组件拥有的状态 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述使用场景基础场景@Styles和stateStyles联合使用在stateStyles里使用常规变量和状态变量stateStyles：多态样式 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 @Styles和@Extend仅仅应用于静态页面的样式复用，stateStyles可以依据组件的内部状态的不同，快速设置不同样式。这就是我们本章要介绍的内容stateStyles（又称为：多态样式）。 概述stateStyles是属性方法，可以根据UI内部状态来设置样式，类似于css伪类，但语法不同。ArkUI提供以下四种状态： focused：获焦态。normal：正常态。pressed：按压态。disabled：不可用态。  使用场景 基础场景下面的示例展示了stateStyles最基本的使用场景。Button1处于第一个组件，Button2处于第二个组件。按压时显示为pressed态指定的黑色。使用Tab键走焦，先是Button1获焦并显示为focus态指定的粉色。当Button2获焦的时候，Button2显示为focus态指定的粉色，Button1失焦显示normal态指定的红色。 已复制@Entry@Componentstruct StateStylesSample {  build() {    Column() {      Button('Button1')        .stateStyles({          focused: {            .backgroundColor(Color.Pink)          },          pressed: {            .backgroundColor(Color.Black)          },          normal: {            .backgroundColor(Color.Red)          }        })        .margin(20)      Button('Button2')        .stateStyles({          focused: {            .backgroundColor(Color.Pink)          },          pressed: {            .backgroundColor(Color.Black)          },          normal: {            .backgroundColor(Color.Red)          }        })    }.margin('30%')  }} 图1 获焦态和按压态  @Styles和stateStyles联合使用以下示例通过@Styles指定stateStyles的不同状态。  已复制@Entry@Componentstruct MyComponent {  @Styles normalStyle() {    .backgroundColor(Color.Gray)  }
  @Styles pressedStyle() {    .backgroundColor(Color.Red)  }
  build() {    Column() {      Text('Text1')        .fontSize(50)        .fontColor(Color.White)        .stateStyles({          normal: this.normalStyle,          pressed: this.pressedStyle,        })    }  }} 图2 正常态和按压态 在stateStyles里使用常规变量和状态变量stateStyles可以通过this绑定组件内的常规变量和状态变量。 已复制@Entry@Componentstruct CompWithInlineStateStyles {  @State focusedColor: Color = Color.Red;  normalColor: Color = Color.Green
  build() {    Column() {      Button('clickMe').height(100).width(100)        .stateStyles({          normal: {            .backgroundColor(this.normalColor)          },          focused: {            .backgroundColor(this.focusedColor)          }        })        .onClick(() => {          this.focusedColor = Color.Pink        })        .margin('30%')    }  }} Button默认normal态显示绿色，第一次按下Tab键让Button获焦显示为focus态的红色，点击事件触发后，再次按下Tab键让Button获焦，focus态变为粉色。 图3 点击改变获焦态样式    上一篇 @Extend装饰器：定义扩展组件样式 下一篇 状态管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。装饰器使用说明使用场景@Styles装饰器：定义组件重用样式 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
  如果每个组件的样式都需要单独设置，在开发过程中会出现大量代码在进行重复样式设置，虽然可以复制粘贴，但为了代码简洁性和后续方便维护，我们推出了可以提炼公共样式进行复用的装饰器@Styles。 @Styles装饰器可以将多条样式设置提炼成一个方法，直接在组件声明的位置调用。通过@Styles装饰器可以快速定义并复用自定义样式。用于快速定义并复用自定义样式。 
说明
 从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
  装饰器使用说明  当前@Styles仅支持通用属性和通用事件。 @Styles方法不支持参数，反例如下。已复制// 反例： @Styles不支持参数@Styles function globalFancy (value: number) {  .width(value)} @Styles可以定义在组件内或全局，在全局定义时需在方法名前面添加function关键字，组件内定义时则不需要添加function关键字。       
说明
 只能在当前文件内使用，不支持export。 
  已复制// 全局@Styles function functionName() { ... }
// 在组件内@Componentstruct FancyUse {  @Styles fancy() {    .height(100)  }}  定义在组件内的@Styles可以通过this访问组件的常量和状态变量，并可以在@Styles里通过事件来改变状态变量的值，示例如下：已复制@Componentstruct FancyUse {  @State heightValue: number = 100  @Styles fancy() {    .height(this.heightValue)    .backgroundColor(Color.Yellow)    .onClick(() => {      this.heightValue = 200    })  }} 组件内@Styles的优先级高于全局@Styles。框架优先找当前组件内的@Styles，如果找不到，则会全局查找。    使用场景 以下示例中演示了组件内@Styles和全局@Styles的用法。  已复制// 定义在全局的@Styles封装的样式@Styles function globalFancy  () {  .width(150)  .height(100)  .backgroundColor(Color.Pink)}
@Entry@Componentstruct FancyUse {  @State heightValue: number = 100  // 定义在组件内的@Styles封装的样式  @Styles fancy() {    .width(200)    .height(this.heightValue)    .backgroundColor(Color.Yellow)    .onClick(() => {      this.heightValue = 200    })  }
  build() {    Column({ space: 10 }) {      // 使用全局的@Styles封装的样式      Text('FancyA')        .globalFancy()        .fontSize(30)      // 使用组件内的@Styles封装的样式      Text('FancyB')        .fancy()        .fontSize(30)    }  }}  上一篇 @BuilderParam装饰器：引用@Builder函数 下一篇 @Extend装饰器：定义扩展组件样式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。transition常见用法if/else产生组件内转场动画ForEach产生组件内转场动画组件内转场动画 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  组件的插入、删除过程即为组件本身的转场过程，组件的插入、删除动画称为组件内转场动画。通过组件内转场动画，可定义组件出现、消失的效果。 组件内转场动画的接口为： 已复制transition(value: TransitionOptions) transition函数的入参为组件内转场的效果，可以定义平移、透明度、旋转、缩放这几种转场样式的单个或者组合的转场效果，必须和animateTo一起使用才能产生组件转场效果。  transition常见用法 type用于指定当前的transition动效生效在组件的变化场景，类型为TransitionType。  组件的插入、删除使用同一个动画效果已复制Button()  .transition({ type: TransitionType.All, scale: { x: 0, y: 0 } }) 当type属性为TransitionType.All时，表示指定转场动效生效在组件的所有变化（插入和删除）场景。此时，删除动画和插入动画是相反的过程，删除动画是插入动画的逆播。例如，以上代码定义了一个Button控件。在插入时，组件从scale的x、y均为0的状态，变化到scale的x、y均为1（即完整显示）的默认状态，以逐渐放大的方式出现。在删除时，组件从scale的x、y均为1的默认状态，变化到指定的scale的x、y均为0的状态，逐渐缩小至尺寸为0。    组件的插入、删除使用不同的动画效果已复制Button()  .transition({ type: TransitionType.Insert, translate: { x: 200, y: -200 }, opacity: 0 })  .transition({ type: TransitionType.Delete, rotate: { x: 0, y: 0, z: 1, angle: 360 } }) 当组件的插入和删除需要实现不同的转场动画效果时，可以调用两次transition函数，分别设置type属性为TransitionType.Insert和TransitionType.Delete。例如，以上代码定义了一个Button控件。在插入时，组件从相对于组件正常布局位置x方向平移200vp、y方向平移-200vp的位置、透明度为0的初始状态，变化到x、y方向平移量为0、透明度为1的默认状态，插入动画为平移动画和透明度动画的组合。在删除时，组件从旋转角为0的默认状态，变化到绕z轴旋转360度的终止状态，即绕z轴旋转一周。   只定义组件的插入或删除其中一种动画效果。已复制Button()  .transition({ type: TransitionType.Delete, translate: { x: 200, y: -200 } }) 当只需要组件的插入或删除的转场动画效果时，仅需设置type属性为TransitionType.Insert或TransitionType.Delete的transition效果。例如，以上代码定义了一个Button控件。删除时，组件从正常位置、没有平移的默认状态，变化到从相对于正常布局位置x方向平移200vp、y方向平移-200vp的位置的状态。插入该组件并不会产生该组件的转场动画。   if/else产生组件内转场动画 if/else语句可以控制组件的插入和删除。如下代码即可通过Button的点击事件，控制if的条件是否满足，来控制if下的Image组件是否显示。  已复制@Entry@Componentstruct IfElseTransition {  @State flag: boolean = true;  @State show: string = 'show';
  build() {    Column() {      Button(this.show).width(80).height(30).margin(30)        .onClick(() => {          if (this.flag) {            this.show = 'hide';          } else {            this.show = 'show';          }          // 点击Button控制Image的显示和消失          this.flag = !this.flag;        })      if (this.flag) {          Image($r('app.media.mountain')).width(200).height(200)      }    }.height('100%').width('100%')  }} 以上代码没有配置任何动画。接下来，我们将给以上代码加入组件内转场的效果。首先Image组件是由if控制的组件，需要给其加上transition的参数，以指定组件内转场的具体效果。例如，可以如以下代码，给其插入时加上平移效果，删除时加上缩放和透明度效果。 已复制if (this.flag) {  Image($r('app.media.mountain')).width(200).height(200)    .transition({ type: TransitionType.Insert, translate: { x: 200, y: -200 } })    .transition({ type: TransitionType.Delete, opacity: 0, scale: { x: 0, y: 0 } })} 以上代码虽然指定了动画的样式，但是未指定动画参数，尚不知道需要用多长时间、怎样的曲线完成该动画。transition必须配合animateTo一起使用，并在animateTo的闭包中，控制组件的插入、删除。对于以上示例代码，即为在animateTo闭包中改变flag的值，该部分代码如下所示。指定动画时长为1000ms，曲线使用animateTo函数默认的曲线，改变flag的值。则由flag变化所引起的一切变化，都会按照该动画参数，产生动画。在这里，flag会影响Image的出现和消失。 已复制animateTo({ duration: 1000 }, () => {  this.flag = !this.flag;}) 经过以上过程，当animateTo和transition一起使用时，即产生了组件内转场动画。完整示例代码如下： 已复制@Entry@Componentstruct IfElseTransition {  @State flag: boolean = true;  @State show: string = 'show';
  build() {    Column() {      Button(this.show).width(80).height(30).margin(30)        .onClick(() => {          if (this.flag) {            this.show = 'hide';          } else {            this.show = 'show';          }                    animateTo({ duration: 1000 }, () => {            // 动画闭包内控制Image组件的出现和消失            this.flag = !this.flag;          })        })      if (this.flag) {        // Image的出现和消失配置为不同的过渡效果        Image($r('app.media.mountain')).width(200).height(200)          .transition({ type: TransitionType.Insert, translate: { x: 200, y: -200 } })          .transition({ type: TransitionType.Delete, opacity: 0, scale: { x: 0, y: 0 } })      }    }.height('100%').width('100%')  }}  
说明
 当配置transition的效果为translate或scale时，本身位置叠加上平移或放大倍数后，动画过程中有可能超过父组件的范围。如果超出父组件的范围时，希望子组件完整的显示，那么可以设置父组件的clip属性为false，使父组件不对子组件产生裁剪。如果超出父组件的范围时，希望超出的子组件部分不显示，那么可以设置父组件的clip属性为true，裁剪掉子组件超出的部分。 
  ForEach产生组件内转场动画 和if/else类似，ForEach可以通过控制数组中的元素个数，来控制组件的插入和删除。通过ForEach来产生组件内转场动画，仍然需要两个条件：  ForEach里的组件配置了transition效果。 在animateTo的闭包中控制组件的插入或删除，即控制数组的元素添加和删除。   以下代码是使用ForEach产生组件内转场动画的一个示例。 已复制@Entry@Componentstruct ForEachTransition {  @State numbers: string[] = ["1", "2", "3", "4", "5"]  startNumber: number = 6;
  build() {    Column({ space: 10 }) {      Column() {        ForEach(this.numbers, (item) => {          // ForEach下的直接组件需配置transition效果          Text(item)            .width(240)            .height(60)            .fontSize(18)            .borderWidth(1)            .backgroundColor(Color.Orange)            .textAlign(TextAlign.Center)            .transition({ type: TransitionType.All, translate: { x: 200 }, scale: { x: 0, y: 0 } })        }, item => item)      }      .margin(10)      .justifyContent(FlexAlign.Start)      .alignItems(HorizontalAlign.Center)      .width("90%")      .height("70%")
      Button('向头部添加元素')        .fontSize(16)        .width(160)        .onClick(() => {          animateTo({ duration: 1000 }, () => {            // 往数组头部插入一个元素，导致ForEach在头部增加对应的组件            this.numbers.unshift(this.startNumber.toString());            this.startNumber++;          })        })      Button('向尾部添加元素')        .width(160)        .fontSize(16)        .onClick(() => {          animateTo({ duration: 1000 }, () => {            // 往数组尾部插入一个元素，导致ForEach在尾部增加对应的组件            this.numbers.push(this.startNumber.toString());            this.startNumber++;          })        })      Button('删除头部元素')        .width(160)        .fontSize(16)        .onClick(() => {          animateTo({ duration: 1000 }, () => {            // 删除数组的头部元素，导致ForEach删除头部的组件            this.numbers.shift();          })        })      Button('删除尾部元素')        .width(160)        .fontSize(16)        .onClick(() => {          animateTo({ duration: 1000 }, () => {            // 删除数组的尾部元素，导致ForEach删除尾部的组件            this.numbers.pop();          })        })    }    .width('100%')    .height('100%')  }} 效果如下图：  由于Column布局方式设为了FlexAlign.Start，即竖直方向从头部开始布局。所以往数组末尾添加元素时，并不会对数组中现存元素对应的组件位置造成影响，只会触发新增组件的插入动画。而往数组头部添加元素时，原来数组中的所有元素的下标都增加了，虽然不会触发其添加或者删除，但是会影响到对应组件的位置。所以除新增的组件会做transition动画以外，之前存在于ForEach中组件也会做位置动画。 
说明
 if/else、ForEach为语法节点，配置组件内转场效果的组件应直接作为语法节点的孩子。由语法节点的增删引起的组件增删，只能触发其直接孩子组件的组件内转场动画，开发者不应期望其对更深层次的组件产生组件转场动画。 
  上一篇 布局更新动画 下一篇 弹簧曲线动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用规则使用示例$$语法：内置组件双向同步 更新时间: 2024-03-25 11:20 毫无帮助帮助不大一般很好非常好
分享
  $$运算符为系统内置组件提供TS变量的引用，使得TS变量和系统内置组件的内部状态保持同步。 内部状态具体指什么取决于组件。例如，Refresh组件的refreshing参数。  使用规则  当前$$支持基础类型变量，以及@State、@Link和@Prop装饰的变量。 当前$$仅支持Refresh组件的refreshing参数。 $$绑定的变量变化时，会触发UI的同步刷新。    使用示例 以Refresh组件的refreshing参数为例： 当使用了$$符号绑定isRefreshing状态变量时，页面进行下拉操作，isRefreshing会变成true。 同时，Text中的isRefreshing状态也会同步改变为true，如果不使用$$符号绑定，则不会同步改变。 已复制// xxx.ets@Entry@Componentstruct RefreshExample {  @State isRefreshing: boolean = false  @State counter: number = 0
  build() {    Column() {      Text('Pull Down and isRefreshing: ' + this.isRefreshing)        .fontSize(30)        .margin(10)
      Refresh({ refreshing: $$this.isRefreshing, offset: 120, friction: 100 }) {        Text('Pull Down and refresh: ' + this.counter)          .fontSize(30)          .margin(10)      }      .onStateChange((refreshStatus: RefreshStatus) => {        console.info('Refresh onStateChange state is ' + refreshStatus)      })    }  }}    上一篇 @Watch装饰器：状态变量更改通知 下一篇 渲染控制 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。特点整体架构开发流程UI开发（ArkTS声明式开发范式）概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  基于ArkTS的声明式开发范式的方舟开发框架是一套开发极简、高性能、支持跨设备的UI开发框架，提供了构建HarmonyOS应用UI所必需的能力，主要包括：  ArkTSArkTS是HarmonyOS优选的主力应用开发语言，围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展。扩展能力包含声明式UI描述、自定义组件、动态扩展UI元素、状态管理和渲染控制。状态管理作为基于ArkTS的声明式开发范式的特色，通过功能不同的装饰器给开发者提供了清晰的页面更新渲染流程和管道。状态管理包括UI组件状态和应用程序状态，两者协作可以使开发者完整地构建整个应用的数据更新和UI渲染。ArkTS语言的基础知识请参考学习ArkTS语言。 布局布局是UI的必要元素，它定义了组件在界面中的位置。ArkUI框架提供了多种布局方式，除了基础的线性布局、层叠布局、弹性布局、相对布局、栅格布局外，也提供了相对复杂的列表、宫格、轮播。 组件组件是UI的必要元素，形成了在界面中的样子，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。系统内置组件包括按钮、单选框、进度条、文本等。开发者可以通过链式调用的方式设置系统内置组件的渲染效果。开发者可以将系统内置组件组合为自定义组件，通过这种方式将页面组件化为一个个独立的UI单元，实现页面不同单元的独立创建、开发和复用，具有更强的工程性。 页面路由和组件导航应用可能包含多个页面，可通过页面路由实现页面间的跳转。一个页面内可能存在组件间的导航如典型的分栏，可通过导航组件实现组件间的导航。 图形方舟开发框架提供了多种类型图片的显示能力和多种自定义绘制的能力，以满足开发者的自定义绘图需求，支持绘制形状、填充颜色、绘制文本、变形与裁剪、嵌入图片等。 动画动画是UI的重要元素之一。优秀的动画设计能够极大地提升用户体验，框架提供了丰富的动画能力，除了组件内置动画效果外，还包括属性动画、显式动画、自定义转场动画以及动画API等，开发者可以通过封装的物理模型或者调用动画能力API来实现自定义动画轨迹。 交互事件交互事件是UI和用户交互的必要元素。方舟开发框架提供了多种交互事件，除了触摸事件、鼠标事件、键盘按键事件、焦点事件等通用事件外，还包括基于通用事件进行进一步识别的手势事件。手势事件有单一手势如点击手势、长按手势、拖动手势、捏合手势、旋转手势、滑动手势，以及通过单一手势事件进行组合的组合手势事件。   特点  开发效率高，开发体验好        代码简洁：通过接近自然语义的方式描述UI，不必关心框架如何实现UI绘制和渲染。 数据驱动UI变化：让开发者更专注自身业务逻辑的处理。当UI发生变化时，开发者无需编写在不同的UI之间进行切换的UI代码， 开发人员仅需要编写引起界面变化的数据，具体UI如何变化交给框架。 开发体验好：界面也是代码，让开发者的编程体验得到提升。  性能优越        声明式UI前端和UI后端分层：UI后端采用C++语言构建，提供对应前端的基础组件、布局、动效、交互事件、组件状态管理和渲染管线。 语言编译器和运行时的优化：统一字节码、高效FFI-Foreign Function Interface、AOT-Ahead Of Time、引擎极小化、类型优化等。  生态容易快速推进能够借力主流语言生态快速推进，语言相对中立友好，有相应的标准组织可以逐步演进。    整体架构  图1 整体架构图    声明式UI前端提供了UI开发范式的基础语言规范，并提供内置的UI组件、布局和动画，提供了多种状态管理机制，为应用开发者提供一系列接口支持。 语言运行时选用方舟语言运行时，提供了针对UI范式语法的解析能力、跨语言调用支持的能力和TS语言高性能运行环境。 声明式UI后端引擎后端引擎提供了兼容不同开发范式的UI渲染管线，提供多种基础组件、布局计算、动效、交互事件，提供了状态管理和绘制能力。 渲染引擎提供了高效的绘制能力，将渲染管线收集的渲染指令，绘制到屏幕的能力。 平台适配层提供了对系统平台的抽象接口，具备接入不同系统的能力，如系统渲染管线、生命周期调度等。   开发流程 使用UI开发框架开发应用时，主要涉及如下开发过程。开发者可以先通过第一个入门实例了解整个应用的UI开发过程。      任务 简介 相关指导    学习ArkTS 介绍了ArkTS的基本语法、状态管理和渲染控制的场景。   基本语法 状态管理 渲染控制    开发布局 介绍了几种常用的布局方式以及如何提升布局性能。   常用布局 布局性能    添加组件 介绍了几种常用的内置组件、自定义组件以及通过API方式支持的界面元素。   常用组件 自定义组件 气泡和菜单    设置页面路由和组件导航 介绍了如何设置页面路由以及组件间的导航。   页面路由 组件导航    显示图形 介绍了如何显示图片、绘制自定义几何图形以及使用画布绘制自定义图形。   图片 几何图形 画布    使用动画 介绍了组件和页面使用动画的典型场景。   页面内的动画 页面间的动画    绑定事件 介绍了事件的基本概念和如何使用通用事件和手势事件。   通用事件 手势事件      上一篇 基于ArkTS的声明式开发范式 下一篇 开发布局 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。配置卡片的配置文件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 卡片相关的配置文件主要包含FormExtensionAbility的配置和卡片的配置两部分： 卡片需要在module.json5配置文件中的extensionAbilities标签下，配置FormExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串“ohos.extension.form”，资源为卡片的具体配置信息的索引。 配置示例如下： 已复制{  "module": {    ...    "extensionAbilities": [      {        "name": "EntryFormAbility",        "srcEntrance": "./ets/entryformability/EntryFormAbility.ts",        "label": "$string:EntryFormAbility_label",        "description": "$string:EntryFormAbility_desc",        "type": "form",        "metadata": [          {            "name": "ohos.extension.form",            "resource": "$profile:form_config"          }        ]      }    ]  }} 卡片的具体配置信息。在上述FormExtensionAbility的元信息（“metadata”配置项）中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。内部字段结构说明如下表所示。 表1 卡片form_config.json配置文件 属性名称  含义  数据类型  是否可缺省    name  表示卡片的类名，字符串最大长度为127字节。  字符串  否   description  表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 该属性将显示在卡片预览界面上，以便用户识别不同卡片。  字符串  可缺省，缺省为空。   src  表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如："./ets/widget/pages/WidgetCard.ets"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如："./js/widget/pages/WidgetCard"  字符串  否   uiSyntax  表示该卡片的类型，当前支持如下两种类型： - arkts：当前卡片为ArkTS卡片。 - hml：当前卡片为JS卡片。  字符串  可缺省，缺省值为hml   window  用于定义与显示窗口相关的配置。  对象  可缺省   isDefault  表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。 - true：默认卡片。 - false：非默认卡片。  布尔值  否   colorMode  表示卡片的主题样式，取值范围如下： - auto：自适应。 - dark：深色主题。 - light：浅色主题。  字符串  可缺省，缺省值为“auto”。   supportDimensions  表示卡片支持的外观规格，取值范围： - 1 * 2：表示1行2列的二宫格。 - 2 * 2：表示2行2列的四宫格。 - 2 * 4：表示2行4列的八宫格。 - 4 * 4：表示4行4列的十六宫格。  字符串数组  否   defaultDimension  表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。  字符串  否   updateEnabled  表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围： - true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。 - false：表示不支持周期性刷新。  布尔类型  否   scheduledUpdateTime  表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 > 说明： > updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。  字符串  可缺省，缺省时不进行定点刷新。   updateDuration  表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。 当取值为0时，表示该参数不生效。 当取值为正整数N时，表示刷新周期为30*N分钟。 > 说明： > updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。  数值  可缺省，缺省值为“0”。   formConfigAbility  表示卡片的配置跳转链接，采用URI格式。  字符串  可缺省，缺省值为空。   formVisibleNotify  标识是否允许卡片使用卡片可见性通知。  字符串  可缺省，缺省值为空。   metadata  表示卡片的自定义信息，包含customizeData数组标签。  对象  可缺省，缺省值为空。     配置示例如下： 已复制{  "forms": [    {      "name": "widget",      "description": "This is a service widget.",      "src": "./ets/widget/pages/WidgetCard.ets",      "uiSyntax": "arkts",      "window": {        "designWidth": 720,        "autoDesignWidth": true      },      "colorMode": "auto",      "isDefault": true,      "updateEnabled": true,      "scheduledUpdateTime": "10:30",      "updateDuration": 1,      "defaultDimension": "2*2",      "supportDimensions": [        "2*2"      ]    }  ]}   上一篇 创建一个ArkTS卡片 下一篇 卡片生命周期管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建一个ArkTS卡片 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在已有的应用工程中，创建ArkTS卡片，具体操作方式如下。 创建卡片。 根据实际业务场景，选择一个卡片模板。 在选择卡片的开发语言类型（Language）时，选择ArkTS选项，然后单击“Finish”，即可完成ArkTS卡片创建。  ArkTS卡片创建完成后，工程中会新增如下卡片相关文件：卡片生命周期管理文件（EntryFormAbility.ts）、卡片页面文件（WidgetCard.ets）和卡片配置文件（form_config.json）。   上一篇 ArkTS卡片开发指导 下一篇 配置卡片的配置文件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发基于ArkTS UI的卡片 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    ArkTS卡片运行机制  ArkTS卡片相关模块  ArkTS卡片开发指导   上一篇 服务卡片概述 下一篇 ArkTS卡片运行机制 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ArkTS卡片开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    创建一个ArkTS卡片  配置卡片的配置文件  卡片生命周期管理  开发卡片页面  开发卡片事件  卡片数据交互   上一篇 ArkTS卡片相关模块 下一篇 创建一个ArkTS卡片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用call事件拉起指定UIAbility到后台 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 许多应用希望借助卡片的能力，实现和应用在前台时相同的功能。例如音乐卡片，卡片上提供播放、暂停等按钮，点击不同按钮将触发音乐应用的不同功能，进而提高用户的体验。在卡片中使用postCardAction接口的call能力，能够将卡片提供方应用的指定UIAbility拉到后台。同时，call能力提供了调用应用指定方法、传递数据的功能，使应用在后台运行时可以通过卡片上的按钮执行不同的功能。 通常使用按钮控件来触发call事件，示例代码如下： 在卡片页面中布局两个按钮，点击其中一个按钮时调用postCardAction向指定UIAbility发送call事件，并在事件内定义需要调用的方法和传递的数据。需要注意的是，method参数为必选参数，且类型需要为string类型，用于触发UIAbility中对应的方法。已复制@Entry@Componentstruct WidgetCard {  build() {    Column() {      Button('功能A')        .margin('20%')        .onClick(() => {          console.info('call EntryAbility funA');          postCardAction(this, {            'action': 'call',            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility            'params': {              'method': 'funA' // 在EntryAbility中调用的方法名            }          });        })       Button('功能B')        .margin('20%')        .onClick(() => {          console.info('call EntryAbility funB');          postCardAction(this, {            'action': 'call',            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility            'params': {              'method': 'funB', // 在EntryAbility中调用的方法名              'num': 1 // 需要传递的其他参数            }          });        })    }    .width('100%')    .height('100%')  }} 在UIAbility中接收call事件并获取参数，根据传递的method不同，执行不同的方法。其余数据可以通过readString的方式获取。需要注意的是，UIAbility需要onCreate生命周期中监听所需的方法。已复制import UIAbility from '@ohos.app.ability.UIAbility'; function FunACall(data) {  // 获取call事件中传递的所有参数  console.log('FunACall param:' + JSON.stringify(data.readString()));  return null;} function FunBCall(data) {  console.log('FunACall param:' + JSON.stringify(data.readString()));  return null;} export default class CameraAbility extends UIAbility {  // 如果UIAbility第一次启动，在收到call事件后会触发onCreate生命周期回调  onCreate(want, launchParam) {      try {          // 监听call事件所需的方法          this.callee.on('funA', FunACall);          this.callee.on('funB', FunBCall);      } catch (error) {          console.log('register failed with error. Cause: ' + JSON.stringify(error));      }  }     // 进程退出时，解除监听  onDestroy() {      try {          this.callee.off('funA');          this.callee.off('funB');      } catch (error) {          console.log('register failed with error. Cause: ' + JSON.stringify(error));      }  }};   上一篇 使用router事件跳转到指定UIAbility 下一篇 通过message事件刷新卡片内容 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发卡片事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    卡片事件能力说明  使用router事件跳转到指定UIAbility  使用call事件拉起指定UIAbility到后台  通过message事件刷新卡片内容  通过router或call事件刷新卡片内容   上一篇 卡片使用自定义绘制能力 下一篇 卡片事件能力说明 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。通过message事件刷新卡片内容 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在卡片页面中可以通过postCardAction接口触发message事件拉起FormExtensionAbility，然后由FormExtensionAbility刷新卡片内容，下面是这种刷新方式的简单示例。 在卡片页面通过注册Button的onClick点击事件回调，并在回调中调用postCardAction接口触发message事件拉起FormExtensionAbility。已复制let storage = new LocalStorage();
@Entry(storage)@Componentstruct WidgetCard {  @LocalStorageProp('title') title: string = 'init';  @LocalStorageProp('detail') detail: string = 'init';
  build() {    Column() {      Button('刷新')        .onClick(() => {          postCardAction(this, {            'action': 'message',            'params': {              'msgTest': 'messageEvent'            }          });        })      Text(`${this.title}`)      Text(`${this.detail}`)    }    .width('100%')    .height('100%')  }} 在FormExtensionAbility的onFormEvent生命周期中调用updateForm接口刷新卡片。已复制import formBindingData from '@ohos.app.form.formBindingData';import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import formProvider from '@ohos.app.form.formProvider';
export default class EntryFormAbility extends FormExtensionAbility {  onFormEvent(formId, message) {    // Called when a specified message event defined by the form provider is triggered.    console.info(`FormAbility onEvent, formId = ${formId}, message: ${JSON.stringify(message)}`);    let formData = {      'title': 'Title Update Success.', // 和卡片布局中对应      'detail': 'Detail Update Success.', // 和卡片布局中对应    };    let formInfo = formBindingData.createFormBindingData(formData)    formProvider.updateForm(formId, formInfo).then((data) => {      console.info('FormAbility updateForm success.' + JSON.stringify(data));    }).catch((error) => {      console.error('FormAbility updateForm failed: ' + JSON.stringify(error));    })  }
  ...} 运行效果如下图所示。    上一篇 使用call事件拉起指定UIAbility到后台 下一篇 通过router或call事件刷新卡片内容 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片事件能力说明 更新时间: 2024-03-20 16:30 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
 ArkTS卡片中提供了postCardAction()接口用于卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片中可以调用。  接口定义：postCardAction(component: Object, action: Object): void 接口参数说明： 参数名  参数类型  必填  参数描述    component  Object  是  当前自定义组件的实例，通常传入this。   action  Object  是  action的具体描述，详情见下表。     action参数说明： Key  Value  样例描述    "action"  string  action的类型，支持三种预定义的类型： "router"：跳转到提供方应用的指定UIAbility。"message"：自定义消息。触发后会调用提供方FormExtensionAbility的onFormEvent()生命周期回调。"call"：后台启动提供方应用。触发后会拉起提供方应用的指定UIAbility（仅支持launchType为singleton的UIAbility，即启动模式为单实例的UIAbility），但不会调度到前台。提供方应用需要具备后台运行权限（ohos.permission.KEEP_BACKGROUND_RUNNING）。   "bundleName"  string  "router" / "call" 类型时跳转的包名，可选。   "moduleName"  string  "router" / "call" 类型时跳转的模块名，可选。   "abilityName"  string  "router" / "call" 类型时跳转的UIAbility名，必填。   "params"  Object  当前action携带的额外参数，内容使用JSON格式的键值对形式。"call"类型时需填入参数'method'，且类型需要为string类型，用于触发UIAbility中对应的方法，必填。     postCardAction()接口示例代码： DOC.hasCopyButton('跳转')  .width('40%')  .height('20%')  .onClick(() => {    postCardAction(this, {      'action': 'router',      'bundleName': 'com.example.myapplication',      'abilityName': 'EntryAbility',      'params': {        'message': 'testForRouter' // 自定义要发送的message      }    });  }) DOC.hasCopyButton('拉至后台')  .width('40%')  .height('20%')  .onClick(() => {    postCardAction(this, {      'action': 'call',      'bundleName': 'com.example.myapplication',      'abilityName': 'EntryAbility',      'params': {        'method': 'fun', // 自定义调用的方法名，必填        'message': 'testForCall' // 自定义要发送的message      }    });  }) 以下介绍通过卡片事件实现的典型开发场景。  上一篇 开发卡片事件 下一篇 使用router事件跳转到指定UIAbility 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用router事件跳转到指定UIAbility 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在卡片中使用postCardAction接口的router能力，能够快速拉起卡片提供方应用的指定UIAbility，因此UIAbility较多的应用往往会通过卡片提供不同的跳转按钮，实现一键直达的效果。例如相机卡片，卡片上提供拍照、录像等按钮，点击不同按钮将拉起相机应用的不同UIAbility，从而提升用户的体验。  通常使用按钮控件来实现页面拉起，示例代码如下： 在卡片页面中布局两个按钮，点击其中一个按钮时调用postCardAction向指定UIAbility发送router事件，并在事件内定义需要传递的内容。已复制@Entry@Componentstruct WidgetCard {  build() {    Column() {      Button('功能A')        .margin('20%')        .onClick(() => {          console.info('Jump to EntryAbility funA');          postCardAction(this, {            'action': 'router',            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility            'params': {              'targetPage': 'funA' // 在EntryAbility中处理这个信息            }          });        })
      Button('功能B')        .margin('20%')        .onClick(() => {          console.info('Jump to EntryAbility funB');          postCardAction(this, {            'action': 'router',            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility            'params': {              'targetPage': 'funB' // 在EntryAbility中处理这个信息            }          });        })    }    .width('100%')    .height('100%')  }} 在UIAbility中接收router事件并获取参数，根据传递的params不同，选择拉起不同的页面。已复制import UIAbility from '@ohos.app.ability.UIAbility';import window from '@ohos.window';
let selectPage = "";let currentWindowStage = null;
export default class CameraAbility extends UIAbility {  // 如果UIAbility第一次启动，在收到Router事件后会触发onCreate生命周期回调  onCreate(want, launchParam) {    // 获取router事件中传递的targetPage参数    console.info("onCreate want:" + JSON.stringify(want));    if (want.parameters.params !== undefined) {      let params = JSON.parse(want.parameters.params);      console.info("onCreate router targetPage:" + params.targetPage);      selectPage = params.targetPage;    }  }  // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调  onNewWant(want, launchParam) {    console.info("onNewWant want:" + JSON.stringify(want));    if (want.parameters.params !== undefined) {      let params = JSON.parse(want.parameters.params);      console.info("onNewWant router targetPage:" + params.targetPage);      selectPage = params.targetPage;    }    if (currentWindowStage != null) {      this.onWindowStageCreate(currentWindowStage);    }  }
  onWindowStageCreate(windowStage: window.WindowStage) {    let targetPage;    // 根据传递的targetPage不同，选择拉起不同的页面    switch (selectPage) {      case 'funA':        targetPage = 'pages/FunA';        break;      case 'funB':        targetPage = 'pages/FunB';        break;      default:        targetPage = 'pages/Index';    }    if (currentWindowStage === null) {      currentWindowStage = windowStage;    }    windowStage.loadContent(targetPage, (err, data) => {      if (err && err.code) {        console.info('Failed to load the content. Cause: %{public}s', JSON.stringify(err));        return;      }    });  }};   上一篇 卡片事件能力说明 下一篇 使用call事件拉起指定UIAbility到后台 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。通过router事件刷新卡片内容通过call事件刷新卡片内容通过router或call事件刷新卡片内容 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在卡片页面中可以通过postCardAction接口触发router或call事件拉起UIAbility，然后由UIAbility刷新卡片内容，下面是这种刷新方式的简单示例。 通过router事件刷新卡片内容在卡片页面通过注册Button的onClick点击事件回调，并在回调中调用postCardAction接口触发router事件拉起UIAbility。已复制let storage = new LocalStorage();
@Entry(storage)@Componentstruct WidgetCard {  @LocalStorageProp('detail') detail: string = 'init';
  build() {    Column() {      Button('跳转')        .margin('20%')        .onClick(() => {          console.info('postCardAction to EntryAbility');          postCardAction(this, {            'action': 'router',            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility            'params': {              'detail': 'RouterFromCard'            }          });        })      Text(`${this.detail}`).margin('20%')    }    .width('100%')    .height('100%')  }} 在UIAbility的onCreate()或者onNewWant()生命周期中可以通过入参want获取卡片的formID和传递过来的参数信息，然后调用updateForm接口刷新卡片。已复制import UIAbility from '@ohos.app.ability.UIAbility';import formBindingData from '@ohos.app.form.formBindingData';import formProvider from '@ohos.app.form.formProvider';import formInfo from '@ohos.app.form.formInfo';
export default class EntryAbility extends UIAbility {  // 如果UIAbility第一次启动，在收到Router事件后会触发onCreate生命周期回调  onCreate(want, launchParam) {    console.info('Want:' + JSON.stringify(want));    if (want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {      let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY];      let message = JSON.parse(want.parameters.params).detail;      console.info(`UpdateForm formId: ${curFormId}, message: ${message}`);      let formData = {        "detail": message + ': onCreate UIAbility.', // 和卡片布局中对应      };      let formMsg = formBindingData.createFormBindingData(formData)      formProvider.updateForm(curFormId, formMsg).then((data) => {        console.info('updateForm success.' + JSON.stringify(data));      }).catch((error) => {        console.error('updateForm failed:' + JSON.stringify(error));      })    }  }  // 如果UIAbility已在后台运行，在收到Router事件后会触发onNewWant生命周期回调  onNewWant(want, launchParam) {    console.info('onNewWant Want:' + JSON.stringify(want));    if (want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) {      let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY];      let message = JSON.parse(want.parameters.params).detail;      console.info(`UpdateForm formId: ${curFormId}, message: ${message}`);      let formData = {        "detail": message + ': onNewWant UIAbility.', // 和卡片布局中对应      };      let formMsg = formBindingData.createFormBindingData(formData)      formProvider.updateForm(curFormId, formMsg).then((data) => {        console.info('updateForm success.' + JSON.stringify(data));      }).catch((error) => {        console.error('updateForm failed:' + JSON.stringify(error));      })    }  }
  ...}   通过call事件刷新卡片内容在使用postCardAction接口的call事件时，需要在FormExtensionAbility中的onAddForm生命周期回调中更新formId。已复制import formBindingData from '@ohos.app.form.formBindingData'; import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';
export default class EntryFormAbility extends FormExtensionAbility {  onAddForm(want) {   let formId = want.parameters["ohos.extra.param.key.form_identity"];   let dataObj1 = {     "formId": formId   };   let obj1 = formBindingData.createFormBindingData(dataObj1);   return obj1; }     ...}; 在卡片页面通过注册Button的onClick点击事件回调，并在回调中调用postCardAction接口触发call事件拉起UIAbility。已复制let storage = new LocalStorage();
@Entry(storage)@Componentstruct WidgetCard {  @LocalStorageProp('detail') detail: string = 'init';  @LocalStorageProp('formId') formId: string = '0';
  build() {    Column() {      Button('拉至后台')        .margin('20%')        .onClick(() => {          console.info('postCardAction to EntryAbility');          postCardAction(this, {            'action': 'call',            'abilityName': 'EntryAbility', // 只能跳转到当前应用下的UIAbility            'params': {              'method': 'funA',              'formId': this.formId,              'detail': 'CallFromCard'            }          });        })      Text(`${this.detail}`).margin('20%')    }    .width('100%')    .height('100%')  }} 在UIAbility的onCreate生命周期中监听call事件所需的方法，然后调用updateForm接口刷新卡片。已复制import UIAbility from '@ohos.app.ability.UIAbility';import formBindingData from '@ohos.app.form.formBindingData';import formProvider from '@ohos.app.form.formProvider';import formInfo from '@ohos.app.form.formInfo';const MSG_SEND_METHOD: string = 'funA' // 在收到call事件后会触发callee监听的方法function FunACall(data) {  // 获取call事件中传递的所有参数  let params = JSON.parse(data.readString())  if (params.formId !== undefined) {    let curFormId = params.formId;    let message = params.detail;    console.info(`UpdateForm formId: ${curFormId}, message: ${message}`);    let formData = {      "detail": message    };    let formMsg = formBindingData.createFormBindingData(formData)    formProvider.updateForm(curFormId, formMsg).then((data) => {      console.info('updateForm success.' + JSON.stringify(data));    }).catch((error) => {      console.error('updateForm failed:' + JSON.stringify(error));    })  }  return null;}export default class EntryAbility extends UIAbility {  // 如果UIAbility第一次启动，call事件后会触发onCreate生命周期回调  onCreate(want, launchParam) {    console.info('Want:' + JSON.stringify(want));    try {       // 监听call事件所需的方法      this.callee.on(MSG_SEND_METHOD, FunACall);    } catch (error) {      console.log(`${MSG_SEND_METHOD} register failed with error ${JSON.stringify(error)}`)    }  }  ...}    上一篇 通过message事件刷新卡片内容 下一篇 卡片数据交互 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。刷新本地图片和网络图片 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在卡片上通常需要展示本地图片或从网络上下载的图片，获取本地图片和网络图片需要通过FormExtensionAbility来实现，如下示例代码介绍了如何在卡片上显示本地图片和网络图片。 下载网络图片需要使用到网络能力，需要申请ohos.permission.INTERNET权限，配置方式请参见配置文件权限声明。在EntryFormAbility中的onAddForm生命周期回调中实现本地文件的刷新。已复制import formBindingData from '@ohos.app.form.formBindingData';import formProvider from '@ohos.app.form.formProvider';import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import request from '@ohos.request';import fs from '@ohos.file.fs';
export default class EntryFormAbility extends FormExtensionAbility {  ...  // 在添加卡片时，打开一个本地图片并将图片内容传递给卡片页面显示  onAddForm(want) {    // 假设在当前卡片应用的tmp目录下有一个本地图片：head.PNG    let tempDir = this.context.getApplicationContext().tempDir;    // 打开本地图片并获取其打开后的fd    let file;    try {      file = fs.openSync(tempDir + '/' + 'head.PNG');    } catch (e) {      console.error(`openSync failed: ${JSON.stringify(e)}`);    }    let formData = {      'text': 'Image: Bear',      'imgName': 'imgBear',      'formImages': {        'imgBear': file.fd      },      'loaded': true    }    // 将fd封装在formData中并返回至卡片页面    return formBindingData.createFormBindingData(formData);  }
  ...} 在EntryFormAbility中的onFormEvent生命周期回调中实现网络文件的刷新。已复制import formBindingData from '@ohos.app.form.formBindingData';import formProvider from '@ohos.app.form.formProvider';import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import request from '@ohos.request';import fs from '@ohos.file.fs';
export default class EntryFormAbility extends FormExtensionAbility {  // 在卡片页面触发message事件时，下载一个网络图片，并将网络图片内容传递给卡片页面显示  onFormEvent(formId, message) {    let formInfo = formBindingData.createFormBindingData({      'text': '刷新中...'    })    formProvider.updateForm(formId, formInfo)    // 注意：FormExtensionAbility在触发生命周期回调时被拉起，仅能在后台存在5秒    // 建议下载能快速下载完成的小文件，如在5秒内未下载完成，则此次网络图片无法刷新至卡片页面上    let netFile = 'https://xxxx/xxxx.png'; // 需要在此处使用真实的网络图片下载链接    let tempDir = this.context.getApplicationContext().tempDir;    let tmpFile = tempDir + '/file' + Date.now();    request.downloadFile(this.context, {      url: netFile, filePath: tmpFile    }).then((task) => {      task.on('complete', function callback() {        console.info('ArkTSCard download complete:' + tmpFile);        let file;        try {          file = fs.openSync(tmpFile);        } catch (e) {          console.error(`openSync failed: ${JSON.stringify(e)}`);        }        let formData = {          'text': 'Image: Https',          'imgName': 'imgHttps',          'formImages': {            'imgHttps': file.fd          },          'loaded': true        }        let formInfo = formBindingData.createFormBindingData(formData)        formProvider.updateForm(formId, formInfo).then((data) => {          console.info('FormAbility updateForm success.' + JSON.stringify(data));        }).catch((error) => {          console.error('FormAbility updateForm failed: ' + JSON.stringify(error));        })      })      task.on('fail', function callBack(err) {        console.info('ArkTSCard download task failed. Cause:' + err);        let formInfo = formBindingData.createFormBindingData({          'text': '刷新失败'        })        formProvider.updateForm(formId, formInfo)      });    }).catch((err) => {      console.error('Failed to request the download. Cause: ' + JSON.stringify(err));    });  }
  ...}; 在卡片页面通过Image组件展示EntryFormAbility传递过来的卡片内容。已复制let storage = new LocalStorage();
@Entry(storage)@Componentstruct WidgetCard {  @LocalStorageProp('text') text: string = '加载中...';  @LocalStorageProp('loaded') loaded: boolean = false;  @LocalStorageProp('imgName') imgName: string = 'name';
  build() {    Column() {      Text(this.text)        .fontSize('12vp')        .textAlign(TextAlign.Center)        .width('100%')        .height('15%')
      Row() {        if (this.loaded) {          Image('memory://' + this.imgName)            .width('50%')            .height('50%')            .margin('5%')        } else {          Image('common/start.PNG')            .width('50%')            .height('50%')            .margin('5%')        }      }.alignItems(VerticalAlign.Center)      .justifyContent(FlexAlign.Center)
      Button('刷新')        .height('15%')        .onClick(() => {          postCardAction(this, {            'action': 'message',            'params': {              'info': 'refreshImage'            }          });        })    }    .width('100%').height('100%')    .alignItems(HorizontalAlign.Center)    .padding('5%')  }}  
说明
Image组件通过入参(memory://fileName)中的memory://标识来进行远端内存图片显示，其中fileName需要和EntryFormAbility传递对象('formImages': {key: fd})中的key相对应。Image组件通过传入的参数是否有变化来决定是否刷新图片，因此EntryFormAbility每次传递过来的imgName都需要不同，连续传递两个相同的imgName时，图片不会刷新。 
  上一篇 定时刷新和定点刷新 下一篇 根据卡片状态刷新不同内容 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片数据交互 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    卡片数据交互说明  定时刷新和定点刷新  刷新本地图片和网络图片  根据卡片状态刷新不同内容   上一篇 通过router或call事件刷新卡片内容 下一篇 卡片数据交互说明 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片数据交互说明 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 ArkTS卡片框架提供了updateForm()接口和requestForm()接口主动触发卡片的页面刷新。  接口  是否系统能力  约束    updateForm  否  1. 提供方调用。 2. 提供方仅允许刷新自己的卡片，其他提供方的卡片无法刷新。   requestForm  是  1. 使用方调用。 2. 仅允许刷新添加到当前使用方的卡片，添加到其他使用方的卡片无法刷新。     下面介绍卡片页面刷新的典型场景。  上一篇 卡片数据交互 下一篇 定时刷新和定点刷新 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片生命周期管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  创建ArkTS卡片，需实现FormExtensionAbility生命周期接口。  在EntryFormAbility.ts中，导入相关模块。已复制import formInfo from '@ohos.app.form.formInfo';import formBindingData from '@ohos.app.form.formBindingData';import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import formProvider from '@ohos.app.form.formProvider'; 在EntryFormAbility.ts中，实现FormExtensionAbility生命周期接口，其中在onAddForm的入参want中可以通过FormParam取出卡片的相关信息。已复制import formInfo from '@ohos.app.form.formInfo';import formBindingData from '@ohos.app.form.formBindingData';import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import formProvider from '@ohos.app.form.formProvider';
export default class EntryFormAbility extends FormExtensionAbility {  onAddForm(want) {    console.info('[EntryFormAbility] onAddForm');    // 在入参want中可以取出卡片的唯一标识：formId    let formId: string = want.parameters[formInfo.FormParam.IDENTITY_KEY];    // 使用方创建卡片时触发，提供方需要返回卡片数据绑定类    let obj = {      'title': 'titleOnAddForm',      'detail': 'detailOnAddForm'    };    let formData = formBindingData.createFormBindingData(obj);    return formData;  }
  onCastToNormalForm(formId) {    // Called when the form provider is notified that a temporary form is successfully    // converted to a normal form.    // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理    console.info(`[EntryFormAbility] onCastToNormalForm, formId: ${formId}`);  }
  onUpdateForm(formId) {    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新    console.info('[EntryFormAbility] onUpdateForm');    let obj = {      'title': 'titleOnUpdateForm',      'detail': 'detailOnUpdateForm'    };    let formData = formBindingData.createFormBindingData(obj);    formProvider.updateForm(formId, formData).catch((err) => {      if (err) {        // 异常分支打印        console.error(`[EntryFormAbility] Failed to updateForm. Code: ${err.code}, message: ${err.message}`);        return;      }    });  }
  onChangeFormVisibility(newStatus) {    // Called when the form provider receives form events from the system.    // 需要配置formVisibleNotify为true，且为系统应用才会回调    console.info('[EntryFormAbility] onChangeFormVisibility');  }
  onFormEvent(formId, message) {    // Called when a specified message event defined by the form provider is triggered.    // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发    console.info('[EntryFormAbility] onFormEvent');  }
  onRemoveForm(formId) {    // Called to notify the form provider that a specified form has been destroyed.    // 当对应的卡片删除时触发的回调，入参是被删除的卡片ID    console.info('[EntryFormAbility] onRemoveForm');  }
  onConfigurationUpdate(config) {    // 当系统配置信息置更新时触发的回调    console.info('[EntryFormAbility] configurationUpdate:' + JSON.stringify(config));  }
  onAcquireFormState(want) {    // Called to return a {@link FormState} object.    // 卡片提供方接收查询卡片状态通知接口，默认返回卡片初始状态。    return formInfo.FormState.READY;  }}  
说明
 FormExtensionAbility进程不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务，在生命周期调度完成后会继续存在5秒，如5秒内没有新的生命周期回调触发则进程自动退出。针对可能需要5秒以上才能完成的业务逻辑，建议拉起主应用进行处理，处理完成后使用updateForm通知卡片进行刷新。 
  上一篇 配置卡片的配置文件 下一篇 开发卡片页面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ArkTS卡片相关模块 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   图1 ArkTS卡片相关模块   FormExtensionAbility：卡片扩展模块，提供卡片创建、销毁、刷新等生命周期回调。 FormExtensionContext：FormExtensionAbility的上下文环境，提供FormExtensionAbility具有的接口和能力。 formProvider：提供卡片提供方相关的接口能力，可通过该模块提供接口实现更新卡片、设置卡片更新时间、获取卡片信息、请求发布卡片等。 formInfo：提供了卡片信息和状态等相关类型和枚举。 formBindingData：提供卡片数据绑定的能力，包括FormBindingData对象的创建、相关信息的描述。 页面布局（Card.ets）：提供声明式范式的UI接口能力。       ArkTS卡片特有能力：postCardAction用于卡片内部和提供方应用间的交互，仅在卡片中可以调用。 ArkTS卡片能力列表：列举了能在ArkTS卡片中使用的API、组件、事件、属性和生命周期调度。  卡片配置：包含FormExtensionAbility的配置和卡片的配置       在module.json5配置文件中的extensionAbilities标签下，配置FormExtensionAbility相关信息。 在resources/base/profile/目录下的form_config.json配置文件中，配置卡片（WidgetCard.ets）相关信息。    上一篇 ArkTS卡片运行机制 下一篇 ArkTS卡片开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片使用动效能力 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 ArkTS卡片开放了使用动画效果的能力，支持显式动画、属性动画、组件内转场能力。需要注意的是，ArkTS卡片使用动画效果时具有以下限制： 表1 动效参数限制名称  参数说明  限制描述    duration  动画播放时长  限制最长的动效播放时长为1秒，当设置大于1秒的时间时，动效时长仍为1秒。   tempo  动画播放速度  卡片中禁止设置此参数，使用默认值1。   delay  动画延迟执行的时长  卡片中禁止设置此参数，使用默认值0。   iterations  动画播放次数  卡片中禁止设置此参数，使用默认值1。     以下示例代码实现了按钮旋转的动画效果：  已复制@Entry@Componentstruct AttrAnimationExample {  @State rotateAngle: number = 0;
  build() {    Column() {      Button('change rotate angle')        .onClick(() => {          this.rotateAngle = 90;        })        .margin(50)        .rotate({ angle: this.rotateAngle })        .animation({          curve: Curve.EaseOut,          playMode: PlayMode.AlternateReverse        })    }.width('100%').margin({ top: 20 })  }}  上一篇 卡片页面能力说明 下一篇 卡片使用自定义绘制能力 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。卡片使用自定义绘制能力 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
       ArkTS卡片开放了自定义绘制的能力，在卡片上可以通过Canvas组件创建一块画布，然后通过CanvasRenderingContext2D对象在画布上进行自定义图形的绘制，如下示例代码实现了在画布的中心绘制了一个笑脸。     已复制@Entry@Componentstruct Card {  private canvasWidth: number = 0;  private canvasHeight: number = 0;  // 初始化CanvasRenderingContext2D和RenderingContextSettings  private settings: RenderingContextSettings = new RenderingContextSettings(true);  private context: CanvasRenderingContext2D = new CanvasRenderingContext2D(this.settings);
  build() {    Column() {      Row() {        Canvas(this.context)          .margin('5%')          .width('90%')          .height('90%')          .onReady(() => {            console.info('[ArkTSCard] onReady for canvas draw content');            // 在onReady回调中获取画布的实际宽和高            this.canvasWidth = this.context.width;            this.canvasHeight = this.context.height;            // 绘制画布的背景            this.context.fillStyle = 'rgba(203, 154, 126, 1.00)';            this.context.fillRect(0, 0, this.canvasWidth, this.canvasHeight);            // 在画布的中心绘制一个红色的圆            this.context.beginPath();            let radius = this.context.width / 3            let circleX = this.context.width / 2            let circleY = this.context.height / 2            this.context.moveTo(circleX - radius, circleY);            this.context.arc(circleX, circleY, radius, 2 * Math.PI, 0, true);            this.context.closePath();            this.context.fillStyle = 'red';            this.context.fill();            // 绘制笑脸的左眼            let leftR = radius / 4            let leftX = circleX - (radius / 2)            let leftY = circleY - (radius / 3.5)            this.context.beginPath();            this.context.arc(leftX, leftY, leftR, 0, Math.PI, true);            this.context.strokeStyle = '#ffff00'            this.context.lineWidth = 10            this.context.stroke()            // 绘制笑脸的右眼            let rightR = radius / 4            let rightX = circleX + (radius / 2)            let rightY = circleY - (radius / 3.5)            this.context.beginPath();            this.context.arc(rightX, rightY, rightR, 0, Math.PI, true);            this.context.strokeStyle = '#ffff00'            this.context.lineWidth = 10            this.context.stroke()            // 绘制笑脸的嘴巴            let mouthR = radius / 2.5            let mouthX = circleX            let mouthY = circleY + (radius / 3)            this.context.beginPath();            this.context.arc(mouthX, mouthY, mouthR, Math.PI, 0, true);            this.context.strokeStyle = '#ffff00'            this.context.lineWidth = 10            this.context.stroke()          })      }    }.height('100%').width('100%')  }}  运行效果如下图所示。   上一篇 卡片使用动效能力 下一篇 开发卡片事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发卡片页面 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    卡片页面能力说明  卡片使用动效能力  卡片使用自定义绘制能力   上一篇 卡片生命周期管理 下一篇 卡片页面能力说明 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ArkTS卡片支持的页面能力卡片页面能力说明 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  开发者可以使用声明式范式开发ArkTS卡片页面。如下卡片页面由DevEco Studio模板自动生成，开发者可以根据自身的业务场景进行调整。  ArkTS卡片具备JS卡片的全量能力，并且新增了动效能力和自定义绘制的能力，支持声明式范式的部分组件、事件、动效、数据管理、状态管理能力，详见“ArkTS卡片支持的页面能力”。  ArkTS卡片支持的页面能力 ArkTS卡片支持的页面能力如下，详细介绍请参见ArkTS声明式开发范式API参考。 在这些能力中，只有标识“支持在ArkTS卡片中使用”的具体能力可用于ArkTS卡片，同时请留意卡片场景下的能力差异说明。  属性动画 显式动画 组件内转场 像素单位 Blank组件 Button组件 Checkbox组件 CheckboxGroup组件 DataPanel组件 Divider组件 Gauge组件 Image组件 LoadingProgress组件 Marquee组件 Progress组件 Qrcode组件 Radio组件 Rating组件 Slider组件 Span组件 Text组件 Toggle组件 Canvas绘制上下文对象 Canvas组件 渐变对象 ImageBitmap对象 ImageData对象 Path2D对象 ForEach组件 Badge容器组件 Column容器组件 Counter容器组件 Flex容器组件 GridCol容器组件 GridRow容器组件 List容器组件 ListItem容器组件 RelativeContainer容器组件 Row容器组件 Stack容器组件 Circle绘制组件 Ellipse绘制组件 Line绘制组件 Path绘制组件 Polygon绘制组件 Polyline绘制组件 Rect绘制组件 Shape绘制组件 Background通用属性 BackgroundBlurStyle通用属性 BorderImage通用属性 Border通用属性 ComponentId通用属性 Enable通用属性 FlexLayout通用属性 GradientColor通用属性 ImageEffect通用属性 LayoutConstraints通用属性 Location通用属性 Opacity通用属性 Overlay通用属性 PolymorphicStyle通用属性 SharpClipping通用属性 Size通用属性 Touch-target通用属性 Transformation通用属性 Visibility通用属性 ZOrder通用属性 点击事件 挂载卸载事件 组件生命周期 状态管理    上一篇 开发卡片页面 下一篇 卡片使用动效能力 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。根据卡片状态刷新不同内容 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 相同的卡片可以添加到桌面上实现不同的功能，比如添加两张桌面的卡片，一张显示杭州的天气，一张显示北京的天气，设置每天早上7点触发定时刷新，卡片需要感知当前的配置是杭州还是北京，然后将对应城市的天气信息刷新到卡片上，以下示例介绍了如何根据卡片的状态动态选择需要刷新的内容。 卡片配置文件：配置每天早上7点触发定时刷新已复制{  "forms": [    {      "name": "widget",      "description": "This is a service widget.",      "src": "./ets/widget/pages/WidgetCard.ets",      "uiSyntax": "arkts",      "window": {        "designWidth": 720,        "autoDesignWidth": true      },      "colorMode": "auto",      "isDefault": true,      "updateEnabled": true,      "scheduledUpdateTime": "07:00",      "updateDuration": 0,      "defaultDimension": "2*2",      "supportDimensions": ["2*2"]    }  ]} 卡片页面：卡片具备不同的状态选择，在不同的状态下需要刷新不同的内容，因此在状态发生变化时通过postCardAction通知EntryFormAbility。已复制let storage = new LocalStorage();@Entry(storage)@Componentstruct WidgetCard {  @LocalStorageProp('textA') textA: string = '待刷新...';  @LocalStorageProp('textB') textB: string = '待刷新...';  @State selectA: boolean = false;  @State selectB: boolean = false;
  build() {    Column() {      Row() {        Checkbox({ name: 'checkbox1', group: 'checkboxGroup' })          .select(false)          .onChange((value: boolean) => {            this.selectA = value;            postCardAction(this, {              'action': 'message',              'params': {                'selectA': JSON.stringify(value)              }            });          })        Text('状态A')      }
      Row() {        Checkbox({ name: 'checkbox2', group: 'checkboxGroup' })          .select(false)          .onChange((value: boolean) => {            this.selectB = value;            postCardAction(this, {              'action': 'message',              'params': {                'selectB': JSON.stringify(value)              }            });          })        Text('状态B')      }
      Row() { // 选中状态A才会进行刷新的内容        Text('状态A: ')        Text(this.textA)      }
      Row() { // 选中状态B才会进行刷新的内容        Text('状态B: ')        Text(this.textB)      }    }.padding('10%')  }} EntryFormAbility：将卡片的状态存储在本地数据库中，在刷新事件回调触发时，通过formId获取当前卡片的状态，然后根据卡片的状态选择不同的刷新内容。已复制import formInfo from '@ohos.app.form.formInfo'import formProvider from '@ohos.app.form.formProvider';import formBindingData from '@ohos.app.form.formBindingData';import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import dataStorage from '@ohos.data.storage'
export default class EntryFormAbility extends FormExtensionAbility {  onAddForm(want) {    let formId = want.parameters[formInfo.FormParam.IDENTITY_KEY];    let isTempCard: boolean = want.parameters[formInfo.FormParam.TEMPORARY_KEY];    if (isTempCard === false) { // 如果为常态卡片，直接进行信息持久化      console.info('Not temp card, init db for:' + formId);      let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')      storeDB.putSync('A' + formId, 'false');      storeDB.putSync('B' + formId, 'false');      storeDB.flushSync();    }    let formData = {};    return formBindingData.createFormBindingData(formData);  }
  onRemoveForm(formId) {    console.info('onRemoveForm, formId:' + formId);    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')    storeDB.deleteSync('A' + formId);    storeDB.deleteSync('B' + formId);  }
  // 如果在添加时为临时卡片，则建议转为常态卡片时进行信息持久化  onCastToNormalForm(formId) {    console.info('onCastToNormalForm, formId:' + formId);    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')    storeDB.putSync('A' + formId, 'false');    storeDB.putSync('B' + formId, 'false');    storeDB.flushSync();  }
  onUpdateForm(formId) {    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')    let stateA = storeDB.getSync('A' + formId, 'false').toString()    let stateB = storeDB.getSync('B' + formId, 'false').toString()    // A状态选中则更新textA    if (stateA === 'true') {      let formInfo = formBindingData.createFormBindingData({        'textA': 'AAA'      })      formProvider.updateForm(formId, formInfo)    }    // B状态选中则更新textB    if (stateB === 'true') {      let formInfo = formBindingData.createFormBindingData({        'textB': 'BBB'      })      formProvider.updateForm(formId, formInfo)    }  }
  onFormEvent(formId, message) {    // 存放卡片状态    console.info('onFormEvent formId:' + formId + 'msg:' + message);    let storeDB = dataStorage.getStorageSync(this.context.filesDir + 'myStore')    let msg = JSON.parse(message)    if (msg.selectA != undefined) {      console.info('onFormEvent selectA info:' + msg.selectA);      storeDB.putSync('A' + formId, msg.selectA);    }    if (msg.selectB != undefined) {      console.info('onFormEvent selectB info:' + msg.selectB);      storeDB.putSync('B' + formId, msg.selectB);    }    storeDB.flushSync();  }};  
说明
通过本地数据库进行卡片信息的持久化时，建议先在onAddForm生命周期中通过TEMPORARY_KEY判断当前添加的卡片是否为常态卡片：如果是常态卡片，则直接进行卡片信息持久化；如果为临时卡片，则可以在卡片转为常态卡片(onCastToNormalForm)时进行持久化；同时需要在卡片销毁(onRemoveForm)时删除当前卡片存储的持久化信息，避免反复添加删除卡片导致数据库文件持续变大。 
  上一篇 刷新本地图片和网络图片 下一篇 开发基于JS UI的卡片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。定时刷新和定点刷新 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  当前卡片框架提供了如下几种按时间刷新卡片的方式：  定时刷新：表示在一定时间间隔内调用onUpdateForm的生命周期回调函数自动刷新卡片内容。可以在form_config.json配置文件的updateDuration字段中进行设置。例如，可以将刷新时间设置为每小时一次。注意：updateDuration（定时刷新）优先级比scheduledUpdateTime（定点刷新）高，配置定时刷新后，定点刷新将失效。已复制{  "forms": [    {      "name": "widget",      "description": "This is a service widget.",      "src": "./ets/widget/pages/WidgetCard.ets",      "uiSyntax": "arkts",      "window": {        "designWidth": 720,        "autoDesignWidth": true      },      "colorMode": "auto",      "isDefault": true,      "updateEnabled": true, // 使能刷新功能      "scheduledUpdateTime": "10:30",                                     "updateDuration": 2, // 设置卡片定时刷新的更新周期（单位为30分钟，取值为自然数）      "defaultDimension": "2*2",      "supportDimensions": ["2*2"]    }  ]} 定点刷新：表示每天在某个时间点刷新，在form_config.json文件中配置，详见scheduledUpdateTime字段。例如，每天在10:30更新卡片内容。      
说明
 当同时配置了定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）时，定时刷新的优先级更高。如果想要配置定点刷新，则需要将updateDuration配置为0。 
 已复制{  "forms": [    {      "name": "widget",      "description": "This is a service widget.",      "src": "./ets/widget/pages/WidgetCard.ets",      "uiSyntax": "arkts",      "window": {        "designWidth": 720,        "autoDesignWidth": true      },      "colorMode": "auto",      "isDefault": true,      "updateEnabled": true, // 使能刷新功能      "scheduledUpdateTime": "10:30", // 设置卡片的定点刷新的时刻      "updateDuration": 0,      "defaultDimension": "2*2",      "supportDimensions": ["2*2"]    }  ]} 下次刷新：通过setFormNextRefreshTime接口指定卡片的下一次刷新时间（最短时间5分钟），例如，在接口调用的5分钟后刷新卡片内容。已复制import formProvider from '@ohos.app.form.formProvider';
let formId = '123456789'; // 实际业务场景需要使用正确的formIdtry {  // 设置过5分钟后更新卡片内容  formProvider.setFormNextRefreshTime(formId, 5, (err, data) => {    if (err) {      console.error(`Failed to setFormNextRefreshTime. Code: ${err.code}, message: ${err.message}`);      return;    } else {      console.info('Succeeded in setFormNextRefreshTimeing.');    }  });} catch (err) {  console.error(`Failed to setFormNextRefreshTime. Code: ${err.code}, message: ${err.message}`);}  在触发定时、定点或主动刷新后，系统会调用FormExtensionAbility的onUpdateForm生命周期回调，在回调中，可以使用updateForm进行提供方刷新卡片。onUpdateForm生命周期回调参考通过FormExtensionAbility刷新卡片内容。 
说明
 1. 定时刷新有配额限制，每张卡片每天最多通过定时方式触发刷新50次，定时刷新包含卡片配置项updateDuration和调用setFormNextRefreshTime两种，当达到50次配额后，无法通过定时方式再次触发刷新，刷新次数会在每天的0点重置。 2. 当前定时刷新使用同一个计时器进行计时，因此卡片定时刷新的第一次刷新会有最多30分钟的偏差。比如第一张卡片A(每隔半小时刷新一次)在3点20分添加成功，定时器启动并每隔半小时触发一次事件，第二张卡片B(每隔半小时刷新一次)在3点40分添加成功，在3点50分定时器事件触发时，卡片A触发定时刷新，卡片B会在下次事件(4点20分)中才会触发。 3. 定时刷新和定点刷新仅在屏幕亮屏情况下才会触发，在灭屏场景下仅会将记录刷新动作，待亮屏时统一进行刷新。 
  上一篇 卡片数据交互说明 下一篇 刷新本地图片和网络图片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。实现原理ArkTS卡片的优势ArkTS卡片的约束ArkTS卡片运行机制 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   实现原理  图1 ArkTS卡片实现原理   卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置，当前仅系统应用可以作为卡片使用方。 卡片提供方：提供卡片显示内容的应用，控制卡片的显示内容、控件布局以及控件点击事件。 卡片管理服务：用于管理系统中所添加卡片的常驻代理服务，提供formProvider接口能力，同时提供卡片对象的管理与使用以及卡片周期性刷新等能力。 卡片渲染服务：用于管理卡片渲染实例，渲染实例与卡片使用方上的卡片组件一一绑定。卡片渲染服务运行卡片页面代码widgets.abc进行渲染，并将渲染后的数据发送至卡片使用方对应的卡片组件。   图2 ArkTS卡片渲染服务运行原理  与JS卡片相比，ArkTS卡片支持在卡片中运行逻辑代码，为确保ArkTS卡片发生问题后不影响卡片使用方应用的使用，ArkTS卡片新增了卡片渲染服务用于运行卡片页面代码widgets.abc，卡片渲染服务由卡片管理服务管理。卡片使用方的每个卡片组件都对应了卡片渲染服务里的一个渲染实例，同一应用提供方的渲染实例运行在同一个虚拟机运行环境中，不同应用提供方的渲染实例运行在不同的虚拟机运行环境中，通过虚拟机运行环境隔离不同应用提供方卡片之间的资源与状态。开发过程中需要注意的是globalThis对象的使用，相同应用提供方的卡片globalThis对象是同一个，不同应用提供方的卡片globalThis对象是不同的。   ArkTS卡片的优势 卡片作为应用的一个快捷入口，ArkTS卡片相较于JS卡片具备如下几点优势：  统一开发范式，提升开发体验和开发效率。OpenHarmony在2022年发布了声明式范式的UI开发框架，而卡片还延续了css/hml/json三段式类Web范式的开发方式，提高了开发者的学习成本，提供ArkTS卡片能力后，统一了卡片和页面的开发范式，页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。  图3 卡片工程结构对比  增强了卡片的能力，使卡片更加万能。        新增了动效的能力：ArkTS卡片开放了属性动画和显式动画的能力，使卡片的交互更加友好。 新增了自定义绘制的能力：ArkTS卡片开放了Canvas画布组件，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。 允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。     ArkTS卡片的约束 ArkTS卡片相较于JS卡片具备了更加丰富的能力，但也增加了使用卡片进行恶意行为的风险。由于ArkTS卡片显示在使用方应用中，使用方应用一般为桌面应用，为确保桌面的使用体验以及功耗相关考虑，对ArkTS卡片的能力做了以下约束：  不支持加载so。 不支持使用native语言开发。 仅支持声明式范式的部分组件、事件、动效、数据管理、状态管理和API能力。 卡片的事件处理和使用方的事件处理是独立的，建议在使用方支持左右滑动的场景下卡片内容不要使用左右滑动功能的组件，以防手势冲突影响交互体验。  除此之外，当前ArkTS卡片还存在如下约束：  暂不支持导入模块。 暂不支持极速预览。 暂不支持断点调试能力。 暂不支持Hot Reload热重载。    上一篇 开发基于ArkTS UI的卡片 下一篇 ArkTS卡片相关模块 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述装饰器说明语法说明观察变化和行为表现限制条件使用场景@Watch和自定义组件更新@Watch与@Link组合使用@Watch装饰器：状态变量更改通知 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 @Watch应用于对状态变量的监听。如果开发者需要关注某个状态变量的值是否改变，可以使用@Watch为状态变量设置回调函数。 
说明
从API version 9开始，该装饰器支持在ArkTS卡片中使用。 
 概述@Watch用于监听状态变量的变化，当状态变量变化时，@Watch的回调方法将被调用。@Watch在ArkUI框架内部判断数值有无更新使用的是严格相等（===），遵循严格相等规范。当在严格相等为false的情况下，就会触发@Watch的回调。  装饰器说明 @Watch补充变量装饰器  说明    装饰器参数  必填。常量字符串，字符串需要有引号。是(string) => void自定义成员函数的方法的引用。   可装饰的自定义组件变量  可监听所有装饰器装饰的状态变量。不允许监听常规变量。   装饰器的顺序  建议@State、@Prop、@Link等装饰器在@Watch装饰器之前。      语法说明 类型  说明    (changedPropertyName? : string) => void  该函数是自定义组件的成员函数，changedPropertyName是被watch的属性名。 在多个状态变量绑定同一个@Watch的回调方法的时候，可以通过changedPropertyName进行不同的逻辑处理 将属性名作为字符串输入参数，不返回任何内容。      观察变化和行为表现当观察到状态变量的变化（包括双向绑定的AppStorage和LocalStorage中对应的key发生的变化）的时候，对应的@Watch的回调方法将被触发；@Watch方法在自定义组件的属性变更之后同步执行；如果在@Watch的方法里改变了其他的状态变量，也会引起状态变更和@Watch的执行；在第一次初始化的时候，@Watch装饰的方法不会被调用，即认为初始化不是状态变量的改变。只有在后续状态改变时，才会调用@Watch回调方法。  限制条件建议开发者避免无限循环。循环可能是因为在@Watch的回调方法里直接或者间接地修改了同一个状态变量引起的。为了避免循环的产生，建议不要在@Watch的回调方法里修改当前装饰的状态变量；开发者应关注性能，属性值更新函数会延迟组件的重新渲染（具体请见上面的行为表现），因此，回调函数应仅执行快速运算；不建议在@Watch函数中调用async await，因为@Watch设计的用途是为了快速的计算，异步行为可能会导致重新渲染速度的性能问题。  使用场景 @Watch和自定义组件更新以下示例展示组件更新和@Watch的处理步骤。count在CountModifier中由@State装饰，在TotalView中由@Prop装饰。 已复制@Componentstruct TotalView {  @Prop @Watch('onCountUpdated') count: number;  @State total: number = 0;  // @Watch 回调  onCountUpdated(propName: string): void {    this.total += this.count;  }
  build() {    Text(`Total: ${this.total}`)  }}
@Entry@Componentstruct CountModifier {  @State count: number = 0;
  build() {    Column() {      Button('add to basket')        .onClick(() => {          this.count++        })      TotalView({ count: this.count })    }  }} 处理步骤： CountModifier自定义组件的Button.onClick点击事件自增count。由于@State count变量更改，子组件TotalView中的@Prop被更新，其@Watch('onCountUpdated')方法被调用，更新了子组件TotalView 中的total变量。子组件TotalView中的Text重新渲染。  @Watch与@Link组合使用以下示例说明了如何在子组件中观察@Link变量。 已复制class PurchaseItem {  static NextId: number = 0;  public id: number;  public price: number;
  constructor(price: number) {    this.id = PurchaseItem.NextId++;    this.price = price;  }}
@Componentstruct BasketViewer {  @Link @Watch('onBasketUpdated') shopBasket: PurchaseItem[];  @State totalPurchase: number = 0;
  updateTotal(): number {    let total = this.shopBasket.reduce((sum, i) => sum + i.price, 0);    // 超过100欧元可享受折扣    if (total >= 100) {      total = 0.9 * total;    }    return total;  }  // @Watch 回调  onBasketUpdated(propName: string): void {    this.totalPurchase = this.updateTotal();  }
  build() {    Column() {      ForEach(this.shopBasket,        (item) => {          Text(`Price: ${item.price.toFixed(2)} €`)        },        item => item.id.toString()      )      Text(`Total: ${this.totalPurchase.toFixed(2)} €`)    }  }}
@Entry@Componentstruct BasketModifier {  @State shopBasket: PurchaseItem[] = [];
  build() {    Column() {      Button('Add to basket')        .onClick(() => {          this.shopBasket.push(new PurchaseItem(Math.round(100 * Math.random())))        })      BasketViewer({ shopBasket: $shopBasket })    }  }} 处理步骤如下： BasketModifier组件的Button.onClick向BasketModifier shopBasket中添加条目；@Link装饰的BasketViewer shopBasket值发生变化；状态管理框架调用@Watch函数BasketViewer onBasketUpdated 更新BasketViewer TotalPurchase的值；@Link shopBasket的改变，新增了数组项，ForEach组件会执行item Builder，渲染构建新的Item项；@State totalPurchase改变，对应的Text组件也重新渲染；重新渲染是异步发生的。   上一篇 其他状态管理概述 下一篇 $$语法：内置组件双向同步 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Exchange类型的共享元素转场Static类型的共享元素转场场景示例放大缩小视图 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在不同页面间，有使用相同的元素（例如同一幅图）的场景，可以使用共享元素转场动画衔接。为了突出不同页面间相同元素的关联性，可为它们添加共享元素转场动画。如果相同元素在不同页面间的大小有明显差异，即可达到放大缩小视图的效果。 共享元素转场的接口为： 已复制sharedTransition(id: string, options?: sharedTransitionOptions) 其中根据sharedTransitionOptions中的type参数，共享元素转场分为Exchange类型的共享元素转场和Static类型的共享元素转场。  Exchange类型的共享元素转场 交换型的共享元素转场，需要两个页面中，存在通过sharedTransition函数配置为相同id的组件，它们称为共享元素。这种类型的共享元素转场适用于两个页面间相同元素的衔接，会从起始页共享元素的位置、大小过渡到目标页的共享元素的位置、大小。如果不指定type，默认为Exchange类型的共享元素转场，这也是最常见的共享元素转场的方式。使用Exchange类型的共享元素转场时，共享元素转场的动画参数由目标页options中的动画参数决定。   Static类型的共享元素转场 静态型的共享元素转场通常用于页面跳转时，标题逐渐出现或隐藏的场景，只需要在一个页面中有Static的共享元素，不能在两个页面中出现相同id的Static类型的共享元素。在跳转到该页面（即目标页）时，配置Static类型sharedTransition的组件做透明度从0到该组件设定的透明度的动画，位置保持不变。在该页面（即起始页）消失时，做透明度逐渐变为0的动画，位置保持不变。 共享元素转场的动画参数由该组件sharedTransition属性中的动画参数决定。   场景示例 下面介绍使用共享元素转场进行放大缩小图片的示例。 已复制// src pageimport router from '@ohos.router';
@Entry@Componentstruct SharedTransitionSrc {  build() {    Column() {      // 配置Exchange类型的共享元素转场，共享元素id为"sharedImage1"      Image($r('app.media.mountain')).width(50).height(50)        .sharedTransition('sharedImage1', { duration: 1000, curve: Curve.Linear })        .onClick(() => {          // 点击小图时路由跳转至下一页面          router.pushUrl({ url: 'pages/myTest/sharedTransitionDst' });        })    }    .padding(10)    .width("100%")    .alignItems(HorizontalAlign.Start)  }}   已复制// dest pageimport router from '@ohos.router';@Entry@Componentstruct SharedTransitionDest {  build() {    Column() {      // 配置Static类型的共享元素转场      Text("SharedTransition dest page")        .fontSize(16)        .sharedTransition('text', { duration: 500, curve: Curve.Linear, type: SharedTransitionEffectType.Static })        .margin({ top: 10 })
      // 配置Exchange类型的共享元素转场，共享元素id为"sharedImage1"      Image($r('app.media.mountain'))        .width(150)        .height(150)        .sharedTransition('sharedImage1', { duration: 500, curve: Curve.Linear })        .onClick(() => {          // 点击图片时路由返回至上一页面          router.back();        })    }    .width("100%")    .alignItems(HorizontalAlign.Center)  }} 上述示例中，第一个页面（src page)和第二个页面（dest page）都配置了id为"sharedImage1"的共享元素转场，使两个页面能匹配到这一组共享元素。从第一个页面跳转到第二个页面时，第一个页面为起始页，第二个页面为目标页。配置id为"sharedImage1"的组件按照目标页中500ms的时长进行共享元素转场，达到放大视图的效果，id为"text"的组件按照配置的Static类型sharedTransition参数中的500ms的时长进行共享元素转场，标题逐渐出现。从第二个页面返回到第一个页面时，第二个页面为起始页，第一个页面为目标页。配置id为"sharedImage1"的组件按照目标页中1000ms的时长进行共享元素转场，缩小为原始视图，id为"text"的组件按照配置的Static类型sharedTransition参数中的500ms的时长进行共享元素转场，标题逐渐隐藏。    上一篇 页面间的动画 下一篇 页面转场动画 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念两种开发范式不同应用类型支持的开发范式方舟开发框架（ArkUI）概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  方舟开发框架（简称ArkUI）为HarmonyOS应用的UI开发提供了完整的基础设施，包括简洁的UI语法、丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。  基本概念  UI：即用户界面。开发者可以将应用的用户界面设计为多个功能页面，每个页面进行单独的文件管理，并通过页面路由API完成页面间的调度管理如跳转、回退等操作，以实现应用内的功能解耦。 组件：UI构建与显示的最小单位，如列表、网格、按钮、单选框、进度条、文本等。开发者通过多种组件的组合，构建出满足自身应用诉求的完整界面。    两种开发范式 针对不同的应用场景及技术背景，方舟开发框架提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）和兼容JS的类Web开发范式（简称“类Web开发范式”）。  声明式开发范式：采用基于TypeScript声明式UI语法扩展而来的ArkTS语言，从组件、动画和状态管理三个维度提供UI绘制能力。 类Web开发范式：采用经典的HML、CSS、JavaScript三段式开发方式，即使用HML标签文件搭建布局、使用CSS文件描述样式、使用JavaScript文件处理逻辑。该范式更符合于Web前端开发者的使用习惯，便于快速将已有的Web应用改造成方舟开发框架应用。  在开发一款新应用时，推荐采用声明式开发范式来构建UI，主要基于以下几点考虑：  开发效率：声明式开发范式更接近自然语义的编程方式，开发者可以直观地描述UI，无需关心如何实现UI绘制和渲染，开发高效简洁。 应用性能：如下图所示，两种开发范式的UI后端引擎和语言运行时是共用的，但是相比类Web开发范式，声明式开发范式无需JS框架进行页面DOM管理，渲染更新链路更为精简，占用内存更少，应用性能更佳。 发展趋势：声明式开发范式后续会作为主推的开发范式持续演进，为开发者提供更丰富、更强大的能力。   图1 方舟开发框架示意图    不同应用类型支持的开发范式 根据所选用HarmonyOS应用模型（Stage模型、FA模型）和页面形态（应用或服务的普通页面、卡片）的不同，对应支持的UI开发范式也有所差异，详见下表。    表1 支持的UI开发范式          应用模型 页面形态 支持的UI开发范式    Stage模型（推荐） 应用或服务的页面 声明式开发范式（推荐）      卡片 声明式开发范式（推荐） 类Web开发范式   FA模型 应用或服务的页面 声明式开发范式 类Web开发范式      卡片 类Web开发范式      上一篇 UI开发 下一篇 基于ArkTS的声明式开发范式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述简介实现原理约束与限制环境准备环境要求搭建环境新建测试脚本编写单元测试脚本编写UI测试脚本执行测试脚本查看测试结果常见问题单元测试用例常见问题UI测试用例常见问题自动化测试框架使用指南 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   概述  为支撑HarmonyOS操作系统的自动化测试活动开展，我们提供了支持JS/TS语言的单元及UI测试框架，支持开发者针对应用接口进行单元测试，并且可基于UI操作进行UI自动化脚本的编写。 本指南重点介绍自动化测试框架的主要功能，同时介绍编写单元/UI自动化测试脚本的方法以及执行过程。  简介 HarmonyOS自动化测试框架arkxtest，作为HarmonyOS工具集的重要组成部分，提供了HarmonyOS自动化脚本编写和运行的基础能力。编写方面提供了一系列支持测试脚本编写的API，包括了基础流程API、断言API以及UI操作相关的API，运行方面提供了识别测试脚本、调度执行测试脚本以及汇总测试脚本执行结果的能力。   实现原理 框架重要分为两大部分：单元测试框架和UI测试框架。  单元测试框架 单元测试框架是测试框架的基础底座，提供了最基本的用例识别、调度、执行及结果汇总的能力。主要功能如下图所示：  单元测试脚本的基础运行流程如下图所示，依赖aa test命令作为执行入口，该命令可具体参考。  UI测试框架 UI测试框架主要对外提供了UiTest API供开发人员在对应测试场景调用，而其脚本的运行基础还是上面提到的单元测试框架。 UI测试框架的主要功能如下图所示：     约束与限制  UI测试框架的能力在HarmonyOS 3.0 release版本之后方可使用，历史版本不支持使用。   单元测试框架的部分能力与其版本有关，具体能力与版本匹配信息可见代码仓中的文档介绍。    环境准备   环境要求 自动化脚本的编写主要基于DevEco Studio，并建议使用3.1.0.400之后的版本进行脚本编写。 脚本执行需要PC连接HarmonyOS设备，如JAD等。   搭建环境 DevEco Studio可参考其官网介绍进行下载，并进行相关的配置动作。   新建测试脚本  在DevEco Studio中新建应用开发工程，其中ohos目录即为测试脚本所在的目录。 在工程目录下打开待测试模块下的ets文件，将光标置于代码中任意位置，单击右键 > Show Context Actions > Create Ohos Test或快捷键Alt+enter > Create Ohos Test创建测试类，更多指导请参考DevEco Studio中指导。    编写单元测试脚本 已复制import { describe, beforeAll, beforeEach, afterEach, afterAll, it, expect } from '@ohos/hypium'import abilityDelegatorRegistry from '@ohos.application.abilityDelegatorRegistry'
const delegator = abilityDelegatorRegistry.getAbilityDelegator()export default function abilityTest() {  describe('ActsAbilityTest', function () {    it('testUiExample',0, async function (done) {      console.info("uitest: TestUiExample begin");      //start tested ability      await delegator.executeShellCommand('aa start -b com.ohos.uitest -a MainAbility').then(result =>{        console.info('Uitest, start ability finished:' + result)      }).catch(err => {        console.info('Uitest, start ability failed: ' + err)      })      await sleep(1000);      //check top display ability      await delegator.getCurrentTopAbility().then((Ability)=>{        console.info("get top ability");        expect(Ability.context.abilityInfo.name).assertEqual('MainAbility');      })      done();    })
    function sleep(time) {      return new Promise((resolve) => setTimeout(resolve, time));    }  })} 单元测试脚本需要包含如下基本元素： 1、依赖导包，以便使用依赖的测试接口。 2、测试代码编写，主要编写测试代码的相关逻辑，如接口调用等。 3、断言接口调用，设置测试代码中的检查点，如无检查点，则不可认为一个完整的测试脚本。   编写UI测试脚本 UI测试脚本是在单元测试框架的基础上编写，主要就是增加了UI测试框架提供的接口调用，实现对应的测试逻辑。 下面的示例代码是在上面的测试脚本基础上增量编写，首先需要增加依赖导包，如下示例代码所示： 已复制import {Driver,ON,Component,MatchPattern} from '@ohos.UiTest' 然后是具体测试代码编写，场景较为简单，就是在启动的应用页面上进行点击操作，然后增加检查点检查用例。 已复制export default function abilityTest() {  describe('ActsAbilityTest', function () {    it('testUiExample',0, async function (done) {      console.info("uitest: TestUiExample begin");      //start tested ability      await delegator.executeShellCommand('aa start -b com.ohos.uitest -a MainAbility').then(result =>{        console.info('Uitest, start ability finished:' + result)      }).catch(err => {        console.info('Uitest, start ability failed: ' + err)      })      await sleep(1000);      //check top display ability      await delegator.getCurrentTopAbility().then((Ability)=>{        console.info("get top ability");        expect(Ability.context.abilityInfo.name).assertEqual('MainAbility');      })      //ui test code      //init driver      var driver = await Driver.create();      await driver.delayMs(1000);      //find button by text 'Next'      var button = await driver.findComponent(ON.text('Next'));      //click button      await button.click();      await driver.delayMs(1000);      //check text      await driver.assertComponentExist(ON.text('after click'));      await driver.pressBack();      done();    })
    function sleep(time) {      return new Promise((resolve) => setTimeout(resolve, time));    }  })}  
说明
 只支持应用内使用。暂不支持应用外的场景实现自动化，例如与权限弹窗和SystemUi上的控件进行交互。 
  执行测试脚本 执行测试脚本可以直接在DevEco Studio中通过点击按钮执行，当前支持以下执行方式： 1、测试包级别执行即执行测试包内的全部用例。 2、测试套级别执行即执行describe方法中定义的全部测试用例。 3、测试方法级别执行即执行指定it方法也就是单条测试用例。    查看测试结果 测试执行完毕后可直接在DevEco Studio中查看测试结果，如下图示例所示：    常见问题   单元测试用例常见问题 1、用例中增加的打印日志在用例结果之后才打印 问题描述 用例中增加的日志打印信息，没有在用例执行过程中出现，而是在用例执行结束之后才出现。 可能原因 此类情况只会存在于用例中有调用异步接口的情况，原则上用例中所有的日志信息均在用例执行结束之前打印。 解决方法 当被调用的异步接口多于一个时，建议将接口调用封装成Promise方式调用。 2、执行用例时报error：fail to start ability 问题描述 执行测试用例时候，用例执行失败，控制台返回错误：fail to start ability。 可能原因 测试包打包过程中出现问题，未将测试框架依赖文件打包在测试包中。 解决方法 检查测试包中是否包含TestRunner.abc文件，如没有则重新编译打包后再次执行测试。 3、执行用例时报用例超时错误 问题描述 用例执行结束，控制台提示execute time XXms错误，即用例执行超时 可能原因 1.用例执行异步接口，但执行过程中没有执行到done函数，导致用例执行一直没有结束，直到超时结束。 2.用例调用函数耗时过长，超过用例执行设置的超时时间。 解决方法 1.检查用例代码逻辑，确保即使断言失败场景认可走到done函数，保证用例执行结束。 2.可在IDE中Run/Debug Configurations中修改用例执行超时配置参数，避免用例执行超时。   UI测试用例常见问题 1、失败日志有“Get windows failed/GetRootByWindow failed”错误信息 问题描述 UI测试用例执行失败，查看hilog日志发现日志中有“Get windows failed/GetRootByWindow failed”错误信息。 可能原因 系统ArkUI开关未开启，导致被测试界面控件树信息未生成。 解决方法 执行如下命令，并重启设备再次执行用例。 已复制hdc shell param set persist.ace.testmode.enabled 1 2、失败日志有“uitest-api dose not allow calling concurrently”错误信息 问题描述 UI测试用例执行失败，查看hilog日志发现日志中有“uitest-api dose not allow calling concurrently”错误信息。 可能原因 1.用例中UI测试框架提供异步接口没有增加await语法糖调用。 2.多进程执行UI测试用例，导致拉起多个UITest进程，框架不支持多进程调用。 解决方法 1.检查用例实现，异步接口增加await语法糖调用。 2.避免多进程执行UI测试用例。 3、失败日志有“dose not exist on current UI! Check if the UI has changed after you got the widget object”错误信息 问题描述 UI测试用例执行失败，查看hilog日志发现日志中有“dose not exist on current UI! Check if the UI has changed after you got the widget object”错误信息。 可能原因 在用例中代码查找到目标控件后，设备界面发生了变化，导致查找到的控件丢失，无法进行下一步的模拟操作。 解决方法 重新执行UI测试用例。   上一篇 应用测试 下一篇 Native API相关指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。内存错误检测操作步骤C/C++内存错误检测 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
仅OpenHarmony工程支持该功能，且镜像为OpenHarmony 3.2 Release及以上版本，点击获取。 
 内存错误检测为追求C/C++的极致性能，编译器和OS(Windows/Linux/Mac)运行框架不会对内存操作进行安全检测。针对该场景，DevEco Studio集成ASan（Address-Sanitizer）为开发者提供面向C/C++的地址越界检测能力，并通过FaultLog展示错误的堆栈详情及导致错误的代码行。 当前仅API Version 9支持。   操作步骤在运行调试窗口勾选Address Sanitizer选项。 如果有引用本地library，需在library模块的build-profile.json5文件中，配置arguments字段值为“-DOHOS_ENABLE_ASAN=ON”，表示以ASan模式编译so文件。 运行或调试当前应用。当程序出现内存错误时，弹出ASan log信息，点击信息中的链接即可跳转至引起内存错误的代码处。   上一篇 打印日志 下一篇 性能分析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Promiseasync/await异步并发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 Promise和async/await提供异步并发能力，是标准的JS异步语法。异步代码会被挂起并在之后继续执行，同一时间只有一段代码执行，适用于单次I/O任务的场景开发，例如一次网络请求、一次文件读写等操作。 异步语法是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，而是可以继续执行其他操作。 PromisePromise是一种用于处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，以方便代码编写和维护。Promise提供了一个状态机制来管理异步操作的不同阶段，并提供了一些方法来注册回调函数以处理异步操作的成功或失败的结果。 Promise有三种状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）。Promise对象创建后处于pending状态，并在异步操作完成后转换为fulfilled或rejected状态。 最基本的用法是通过构造函数实例化一个Promise对象，同时传入一个带有两个参数的函数，通常称为executor函数。executor函数接收两个参数：resolve和reject，分别表示异步操作成功和失败时的回调函数。例如，以下代码创建了一个Promise对象并模拟了一个异步操作： 已复制const promise = new Promise((resolve, reject) => {  setTimeout(() => {    const randomNumber = Math.random();    if (randomNumber > 0.5) {      resolve(randomNumber);    } else {      reject(new Error('Random number is too small'));    }  }, 1000);}); 上述代码中，setTimeout函数模拟了一个异步操作，并在1秒钟后随机生成一个数字。如果随机数大于0.5，则执行resolve回调函数并将随机数作为参数传递；否则执行reject回调函数并传递一个错误对象作为参数。 Promise对象创建后，可以使用then方法和catch方法指定fulfilled状态和rejected状态的回调函数。then方法可接受两个参数，一个处理fulfilled状态的函数，另一个处理rejected状态的函数。只传一个参数则表示状态改变就执行，不区分状态结果。使用catch方法注册一个回调函数，用于处理“失败”的结果，即捕获Promise的状态改变为rejected状态或操作失败抛出的异常。例如： 已复制promise.then(result => {  console.info(`Random number is ${result}`);}).catch(error => {  console.error(error.message);}); 上述代码中，then方法的回调函数接收Promise对象的成功结果作为参数，并将其输出到控制台上。如果Promise对象进入rejected状态，则catch方法的回调函数接收错误对象作为参数，并将其输出到控制台上。  async/awaitasync/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。 async函数是一个返回Promise对象的函数，用于表示一个异步操作。在async函数内部，可以使用await关键字等待一个Promise对象的解析，并返回其解析值。如果一个async函数抛出异常，那么该函数返回的Promise对象将被拒绝，并且异常信息会被传递给Promise对象的onRejected()方法。 下面是一个使用async/await的例子，其中模拟了一个异步操作，该操作会在3秒钟后返回一个字符串。 已复制async function myAsyncFunction() {  const result = await new Promise((resolve) => {    setTimeout(() => {      resolve('Hello, world!');    }, 3000);  });  console.info(String(result)); // 输出： Hello, world!}
myAsyncFunction(); 在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。 需要注意的是，由于要等待异步操作完成，因此需要将整个操作包在async函数中。除了在async函数中使用await外，还可以使用try/catch块来捕获异步操作中的异常。 已复制async function myAsyncFunction() {  try {    const result = await new Promise((resolve) => {      resolve('Hello, world!');    });  } catch (e) {    console.error(`Get exception: ${e}`);  }}
myAsyncFunction();   上一篇 使用异步并发能力进行开发 下一篇 单次I/O任务开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。音频通话 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    音频通话开发概述  开发音频通话功能   上一篇 音频输入设备管理 下一篇 音频通话开发概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用AudioRenderer播放对端的通话声音使用AudioCapturer录制本端的通话声音开发音频通话功能 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 在音频通话场景下，音频输出（播放对端声音）和音频输入（录制本端声音）会同时进行，应用可以通过使用AudioRenderer来实现音频输出，通过使用AudioCapturer来实现音频输入，同时使用AudioRenderer和AudioCapturer即可实现音频通话功能。 在音频通话开始和结束时，应用可以自行检查当前的音频场景模式和铃声模式，以便采取合适的音频管理及提示策略。 以下代码示范了同时使用AudioRenderer和AudioCapturer实现音频通话功能的基本过程，其中未包含音频通话数据的传输过程，实际开发中，需要将网络传输来的对端通话数据解码播放，此处仅以读取音频文件的数据代替；同时需要将本端录制的通话数据编码打包，通过网络发送给对端，此处仅以将数据写入音频文件代替。 使用AudioRenderer播放对端的通话声音该过程与使用AudioRenderer开发音频播放功能过程相似，关键区别在于audioRenderInfo参数和音频数据来源。audioRenderInfo参数中，音频内容类型需设置为语音，CONTENT_TYPE_SPEECH，音频流使用类型需设置为语音通信，STREAM_USAGE_VOICE_COMMUNICATION。已复制import audio from '@ohos.multimedia.audio';import fs from '@ohos.file.fs';const TAG = 'VoiceCallDemoForAudioRenderer';// 与使用AudioRenderer开发音频播放功能过程相似，关键区别在于audioRendererInfo参数和音频数据来源export default class VoiceCallDemoForAudioRenderer {  private renderModel = undefined;  private audioStreamInfo = {    samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_48000, // 采样率    channels: audio.AudioChannel.CHANNEL_2, // 通道    sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式    encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式  }  private audioRendererInfo = {    // 需使用通话场景相应的参数    content: audio.ContentType.CONTENT_TYPE_SPEECH, // 音频内容类型：语音    usage: audio.StreamUsage.STREAM_USAGE_VOICE_COMMUNICATION, // 音频流使用类型：语音通信    rendererFlags: 0 // 音频渲染器标志：默认为0即可  }  private audioRendererOptions = {    streamInfo: this.audioStreamInfo,    rendererInfo: this.audioRendererInfo  }  // 初始化，创建实例，设置监听事件  init() {    audio.createAudioRenderer(this.audioRendererOptions, (err, renderer) => { // 创建AudioRenderer实例      if (!err) {        console.info(`${TAG}: creating AudioRenderer success`);        this.renderModel = renderer;        this.renderModel.on('stateChange', (state) => { // 设置监听事件，当转换到指定的状态时触发回调          if (state == 1) {            console.info('audio renderer state is: STATE_PREPARED');          }          if (state == 2) {            console.info('audio renderer state is: STATE_RUNNING');          }        });        this.renderModel.on('markReach', 1000, (position) => { // 订阅markReach事件，当渲染的帧数达到1000帧时触发回调          if (position == 1000) {            console.info('ON Triggered successfully');          }        });      } else {        console.info(`${TAG}: creating AudioRenderer failed, error: ${err.message}`);      }    });  }  // 开始一次音频渲染  async start() {    let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];    if (stateGroup.indexOf(this.renderModel.state) === -1) { // 当且仅当状态为STATE_PREPARED、STATE_PAUSED和STATE_STOPPED之一时才能启动渲染      console.error(TAG + 'start failed');      return;    }    await this.renderModel.start(); // 启动渲染    const bufferSize = await this.renderModel.getBufferSize();    // 此处仅以读取音频文件的数据举例，实际音频通话开发中，需要读取的是通话对端传输来的音频数据    let context = getContext(this);    let path = context.filesDir;    const filePath = path + '/voice_call_data.wav'; // 沙箱路径，实际路径为/data/storage/el2/base/haps/entry/files/voice_call_data.wav    let file = fs.openSync(filePath, fs.OpenMode.READ_ONLY);    let stat = await fs.stat(filePath);    let buf = new ArrayBuffer(bufferSize);    let len = stat.size % bufferSize === 0 ? Math.floor(stat.size / bufferSize) : Math.floor(stat.size / bufferSize + 1);    for (let i = 0; i < len; i++) {      let options = {        offset: i * bufferSize,        length: bufferSize      };      let readsize = await fs.read(file.fd, buf, options);      // buf是要写入缓冲区的音频数据，在调用AudioRenderer.write()方法前可以进行音频数据的预处理，实现个性化的音频播放功能，AudioRenderer会读出写入缓冲区的音频数据进行渲染      let writeSize = await new Promise((resolve, reject) => {        this.renderModel.write(buf, (err, writeSize) => {          if (err) {            reject(err);          } else {            resolve(writeSize);          }        });      });      if (this.renderModel.state === audio.AudioState.STATE_RELEASED) { // 如果渲染器状态为STATE_RELEASED，停止渲染        fs.close(file);        await this.renderModel.stop();      }      if (this.renderModel.state === audio.AudioState.STATE_RUNNING) {        if (i === len - 1) { // 如果音频文件已经被读取完，停止渲染          fs.close(file);          await this.renderModel.stop();        }      }    }  }  // 暂停渲染  async pause() {    // 只有渲染器状态为STATE_RUNNING的时候才能暂停    if (this.renderModel.state !== audio.AudioState.STATE_RUNNING) {      console.info('Renderer is not running');      return;    }    await this.renderModel.pause(); // 暂停渲染    if (this.renderModel.state === audio.AudioState.STATE_PAUSED) {      console.info('Renderer is paused.');    } else {      console.error('Pausing renderer failed.');    }  }  // 停止渲染  async stop() {    // 只有渲染器状态为STATE_RUNNING或STATE_PAUSED的时候才可以停止    if (this.renderModel.state !== audio.AudioState.STATE_RUNNING && this.renderModel.state !== audio.AudioState.STATE_PAUSED) {      console.info('Renderer is not running or paused.');      return;    }    await this.renderModel.stop(); // 停止渲染    if (this.renderModel.state === audio.AudioState.STATE_STOPPED) {      console.info('Renderer stopped.');    } else {      console.error('Stopping renderer failed.');    }  }  // 销毁实例，释放资源  async release() {    // 渲染器状态不是STATE_RELEASED状态，才能release    if (this.renderModel.state === audio.AudioState.STATE_RELEASED) {      console.info('Renderer already released');      return;    }    await this.renderModel.release(); // 释放资源    if (this.renderModel.state === audio.AudioState.STATE_RELEASED) {      console.info('Renderer released');    } else {      console.error('Renderer release failed.');    }  }}   使用AudioCapturer录制本端的通话声音该过程与使用AudioCapturer开发音频录制功能过程相似，关键区别在于audioCapturerInfo参数和音频数据流向。audioCapturerInfo参数中音源类型需设置为语音通话，SOURCE_TYPE_VOICE_COMMUNICATION。已复制import audio from '@ohos.multimedia.audio';import fs from '@ohos.file.fs';const TAG = 'VoiceCallDemoForAudioCapturer';// 与使用AudioCapturer开发音频录制功能过程相似，关键区别在于audioCapturerInfo参数和音频数据流向export default class VoiceCallDemoForAudioCapturer {  private audioCapturer = undefined;  private audioStreamInfo = {    samplingRate: audio.AudioSamplingRate.SAMPLE_RATE_44100, // 采样率    channels: audio.AudioChannel.CHANNEL_1, // 通道    sampleFormat: audio.AudioSampleFormat.SAMPLE_FORMAT_S16LE, // 采样格式    encodingType: audio.AudioEncodingType.ENCODING_TYPE_RAW // 编码格式  }  private audioCapturerInfo = {    // 需使用通话场景相应的参数    source: audio.SourceType.SOURCE_TYPE_VOICE_COMMUNICATION, // 音源类型：语音通话    capturerFlags: 0 // 音频采集器标志：默认为0即可  }  private audioCapturerOptions = {    streamInfo: this.audioStreamInfo,    capturerInfo: this.audioCapturerInfo  }  // 初始化，创建实例，设置监听事件  init() {    audio.createAudioCapturer(this.audioCapturerOptions, (err, capturer) => { // 创建AudioCapturer实例      if (err) {        console.error(`Invoke createAudioCapturer failed, code is ${err.code}, message is ${err.message}`);        return;      }      console.info(`${TAG}: create AudioCapturer success`);      this.audioCapturer = capturer;      this.audioCapturer.on('markReach', 1000, (position) => { // 订阅markReach事件，当采集的帧数达到1000时触发回调        if (position === 1000) {          console.info('ON Triggered successfully');        }      });      this.audioCapturer.on('periodReach', 2000, (position) => { // 订阅periodReach事件，当采集的帧数达到2000时触发回调        if (position === 2000) {          console.info('ON Triggered successfully');        }      });    });  }  // 开始一次音频采集  async start() {    let stateGroup = [audio.AudioState.STATE_PREPARED, audio.AudioState.STATE_PAUSED, audio.AudioState.STATE_STOPPED];    if (stateGroup.indexOf(this.audioCapturer.state) === -1) { // 当且仅当状态为STATE_PREPARED、STATE_PAUSED和STATE_STOPPED之一时才能启动采集      console.error(`${TAG}: start failed`);      return;    }    await this.audioCapturer.start(); // 启动采集    // 此处仅以将音频数据写入文件举例，实际音频通话开发中，需要将本端采集的音频数据编码打包，通过网络发送给通话对端    let context = getContext(this);    const path = context.filesDir + '/voice_call_data.wav'; // 采集到的音频文件存储路径    let file = fs.openSync(path, 0o2 | 0o100); // 如果文件不存在则创建文件    let fd = file.fd;    let numBuffersToCapture = 150; // 循环写入150次    let count = 0;    while (numBuffersToCapture) {      let bufferSize = await this.audioCapturer.getBufferSize();      let buffer = await this.audioCapturer.read(bufferSize, true);      let options = {        offset: count * bufferSize,        length: bufferSize      };      if (buffer === undefined) {        console.error(`${TAG}: read buffer failed`);      } else {        let number = fs.writeSync(fd, buffer, options);        console.info(`${TAG}: write date: ${number}`);      }      numBuffersToCapture--;      count++;    }  }  // 停止采集  async stop() {    // 只有采集器状态为STATE_RUNNING或STATE_PAUSED的时候才可以停止    if (this.audioCapturer.state !== audio.AudioState.STATE_RUNNING && this.audioCapturer.state !== audio.AudioState.STATE_PAUSED) {      console.info('Capturer is not running or paused');      return;    }    await this.audioCapturer.stop(); // 停止采集    if (this.audioCapturer.state === audio.AudioState.STATE_STOPPED) {      console.info('Capturer stopped');    } else {      console.error('Capturer stop failed');    }  }  // 销毁实例，释放资源  async release() {    // 采集器状态不是STATE_RELEASED或STATE_NEW状态，才能release    if (this.audioCapturer.state === audio.AudioState.STATE_RELEASED || this.audioCapturer.state === audio.AudioState.STATE_NEW) {      console.info('Capturer already released');      return;    }    await this.audioCapturer.release(); // 释放资源    if (this.audioCapturer.state == audio.AudioState.STATE_RELEASED) {      console.info('Capturer released');    } else {      console.error('Capturer release failed');    }  }}    上一篇 音频通话开发概述 下一篇 视频播放 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。音频场景模式铃声模式通话场景音频设备切换音频通话开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  常用的音频通话模式包括VOIP通话和蜂窝通话。  VOIP通话：VOIP（Voice over Internet Protocol）通话是指基于互联网协议（IP）进行通讯的一种语音通话技术。VOIP通话会将通话信息打包成数据包，通过网络进行传输，因此VOIP通话对网络要求较高，通话质量与网络连接速度紧密相关。 蜂窝通话（仅对系统应用开放）蜂窝通话是指传统的电话功能，由运营商提供服务，目前仅对系统应用开放，未向三方应用提供开发接口。  在开发音频通话相关功能时，开发者可以根据实际情况，检查当前的音频场景模式和铃声模式，以使用相应的音频处理策略。  音频场景模式 应用使用音频通话相关功能时，系统会切换至与通话相关的音频场景模式（AudioScene），当前预置了多种音频场景，包括响铃、通话、语音聊天等，在不同的场景下，系统会采用不同的策略来处理音频。 当前预置的音频场景：  AUDIO_SCENE_DEFAULT：默认音频场景，音频通话之外的场景均可使用。 AUDIO_SCENE_VOICE_CHAT：语音聊天音频场景，VOIP通话时使用。  应用可通过AudioManager的getAudioScene来获取当前的音频场景模式。当应用开始或结束使用音频通话相关功能时，可通过此方法检查系统是否已切换为合适的音频场景模式。   铃声模式 在用户进入到音频通话时，应用可以使用铃声或振动来提示用户。系统通过调整铃声模式（AudioRingMode），实现便捷地管理铃声音量，并调整设备的振动模式。 当前预置的三种铃声模式：  RINGER_MODE_SILENT：静音模式，此模式下铃声音量为零（即静音）。 RINGER_MODE_VIBRATE：振动模式，此模式下铃声音量为零，设备振动开启（即响铃时静音，触发振动）。 RINGER_MODE_NORMAL：响铃模式，此模式下铃声音量正常。  应用可以调用AudioVolumeGroupManager中的getRingerMode获取当前的铃声模式，以便采取合适的提示策略。 如果应用希望及时获取铃声模式的变化情况，可以通过AudioVolumeGroupManager中的on('ringerModeChange')监听铃声模式变化事件，使应用在铃声模式发生变化时及时收到通知，方便应用做出相应的调整。   通话场景音频设备切换 在通话场景下，系统会根据默认优先级选择合适的音频设备。应用可以根据需要，自主切换音频设备。 通信设备类型（CommunicationDeviceType）是系统预置的可用于通话场景的设备，应用可以使用AudioRoutingManager的isCommunicationDeviceActive函数获取指定通信设备的激活状态，并且可以使用AudioRoutingManager的setCommunicationDevice设置通信设备的激活状态，通过激活设备来实现通话场景音频设备的切换。   上一篇 音频通话 下一篇 开发音频通话功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建AudioRoutingManager实例支持的音频输入设备类型获取输入设备信息监听设备连接状态变化音频输入设备管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  有时设备同时连接多个音频输入设备，需要指定音频输入设备进行音频录制，此时需要使用AudioRoutingManager接口进行输入设备的管理，API说明可以参考AudioRoutingManager API文档。  创建AudioRoutingManager实例 在使用AudioRoutingManager管理音频设备前，需要先导入模块并创建实例。 已复制import audio from '@ohos.multimedia.audio';  // 导入audio模块
let audioManager = audio.getAudioManager();  // 需要先创建AudioManager实例
let audioRoutingManager = audioManager.getRoutingManager();  // 再调用AudioManager的方法创建AudioRoutingManager实例   支持的音频输入设备类型 目前支持的音频输入设备见下表：     名称 值 说明    WIRED_HEADSET 3 有线耳机，带麦克风。   BLUETOOTH_SCO 7 蓝牙设备SCO（Synchronous Connection Oriented）连接。   MIC 15 麦克风。   USB_HEADSET 22 USB耳机，带麦克风。      获取输入设备信息 使用getDevices()方法可以获取当前所有输入设备的信息。 已复制audioRoutingManager.getDevices(audio.DeviceFlag.INPUT_DEVICES_FLAG).then((data) => {  console.info('Promise returned to indicate that the device list is obtained.');});   监听设备连接状态变化 可以设置监听事件来监听设备连接状态的变化，当有设备连接或断开时触发回调： 已复制// 监听音频设备状态变化audioRoutingManager.on('deviceChange', audio.DeviceFlag.INPUT_DEVICES_FLAG, (deviceChanged) => {  console.info('device change type : ' + deviceChanged.type);  // 设备连接状态变化，0为连接，1为断开连接  console.info('device descriptor size : ' + deviceChanged.deviceDescriptors.length);  console.info('device change descriptor : ' + deviceChanged.deviceDescriptors[0].deviceRole);  // 设备角色  console.info('device change descriptor : ' + deviceChanged.deviceDescriptors[0].deviceType);  // 设备类型});
// 取消监听音频设备状态变化audioRoutingManager.off('deviceChange', (deviceChanged) => {  console.info('Should be no callback.');});   上一篇 音频录制流管理 下一篇 音频通话 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。创建AudioRoutingManager实例支持的音频输出设备类型获取输出设备信息监听设备连接状态变化音频输出设备管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  有时设备同时连接多个音频输出设备，需要指定音频输出设备进行音频播放，此时需要使用AudioRoutingManager接口进行输出设备的管理，API说明可以参考AudioRoutingManager API文档。  创建AudioRoutingManager实例 在使用AudioRoutingManager管理音频设备前，需要先导入模块并创建实例。 已复制import audio from '@ohos.multimedia.audio';  // 导入audio模块
let audioManager = audio.getAudioManager();  // 需要先创建AudioManager实例
let audioRoutingManager = audioManager.getRoutingManager();  // 再调用AudioManager的方法创建AudioRoutingManager实例   支持的音频输出设备类型 目前支持的音频输出设备见下表：     名称 值 说明    EARPIECE 1 听筒。   SPEAKER 2 扬声器。   WIRED_HEADSET 3 有线耳机，带麦克风。   WIRED_HEADPHONES 4 有线耳机，无麦克风。   BLUETOOTH_SCO 7 蓝牙设备SCO（Synchronous Connection Oriented）连接。   BLUETOOTH_A2DP 8 蓝牙设备A2DP（Advanced Audio Distribution Profile）连接。   USB_HEADSET 22 USB耳机，带麦克风。      获取输出设备信息 使用getDevices()方法可以获取当前所有输出设备的信息。 已复制audioRoutingManager.getDevices(audio.DeviceFlag.OUTPUT_DEVICES_FLAG).then((data) => {  console.info('Promise returned to indicate that the device list is obtained.');});   监听设备连接状态变化 可以设置监听事件来监听设备连接状态的变化，当有设备连接或断开时触发回调： 已复制// 监听音频设备状态变化audioRoutingManager.on('deviceChange', audio.DeviceFlag.OUTPUT_DEVICES_FLAG, (deviceChanged) => {  console.info('device change type : ' + deviceChanged.type);  // 设备连接状态变化，0为连接，1为断开连接  console.info('device descriptor size : ' + deviceChanged.deviceDescriptors.length);  console.info('device change descriptor : ' + deviceChanged.deviceDescriptors[0].deviceRole);  // 设备角色  console.info('device change descriptor : ' + deviceChanged.deviceDescriptors[0].deviceType);  // 设备类型});
// 取消监听音频设备状态变化audioRoutingManager.off('deviceChange', (deviceChanged) => {  console.info('Should be no callback.');});   上一篇 音频播放流管理 下一篇 音频录制 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。音频播放 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    音频播放开发概述  使用AVPlayer开发音频播放功能  使用AudioRenderer开发音频播放功能  使用OpenSL ES开发音频播放功能  多音频播放的并发策略  播放音量管理  音频播放流管理  音频输出设备管理   上一篇 AVPlayer和AVRecorder 下一篇 音频播放开发概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。音频打断策略焦点模式打断类型监听音频打断事件多音频播放的并发策略 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   音频打断策略 多音频并发，即多个音频流同时播放。此场景下，如果系统不加管控，会造成多个音频流混音播放，容易让用户感到嘈杂，造成不好的用户体验。为了解决这个问题，系统预设了音频打断策略，对多音频播放的并发进行管控，只有持有音频焦点的音频流才可以正常播放，避免多个音频流无序并发播放的现象出现。 当应用开始播放音频时，系统首先为相应的音频流申请音频焦点，获得焦点的音频流可以播放；若焦点申请被拒绝，则不能播放。在音频流播放的过程中，若被其他音频流打断，则会失去音频焦点。当音频流失去音频焦点时，只能暂停播放。在应用播放音频的过程中，这些动作均由系统自行完成，无需应用主动触发。但为了维持应用和系统的状态一致性，保证良好的用户体验，推荐应用监听音频打断事件，并在收到音频打断事件（InterruptEvent）时做出相应处理。 为满足应用对多音频并发策略的不同需求，音频打断策略预设了两种焦点模式，针对同一应用创建的多个音频流，应用可通过设置焦点模式，选择由应用自主管控或由系统统一管控。 音频打断策略决定了应该对音频流采取何种操作，如暂停播放、继续播放、降低音量播放、恢复音量播放等，这些操作可能由系统或应用来执行。音频打断策略预置了两种打断类型，用于区分音频打断事件（InterruptEvent）的执行者。   焦点模式 音频打断策略预设了两种焦点模式（InterruptMode）：  共享焦点模式（SHARE_MODE）：由同一应用创建的多个音频流，共享一个音频焦点。这些音频流之间的并发规则由应用自主决定，音频打断策略不会介入。当其他应用创建的音频流与该应用的音频流并发播放时，才会触发音频打断策略的管控。 独立焦点模式（INDEPENDENT_MODE）：应用创建的每一个音频流均会独立拥有一个音频焦点，当多个音频流并发播放时，会触发音频打断策略的管控。  应用可以按需选择合适的焦点模式，在创建音频流时，系统默认采用共享焦点模式，应用可主动设置所需的模式。 设置焦点模式的方法：  若使用AVPlayer开发音频播放功能，则可以通过修改AVPlayer的audioInterruptMode属性进行设置。 若使用AudioRenderer开发音频播放功能，则可以调用AudioRenderer的setInterruptMode函数进行设置。    打断类型 音频打断策略（包括两种焦点模式）决定了应该对各个音频流采取何种操作，如暂停播放、继续播放、降低音量播放、恢复音量播放等。而针对这些操作的执行过程，根据执行者的不同，可以分为两种打断类型（InterruptForceType）：  强制打断类型（INTERRUPT_FORCE）：由系统进行操作，强制打断音频播放。 共享打断类型（INTERRUPT_SHARE）：由应用进行操作，可以选择打断或忽略。  对于音频打断策略的执行，系统默认采用强制打断类型（INTERRUPT_FORCE），应用无法更改。但对于一些策略（如继续播放等），系统无法强制执行，所以这两种打断类型均可能出现。应用可根据音频打断事件（InterruptEvent）的成员变量forceType的值，获取该事件采用的打断类型。 在应用播放音频的过程中，系统自动为音频流执行申请焦点、持有焦点、释放焦点等动作，当发生音频打断事件时，系统强制对音频流执行暂停、停止、降低音量、恢复音量等操作，并向应用发送音频打断事件（InterruptEvent）回调。由于系统会强制改变音频流状态，为了维持应用和系统的状态一致性，保证良好的用户体验，推荐应用监听音频打断事件，并在收到音频打断事件（InterruptEvent）时做出相应处理。 对于一些系统无法强制执行的操作（例如音频流继续播放的场景），会向应用发送包含了共享打断类型的音频打断事件，由应用自行执行相应操作，此时应用可以选择执行或忽略，系统不会干涉。   监听音频打断事件 在应用播放音频时，推荐应用监听音频打断事件，当音频打断事件发生时，系统会根据预设策略，对音频流做出相应的操作，并针对状态发生改变的音频流，向所属的应用发送音频打断事件。 应用收到音频打断事件后，需根据其内容提示，做出相应的处理，避免出现应用状态与预期效果不一致的问题。 监听音频打断事件的方法：  若使用AVPlayer开发音频播放功能，则可以调用AVPlayer的on('audioInterrupt')函数进行监听，当收到音频打断事件（InterruptEvent）时，应用需根据其内容，做出相应的调整。 若使用AudioRenderer开发音频播放功能，则可以调用AudioRenderer的on('audioInterrupt')函数进行监听，当收到音频打断事件（InterruptEvent）时，应用需根据其内容，做出相应的调整。        为了带给用户更好的体验，针对不同的音频打断事件内容，应用需要做出相应的处理操作。此处以使用AudioRenderer开发音频播放功能为例，展示推荐应用采取的处理方法，提供伪代码供开发者参考（若使用AVPlayer开发音频播放功能，处理方法类似），具体的代码实现，开发者可结合实际情况编写，处理方法也可自行调整。      已复制let isPlay; // 是否正在播放，实际开发中，对应与音频播放状态相关的模块let isDucked; //是否降低音量，实际开发中，对应与音频音量相关的模块let started; // 标识符，记录“开始播放（start）”操作是否成功
async function onAudioInterrupt(){  // 此处以使用AudioRenderer开发音频播放功能举例，变量audioRenderer即为播放时创建的AudioRenderer实例。  audioRenderer.on('audioInterrupt', async(interruptEvent) => {    // 在发生音频打断事件时，audioRenderer收到interruptEvent回调，此处根据其内容做相应处理    // 先读取interruptEvent.forceType的类型，判断系统是否已强制执行相应操作    // 再读取interruptEvent.hintType的类型，做出相应的处理    if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_FORCE) {      // 强制打断类型（INTERRUPT_FORCE）：音频相关处理已由系统执行，应用需更新自身状态，做相应调整       switch (interruptEvent.hintType) {        case audio.InterruptHint.INTERRUPT_HINT_PAUSE:          // 此分支表示系统已将音频流暂停（临时失去焦点），为保持状态一致，应用需切换至音频暂停状态          // 临时失去焦点：待其他音频流释放音频焦点后，本音频流会收到resume对应的音频打断事件，到时可自行继续播放          isPlay = false; // 此句为简化处理，代表应用切换至音频暂停状态的若干操作          break;        case audio.InterruptHint.INTERRUPT_HINT_STOP:          // 此分支表示系统已将音频流停止（永久失去焦点），为保持状态一致，应用需切换至音频暂停状态          // 永久失去焦点：后续不会再收到任何音频打断事件，若想恢复播放，需要用户主动触发。          isPlay = false; // 此句为简化处理，代表应用切换至音频暂停状态的若干操作          break;        case audio.InterruptHint.INTERRUPT_HINT_DUCK:          // 此分支表示系统已将音频音量降低（默认降到正常音量的20%），为保持状态一致，应用需切换至降低音量播放状态          // 若应用不接受降低音量播放，可在此处选择其他处理方式，如主动暂停等          isDucked = true; // 此句为简化处理，代表应用切换至降低音量播放状态的若干操作          break;        case audio.InterruptHint.INTERRUPT_HINT_UNDUCK:          // 此分支表示系统已将音频音量恢复正常，为保持状态一致，应用需切换至正常音量播放状态          isDucked = false; // 此句为简化处理，代表应用切换至正常音量播放状态的若干操作          break;        default:          break;      }    } else if (interruptEvent.forceType === audio.InterruptForceType.INTERRUPT_SHARE) {      // 共享打断类型（INTERRUPT_SHARE）：应用可自主选择执行相关操作或忽略音频打断事件      switch (interruptEvent.hintType) {        case audio.InterruptHint.INTERRUPT_HINT_RESUME:          // 此分支表示临时失去焦点后被暂停的音频流此时可以继续播放，建议应用继续播放，切换至音频播放状态          // 若应用此时不想继续播放，可以忽略此音频打断事件，不进行处理即可          // 继续播放，此处主动执行start()，以标识符变量started记录start()的执行结果          await audioRenderer.start().then(async function () {            started = true; // start()执行成功          }).catch((err) => {            started = false; // start()执行失败          });          // 若start()执行成功，则切换至音频播放状态          if (started) {            isPlay = true; // 此句为简化处理，代表应用切换至音频播放状态的若干操作          } else {            // 音频继续播放执行失败          }          break;        default:          break;      }   }  });}    上一篇 使用OpenSL ES开发音频播放功能 下一篇 播放音量管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。如何选择音频播放开发方式音频播放开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 如何选择音频播放开发方式在HarmonyOS系统中，多种API都提供了音频播放开发的支持，不同的API适用于不同音频数据格式、音频资源来源、音频使用场景，甚至是不同开发语言。因此，选择合适的音频播放API，有助于降低开发工作量，实现更佳的音频播放效果。 AVPlayer：功能较完善的音频、视频播放ArkTS/JS API，集成了流媒体和本地资源解析、媒体资源解封装、音频解码和音频输出功能。可以用于直接播放mp3、m4a等格式的音频文件，不支持直接播放PCM格式文件。AudioRenderer：用于音频输出的的ArkTS/JS API，仅支持PCM格式，需要应用持续写入音频数据进行工作。应用可以在输入前添加数据预处理，如设定音频文件的采样率、位宽等，要求开发者具备音频处理的基础知识，适用于更专业、更多样化的媒体播放应用开发。OpenSL ES：一套跨平台标准化的音频Native API，目前阶段唯一的音频类Native API，同样提供音频输出能力，仅支持PCM格式，适用于从其他嵌入式平台移植，或依赖在Native层实现音频输出功能的播放应用使用。在音频播放中，应用时常需要用到一些急促简短的音效，如相机快门音效、按键音效、游戏射击音效等，当前只能使用AVPlayer播放音频文件替代实现，在HarmonyOS后续版本将会推出相关接口来支持该场景。   上一篇 音频播放 下一篇 使用AVPlayer开发音频播放功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。读取或监听应用内音频流状态变化读取或监听所有音频流的变化开发步骤及注意事项音频播放流管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  对于播放音频类的应用，开发者需要关注该应用的音频流的状态以做出相应的操作，比如监听到状态为播放中/暂停时，及时改变播放按钮的UI显示。  读取或监听应用内音频流状态变化 参考使用AudioRenderer开发音频播放功能或audio.createAudioRenderer，完成AudioRenderer的创建，然后可以通过以下两种方式查看音频流状态的变化：  方法1：直接查看AudioRenderer的state：已复制let audioRendererState = audioRenderer.state;console.info(`Current state is: ${audioRendererState }`)   方法2：注册stateChange监听AudioRenderer的状态变化：已复制audioRenderer.on('stateChange', (rendererState) => {  console.info(`State change to: ${rendererState}`)});  获取state后可对照AudioState来进行相应的操作，比如更改暂停播放按钮的显示等。   读取或监听所有音频流的变化 如果部分应用需要查询获取所有音频流的变化信息，可以通过AudioStreamManager读取或监听所有音频流的变化。 如下为音频流管理调用关系图：  在进行应用开发的过程中，开发者需要使用getStreamManager()创建一个AudioStreamManager实例，进而通过该实例管理音频流。开发者可通过调用on('audioRendererChange')监听音频流的变化，在音频流状态变化、设备变化时获得通知。同时可通过off('audioRendererChange')取消相关事件的监听。另外，开发者可以主动调用getCurrentAudioRendererInfoArray()来查询播放流的唯一ID、播放流客户端的UID、音频流状态等信息。 详细API含义可参考音频管理API文档AudioStreamManager。   开发步骤及注意事项  创建AudioStreamManager实例。在使用AudioStreamManager的API前，需要使用getStreamManager()创建一个AudioStreamManager实例。 已复制import audio from '@ohos.multimedia.audio';let audioManager = audio.getAudioManager();let audioStreamManager = audioManager.getStreamManager(); 使用on('audioRendererChange')监听音频播放流的变化。 如果音频流监听应用需要在音频播放流状态变化、设备变化时获取通知，可以订阅该事件。已复制audioStreamManager.on('audioRendererChange',  (AudioRendererChangeInfoArray) => {  for (let i = 0; i < AudioRendererChangeInfoArray.length; i++) {    let AudioRendererChangeInfo = AudioRendererChangeInfoArray[i];    console.info(`## RendererChange on is called for ${i} ##`);    console.info(`StreamId for ${i} is: ${AudioRendererChangeInfo.streamId}`);    console.info(`Content ${i} is: ${AudioRendererChangeInfo.rendererInfo.content}`);    console.info(`Stream ${i} is: ${AudioRendererChangeInfo.rendererInfo.usage}`);    console.info(`Flag ${i} is: ${AudioRendererChangeInfo.rendererInfo.rendererFlags}`);     for (let j = 0;j < AudioRendererChangeInfo.deviceDescriptors.length; j++) {      console.info(`Id: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].id}`);      console.info(`Type: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceType}`);      console.info(`Role: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceRole}`);      console.info(`Name: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].name}`);      console.info(`Address: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].address}`);      console.info(`SampleRates: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].sampleRates[0]}`);      console.info(`ChannelCount ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelCounts[0]}`);      console.info(`ChannelMask: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelMasks}`);    }  }}); （可选）使用off('audioRendererChange')取消监听音频播放流变化。已复制audioStreamManager.off('audioRendererChange');console.info('RendererChange Off is called '); （可选）使用getCurrentAudioRendererInfoArray()获取所有音频播放流的信息。               该接口可获取音频播放流唯一ID，音频播放客户端的UID，音频状态以及音频播放器的其他信息。        
说明
 对所有音频流状态进行监听的应用需要申请权限ohos.permission.USE_BLUETOOTH，否则无法获得实际的设备名称和设备地址信息，查询到的设备名称和设备地址（蓝牙设备的相关属性）将为空字符串。 
 已复制async function getCurrentAudioRendererInfoArray(){  await audioStreamManager.getCurrentAudioRendererInfoArray().then( function (AudioRendererChangeInfoArray) {    console.info(`getCurrentAudioRendererInfoArray  Get Promise is called `);    if (AudioRendererChangeInfoArray != null) {s      for (let i = 0; i < AudioRendererChangeInfoArray.length; i++) {        let AudioRendererChangeInfo = AudioRendererChangeInfoArray[i];        console.info(`StreamId for ${i} is: ${AudioRendererChangeInfo.streamId}`);        console.info(`Content ${i} is: ${AudioRendererChangeInfo.rendererInfo.content}`);        console.info(`Stream ${i} is: ${AudioRendererChangeInfo.rendererInfo.usage}`);        console.info(`Flag ${i} is: ${AudioRendererChangeInfo.rendererInfo.rendererFlags}`);          for (let j = 0;j < AudioRendererChangeInfo.deviceDescriptors.length; j++) {          console.info(`Id: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].id}`);          console.info(`Type: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceType}`);          console.info(`Role: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].deviceRole}`);          console.info(`Name: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].name}`);          console.info(`Address: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].address}`);          console.info(`SampleRates: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].sampleRates[0]}`);          console.info(`ChannelCount ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelCounts[0]}`);          console.info(`ChannelMask: ${i} : ${AudioRendererChangeInfo.deviceDescriptors[j].channelMasks}`);        }      }    }  }).catch((err) => {    console.error(`Invoke getCurrentAudioRendererInfoArray failed, code is ${err.code}, message is ${err.message}`);  });}     上一篇 播放音量管理 下一篇 音频输出设备管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。音频录制 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    音频录制开发概述  使用AVRecorder开发音频录制功能  使用AudioCapturer开发音频录制功能  使用OpenSL ES开发音频录制功能  管理麦克风  音频录制流管理  音频输入设备管理   上一篇 音频输出设备管理 下一篇 音频录制开发概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。如何选择音频录制开发方式开发音频录制应用须知音频录制开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 如何选择音频录制开发方式在HarmonyOS系统中，多种API都提供了音频录制开发的支持，不同的API适用于不同录音输出格式、音频使用场景或不同开发语言。因此，选择合适的音频录制API，有助于降低开发工作量，实现更佳的音频录制效果。 AVRecorder：功能较完善的音频、视频录制ArkTS/JS API，集成了音频输入录制、音频编码和媒体封装的功能。开发者可以直接调用设备硬件如麦克风录音，并生成m4a音频文件。AudioCapturer：用于音频输入的的ArkTS/JS API，仅支持PCM格式，需要应用持续读取音频数据进行工作。应用可以在音频输出后添加数据处理，要求开发者具备音频处理的基础知识，适用于更专业、更多样化的媒体录制应用开发。OpenSL ES：一套跨平台标准化的音频Native API，目前阶段唯一的音频类Native API，同样提供音频输入原子能力，仅支持PCM格式，适用于从其他嵌入式平台移植，或依赖在Native层实现音频输入功能的录音应用使用。  开发音频录制应用须知应用可以调用麦克风录制音频，但该行为属于隐私敏感行为，在调用麦克风前，需要先向用户申请权限“ohos.permission.MICROPHONE”。 权限申请的流程请参考访问控制授权申请指导。如何使用和管理麦克风请参考管理麦克风。   上一篇 音频录制 下一篇 使用AVRecorder开发音频录制功能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。读取或监听应用内音频流状态变化读取或监听所有录制流的变化开发步骤及注意事项音频录制流管理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  对于录制音频类的应用，开发者需要关注该应用的音频流的状态以做出相应的操作，比如监听到状态为结束时，及时提示用户录制已结束。  读取或监听应用内音频流状态变化 参考使用AudioCapturer开发音频录制功能或audio.createAudioCapturer，完成AudioCapturer的创建，然后可以通过以下两种方式查看音频流状态的变化：  方法1：直接查看AudioCapturer的state：已复制let audioCapturerState = audioCapturer.state;console.info(`Current state is: ${audioCapturerState }`) 方法2：注册stateChange监听AudioCapturer的状态变化：已复制audioCapturer.on('stateChange', (capturerState) => {  console.info(`State change to: ${capturerState}`)});  获取state后可对照AudioState来进行相应的操作，比如显示录制结束的提示等。   读取或监听所有录制流的变化 如果部分应用需要查询获取所有音频流的变化信息，可以通过AudioStreamManager读取或监听所有音频流的变化。 如下为音频流管理调用关系图：  在进行应用开发的过程中，开发者需要使用getStreamManager()创建一个AudioStreamManager实例，进而通过该实例管理音频流。开发者可通过调用on('audioCapturerChange')监听音频流的变化，在音频流状态变化、设备变化时获得通知，同时可通过off('audioCapturerChange')取消相关事件的监听。另外，开发者可以通过主动调用getCurrentAudioCapturerInfoArray()查询录制流的唯一ID、录制流客户端的UID、以及流状态等信息。 详细API含义可参考音频管理API文档AudioStreamManager。   开发步骤及注意事项  创建AudioStreamManager实例。               在使用AudioStreamManager的API前，需要使用getStreamManager()创建一个AudioStreamManager实例。        已复制import audio from '@ohos.multimedia.audio';let audioManager = audio.getAudioManager();let audioStreamManager = audioManager.getStreamManager();  使用on('audioCapturerChange')监听音频录制流更改事件。 如果音频流监听应用需要在音频录制流状态变化、设备变化时获取通知，可以订阅该事件。已复制audioStreamManager.on('audioCapturerChange', (AudioCapturerChangeInfoArray) =>  {  for (let i = 0; i < AudioCapturerChangeInfoArray.length; i++) {    console.info(`## CapChange on is called for element ${i} ##`);    console.info(`StreamId for ${i} is: ${AudioCapturerChangeInfoArray[i].streamId}`);    console.info(`Source for ${i} is: ${AudioCapturerChangeInfoArray[i].capturerInfo.source}`);    console.info(`Flag  ${i} is: ${AudioCapturerChangeInfoArray[i].capturerInfo.capturerFlags}`);    let devDescriptor = AudioCapturerChangeInfoArray[i].deviceDescriptors;    for (let j = 0; j < AudioCapturerChangeInfoArray[i].deviceDescriptors.length; j++) {      console.info(`Id: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].id}`);      console.info(`Type: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].deviceType}`);      console.info(`Role: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].deviceRole}`);      console.info(`Name: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].name}`);      console.info(`Address: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].address}`);      console.info(`SampleRates: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].sampleRates[0]}`);      console.info(`ChannelCounts ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].channelCounts[0]}`);      console.info(`ChannelMask: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].channelMasks}`);    }  }}); （可选）使用off('audioCapturerChange')取消监听音频录制流变化。已复制audioStreamManager.off('audioCapturerChange');console.info('CapturerChange Off is called'); （可选）使用getCurrentAudioCapturerInfoArray()获取当前音频录制流的信息。               该接口可获取音频录制流唯一ID，音频录制客户端的UID，音频状态以及音频捕获器的其他信息。        
说明
 对所有音频流状态进行监听的应用需要申请权限ohos.permission.USE_BLUETOOTH，否则无法获得实际的设备名称和设备地址信息，查询到的设备名称和设备地址（蓝牙设备的相关属性）将为空字符串。 
  已复制async function getCurrentAudioCapturerInfoArray(){  await audioStreamManager.getCurrentAudioCapturerInfoArray().then( function (AudioCapturerChangeInfoArray) {    console.info('getCurrentAudioCapturerInfoArray **** Get Promise Called ****');    if (AudioCapturerChangeInfoArray != null) {      for (let i = 0; i < AudioCapturerChangeInfoArray.length; i++) {        console.info(`StreamId for ${i} is: ${AudioCapturerChangeInfoArray[i].streamId}`);        console.info(`Source for ${i} is: ${AudioCapturerChangeInfoArray[i].capturerInfo.source}`);        console.info(`Flag  ${i} is: ${AudioCapturerChangeInfoArray[i].capturerInfo.capturerFlags}`);        for (let j = 0; j < AudioCapturerChangeInfoArray[i].deviceDescriptors.length; j++) {          console.info(`Id: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].id}`);          console.info(`Type: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].deviceType}`);          console.info(`Role: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].deviceRole}`);          console.info(`Name: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].name}`);          console.info(`Address: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].address}`);          console.info(`SampleRates: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].sampleRates[0]}`);          console.info(`ChannelCounts ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].channelCounts[0]}`);          console.info(`ChannelMask: ${i} : ${AudioCapturerChangeInfoArray[i].deviceDescriptors[j].channelMasks}`);        }      }    }  }).catch((err) => {    console.error(`Invoke getCurrentAudioCapturerInfoArray failed, code is ${err.code}, message is ${err.message}`);  });}    上一篇 管理麦克风 下一篇 音频输入设备管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。音视频 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    音视频概述  AVPlayer和AVRecorder  音频播放  音频录制  音频通话  视频播放   上一篇 媒体应用开发概述 下一篇 音视频概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发说明音频流介绍音频流使用场景信息支持的音频格式音视频概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  在音视频开发指导中，将介绍各种涉及音频、视频播放或录制功能场景的开发方式，指导开发者如何使用系统提供的音视频API实现对应功能。比如使用TonePlayer实现简单的提示音，当设备接收到新消息时，会发出短促的“滴滴”声；使用AVPlayer实现音乐播放器，循环播放一首音乐。 在每个功能中，会介绍多种实现方式以应对不同的使用场景，以及该场景相关的子功能点。比如在音频播放功能内，会同时介绍音频的并发策略、音量管理和输出设备等在操作系统中的处理方式，帮助开发者能够开发出功能覆盖更全面的应用。 本开发指导仅针对音视频播放或录制本身，由@ohos.multimedia.audio（下文简称audio模块）和@ohos.multimedia.media（下文简称media模块）提供相关能力，不涉及UI界面、图形处理、媒体存储或其他相关领域功能。  开发说明 在开发音频功能之前，尤其是要实现处理音频数据的功能前，建议开发者先了解声学相关的知识，帮助理解操作系统提供的API是如何控制音频系统，从而开发出更易用、体验更好的音视频类应用。建议了解的相关概念包括但不限于：  音频量化的过程：采样 > 量化 > 编码 音频量化过程的相关概念：模拟信号和数字信号、采样率、声道、采样格式、位宽、码率、常见编码格式（如AAC、MP3、PCM、WMA等）、常见封装格式（如WAV、MPA、FLAC、AAC、OGG等）  在开发音乐、视频播放功能之前，建议了解流媒体播放的相关概念包括但不限于：  播放过程：网络协议 > 容器格式 > 音视频编解码 > 图形/音频渲染 网络协议：比如HLS、HTTP/HTTPS；容器格式：比如mp4，mkv，mpeg-ts，webm。 编码格式：比如h263/h264/h265，MPEG4/MPEG2。    音频流介绍 在开发音频应用之前，还需要了解什么是音频流，它是HarmonyOS音频系统中的关键概念，在之后的章节中会多次提及。 音频流，是音频系统中对一个具备音频格式和音频使用场景信息的独立音频数据处理单元的定义，可以表示播放，也可以表示录制，并且具备独立音量调节和音频设备路由切换能力。 音频流基础信息通过AudioStreamInfo表示，包含采样、声道、位宽、编码信息，是创建音频播放或录制流的必要参数，描述了音频数据的基本属性。在配置时开发者需要保证基础信息与传输的音频数据是相匹配的，音频系统才能正确处理数据。   音频流使用场景信息 除了基本属性，音频流还需要具备使用场景信息。基础信息只能对音频数据进行描述，但在实际的使用过程中，不同的音频流，在音量大小，设备路由，并发策略上是有区别的。系统就是通过音频流所附带的使用场景信息，为不同的音频流制定合适的处理策略，以达到最佳的音频用户体验。  播放场景音频播放场景的信息，通过StreamUsage和ContentType进行描述。 StreamUsage指音频流本身的用途类型，包括媒体、语音通信、语音播报、通知、铃声等。 ContentType指音频流中数据的内容类型，包括语音、音乐、影视、通知、铃声等。 录制场景音频流录制场景的信息，通过SourceType进行描述。 SourceType指音频流中录音源的类型，包括麦克风音频源、语音识别音频源、语音通话音频源等。    支持的音频格式 audio模块下的接口支持PCM编码，包括AudioRenderer、AudioCapturer、TonePlayer、OpenSL ES等。 音频格式说明：  支持的常用的音频采样率（Hz）：8000、11025、12000、16000、22050、24000、32000、44100、48000、64000、96000，具体参考枚举AudioSamplingRate。不同设备支持的采样率规格会存在差异。 支持单声道、双声道，具体参考AudioChannel。 支持的采样格式：U8（无符号8位整数）、S16LE（带符号的16位整数，小尾数）、S24LE（带符号的24位整数，小尾数）、S32LE（带符号的32位整数，小尾数）、F32LE（带符号的32位浮点数，小尾数），具体参考AudioSampleFormat。由于系统限制，S24LE、S32LE、F32LE仅部分设备支持，请根据实际情况使用。 小尾数指的是小端模式，即数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。这种存储模式将地址的高低和数据的位权有效结合起来，高地址部分权值高，低地址部分权值低。  media模块下的接口支持的音视频格式将在AVPlayer和AVRecorder的介绍中承载。   上一篇 音视频 下一篇 AVPlayer和AVRecorder 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。AVPlayer音频播放视频播放支持的格式与协议AVRecorder支持的格式AVPlayer和AVRecorder 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  media模块提供了AVPlayer和AVRecorder用于播放、录制音视频。  AVPlayer AVPlayer主要工作是将Audio/Video媒体资源（比如mp4/mp3/mkv/mpeg-ts等）转码为可供渲染的图像和可听见的音频模拟信号，并通过输出设备进行播放。 AVPlayer提供功能完善一体化播放能力，应用只需要提供流媒体来源，不负责数据解析和解码就可达成播放效果。   音频播放 当使用AVPlayer开发音乐应用播放音频时，其交互关系如图所示。  图1 音频播放外部模块交互图   音乐类应用通过调用JS接口层提供的AVPlayer接口实现相应功能时，框架层会通过播放服务（Player Framework）将资源解析成音频数据流（PCM），音频数据流经过软件解码后输出至音频服务（Audio Framework），由音频服务输出至音频驱动渲染，实现音频播放功能。完整的音频播放需要应用、Player Framework、Audio Framework、音频HDI共同实现。 图1中，数字标注表示需要数据与外部模块的传递。  音乐应用将媒体资源传递给AVPlayer接口。 Player Framework将音频PCM数据流输出给Audio Framework，再由Audio Framework输出给音频HDI。    视频播放 当使用AVPlayer开发视频应用播放视频时，其交互关系如图所示。  图2 视频播放外部模块交互图   应用通过调用JS接口层提供的AVPlayer接口实现相应功能时，框架层会通过播放服务（Player Framework）解析成单独的音频数据流和视频数据流，音频数据流经过软件解码后输出至音频服务（Audio Framework），再至硬件接口层的音频HDI，实现音频播放功能。视频数据流经过硬件（推荐）/软件解码后输出至图形渲染服务（Graphic Framework），再输出至硬件接口层的显示HDI，完成图形渲染。 完整的视频播放需要：应用、XComponent、Player Framework、Graphic Framework、Audio Framework、显示HDI和音频HDI共同实现。 图2中，数字标注表示需要数据与外部模块的传递。  应用从XComponent组件获取窗口SurfaceID，获取方式参考XComponent。 应用把媒体资源、SurfaceID传递给AVPlayer接口。 Player Framework把视频ES数据流输出给解码HDI，解码获得视频帧（NV12/NV21/RGBA）。 Player Framework把音频PCM数据流输出给Audio Framework，Audio Framework输出给音频HDI。 Player Framework把视频帧（NV12/NV21/RGBA）输出给Graphic Framework，Graphic Framework输出给显示HDI。    支持的格式与协议 推荐使用以下主流的播放格式，音视频容器、音视频编码属于内容创作者所掌握的专业领域，不建议应用开发者自制码流进行测试，以免产生无法播放、卡顿、花屏等兼容性问题。若发生此类问题不会影响系统，退出播放即可。 支持的协议如下：     协议类型 协议描述    本地点播 协议格式：支持file descriptor，禁止file path   网络点播 协议格式：支持http/https/hls    支持的音频播放格式如下：     音频容器规格 规格描述    m4a 音频格式：AAC   aac 音频格式：AAC   mp3 音频格式：MP3   ogg 音频格式：VORBIS   wav 音频格式：PCM    
说明
 视频播放支持的视频格式分为必选规格和可选规格。必选规格为所有设备均支持的视频格式。对于可选规格，不同设备的实际实现不同。建议开发者做对应的兼容处理，保证应用功能全平台兼容。 
     视频格式 是否必选规格    H264 是   MPEG2 否   MPEG4 否   H263 否   VP8 否    支持的视频播放格式和主流分辨率如下：     视频容器规格 规格描述 分辨率    mp4 视频格式：H264/MPEG2/MPEG4/H263 音频格式：AAC/MP3 主流分辨率，如4K/1080P/720P/480P/270P   mkv 视频格式：H264/MPEG2/MPEG4/H263 音频格式：AAC/MP3 主流分辨率，如4K/1080P/720P/480P/270P   ts 视频格式：H264/MPEG2/MPEG4 音频格式：AAC/MP3 主流分辨率，如4K/1080P/720P/480P/270P   webm 视频格式：VP8 音频格式：VORBIS 主流分辨率，如4K/1080P/720P/480P/270P      AVRecorder AVRecorder主要工作是捕获音频信号，接收视频信号，完成音视频编码并保存到文件中，帮助开发者轻松实现音视频录制功能，包括开始录制、暂停录制、恢复录制、停止录制、释放资源等功能控制。它允许调用者指定录制的编码格式、封装格式、文件路径等参数。   图3 视频录制外部模块交互图    音频录制：应用通过调用JS接口层提供的AVRecorder接口实现音频录制时，框架层会通过录制服务（Player Framework），调用音频服务（Audio Framework）通过音频HDI捕获音频数据，通过软件编码封装后保存至文件中，实现音频录制功能。 视频录制：应用通过调用JS接口层提供的AVRecorder接口实现视频录制时，先通过Camera接口调用相机服务（Camera Framework）通过视频HDI捕获图像数据送至框架层的录制服务，录制服务将图像数据通过视频编码HDI编码，再将编码后的图像数据封装至文件中，实现视频录制功能。      
说明
 AVRecorder只负责视频数据的处理，需要与视频数据采集模块配合才能完成视频录制。视频数据采集模块需要通过Surface将视频数据传递给AVRecorder进行数据处理。 当前常用的数据采集模块为相机模块，相关说明以相机举例，相机模块目前仅对系统应用开放。 
  通过音视频录制组合，可分别实现纯音频录制、纯视频录制，音视频录制。 图3中，数字标注表示需要数据与外部模块的传递。  应用通过AVRecorder接口从录制服务获取SurfaceID。 应用将SurfaceID设置给相机服务，相机服务可以通过SurfaceID获取到Surface。相机服务通过视频HDI捕获图像数据送至框架层的录制服务。 相机服务通过Surface将视频数据传递给录制服务。 录制服务通过视频编码HDI模块将视频数据编码。 录制服务将音频参数设置给音频服务，并从音频服务获取到音频数据。   支持的格式 支持的音频源如下：     音频源类型 说明    mic 系统麦克风作为音频源输入。    支持的视频源如下：     视频源类型 说明    surface_yuv 输入surface中携带的是raw data。   surface_es 输入surface中携带的是ES data。    支持的音视频编码格式如下：     音视频编码格式 说明    audio/mp4a-latm 音频/mp4a-latm类型   video/mp4v-es 视频/mpeg4类型   video/avc 视频/avc类型    支持的输出文件格式如下：     输出文件格式 说明    mp4 视频的容器格式，MP4。   m4a 音频的容器格式，M4A。      上一篇 音视频概述 下一篇 音频播放 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。功能介绍后台任务类型后台任务总体概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 功能介绍设备返回主界面、锁屏、应用切换等操作会使应用退至后台。应用退至后台后，如果继续活动，可能会造成设备耗电快、用户界面卡顿等现象。为了降低设备耗电速度、保障用户使用流畅度，系统会对退至后台的应用进行管控，包括进程挂起（即系统不再为应用进程分配CPU资源，同时对应的公共事件等不再发给应用进程）和进程终止。 应用退至后台一小段时间（由系统定义），应用进程会被挂起。应用退至后台，在后台被访问一小段时间（由系统定义）后，应用进程会被挂起。资源不足时，系统会终止部分应用进程（即回收该进程的所有资源）。 同时，为了保障后台音乐播放、日历提醒等功能的正常使用，系统提供了规范内受约束的后台任务，扩展应用在后台运行时间。  后台任务类型OpenHarmony标准系统支持规范内受约束的后台任务，包括短时任务、长时任务、延迟任务、代理提醒和能效资源。 开发者可以根据如下功能介绍，选择合适的后台任务以满足应用退至后台后继续运行的需求。 短时任务：适用于实时性要求高、耗时不长的任务，例如状态保存。长时任务：适用于长时间运行在后台、用户可感知的任务，例如后台播放音乐、导航、设备连接等，使用长时任务避免应用进程被挂起。延迟任务：对于实时性要求不高、可延迟执行的任务，系统提供了延迟任务，即满足条件的应用退至后台后被放入执行队列，系统会根据内存、功耗等统一调度。代理提醒：代理提醒是指应用退后台或进程终止后，系统会代理应用做相应的提醒。适用于定时提醒类业务，当前支持的提醒类型包括倒计时、日历和闹钟三类。  图1 后台任务类型选择 
说明
系统仅支持规范内的后台任务。应用退至后台后，若未使用规范内的后台任务或选择的后台任务类型不正确，对应的应用进程会被挂起或终止。应用申请了规范内的后台任务，仅会提升应用进程被回收的优先级。当系统资源严重不足时，即使应用进程申请了规范内的后台任务，系统仍会终止部分进程，用以保障系统稳定性。 
  上一篇 后台任务（Background Task）管理 下一篇 短时任务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。build-profile.json5（API Version 8~9）工程级build-profile.json5模块级build-profile.json5oh-package.json5（API Version 9）工程级oh-package.json5模块级oh-package.json5package.json（API Version 8）工程级package.json模块级package.jsonbuild.gradle（API Version 4至7）工程级build.gradle模块级build.gradle配置编译构建信息 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在进行应用/服务的编译构建前，需要对工程和编译构建的Module进行设置。API Version 9、API Version 8与API Version 4~7的构建体系不同，因此在设置编译构建信息时也存在差异： API Version 9：需要对构建配置文件、构建脚本、应用依赖的共享包等信息进行设置。build-profile.json5：应用/服务构建配置文件。hvigorfile.ts：自定义编译构建脚本。oh-package.json5：应用的三方包依赖，支持共享包的依赖。  API Version 8：需要对构建配置文件、构建脚本、应用依赖的npm包等信息进行设置。build-profile.json5：HarmonyOS应用/服务构建配置文件。hvigorfile.ts：自定义编译构建脚本。package.json：应用的三方包依赖，支持HAR（遵循npm标准规范）和npm包的依赖。  API Version 4~7：需要通过build.gradle来对工程编译构建参数进行设置。 build-profile.json5（API Version 8~9） 工程级build-profile.json5工程级build-profile.json5的示例如下所示： 已复制{  "app": {     //工程的签名信息，可包含多个签名信息    "signingConfigs": [        {        "name": "default",  //标识签名方案的名称        "type": "HarmonyOS",  //标识HarmonyOS应用        //该方案的签名材料        "material": {            "certpath": "D:\\SigningConfig\\debug_hos.cer",  //调试或发布证书文件，格式为.cer          "storePassword": "******",  //密钥库密码，以密文形式呈现          "keyAlias": "debugKey",  //密钥别名信息          "keyPassword": "******",  //密钥密码，以密文形式呈现          "profile": "D:\\SigningConfig\\debug_hos.p7b",  //调试或发布证书Profile文件，格式为.p7b          "signAlg": "SHA256withECDSA",  //密钥库signAlg参数          "storeFile": "D:\\SigningConfig\\debug_hos.p12"  //密钥库文件，格式为.p12        }      }    ],    "compileSdkVersion": 9,  //指定HarmonyOS应用/服务编译时的SDK版本    "compatibleSdkVersion": 9,  //指定HarmonyOS应用/服务兼容的最低SDK版本    //定义构建的产品品类，如通用默认版、付费版、免费版等    "products": [        {        "name": "default",  //定义产品的名称，支持定制多product目标产物，具体请参考定制多目标构建产物        "signingConfig": "default",  //指定当前产品品类对应的签名信息，签名信息需要在signingConfigs中进行定义      }    ]  },  "modules": [    {      "name": "entry",  //模块名称      "srcPath": "./entry",  //标明模块根目录相对工程根目录的相对路径      "targets": [  //定义构建的APP产物，由product和各模块定义的targets共同定义        {          "name": "default",  //target名称，由各个模块的build-profile.json5中的targets字段定义          "applyToProducts": [              "default"   //表示将该模块下的“default” Target打包到“default” Product中          ]        }      ]    }  ]}  模块级build-profile.json5模块级build-profile.json5的示例如下所示： 已复制{  "apiType": 'faMode',  //API类型，支持FA和Stage模型  "showInServiceCenter": true,  //是否在服务中心展示  "buildOption": {    //配置筛选har依赖.so资源文件的过滤规则    "napiLibFilterOption": {      //按照.so文件的优先级顺序，打包最高优先级的.so文件      "pickFirsts": [        "**/1.so"      ],      //按照.so文件的优先级顺序，打包最低优先级的.so 文件      "pickLasts": [        "**/2.so"      ],      //排除的.so文件      "excludes": [        "**/3.so"      ],      //允许当.so重名冲突时，使用高优先级的.so文件覆盖低优先级的.so文件      "enableOverride": true    },    //cpp相关编译配置    "externalNativeOptions": {      "path": "./src/main/cpp/CMakeLists.txt",  //CMake配置文件，提供CMake构建脚本      "arguments": "",  //传递给CMake的可选编译参数      "abiFilters": [  //用于设置本机的ABI编译环境        "armeabi-v7a",        "arm64-v8a"      ],      "cppFlags": ""  //设置C++编译器的可选参数    },  },  "targets": [  //定义的Target，开发者可以定制不同的Target，具体请参考定制多目标构建产物    {      "name": "default",      "runtimeOS": "HarmonyOS",    },    {      "name": "ohosTest",    }      ]}  oh-package.json5（API Version 9）应用/服务支持通过ohpm来安装、共享、分发代码，管理项目的依赖关系。oh-package.json5格式遵循标准的ohpm规范。  工程级oh-package.json5工程级oh-package.json5的示例如下所示： 已复制{  "name": "myapplication",  "version": "1.0.0",  "description": "Please describe the basic information.",  "main": "",  "author": "",  "license": "",  "dependencies": {},  "devDependencies": {    "@ohos/hypium": "1.0.6"  }}   模块级oh-package.json5模块级oh-package.json5的示例如下所示：已复制{  "name": "entry",  "version": "1.0.0",  "description": "Please describe the basic information.",  "main": "index.ets",  "author": "",  "license": "",  "dependencies": {},}    package.json（API Version 8）应用/服务支持通过npm来安装、共享、分发代码，管理项目的依赖关系。HarmonyOS npm规范是在标准npm规范的基础上，增加了对HarmonyOS平台的拓展。因此，package.json格式遵循标准的npm规范（具体可查阅npm官方文档），接下来主要介绍HarmonyOS npm部分的规范。  工程级package.json工程级package.json的示例如下所示： 已复制{  "name": "myapplication",  "version": "1.0.0",  "ohos": {    "org": "huawei",    "buildTool": "hvigor",    "directoryLevel": "project"  },  "description": "example description",  "repository": {},  "license": "ISC",  "dependencies": {    "@ohos/hypium": "1.0.5",    "@ohos/hvigor": "1.4.0",    "@ohos/hvigor-ohos-plugin": "1.4.0"  }} HarmonyOS npm相关字段说明如下，其余字段遵循package.json标准规范。 ohos闭包：HarmonyOS应用/服务的扩展字段，表示在npm标准规范的基础上叠加了HarmonyOS npm的内容。org：标识HarmonyOS npm包的维护主体。buildTool：标识HarmonyOS npm包的构建工具是hvigor。directoryLevel：标识HarmonyOS npm包是工程的依赖。 dependencies闭包：设置工程依赖的npm包及版本，在遵循npm原生的基础上，可以添加@ohos相关的依赖，如构建插件，HarmonyOS npm三方共享包等。  模块级package.json模块级package.json的示例如下所示：已复制{    "license": "ISC",    "devDependencies": {        "@types/libentry.so": "file:./src/main/cpp/types/libentry"    },    "name": "entry",    "ohos": {        "org": "huawei",        "directoryLevel": "module",        "buildTool": "hvigor"    },    "description": "example description",    "repository": {},    "version": "1.0.0",    "dependencies": {}}  关于HarmonyOS npm包的相关字段说明如下，其余字段遵循package.json标准规范。 ohos闭包：HarmonyOS应用/服务的扩展字段，表示在npm标准规范的基础上叠加了HarmonyOS npm的内容。org：标识HarmonyOS npm包的维护主体。directoryLevel：标识HarmonyOS npm包是模块级的依赖。buildTool：标识HarmonyOS npm包的构建工具是hvigor。 dependencies闭包：设置模块依赖的npm包及版本，在遵循npm原生的基础上，可以添加@ohos相关的依赖，如HarmonyOS npm三方共享包等。  build.gradle（API Version 4至7） 工程级build.gradle工程级build.gradle的示例如下所示：已复制apply plugin: 'com.huawei.ohos.app'ohos {    compileSdkVersion 7    signingConfigs {        debug {            storeFile file('D:\\Sdk\\storeFile')    //本地keystore            storePassword 'storePassword'           //生成本地keystore时的storePassword参数            keyAlias 'keyAlias'                     //生成本地keystore时的alias参数            keyPassword 'keyPassword'               //keyPassword参数,pkcs12格式的keystore采用生成本地keystore时的keyPassword参数            signAlg 'SHA256withECDSA'               //生成本地keystore时的signAlg参数            profile file('D:\\Sdk\\profile')        //导入调试/发布profile            certpath file('D:\\Sdk\\certpath')      //导入调试/发布证书        }    }}    buildscript {    repositories {        maven {            url 'https://repo.huaweicloud.com/repository/maven/'           }        maven {            url 'https://developer.huawei.com/repo/'          }    }    dependencies {        classpath 'com.huawei.ohos:hap:3.1.2.0'        classpath 'com.huawei.ohos:decctest:1.2.7.19'    }}
allprojects {    repositories {        maven {            url 'https://repo.huaweicloud.com/repository/maven/'                        //allowInsecureProtocol = true    //若maven仓是http协议地址，则需要添加该字段，表示允许使用非安全协议的http仓        }        maven {            url 'https://developer.huawei.com/repo/'        }    }}
  关于工程级build.gradle各字段说明如下： apply plugin：在工程级Gradle中引入打包app的插件，不需要修改。ohos闭包：工程配置，包括如下配置项：compileSdkVersion：应用/服务编译构建的目标SDK版本。signingConfigs：应用/服务的签名信息，包括调试签名信息或发布签名信息。 buildscript闭包：工程编译构建所需要的依赖，包括Maven仓地址和依赖的插件版本，例如HarmonyOS编译构建插件和DECC测试插件。allprojects闭包：工程自身所需要的依赖，比如引用第三方库的Maven仓库和依赖包。  模块级build.gradle模块级build.gradle的示例如下所示： 已复制apply plugin: 'com.huawei.ohos.hap'    //打包hap插件：将entry/feature模块打包为hap的插件//apply plugin: 'com.huawei.ohos.library'    //打包har插件：将HarmonyOS Library模块打包为har的插件//apply plugin: 'java-library'    //打包jar插件：将Java Library模块打包为jar的插件apply plugin: 'com.huawei.ohos.decctest'    //decctest测试框架插件ohos {    compileSdkVersion 7    defaultConfig {        compatibleSdkVersion 4    }    showInServiceCenter true    buildTypes {        release {            proguardOpt {                              proguardEnabled true    //开启代码混淆功能                              rulesFiles 'proguard-rules.pro'    // 配置混淆规则文件相对路径                              consumerRulesFiles 'consumer-rules.pro'    // 配置打包混淆规则文件相对路径，仅在HarmonyOS Library模块中配置            }        }    }    packageOptions {        exclude "**/*.proto"    }        //entryModules "entry"    // 该Feature模块关联的Entry模块    // C++工程编译构建代码设置    externalNativeBuild {        path "src/main/cpp/CMakeLists.txt"   //CMake配置入口，提供CMake构建脚本的相对路径        arguments ""   // 传递给CMake的可选编译参数        abiFilters "arm64-v8a"  // 用于设置本机的ABI编译环境        cppFlags ""   // 设置C++编译器的可选参数    }    mergeJsSrc true    compileOptions {        annotationEnabled true    }}dependencies {        //entryImplementation project(':entry')    //依赖的entry模块名称    implementation fileTree(dir: 'libs', include: ['*.jar', '*.har'])    testImplementation 'junit:junit:4.13.1'    ohosTestImplementation 'com.huawei.ohos.testkit:runner:2.0.0.200'}decc {    supportType = ['html', 'xml']}
 关于模块级build.gradle各字段说明如下： apply plugin：在模块级build.gradle中引入打包hap、har、Jar以及decctest的插件。ohos闭包：模块配置，包括如下配置项：compileSdkVersion：指定HarmonyOS应用/服务编译时的SDK版本。compatibleSdkVersion：指定HarmonyOS应用/服务兼容的最低SDK版本。showInServiceCenter：是否在服务中心展示，在创建工程时选择了“Show in service center”选项会生成该字段。buildTypes：配置build类型以及每种类型构建打包的签名、压缩、混淆的配置。externalNativeBuild：C/C++编译构建代码设置项。entryModules：该Feature模块关联的Entry模块，仅Feature模块存在该字段。packageOptions：将entry/feature模块打包为hap时，排除不需要打包到HAP中的文件。mergeJsSrc：跨设备的应用/服务编译构建，是否需要合并JS代码。Wearable和Lite Wearable共用一个工程，如下图所示：当进行编译构建时，将wearable/liteWearable目录下的JS文件与pages目录（Wearable和Lite Wearable共用的源码）下的JS文件进行合并打包。 annotationEnabled：支持数据库注释。 dependencies闭包：该模块所需的依赖项。   上一篇 编译构建概述 下一篇 默认开启模块化编译模式 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用约束操作步骤构建闭源HAR 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持闭源HAR构建，通过对代码进行编译混淆，生成闭源HAR。在不共享源码的情况下，通过闭源HAR对外提供组件、资源等，可以实现多个模块或者多个工程共享组件、资源等。 使用约束闭源HAR仅支持API 9的Stage工程。HAR包不支持在module.json5中配置ability、extension组件。HAR包不支持pages路由配置。HAR包自身的构建打包不支持本地的依赖项（本地的har包）。  操作步骤新建工程时选择API 9的Stage模型，工程创建完成后，新建“Static Library”模块。编写代码。已复制  library  // HAR根目录  ├─libs  // 存放用户自定义引用的Native库，一般为.so文件  └─src  │   └─main  │     ├─cpp  │     │  ├─types  // 定义Native API对外暴露的接口    │     │  │  └─liblibrary    │     │  │      ├─index.d.ts  │     │  │      └─oh-package.json5   │     │  ├─CMakeLists.txt  // CMake配置文件    │     │  └─hello.cpp  // C++源码文件  │     └─ets  // ArkTS源码目录  │     │  └─components  │     │     └─mainpage  │     │         └─MainPage.ets  │     ├─resources  // 资源目录，用于存放资源文件，如图片、多媒体、字符串等    │     └─module.json5  // 模块配置文件，包含当前HAR的配置信息    ├─build-profile.json5  // Hvigor编译构建所需的配置文件，包含编译选项  ├─hvigorfile.ts  // Hvigor构建脚本文件，包含构建当前模块的插件、自定义任务等  ├─index.ets  // HAR的入口文件，一般作为出口定义HAR对外提供的函数、组件等     └─oh-package.json5  // HAR的描述文件，定义HAR的基本信息、依赖项等 在oh-package.json5中“main”字段定义导出文件入口。若不设置“main”字段，默认以当前目录下index.ets为入口文件，依据.ets>.ts>.js的顺序依次检索。以将ets/components/mainpage/MainPage.ets文件设置为入口文件为例：已复制{  ...  "main": "./src/main/ets/components/mainpage/MainPage.ets",  ...} 在当前HAR模块的build-profile.json5中，将artifactType字段值设置为obfuscation。已复制{  "apiType": 'stageMode',  "buildOption": {    "artifactType": "obfuscation", // 定义产物类型，obfuscation表示为使用混淆模式    ...  },  ...} 若部分工程源文件无需构建到HAR包中，可在module目录下新建.ohpmignore文件，用于配置打包时要忽略的文件，支持正则表达式写法。将无需打包进HAR包的文件/文件夹名称写入.ohpmignore文件中。DevEco Studio构建时将过滤掉.ohpmignore文件中所包含的文件目录。 选中HAR模块的根目录，点击Build > Make Module '<module-name>'启动构建。 构建完成后，build目录下生成闭源HAR包产物。    如需将闭源包转换为开源包，请将模块级build-profile.json5中“artifactType”字段值改为“original”或直接删除（缺省为original），再次触发编译。 已复制{  "apiType": 'stageMode',  "buildOption": {    "artifactType": "original", // original表示不使用混淆模式    ...  },  ...}  上一篇 HAP唯一性校验逻辑 下一篇 定制多目标构建产物 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。构建体系工程目录及配置文件说明工程目录及配置文件（API Version 8）工程目录及配置文件（API Version 4~7）如何构建应用/服务启动应用/服务构建查看编译过程查看编译结果多工程构建编译构建概述 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 编译构建是将应用/服务的源代码、资源、第三方库等，通过编译工具转换为可直接在硬件设备上运行的二进制机器码，然后再将二进制机器码封装为HAP/APP软件包，并为HAP/APP包进行签名的过程。其中，HAP是可以直接运行在模拟器或真机设备中的软件包；APP则是用于应用/服务上架到华为应用市场。HAP和APP的关系说明请参考工程介绍。 HarmonyOS应用/服务支持API Version 4~9，但API Version 4~7与API Version 8~9在编译构建体系、工程目录及配置文件等存在差异，接下来将详细介绍两者之间的差异。 构建体系HarmonyOS应用/服务API Version 4~7和API Version 8~9的构建工具和构建插件不同。 API Version 4~7构建体系是由Gradle构建工具和构建插件组成；API Version 8~9构建体系是由Hvigor构建工具和构建插件组成。 Gradle构建工具作为业界流行的自动化构建开源工具，本章节不再赘述，接下来为大家介绍Hvigor构建体系。  Hvigor构建工具：一款全新基于TS实现的前端构建任务编排工具，结合npm包管理机制，主要提供任务管理机制，任务注册编排、工程模型管理、配置管理等关键能力，更符合ArkTS/JS开发者的开发习惯。 构建插件hvigor-ohos-plugin：是基于Hvigor构建工具开发的一个插件，利用Hvigor的任务编排机制实现应用/服务构建任务流的执行，完成HAP/APP的构建打包，应用于应用/服务的构建。 DevEco Studio会自动配置配套版本的编译工具和构建插件依赖，关于构建工具和构建插件的版本配套关系可参考DevEco Studio版本说明。如需修改构建工具和构建插件版本，API 9及以上版本和API 8版本工程的修改位置不同： API 9及以上版本需修改hvigor目录下的hvigor-config.json5文件，示例如下。已复制{  “hvigorVersion”: "2.2.1",  "dependencies": {        "@ohos/hvigor-ohos-plugin": "2.2.1"  }} API 8版本需要在工程级的package.json文件中配置相应的版本依赖，示例如下。已复制{  ...  "dependencies": {    "@ohos/hvigor": "1.4.0",    "@ohos/hvigor-ohos-plugin": "1.4.0"  }}  工程目录及配置文件说明工程目录及配置文件（API Version 9） HarmonyOS API Version 9基于Hvigor构建体系，DevEco Studio定义了其工程范式，下面是Hvigor构建体系的工程目录结构示意图：  关于Hvigor构建体系中的构建配置文件（build-profile.json5）、构建脚本（hvigorfile.ts）、依赖配置（oh-package.json5）的详细说明请参考配置编译构建信息章节。  工程目录及配置文件（API Version 8）HarmonyOS API Version 8基于Hvigor构建体系，DevEco Studio定义了其工程范式，下面是Hvigor构建体系的工程目录结构示意图：  关于Hvigor构建体系中的构建配置文件（build-profile.json5）、构建脚本（hvigorfile.ts）、依赖配置（package.json）的详细说明请参考配置编译构建信息章节。  工程目录及配置文件（API Version 4~7）HarmonyOS API Version 4~7基于Gradle构建体系，DevEco Studio定义了其工程范式，下面是Gradle构建体系的工程目录结构示意图：  关于build.gradle详细说明请参考配置编译构建信息章节。  如何构建应用/服务 启动应用/服务构建
说明
在完成应用/服务开发后，如果开发者需要将应用包上传到AGC平台的软件包管理或第三方管理平台草稿箱中，可选择通过Upload Project完成编译并上传，具体请参见通过DevEco Studio编译和上传软件包。 
 通过DevEco Studio构建应用/服务的方式有以下两种： 方式一：通过单击或按钮，DevEco Studio会启动应用/服务的编译，并将编译后的HAP部署到设备中。这种方式一般用于应用开发阶段进行应用的调试、功能验证等场景。方式二：通过DevEco Studio的Build菜单栏的编译选项进行构建，HAP的构建结果存放于各模块的“build”文件夹下，APP包的构建结果存放于工程的“build”文件夹下。这种方式可以分别编译HAP和APP包，其中HAP可用于安装到设备中进行功能验证，APP包则用于将应用/服务发布到应用市场。 关于Build菜单下的编译选项说明如下： 菜单项  说明    Build Hap(s)/APP(s) > Build Hap(s)  对整个工程进行构建，若工程中有多个Module，则编译后会生成多个HAP。构建的HAP为debug类型，携带调试信息文件，包括*.js，*.js.map等文件。   Build Hap(s)/APP(s) > Build APP(s)  对整个工程进行构建，将工程构建生成一个APP包，如果存在多个模块，APP包会包含多个HAP，HAP为Release类型，不包含调试信息文件。   Make Module  对工程中当前选择的模块进行构建，只会编译指定的模块名生成HAP、HAR和JAR包。   Rebuild Project  对工程中各个模块进行Clean操作后，重新进行构建，生成对应的HAP。   Clean Project  清除构建过程中的缓存文件，以及构建生成的HAP/APP/HAR/JAR包。   Generate Key and CSR  用于生成申请调试/发布证书所需要的密钥和证书请求文件。       查看编译过程启动编译后，您可以在底部工具栏窗口查看编译任务的详细信息，例如执行的编译流程、任务的执行时间等信息。如果在编译构建过程中出现错误，您可以根据编译任务的详细错误说明进行问题的定位。 API Version 8~9工程编译构建示意图如下：  API Version 4~7工程编译构建示意图如下：   另外，针对Native C++开发方式，DevEco Studio支持的编译工具链为CMake和NinJa，在启动编译后，可以在底部工具栏窗口的输出内容中查看到编译工具链的具体配置信息。 CMake的配置信息如下所示。  NinJa的配置信息如下所示。   查看编译结果编译构建成功后，您可以在工程目录中找到对应的编译产物（如APP/HAP）。 API Version 8~9编译构建结果：  API Version 4~7编译构建结果：   多工程构建为降低大型应用多个团队协作开发的复杂度，提供多工程开发模式，提高协作开发效率。多工程开发能力支持将大型应用拆分为多个模块，每个模块对应一个单独工程。在每个工程分别编译生成HAP后，需统一打包生成一个APP，用于上架应用市场。 分别在每个工程的build-profile.json5配置文件中，设置multiProjects字段值为true。已复制{  "app": {    ...    "multiProjects": true,  }} 准备好HAP打包工具app_packing_tool.jar（在${HOS_SDK_HOME}/openharmony/版本号/toolchains/lib下）。使用如下命令，将多个HAP进行打包。hap-list：多个HAP文件名称，如“1.hap”和“2.hap”，用逗号隔开；out-path：生成的APP名称，如“final.app” 已复制java -jar app_packing_tool.jar --mode multiApp --hap-list 1.hap,2.hap --out-path final.app    上一篇 编译构建 下一篇 配置编译构建信息 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤获取当前蜂窝网络信号信息 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 场景介绍应用通常需要获取用户所在蜂窝网络下信号信息，以便获取当前驻网质量。开发者可以通过本业务，获取到用户指定SIM卡当前所在网络下的信号信息。  接口说明radio模块提供了获取当前网络信号信息的方法。observer模块为开发者提供蜂窝网络状态订阅和取消订阅功能。具体接口说明如下表。 功能分类  接口名  描述  所需权限    信号强度信息  radio.getSignalInformation​​()  获取当前注册蜂窝网络信号强度信息  无   订阅蜂窝网络信号变化  observer.on('signalInfoChange')  订阅蜂窝网络信号变化  无   取消订阅蜂窝网络信号变化  observer.off('signalInfoChange')  取消订阅蜂窝网络信号变化  无      开发步骤import需要的模块。 调用getSignalInformation()方法，返回所有SignalInformation列表。 遍历SignalInformation数组，并分别根据不同的signalType得到不同制式的信号强度。 订阅蜂窝网络信号变化（可选）。 已复制import radio from '@ohos.telephony.radio'import observer from '@ohos.telephony.observer';
// 以获取卡1的信号强度为例let slotId = 0;radio.getSignalInformation(slotId, (err, data) => {    if (!err) {        console.log("get signal information success.");        // 遍历数组，输出不同网络制式下的信号强度        for (let j = 0; j < data.length; j++) {            console.log("type:" + data[j].signalType + ", level:" + data[j].signalLevel);        }    } else {        console.log("get signal information fail, err is:" + JSON.stringify(err));    }});// 订阅蜂窝网络信号变化（可选）observer.on("signalInfoChange", (data) => {    console.log("signal info change, data is:" + JSON.stringify(data));});    上一篇 跳转拨号界面 下一篇 数据管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用证书操作使用证书吊销列表操作使用证书链校验器操作使用被吊销证书操作证书开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
说明
 本开发指导基于API version 9，适用于JS语言开发 
  使用证书操作 场景说明 使用证书操作中，典型的场景有：  解析X509证书数据生成证书对象。 获取证书信息，比如：证书版本、证书序列号等。 获取证书对象的序列化数据。 获取证书公钥。 证书验签。 校验证书有效期。  接口及参数说明 详细接口说明可参考API参考。 以上场景涉及的常用接口如下表所示：     实例名 接口名 描述    cryptoCert createX509Cert(inStream : EncodingBlob, callback : AsyncCallback<X509Cert>) : void 使用callback方式解析X509证书数据生成证书对象   cryptoCert createX509Cert(inStream : EncodingBlob) : Promise<X509Cert> 使用promise方式解析X509证书数据生成证书对象   X509Cert verify(key : cryptoFramework.PubKey, callback : AsyncCallback<void>) : void 使用callback方式进行证书验签   X509Cert verify(key : cryptoFramework.PubKey) : Promise<void> 使用promise方式进行证书验签   X509Cert getEncoded(callback : AsyncCallback<EncodingBlob>) : void 使用callback方式获取证书序列化数据   X509Cert getEncoded() : Promise<EncodingBlob> 使用promise方式获取证书序列化数据   X509Cert getPublicKey() : cryptoFramework.PubKey 获取证书公钥   X509Cert checkValidityWithDate(date: string) : void 校验证书有效期   X509Cert getVersion() : number 获取证书版本   X509Cert getSerialNumber() : number 获取证书序列号   X509Cert getIssuerName() : DataBlob 获取证书颁发者名称   X509Cert getSubjectName() : DataBlob 获取证书主体名称   X509Cert getNotBeforeTime() : string 获取证书有效期起始时间   X509Cert getNotAfterTime() : string 获取证书有效期截至时间   X509Cert getSignature() : DataBlob 获取证书签名   X509Cert getSignatureAlgName() : string 获取证书签名算法名称   X509Cert getSignatureAlgOid() : string 获取证书签名算法OID   X509Cert getSignatureAlgParams() : DataBlob 获取证书签名算法参数   X509Cert getKeyUsage() : DataBlob 获取证书秘钥用途   X509Cert getExtKeyUsage() : DataArray 获取证书扩展秘钥用途   X509Cert getBasicConstraints() : number 获取证书基本约束   X509Cert getSubjectAltNames() : DataArray 获取证书主体可选名称   X509Cert getIssuerAltNames() : DataArray 获取证书颁发者可选名称    开发步骤 示例：解析X509证书数据生成证书对象，并调用对象方法（包含场景1-6） 已复制import cryptoCert from '@ohos.security.cert';import cryptoFramework from '@ohos.security.cryptoFramework';
// 证书数据，此处仅示例，业务需根据场景自行设置let certData = "-----BEGIN CERTIFICATE-----\n"+ "IBzTCCAXCgAwIBAgIGAXKnMKNyMAwGCCqBHM9VAYN1BQAwSTELMAkGA1UEBhMC\n"+ "04xDjAMBgNVBAoTBUdNU1NMMRAwDgYDVQQLEwdQS0kvU00yMRgwFgYDVQQDEw9S\n"+ "290Q0EgZm9yIFRlc3QwIhgPMjAxNTEyMzExNjAwMDBaGA8yMDM1MTIzMDE2MDAw\n"+ "FowSTELMAkGA1UEBhMCQ04xDjAMBgNVBAoTBUdNU1NMMRAwDgYDVQQLEwdQS0kv\n"+ "00yMRgwFgYDVQQDEw9Sb290Q0EgZm9yIFRlc3QwWTATBgcqhkjOPQIBBggqgRzP\n"+ "QGCLQNCAATj+apYlL+ddWXZ7+mFZXZJGbcJFXUN+Fszz6humeyWZP4qEEr2N0+a\n"+ "dwo/21ft232yo0jPLzdscKB261zSQXSoz4wPDAZBgNVHQ4EEgQQnGnsD7oaOcWv\n"+ "CTrspwSBDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIAxjAMBggqgRzP\n"+ "QGDdQUAA0kAMEYCIQCEnW5BlQh0vmsOLxSoXYc/7zs++wWyFc1tnBHENR4ElwIh\n"+ "I1Lwu6in1ruflZhzseWulXwcITf3bm/Y5X1g1XFWQUH\n"+ "-----END CERTIFICATE-----\n";
// string转Uint8Arrayfunction stringToUint8Array(str) {    var arr = [];    for (var i = 0, j = str.length; i < j; i++) {        arr.push(str.charCodeAt(i));    }    return new Uint8Array(arr);}
// 证书示例function certSample() {    let encodingBlob = {        // 将string类型证书数据转为Uint8Array        data: stringToUint8Array(certData),        // 证书格式：支持PEM和DER，此例中对应PEM        encodingFormat: cryptoCert.EncodingFormat.FORMAT_PEM    };
    // 创建证书对象    cryptoCert.createX509Cert(encodingBlob, function (err, x509Cert) {        if (err != null) {            // 创建证书对象失败            console.log("createX509Cert failed, errCode: " + err.code + ", errMsg: " + err.message);            return;        }        // 创建证书对象成功        console.log("createX509Cert success");
        // 获取证书版本        let version = x509Cert.getVersion();                // 获取证书对象的序列化数据        x509Cert.getEncoded(function (err, data) {            if (err != null) {                // 获取序列化数据失败                console.log("getEncoded failed, errCode: " + err.code + ", errMsg: " + err.message);            } else {                // 获取序列化数据成功                console.log("getEncoded success");            }        });
        // 业务需通过上级证书对象或本证书对象(自签名)的getPublicKey接口获取公钥对象，此处省略        let pubKey = null;        try {            pubKey = x509Cert.getPublicKey();        } catch (error) {            console.log("getPublicKey failed, errCode: " + error.code + ", errMsg: " + error.message);        }
        // 证书验签        x509Cert.verify(pubKey, function (err, data) {            if (err == null) {                // 验签成功                console.log("verify success");            } else {                // 验签失败                console.log("verify failed, errCode: " + err.code + ", errMsg: " + err.message);            }        });
        // 时间字符串        let date = "150527000001Z";                // 校验证书有效期        try {            x509Cert.checkValidityWithDate(date);        } catch (error) {            console.log("checkValidityWithDate failed, errCode: " + error.code + ", errMsg: " + error.message);        }    });}   使用证书吊销列表操作 场景说明 使用证书吊销列表操作中，典型的场景有：  解析X509证书吊销列表数据生成吊销列表对象。 获取证书吊销列表信息，比如：证书吊销列表版本、证书吊销列表类型等。 获取证书吊销列表对象的序列化数据。 检查证书是否被吊销。 证书吊销列表验签。 获取被吊销证书。  接口及参数说明 详细接口说明可参考API参考。 以上场景涉及的常用接口如下表所示：     实例名 接口名 描述    cryptoCert createX509Crl(inStream : EncodingBlob, callback : AsyncCallback<X509Crl>) : void 使用callback方式解析X509证书吊销列表数据生成证书吊销列表对象   cryptoCert createX509Crl(inStream : EncodingBlob) : Promise<X509Crl> 使用promise方式解析X509证书吊销列表数据生成证书吊销列表对象   X509Crl isRevoked(cert : X509Cert) : boolean 检查证书是否被吊销   X509Crl getType() : string 获取证书吊销列表类型   X509Crl getEncoded(callback : AsyncCallback<EncodingBlob>) : void 使用callback方式获取证书吊销列表序列化数据   X509Crl getEncoded() : Promise<EncodingBlob> 使用promise方式获取证书吊销列表序列化数据   X509Crl verify(key : cryptoFramework.PubKey, callback : AsyncCallback<void>) : void 使用callback方式进行证书吊销列表验签   X509Crl verify(key : cryptoFramework.PubKey) : Promise<void> 使用Promise方式进行证书吊销列表验签   X509Crl getVersion() : number 获取证书吊销列表版本   X509Crl getIssuerName() : DataBlob 获取证书吊销列表颁发者名称   X509Crl getLastUpdate() : string 获取证书吊销列表lastUpdate日期   X509Crl getNextUpdate() : string 获取证书吊销列表nextUpdate日期   X509Crl getRevokedCert(serialNumber : number) : X509CrlEntry 通过序列号获取证书吊销列表中的被吊销证书   X509Crl getRevokedCertWithCert(cert : X509Cert) : X509CrlEntry 通过X509证书获取证书吊销列表中的被吊销证书   X509Crl getRevokedCerts(callback : AsyncCallback<Array<X509CrlEntry>>) : void 使用callback方式获取证书吊销列表的所有被吊销证书   X509Crl getRevokedCerts() : Promise<Array<X509CrlEntry>> 使用Promise方式获取证书吊销列表的所有被吊销证书   X509Crl getTbsInfo() : DataBlob 获取证书吊销列表的tbsCertList   X509Crl getSignature() : DataBlob 获取证书吊销列表的签名   X509Crl getSignatureAlgName() : string 获取证书吊销列表的签名算法名称   X509Crl getSignatureAlgOid() : string 获取证书吊销列表的签名算法OID   X509Crl getSignatureAlgParams() : DataBlob 获取证书吊销列表的签名算法参数    开发步骤 示例：解析X509证书吊销列表数据生成证书吊销列表对象，并调用对象方法（包含场景1-6） 已复制import cryptoCert from '@ohos.security.cert';import cryptoFramework from '@ohos.security.cryptoFramework';
// 证书吊销列表数据，此处仅示例，业务需根据场景自行设置let crlData = "-----BEGIN X509 CRL-----\n"+ "MIIBijB0AgEBMA0GCSqGSIb3DQEBCwUAMBMxETAPBgNVBAMMCHJvb3QtY2ExFw0y\n"+ "MDA2MTkxNjE1NDhaFw0yMDA3MTkxNjE1NDhaMBwwGgIJAMsozRATnap1Fw0yMDA2\n"+ "MTkxNjEyMDdaoA8wDTALBgNVHRQEBAICEAIwDQYJKoZIhvcNAQELBQADggEBACPs\n"+ "9gQB+djaXPHHRmAItebZpD3iJ/e36Dxr6aMVkn9FkI8OVpUI4RNcCrywyCZHQJte\n"+ "995bbPjP7f1sZstOTZS0fDPgJ5SPAxkKOQB+SQnBFrlZSsxoUNU60gRqd2imR0Rn\n"+ "1r09rP69F6E4yPc9biEld+llLGgoImP3zPOVDD6fbfcvVkjStY3bssVEQ/vjp4a3\n"+ "/I12U7ZnSe3jaKqaQBoVJppkTFOIOq7IOxf5/IkMPmvRHDeC2IzDMzcUxym0dkny\n"+ "EowHrjzo0bZVqpHMA2YgKZuwTpVLHk9GeBEK2hVkIoPVISkmiU4HFg0S6z68C5yd\n"+ "DrAA7hErVgXhtURLbAI=\n"+ "-----END X509 CRL-----\n";
// string转Uint8Arrayfunction stringToUint8Array(str) {    var arr = [];    for (var i = 0, j = str.length; i < j; i++) {        arr.push(str.charCodeAt(i));    }    return new Uint8Array(arr);}
// 证书吊销列表示例function crlSample() {    let encodingBlob = {        // 将string类型证书吊销列表数据转为Uint8Array        data: stringToUint8Array(crlData),        // 证书吊销列表格式：支持PEM和DER，此例中对应PEM        encodingFormat: cryptoCert.EncodingFormat.FORMAT_PEM    };
    // 创建证书吊销列表对象    cryptoCert.createX509Crl(encodingBlob, function (err, x509Crl) {        if (err != null) {            // 创建证书吊销列表对象失败            console.log("createX509Crl failed, errCode: " + err.code + ", errMsg: " + err.message);            return;        }        // 创建证书吊销列表对象成功        console.log("createX509Crl success");
        // 获取证书吊销列表版本        let version = x509Crl.getVersion();                // 获取证书吊销列表对象的序列化数据        x509Crl.getEncoded(function (err, data) {            if (err != null) {                // 获取序列化数据失败                console.log("getEncoded failed, errCode: " + err.code + ", errMsg: " + err.message);            } else {                // 获取序列化数据成功                console.log("getEncoded success");            }        });
        // 业务需通过cryptoFramework的createX509Cert生成X509Cert证书对象，此处省略        let x509Cert = null;        // 检查证书是否被吊销        try {            let revokedFlag = x509Crl.isRevoked(x509Cert);        } catch (error) {           console.log("isRevoked failed, errCode: " + error.code + ", errMsg: " + error.message);        }
        // 业务需通过将public key二进制数据输入 @ohos.security.cryptoFramework的convertKey接口获取PubKey对象，此处省略        let pubKey = null;                // 证书吊销列表验签        x509Crl.verify(pubKey, function (err, data) {            if (err == null) {                // 验签成功                console.log("verify success");            } else {                // 验签失败                console.log("verify failed, errCode: " + err.code + ", errMsg: " + err.message);            }        });
        // 证书序列号，业务需自行设置        let serialNumber = 1000;
        // 获取被吊销证书对象        try {            let entry = x509Crl.getRevokedCert(serialNumber);        } catch (error) {           console.log("getRevokedCert failed, errCode: " + error.code + ", errMsg: " + error.message);        }    });}   使用证书链校验器操作 场景说明 使用证书链校验器操作中，典型的场景：证书链校验。 接口及参数说明 详细接口说明可参考API参考。 以上场景涉及的常用接口如下表所示：     实例名 接口名 描述    cryptoCert createCertChainValidator(algorithm :string) : CertChainValidator 使用指定算法生成证书链校验器对象   CertChainValidator validate(certChain : CertChainData, callback : AsyncCallback<void>) : void 使用callback方式校验证书链   CertChainValidator validate(certChain : CertChainData) : Promise<void> 使用promise方式校验证书链   CertChainValidator algorithm : string 证书链校验器算法名称    开发步骤 示例：创建证书链校验器对象，并对证书链数据进行校验（场景1） 已复制import cryptoCert from '@ohos.security.cert';
// 一级证书数据，此处仅示例，业务需自行设置真实数据let caCertData = "-----BEGIN CERTIFICATE-----\n"+ "...\n"+ "...\n"+ "...\n"+ "-----END CERTIFICATE-----\n";
// 二级证书数据，此处仅示例，业务需自行设置真实数据let secondCaCertData = "-----BEGIN CERTIFICATE-----\n"+ "...\n"+ "...\n"+ "...\n"+ "-----END CERTIFICATE-----\n";
// string转Uint8Arrayfunction stringToUint8Array(str) {    var arr = [];    for (var i = 0, j = str.length; i < j; i++) {        arr.push(str.charCodeAt(i));    }    return new Uint8Array(arr);}
// 证书链校验器示例：此示例中以校验二级证书链为例，业务需根据场景自行修改function certChainValidatorSample() {    // 证书链校验器算法，当前仅支持PKIX    let algorithm = "PKIX";        // 创建证书链校验器对象    let validator = cryptoCert.createCertChainValidator(algorithm);        // 一级证书数据    let uint8ArrayOfCaCertData = stringToUint8Array(caCertData);        // 一级证书数据长度    let uint8ArrayOfCaCertDataLen = new Uint8Array(new Uint16Array([uint8ArrayOfCaCertData.byteLength]).buffer);        // 二级证书数据    let uint8ArrayOf2ndCaCertData = stringToUint8Array(secondCaCertData);        // 二级证书数据长度    let uint8ArrayOf2ndCaCertDataLen = new Uint8Array(new Uint16Array([uint8ArrayOf2ndCaCertData.byteLength]).buffer);        // 证书链二进制数据：二级证书数据长度+二级证书数据+一级证书数据长度+一级证书数据（L-V格式）    let encodingData = new Uint8Array(uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length +                                     uint8ArrayOfCaCertDataLen.length + uint8ArrayOfCaCertData.length);    for (var i = 0; i < uint8ArrayOf2ndCaCertDataLen.length; i++) {        encodingData[i] = uint8ArrayOf2ndCaCertDataLen[i];    }    for (var i = 0; i < uint8ArrayOf2ndCaCertData.length; i++) {        encodingData[uint8ArrayOf2ndCaCertDataLen.length + i] = uint8ArrayOf2ndCaCertData[i];    }    for (var i = 0; i < uint8ArrayOfCaCertDataLen.length; i++) {        encodingData[uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length + i] = uint8ArrayOfCaCertDataLen[i];    }    for (var i = 0; i < uint8ArrayOfCaCertData.length; i++) {        encodingData[uint8ArrayOf2ndCaCertDataLen.length + uint8ArrayOf2ndCaCertData.length +                     uint8ArrayOfCaCertDataLen.length + i] = uint8ArrayOfCaCertData[i];    }        let certChainData = {        // Uint8Array类型：L-V格式(证书数据长度-证书数据)        data: encodingData,        // 证书数量，此示例中为2        count: 2,        // 证书格式：支持PEM和DER，此例中对应PEM        encodingFormat: cryptoCert.EncodingFormat.FORMAT_PEM    };        // 校验证书链    validator.validate(certChainData, function (err, data) {        if (err != null) {            // 证书链校验失败            console.log("validate failed, errCode: " + err.code + ", errMsg: " + err.message);        } else {            // 证书链校验成功            console.log("validate success");        }    });}   使用被吊销证书操作 场景说明 使用被吊销证书操作中，典型的场景有：  获取被吊销证书对象。 获取被吊销证书信息，比如：序列号、证书颁发者、证书吊销日期。 获取被吊销证书对象的序列化数据。  接口及参数说明 详细接口说明可参考API参考。 以上场景涉及的常用接口如下表所示：     实例名 接口名 描述    X509CrlEntry getEncoded(callback : AsyncCallback<EncodingBlob>) : void; 使用callback方式获取被吊销证书的序列化数据   X509CrlEntry getEncoded() : Promise<EncodingBlob>; 使用promise方式获取被吊销证书的序列化数据   X509CrlEntry getSerialNumber() : number; 获取被吊销证书的序列号   X509CrlEntry getCertIssuer() : DataBlob; 获取被吊销证书颁发者   X509CrlEntry getRevocationDate() : string; 获取被吊销证书的吊销日期    开发步骤 示例：获取被吊销证书对象，并调用对象方法（包含场景1-3） 已复制import cryptoCert from '@ohos.security.cert';
// 被吊销证书示例function crlEntrySample() {    // 业务需自行通过cryptoFramework的createX509Crl接口创建X509Crl对象，此处省略    let x509Crl = null;        // 获取被吊销证书对象，业务需根据场景调用X509Crl的接口获取，此示例使用getRevokedCert获取    let serialNumber = 1000;    let crlEntry = null;    try {        crlEntry = x509Crl.getRevokedCert(serialNumber);    } catch (error) {        console.log("getRevokedCert failed, errCode: " + error.code + ", errMsg: " + error.message);    }
    // 获取被吊销证书的序列号    serialNumber = crlEntry.getSerialNumber();        // 获取被吊销证书的吊销日期    try {        crlEntry.getRevocationDate();    } catch (error) {        console.log("getRevocationDate failed, errCode: " + error.code + ", errMsg: " + error.message);    }
    // 获取被吊销证书对象的序列化数据    crlEntry.getEncoded(function (err, data) {        if (err != null) {            // 获取序列化数据失败            console.log("getEncoded failed, errCode: " + err.code + ", errMsg: " + err.message);        } else {            // 获取序列化数据成功            console.log("getEncoded success");        }    });}   上一篇 证书概述 下一篇 网络与连接 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。证书基本概念约束与限制证书规格证书概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 提供X509证书相关的功能。开发者可以通过调用该系统能力，实现迅捷开发。 证书基本概念数字证书提供了一种数字验证用户、设备、业务身份的方式。X509证书是国际定制的标准格式。加解密算法库框架部件提供X509证书、X509证书吊销列表、证书链校验器相关的功能。 X509证书：提供X509证书的解析、序列化、X509证书签名验证、证书相关的信息查询等功能X509证书吊销列表：提供X509证书吊销列表的解析、序列化、信息查询等功能证书链校验器：提供证书链校验（不包括证书有效期的校验）、证书链算法名称查询的功能  约束与限制不支持多线程并发操作。  证书规格证书链校验 由于端侧系统时间不可信，证书链校验不包含对证书有效时间的校验。如果需要检查证书的时间有效性，可使用X509证书的checkValidityWithDate()方法进行检查。 证书格式 目前支持DER与PEM格式的证书。    上一篇 证书 下一篇 证书开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS应用云测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     兼容性测试  稳定性测试  性能测试  功耗测试  UX测试   上一篇 隐私测试 下一篇 兼容性测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Codelabs 更新时间: 2023-10-20 16:47 毫无帮助帮助不大一般很好非常好
分享
 为了方便开发者针对重点功能或场景进行开发，本页面对当前有的Codelabs资源进行了汇总，如下表所示： 分类  主题  简介    优秀案例  溪村小镇（ArkTS）  基于ArkUI实现的一款呈现溪村小镇园区风貌的应用，主要用于展示HarmonyOS多样的UI特性和丰富的动画效果。   一次开发，多端部署-购物应用（ArkTS）  基于自适应和响应式布局，实现一次开发，多端部署的购物应用。   一次开发，多端部署-音乐专辑（ArkTS）  基于自适应和响应式布局，实现一次开发、多端部署音乐专辑页面。   健康生活应用（ArkTS）  利用ArkTS声明式开发范式和HarmonyOS的关系型数据库等能力，实现了一个健康生活应用。   Ability开发  UIAbility和自定义组件生命周期（ArkTS）  本篇Codelab主要介绍UIAbility和自定义组件生命周期。   UIAbility内页面间的跳转（ArkTS）  基于Stage模型下的Ability开发，实现Ability内页面间的跳转。   Stage模型下Ability的创建和使用（ArkTS）  本篇Codelab基于Stage模型，以购物应用为例，讲解Ability的创建和使用。   UI（ArkTS）  一次开发，多端部署-视频应用（ArkTS）  基于“一次开发，多端部署”能力实现的一个视频播放类应用主页面。   电子相册（ArkTS）  基于ArkTS实现一个电子相册的案例，通过捏合和拖拽手势控制图片的放大、缩小、左右拖动查看细节等效果。   构建多种样式弹窗（ArkTS）  本篇Codelab使用弹窗功能，实现多种样式弹窗案例。   简易计算器（ArkTS）  基于基础组件、容器组件，实现一个支持加减乘除混合运算的计算器。   自定义抽奖转盘（ArkTS）  基于画布组件，实现自定义抽奖转盘功能。   像素转换（ArkTS）  基于像素单位，展示了像素单位的基本知识与像素转换API的使用。   二级联动（ArkTS）  使用ArkTS语言，实现一个导航与内容二级联动的效果。   目标管理（ArkTS）  基于ArkTS实现一个目标管理器，介绍页面级变量的状态管理。   弹性布局（ArkTS）  基于Flex容器组件特性，实现弹性布局效果。   待办列表（ArkTS）  基于ArkTS声明式语法和ArkTS基础组件，实现简易待办事项的案例。   ArkTS基础知识（ArkTS）  本篇Codelab使用渲染控制语法和组件化基础知识，搭建一个可刷新的排行榜页面。   动效示例（ArkTS）  利用ArkTS语言为组件的属性添加过渡动态效果，提升用户体验。   转场动画的使用（ArkTS）  基于ArkTS语言及转场动画接口，实现一系列页面动画切换的场景。   自定义下拉刷新动画（ArkTS）  基于组件动画animation属性设置，实现下拉刷新动画 。   ArkUI常用布局容器对齐方式（ArkTS）  基于ArkTS扩展的声明式开发范式，实现Flex、Column、Row和Stack四种常用布局容器对齐方式。   常用组件与布局（ArkTS）  基于ArkTS扩展的声明式开发范式，使用常用组件与布局实现一个购物社交应用示例。   Web组件之cookie常见操作（ArkTS）  使用ArkTS语言，Web组件对cookie的读写操作。   Swiper使用（ArkTS）  使用ArkTS语言，基于Swiper容器组件，实现几种常见的应用场景。例如顶部导航、广告轮播图等场景。   基础组件Slider的使用（ArkTS）  使用Slider组件，实现了可调节风车大小和转速的动画效果。   List组件的用法之商品列表（ArkTS）  本篇Codelab使用Scroll组件、List组件以及LazyForEach组件实现一个商品列表的页面。   List组件的用法之设置项（ArkTS）  本篇Codelab使用List组件、Toggle组件以及Router相关接口，实现一个简单的设置页。   UI（JS）  image、image-animator组件的使用（JS）  基于image、image-animator组件，实现几种常见的图片点击效果。   input、label组件的使用（JS）  基于input、label和dialog组件，实现表单页面的输入、必填校验和提交功能。   rating组件的使用（JS）  基于rating组件，实现星级打分的效果。   slider组件的使用（JS）  基于slider组件，实现调节风车大小和转动速度的动画效果。   switch、chart组件的使用（JS）  基于switch、chart组件，实现可静态或动态显示的图表数据可视化案例。   弹窗基本使用（JS）  基于dialog和button组件，介绍几种自定义弹窗样式。   动画样式（JS）  基于动画样式，实现几种常见动画效果。   toolbar、toolbar-item组件的使用（JS）  基于toolbar和toolbar-item组件，实现一个简单的底部导航应用。   video组件的使用（JS）  基于video和slider组件，实现视频播放功能。   购物应用（JS）  基于常用组件、页面路由，实现购物应用。   公共事件与通知  系统公共事件（ArkTS）  通过订阅、退订Wi-Fi连接状态事件和电池充电状态事件，实现订阅、退订系统公共事件。   进度条通知（ArkTS）  基于HarmonyOS通知能力，实现进度条通知的案例。   闹钟（ArkTS）  基于ArkTS的声明式开发范式及HarmonyOS的后台代理提醒能力，实现简单的闹钟提醒功能。   窗口管理  窗口管理（ArkTS）  基于窗口管理，实现一个验证码登录案例。   媒体  录音机（ArkTS）  基于HarmonyOS的媒体能力，实现一个录音机。   视频播放器（ArkTS）  基于HarmonyOS的播放管理类（AVPlayer），实现视频播放功能。   图片编辑（ArkTS）  基于图片编解码，实现图片编辑，包含裁剪、旋转、色域调节（本文只介绍亮度、透明度、饱和度）等功能。   简易视频播放器（ArkTS）  基于ArkUI框架，实现一个简单视频播放器，可支持海报轮播、视频播放等功能。   图片编辑（JS）  基于canvas组件、图片编解码，实现一个简易的图片编辑器应用。   网络连接  新闻发布（ArkTS）  基于网络管理和文件管理实现新闻发布和新闻加载刷新的功能。   HTTPS请求过程（ArkTS）  基于网络模块，实现数据安全加密传输。   新闻数据加载（ArkTS）  基于HTTP网络请求加载新闻数据，提供下拉刷新和上拉加载功能。   Web组件抽奖案例（ArkTS）  基于Web组件加载本地和在线H5小程序，实现ArkTS和H5交互功能。   数据库  关系型数据库（ArkTS）  本Codelab介绍了关系型数据库的基本用法，包括增、删、改、查操作。   首选项（ArkTS）  基于首选项，实现对本地应用数据的访问及操作。   应用内字体大小调节（ArkTS）  基于Slider组件和首选项，实现通过拖动滑块调节应用内字体大小的功能。   应用首次启动（ArkTS）  基于自定义弹框、首选项和页面路由实现一个模拟应用首次启动的案例。   设备管理  计步器应用（ArkTS）  基于计步传感器、位置服务和后台任务，实现计步器应用。   分布式  分布式新闻客户端（ArkTS）  基于HarmonyOS ArkUI，使用HarmonyOS应用中Service Ability和Page Ability，实现跨设备FA拉起。   分布式新闻客户端（JS）  基于兼容JS的类Web开发范式，使用HarmonyOS应用中Service Ability和Page Ability，实现跨设备FA拉起。   分布式手写板（JS）  基于兼容JS的的类Web开发范式，使用分布式能力，实现多设备同步书写互动。   分布式鉴权（JS）  基于FeatureAbility分布式拉起FA机制，实现鉴权功能。   卡片  健康生活卡片（ArkTS）  基于健康生活应用实现ArkTS卡片。   电影卡片（JS）  基于元服务卡片的能力，实现带有卡片的电影应用，介绍卡片的开发过程和生命周期实现。   计步器卡片（JS）  基于Stage模型实现带有卡片的计步应用，用于介绍卡片的开发及生命周期实现。   效率提升  使用DevEco Studio高效开发（ArkTS）  使用DevEco Studio开发工具，高效开发登录应用的案例。   常见组件和容器低代码开发示例（ArkTS）  基于ArkTS语言的低代码开发方式，利用常用组件实现任务列表和任务信息的页面展示。   三方库  库的调用（ArkTS）  基于ArkTS语言实现对社区库和本地库的调用及使用。   Native  简易Native C++ 示例（ArkTS）  基于Native C++模板，实现通过Native API调用C标准库的功能。   Native XComponent组件的使用（ArkTS）  基于XComponent组件调用Native API，实现图形渲染。     上一篇 示例代码 下一篇 视频教程 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。代码检查规则表 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
  表1 Code Linter代码检查规则表序号  规则ID  描述  正例  反例  RuleSet    1  @typescript-eslint/await-thenable  如果await一个非Thenable的值，await 会把该值转换为已正常处理的 Promise，然后等待其处理结果。此时await反而会影响代码性能  await Promise.resolve('value');  const createValue = async () => 'value'; await createValue();  await 'value';  const createValue = () => 'value'; await createValue();  recommended   2  @typescript-eslint/consistent-type-imports  如果导入类型（type），将导入类型和导出其他对象分开写  import type { Foo } from 'Foo'; import type Bar from 'Bar'; type T = Foo; const x: Bar = 1;  import { Foo } from 'Foo'; import Bar from 'Bar'; type T = Foo; const x: Bar = 1;  recommended   3  @typescript-eslint/explicit-function-return-type  声明函数和类方法的返回类型可以使得编译器能够帮助检查返回类型的一致性  // No return value should be expected (void) function test(): void { return; }  // A return value of type number var fn = function (): number { return 1; };  // A return value of type string var arrowFn = (): string => 'test';  class Test { // No return value should be expected (void) method(): void { return; } }  // Should indicate that no value is returned (void) function test() { return; }  // Should indicate that a number is returned var fn = function () { return 1; };  // Should indicate that a string is returned var arrowFn = () => 'test';  class Test { // Should indicate that no value is returned (void) method() { return; } }  recommended   4  @typescript-eslint/no-dynamic-delete  delete会改变对象的布局，而delete对象的可计算属性会非常危险，而且会大幅约束语言运行时的优化从而影响执行性能  const container: { [i: string]: number } = { /* ... */ };  // 一定程度也会影响优化性能，但比删除可计算属性好一些。 delete container.aaa;  delete container[7]; delete container['-Infinity'];  // Can be replaced with the constant equivalents, such as container.aaa delete container['aaa']; delete container['Infinity'];  // Dynamic, difficult-to-reason-about lookups const name = 'name'; delete container[name]; delete container[name.toUpperCase()];  recommended   5  @typescript-eslint/no-for-in-array  for in在语义上原本是用来遍历对象属性，虽然使用它来遍历数组也合法，但是会影响执行性能。禁止使用for in来进行数组访问，一般使用forEach/for of/for(int i;...)来遍历数组  for (const x in { a: 3, b: 4, c: 5 }) { console.log(x); }  for (const x in [3, 4, 5]) { console.log(x); }  recommended   6  @typescript-eslint/no-this-alias  禁止将This赋值给一个变量，约束This在一个Scope内使用  setTimeout(() => { this.doWork(); });  const self = this;  setTimeout(function () { self.doWork(); });  recommended   7  @typescript-eslint/no-explicit-any  不允许定义any类型。它的目的是为了让类型在TS中尽量明确，帮助语言运行时优化  const age: number = 17; function greet(): string {} function greet(param: Array<string>): string {}  const age: any = 'seventeen'; function greet(): any {} function greet(param: Array<any>): string {}  recommended   8  @typescript-eslint/no-unsafe-argument  不允许使用any作为参数传递  declare function foo(arg1: string, arg2: number, arg3: string): void;  foo('a', 1, 'b');  const tuple1 = ['a', 1, 'b'] as const; foo(...tuple1);  declare function foo(arg1: string, arg2: number, arg3: string): void;  const anyTyped = 1 as any;  foo(...anyTyped); foo(anyTyped, 1, 'a');  const tuple1 = ['a', anyTyped, 'b'] as const; foo(...tuple1);  recommended   9  @typescript-eslint/no-unsafe-assignment  不允许在赋值中使用any  const x = 1；  const x: Set<string> = new Set<string>();  const x = 1 as any,  const x: Set<string> = new Set<any>();  recommended   10  @typescript-eslint/no-unsafe-call  不允许call类型为any的变量  declare const typedVar: () => void; declare const typedNested: { prop: { a: () => void } };  typedVar(); typedNested.prop.a();  declare const anyVar: any; declare const nestedAny: { prop: any };  anyVar(); anyVar.a.b();  nestedAny.prop(); nestedAny.prop['a']();  recommended   11  @typescript-eslint/no-unsafe-member-access  不允许访问类型为any的对象的成员  declare const properlyTyped: { prop: { a: string } };  properlyTyped.prop.a; properlyTyped.prop['a'];  declare const anyVar: any; declare const nestedAny: { prop: any };  anyVar.a; anyVar.a.b;  nestedAny.prop.a; nestedAny.prop['a'];  recommended   12  @typescript-eslint/no-unsafe-return  不允许声明函数返回值类型为any或者any[]  function foo1() : number { return 1; }  function foo1() { return 1 as any; }  recommended   13  @typescript-eslint/adjacent-overload-signatures  要求重载方法声明必须连续  export function bar(): void; export function foo(s: string): void; export function foo(n: number): void; export function foo(sn: string | number): void;  export function foo(s: string): void; export function foo(n: number): void; export function bar(): void; export function foo(sn: string | number): void;  all   14  @typescript-eslint/array-type  检查 `T[]` 或 `Array<T>`的使用一致性  const x: string[] = ['a', 'b']; const y: readonly string[] = ['a', 'b'];  const x: Array<string> = ['a', 'b']; const y: ReadonlyArray<string> = ['a', 'b'];  all   15  @typescript-eslint/ban-ts-comment  禁止在`@ts-<directive>` 注解后添加注释  if (false) { // Compiler warns about unreachable code error console.log('hello'); }  if (false) { // @ts-ignore: Unreachable code error console.log('hello'); } if (false) { /* @ts-ignore: Unreachable code error */ console.log('hello'); }  all   16  @typescript-eslint/ban-tslint-comment  禁止`// tslint:<rule-flag>`注释  // This is a comment that just happens to mention tslint /* This is a multiline comment that just happens to mention tslint */ someCode(); // This is a comment that just happens to mention tslint  /* tslint:disable */ /* tslint:enable */ /* tslint:disable:rule1 rule2 rule3... */ /* tslint:enable:rule1 rule2 rule3... */ // tslint:disable-next-line someCode(); // tslint:disable-line // tslint:disable-next-line:rule1 rule2 rule3…  all   17  @typescript-eslint/ban-types  禁用特定类型  // use lower-case primitives for consistency const str: string = 'foo'; const bool: boolean = true; const num: number = 1; const symb: symbol = Symbol('foo'); const bigInt: bigint = 1n;  // use lower-case primitives for consistency const str: String = 'foo'; const bool: Boolean = true; const num: Number = 1; const symb: Symbol = Symbol('foo'); const bigInt: BigInt = 1n;  all   18  @typescript-eslint/class-literal-property-style  强制类字面量公开类型一致  class Mx { public readonly myField1 = 1;  // not a literal public readonly myField2 = [1, 2, 3];  private readonly ['myField3'] = 'hello world';  public get myField4() { return `hello from ${window.location.href}`; } }  class Mx { public static get myField1() { return 1; }  private get ['myField2']() { return 'hello world'; } }  all   19  @typescript-eslint/consistent-indexed-object-style  要求或禁止`Record`类型  interface Foo { [key: string]: unknown; }  type Foo = { [key: string]: unknown; };  type Foo = Record<string, unknown>;  all   20  @typescript-eslint/consistent-type-assertions  要求使用一致的类型断言  const x: T = { ... }; const y = { ... } as any; const z = { ... } as unknown;  function foo(): T { return { ... }; }  const x = { ... } as T;  function foo() { return { ... } as T; }  all   21  @typescript-eslint/consistent-type-definitions  强制类型定义使用一致的`interface` 或 `type`  type T = string; type Foo = string | {};  interface T { x: number; }  type T = { x: number };  all   22  @typescript-eslint/explicit-member-accessibility  要求类属性或方法使用明确的访问标签  class Animal { constructor(public animalName: string) {} }  class Animal { constructor(public readonly animalName: string) {} }  all   23  @typescript-eslint/explicit-module-boundary-types  要求导出函数中提供明确的return及参数类型  // Function is not exported function test() { return; }  // A return value of type number export var fn = function (): number { return 1; };  // Should indicate that no value is returned (void) export function test() { return; }  // Should indicate that a number is returned export default function () { return 1; }  recommended   24  @typescript-eslint/member-delimiter-style  要求对interfaces和type字面量提供精确的数字定界符  interface Foo { name: string; greet(): string; }  interface Foo { name: string }  interface Foo { name: string greet(): string }  // using incorrect delimiter interface Bar { name: string, greet(): string, }  all   25  @typescript-eslint/member-ordering  要求一致的成员声明顺序  interface Foo { [Z: string]: any; // -> signature  A(): void; // -> method  new (); // -> constructor  B: string; // -> field }  interface Foo { B: string; // -> field  new (); // -> constructor  A(): void; // -> method  [Z: string]: any; // -> signature }  all   26  @typescript-eslint/method-signature-style  强制使用特定的方法签名语法  interface T1 { func(arg: string): number; } type T2 = { func(arg: boolean): void; };  interface T1 { func: (arg: string) => number; } type T2 = { func: (arg: boolean) => void; };  all   27  @typescript-eslint/naming-convention  强制代码仓使用同样的命名规范  -  -  all   28  @typescript-eslint/no-base-to-string  要求仅在转换为字符串时在对象上调用 .toString()  // These types all have useful .toString()s 'Text' + true; `Value: ${123}`; `Arrays too: ${[1, 2, 3]}`; (() => {}).toString();  // Passing an object or class instance to string concatenation: '' + {};  class MyClass {} const value = new MyClass(); value + '';  // Interpolation and manual .toString() calls too: `Value: ${value}`; ({}.toString());  all   29  @typescript-eslint/no-confusing-non-null-assertion  不允许在可能引发歧义的位置使用非空断言  interface Foo { bar?: string; num?: number; }  const foo: Foo = getFoo(); const isEqualsBar = foo.bar == 'hello'; const isEqualsNum = (1 + foo.num!) == 2;  interface Foo { bar?: string; num?: number; }  const foo: Foo = getFoo(); const isEqualsBar = foo.bar! == 'hello'; const isEqualsNum = 1 + foo.num! == 2;  all   30  @typescript-eslint/no-confusing-void-expression  void 类型的表达式需出现在语句位置（不可用于赋值、返回等）  // just a regular void function in a statement position alert('Hello, world!');  // this function returns a boolean value so it's ok const response = confirm('Are you sure?'); console.log(confirm('Are you sure?'));  // somebody forgot that `alert` doesn't return anything const response = alert('Are you sure?'); console.log(alert('Are you sure?'));  all   31  @typescript-eslint/no-empty-interface  禁止声明空interface  // an interface with any number of members interface Foo { name: string; }  // same as above interface Bar { age: number; }  // an interface with more than one supertype // in this case the interface can be used as a replacement of a union type. interface Baz extends Foo, Bar {}  // an empty interface interface Foo {}  // an interface with only one supertype (Bar === Foo) interface Bar extends Foo {}  // an interface with an empty list of supertypes interface Baz {}  all   32  @typescript-eslint/no-extra-non-null-assertion  不允许多余的非空断言  const foo: { bar: number } | null = null; const bar = foo!.bar;  function foo(bar: number | undefined) { const bar: number = bar!; }  const foo: { bar: number } | null = null; const bar = foo!!!.bar;  function foo(bar: number | undefined) { const bar: number = bar!!!; }  all   33  @typescript-eslint/no-extraneous-class  不允许将类用作namespace  export const version = 42;  export function isProduction() { return process.env.NODE_ENV === 'production'; }  function logHelloWorld() { console.log('Hello, world!'); }  class StaticConstants { static readonly version = 42;  static isProduction() { return process.env.NODE_ENV === 'production'; } }  class HelloWorldLogger { constructor() { console.log('Hello, world!'); } }  all   34  @typescript-eslint/no-floating-promises  恰当地处理类Promise的语句  const promise = new Promise((resolve, reject) => resolve('value')); await promise;  async function returnsPromise() { return 'value'; } returnsPromise().then( () => {}, () => {}, );  Promise.reject('value').catch(() => {});  Promise.reject('value').finally(() => {});  const promise = new Promise((resolve, reject) => resolve('value')); promise;  async function returnsPromise() { return 'value'; } returnsPromise().then(() => {});  Promise.reject('value').catch();  Promise.reject('value').finally();  all   35  @typescript-eslint/no-implicit-any-catch  避免catch表达式中变量为隐含的any类型  try { // ... } catch (e: unknown) { // ... }  try { // ... } catch (e) { // ... }  all   36  @typescript-eslint/no-inferrable-types  不允许对初始化为数字、字符串或布尔值的变量或参数进行显式类型声明  const a = 10n; const a = BigInt(10); const a = !0; const a = Boolean(null); const a = true;  const a: bigint = 10n; const a: bigint = BigInt(10); const a: boolean = !0; const a: boolean = Boolean(null); const a: boolean = true;  all   37  @typescript-eslint/no-invalid-void-type  禁止在泛型或返回类型之外使用 `void` 类型  type NoOp = () => void;  function noop(): void {}  let trulyUndefined = void 0;  async function promiseMeSomething(): Promise<void> {}  type stillVoid = void | never;  type PossibleValues = string | number | void; type MorePossibleValues = string | ((number & any) | (string | void));  function logSomething(thing: void) {} function printArg<T = void>(arg: T) {}  all   38  @typescript-eslint/no-misused-new  强制new和constructor定义有效  declare class C { constructor(); }  interface I { new (): C; }  declare class C { new(): C; }  interface I { new (): I; constructor(): void; }  all   39  @typescript-eslint/no-misused-promises  禁止Promise使用在未设计处理它们的位置  const promise = Promise.resolve('value');  // Always `await` the Promise in a conditional if (await promise) { // Do something }  const val = (await promise) ? 123 : 456;  while (await promise) { // Do something }  const promise = Promise.resolve('value');  if (promise) { // Do something }  const val = promise ? 123 : 456;  while (promise) { // Do something }  all   40  @typescript-eslint/no-namespace  禁用TypeScript namespace关键字  declare module 'foo' {}  module foo {} namespace foo {}  declare module foo {} declare namespace foo {}  all   41  @typescript-eslint/no-non-null-asserted-optional-chain  禁止在可选链式调用中使用非空断言  foo?.bar; foo?.bar();  foo?.bar!; foo?.bar()!;  all   42  @typescript-eslint/no-non-null-assertion  禁止使用`!`后缀运算符做非空断言  interface Example { property?: string; }  declare const example: Example; const includesBaz = example.property?.includes('baz') ?? false;  interface Example { property?: string; }  declare const example: Example; const includesBaz = example.property!.includes('baz');  all   43  @typescript-eslint/no-require-imports  禁止调用require方法  import * as lib1 from 'lib1'; import { lib2 } from 'lib2'; import * as lib3 from 'lib3';  const lib1 = require('lib1'); const { lib2 } = require('lib2'); import lib3 = require('lib3');  all   44  @typescript-eslint/no-type-alias  允许或禁止使用type别名  type Foo = 'a';  type Foo = 'a' | 'b';  type Foo = string;  -  all   45  @typescript-eslint/no-unnecessary-boolean-literal-compare  禁止对布尔型字面量进行非必要的比较  declare const someCondition: boolean; if (someCondition) { }  declare const someCondition: boolean; if (someCondition === true) { }  all   46  @typescript-eslint/no-unnecessary-condition  禁止条件语句恒为true或false  function head<T>(items: T[]) { // Necessary, since items.length might be 0 if (items.length) { return items[0].toUpperCase(); } }  function head<T>(items: T[]) { // items can never be nullable, so this is unnecessary if (items) { return items[0].toUpperCase(); } }  all   47  @typescript-eslint/no-unnecessary-qualifier  禁止非必要的命名空间引用  enum A { B, C = B, }  namespace A { export type B = number; const x: B = 3; }  enum A { B, C = A.B, }  namespace A { export type B = number; const x: A.B = 3; }  all   48  @typescript-eslint/no-unnecessary-type-arguments  禁止使用和默认值相等的泛型  function f<T = number>() {} f(); f<string>();  function f<T = number>() {} f<number>();  all   49  @typescript-eslint/no-unnecessary-type-assertion  禁止使用不改变表达式类型的类型断言  const foo = <number>3; const foo = 3 as number;  const foo = 3; const bar = foo!; const foo = <3>3;  all   50  @typescript-eslint/no-unnecessary-type-constraint  禁止对泛型做不必要约束  interface Foo<T> {}  type Bar<T> = {};  class Baz<T> { qux<U> { } }  interface FooAny<T extends any> {}  type BarAny<T extends any> = {};  class BazAny<T extends any> { quxAny<U extends any>() {} }  recommended   51  @typescript-eslint/parameter-properties  变量的修饰符控制  class Foo { constructor(name: string) {} }  class Foo { constructor(readonly name: string) {} }  class Foo { constructor(private name: string) {} }  all   52  @typescript-eslint/prefer-as-const  强制对字面量类型使用`as const`  let foo = 'bar'; let foo = 'bar' as const; let foo: 'bar' = 'bar' as const;  let bar: 2 = 2; let foo = <'bar'>'bar'; let foo = { bar: 'baz' as 'baz' };  all   53  @typescript-eslint/prefer-enum-initializers  要求显示初始化每个枚举成员的值  enum Status { Open = 'Open', Close = 'Close', }  enum Direction { Up = 1, Down = 2, }  enum Status { Open = 1, Close, }  enum Direction { Up, Down, }  all   54  @typescript-eslint/prefer-for-of  尽可能地使用for…of代替传统的for循环  declare const array: string[];  for (const x of array) { console.log(x); }  for (let i = 0; i < array.length; i++) { // i is used, so for-of could not be used. console.log(i, array[i]); }  declare const array: string[];  for (let i = 0; i < array.length; i++) { console.log(array[i]); }  all   55  @typescript-eslint/prefer-function-type  强制使用函数类型而非带有调用签名的interface  type Example = () => string;  function foo(example: () => number): number { return bar(); }  interface Example { (): string; }  function foo(example: { (): number }): number { return example(); }  all   56  @typescript-eslint/prefer-includes  强制使用includes方法替代indexOf方法  str.includes(value); array.includes(value); readonlyArray.includes(value);  str.indexOf(value) !== -1; array.indexOf(value) !== -1; readonlyArray.indexOf(value) === -1;  all   57  @typescript-eslint/prefer-literal-enum-member  要求所有的枚举成员都是字面量  enum Valid { A, B = 'TestStr', // A regular string C = 4, // A number D = null, E = /some_regex/, }  const str = 'Test'; enum Invalid { A = str, // Variable assignment B = {}, // Object assignment C = `A template literal string`, // Template literal D = new Set(1, 2, 3), // Constructor in assignment E = 2 + 2, // Expression assignment }  recommended   58  @typescript-eslint/prefer-namespace-keyword  要求使用namespace替代module来声明自定义TypeScript模块  namespace Example {}  declare module 'foo' {}  module Example {}  all   59  @typescript-eslint/prefer-nullish-coalescing  强制使用null合并运算符而不是逻辑链接  const foo: any = 'bar'; foo ?? 'a string'; foo ?? 'a string'; foo ?? 'a string'; foo ?? 'a string';  const foo: any = 'bar'; foo !== undefined && foo !== null ? foo : 'a string'; foo === undefined || foo === null ? 'a string' : foo; foo == undefined ? 'a string' : foo; foo == null ? 'a string' : foo;  all   60  @typescript-eslint/prefer-optional-chain  强制使用简洁的可选链式调用，而不是拼接逻辑与、否定逻辑或或空对象  foo?.a?.b?.c; foo?.['a']?.b?.c; foo?.a?.b?.method?.();  foo && foo.a && foo.a.b && foo.a.b.c; foo && foo['a'] && foo['a'].b && foo['a'].b.c; foo && foo.a && foo.a.b && foo.a.b.method && foo.a.b.method();  all   61  @typescript-eslint/prefer-readonly  如果私有成员在构造方法外不会被修改，则应被标记为readonly  class Container { // Public members might be modified externally public publicMember: boolean;  // Protected members might be modified by child classes protected protectedMember: number;  // This is modified later on by the class private modifiedLater = 'unchanged';  public mutate() { this.modifiedLater = 'mutated'; } }  class Container { // These member variables could be marked as readonly private neverModifiedMember = true; private onlyModifiedInConstructor: number;  public constructor( onlyModifiedInConstructor: number, // Private parameter properties can also be marked as readonly private neverModifiedParameter: string, ) { this.onlyModifiedInConstructor = onlyModifiedInConstructor; } }  all   62  @typescript-eslint/prefer-readonly-parameter-types  函数参数应该被标记为readonly以防止被输入值意外修改  function array1(arg: readonly string[]) {} function array2(arg: readonly (readonly string[])[]) {} function array3(arg: readonly [string, number]) {} function array4(arg: readonly [readonly string[], number]) {}  function array1(arg: string[]) {} // array is not readonly function array2(arg: readonly string[][]) {} // array element is not readonly function array3(arg: [string, number]) {} // tuple is not readonly function array4(arg: readonly [string[], number]) {} // tuple element is not readonly  all   63  @typescript-eslint/prefer-reduce-type-parameter  在调用 Array#reduce 而不是强制转换时强制使用类型参数  [1, 2, 3].reduce<number[]>((arr, num) => arr.concat(num * 2), []);  ['a', 'b'].reduce<Record<string, boolean>>( (accum, name) => ({ ...accum, [name]: true, }), {}, );  [1, 2, 3].reduce((arr, num) => arr.concat(num * 2), [] as number[]);  ['a', 'b'].reduce( (accum, name) => ({ ...accum, [name]: true, }), {} as Record<string, boolean>, );  all   64  @typescript-eslint/prefer-regexp-exec  如果未提供全局标记，强制使用RegExp#exec替代String#match  /thing/.exec('something');  'some things are just things'.match(/thing/g);  const text = 'something'; const search = /thing/; search.exec(text);  something'.match(/thing/);  'some things are just things'.match(/thing/);  const text = 'something'; const search = /thing/; text.match(search);  all   65  @typescript-eslint/prefer-string-starts-ends-with  强制使用String#startsWith和String#endsWith替代其它的用于检测子字符串的判同方法  declare const foo: string;  // starts with foo.startsWith('bar');  // ends with foo.endsWith('bar');  declare const foo: string;  // starts with foo[0] === 'b'; foo.charAt(0) === 'b'; foo.indexOf('bar') === 0; foo.slice(0, 3) === 'bar'; foo.substring(0, 3) === 'bar'; foo.match(/^bar/) != null; /^bar/.test(foo);  // ends with foo[foo.length - 1] === 'b'; foo.charAt(foo.length - 1) === 'b'; foo.lastIndexOf('bar') === foo.length - 3; foo.slice(-3) === 'bar'; foo.substring(foo.length - 3) === 'bar'; foo.match(/bar$/) != null; /bar$/.test(foo);  all   66  @typescript-eslint/prefer-ts-expect-error  强制使用@ts-expect-error替代@ts-ignore  // @ts-expect-error const str: string = 1;  /** * Explaining comment * * @ts-expect-error */ const multiLine: number = 'value';  /** @ts-expect-error */ const block: string = 1;  const isOptionEnabled = (key: string): boolean => { // @ts-expect-error: if key isn't in globalOptions it'll be undefined which is false return !!globalOptions[key]; };  // @ts-ignore const str: string = 1;  /** * Explaining comment * * @ts-ignore */ const multiLine: number = 'value';  /** @ts-ignore */ const block: string = 1;  const isOptionEnabled = (key: string): boolean => { // @ts-ignore: if key isn't in globalOptions it'll be undefined which is false return !!globalOptions[key]; };  all   67  @typescript-eslint/promise-function-async  任何返回Promise的函数或方法都要添加async标记  const arrowFunctionReturnsPromise = async () => Promise.resolve('value');  async function functionReturnsPromise() { return Promise.resolve('value'); }  const arrowFunctionReturnsPromise = () => Promise.resolve('value');  function functionReturnsPromise() { return Promise.resolve('value'); }  all   68  @typescript-eslint/require-array-sort-compare  要求Array#sort调用必须提供一个compareFunction  const array: any[]; const userDefinedType: { sort(): void };  array.sort((a, b) => a - b); array.sort((a, b) => a.localeCompare(b));  userDefinedType.sort();  const array: any[]; const stringArray: string[];  array.sort();  // String arrays should be sorted using `String#localeCompare`. stringArray.sort();  all   69  @typescript-eslint/restrict-plus-operands  要求两个加法操作数的类型相同，且必须是“bigint”、“number”或“string”  var foo = parseInt('5.5', 10) + 10; var foo = 1n + 1n;  var foo = '5.5' + 5; var foo = 1n + 1;  all   70  @typescript-eslint/restrict-template-expressions  强制模板字面量表达式为string类型  const arg = 'foo'; const msg1 = `arg = ${arg}`; const msg2 = `arg = ${arg || 'default'}`;  const stringWithKindProp: string & { _kind?: 'MyString' } = 'foo'; const msg3 = `stringWithKindProp = ${stringWithKindProp}`;  const arg1 = [1, 2]; const msg1 = `arg1 = ${arg1}`;  const arg2 = { name: 'Foo' }; const msg2 = `arg2 = ${arg2 || null}`;  all   71  @typescript-eslint/strict-boolean-expressions  布尔表达式中禁用特殊类型  // Using logical operator short-circuiting is allowed const Component = () => { const entry = map.get('foo') || {}; return entry && <p>Name: {entry.name}</p>; };  // nullable values should be checked explicitly against null or undefined let num: number | undefined = 0; if (num != null) { console.log('num is defined'); }  // nullable numbers are considered unsafe by default let num: number | undefined = 0; if (num) { console.log('num is defined'); }  // nullable strings are considered unsafe by default let str: string | null = null; if (!str) { console.log('str is empty'); }  all   72  @typescript-eslint/switch-exhaustiveness-check  要求switch-case语句以union类型结束  type Day = | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Sunday';  const day = 'Monday' as Day; let result = 0;  switch (day) { case 'Monday': result = 1; break; default: result = 42; }  type Day = | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Sunday';  const day = 'Monday' as Day; let result = 0;  switch (day) { case 'Monday': result = 1; break; }  all   73  @typescript-eslint/triple-slash-reference  禁止某些支持 ES6 样式导入声明的三重斜杠指令  -  /// <reference path="foo" /> /// <reference types="bar" /> /// <reference lib="baz" />  all   74  @typescript-eslint/type-annotation-spacing  类型注解需保持前后间距一致  let foo: string = "bar";  function foo(): string {}  class Foo { name: string; }  type Foo = () => {};  let foo:string = "bar"; let foo :string = "bar"; let foo : string = "bar";  function foo():string {} function foo() :string {} function foo() : string {}  all   75  @typescript-eslint/typedef  要求在特定位置使用类型注解  const [a]: number[] = [1]; const [b]: [number] = [2]; const [c, d]: [boolean, string] = [true, 'text'];  const [a] = [1]; const [b, c] = [1, 2];  all   76  @typescript-eslint/unbound-method  强制未绑定方法在其预期范围内被调用  class MyClass { public logUnbound(): void { console.log(this); }  public logBound = () => console.log(this); }  const instance = new MyClass();  // logBound will always be bound with the correct scope const { logBound } = instance; logBound();  // .bind and lambdas will also add a correct scope const dotBindLog = instance.logBound.bind(instance); const innerLog = () => instance.logBound();  class MyClass { public log(): void { console.log(this); } }  const instance = new MyClass();  // This logs the global scope (`window`/`global`), not the class instance const myLog = instance.log; myLog();  // This log might later be called with an incorrect scope const { log } = instance;  all   77  @typescript-eslint/unified-signatures  禁止两个可以通过union或可选参数合二为一的重载  function x(x: number | string): void;  function y(...x: number[]): void;  function x(x: number): void; function x(x: string): void;  function y(): void; function y(...x: number[]): void;  all   78  @typescript-eslint/brace-style  大括号风格  if (foo) { bar(); } else { baz(); }  if (foo) { bar(); } else { baz(); }  all   79  @typescript-eslint/comma-dangle  逗号风格  var foo = { bar: "baz", qux: "quux" };  foo({ bar: "baz", qux: "quux", });  all   80  @typescript-eslint/comma-spacing  逗号前后空格  var foo = 1, bar = 2 , baz = 3; var arr = [1, 2]; var arr = [1,, 3] var obj = {"foo": "bar", "baz": "qur"};  var foo = 1 ,bar = 2; var arr = [1 , 2]; var obj = {"foo": "bar" ,"baz": "qur"};  all   81  @typescript-eslint/default-param-last  缺省参数放在最后  function f(a = 0) {} function f(a: number, b = 0) {} function f(a: number, b?: number) {} function f(a: number, b?: number, c = 0) {}  function f(a = 0, b: number) {} function f(a: number, b = 0, c: number) {} function f(a: number, b?: number, c: number) {}  all   82  @typescript-eslint/dot-notation  强制使用点符号访问对象属性  var x = foo.bar;  var x = foo["bar"];  all   83  @typescript-eslint/func-call-spacing  方法调用时方法名和括号之间的空格  fn();  fn ();  fn ();  all   84  @typescript-eslint/init-declarations  变量声明时初始化  function foo() { var bar = 1; let baz = 2; const qux = 3; }  function foo() { var bar; let baz; }  all   85  @typescript-eslint/keyword-spacing  关键字前后的空格  if (foo) { //... } else if (bar) { //... } else { //... }  if (foo) { //... }else if (bar) { //... }else { //... }  all   86  @typescript-eslint/lines-between-class-members  类成员之间使用空行分隔  class MyClass { x;  foo() { //... }  bar() { //... } }  class MyClass { x; foo() { //... } bar() { //... } }  all   87  @typescript-eslint/no-array-constructor  不要使用原始的Array构造方法（要带泛型）  Array<number>(0, 1, 2); new Array<Foo>(x, y, z);  Array(500); new Array(someOtherArray.length);  Array(0, 1, 2); new Array(0, 1, 2);  all   88  @typescript-eslint/no-dupe-class-members  重复的类成员声明（后面的声明会覆盖前面的）  class Foo { bar() { } qux() { } }  class Foo { bar() { } bar() { } }  all   89  @typescript-eslint/no-duplicate-imports  同一个模块多次import  import { AValue, type AType, type BType } from './mama-mia'  import { AValue, type AType } from './mama-mia' import type { BType } from './mama-mia'  all   90  @typescript-eslint/no-empty-function  空方法体  function foo() { // do nothing. }  var foo = function() { // any clear comments. };  var foo = () => { bar(); };  function foo() {}  var foo = function() {};  var foo = () => {};  all   91  @typescript-eslint/no-extra-parens  无额外的运算符优先级括号  (0).toString();  ({}.toString.call());  (function(){}) ? a() : b();  a = (b * c);  (a * b) + c;  all   92  @typescript-eslint/no-extra-semi  无多余的分号  var x = 5;  function foo() { // code }  var x = 5;;  function foo() { // code };  all   93  @typescript-eslint/no-implied-eval  避免隐含的evel表达式  setTimeout(function () { alert('Hi!'); }, 100);  setInterval(function () { alert('Hi!'); }, 100);  setTimeout('alert(`Hi!`);', 100);  setInterval('alert(`Hi!`);', 100);  all   94  @typescript-eslint/no-invalid-this  不要编写无效的this表达式  this.a = 0; baz(() => this);  function Foo() { // OK, this is in a legacy style constructor. this.a = 0; baz(() => this); }  function foo() { this.a = 0; baz(() => this); }  var foo = function() { this.a = 0; baz(() => this); };  all   95  @typescript-eslint/no-loop-func  不要在循环体中重复创建函数  var a = function() {};  for (var i=10; i; i--) { a(); }  for (var i=10; i; i--) { (function() { return i; })(); }  while(i) { var a = function() { return i; }; a(); }  all   96  @typescript-eslint/no-loss-of-precision  避免数值精度丢失  const x = 12345 const x = 123.456 const x = 123e34  const x = 9007199254740993 const x = 5123000000000000000000000000001 const x = 1230000000000000000000000.0  all   97  @typescript-eslint/no-magic-numbers  避免使用魔鬼数字  var TAX = 0.25;  var dutyFreePrice = 100, finalPrice = dutyFreePrice + (dutyFreePrice * TAX);  var dutyFreePrice = 100, finalPrice = dutyFreePrice + (dutyFreePrice * 0.25);  all   98  @typescript-eslint/no-redeclare  避免重复声明  var a = 3; a = 10;  var a = 3; var a = 10;  all   99  @typescript-eslint/no-shadow  避免变量名隐藏  var a = 3; function b() { var b = 10; }  var a = 3; function b() { var a = 10; }  all   100  @typescript-eslint/no-throw-literal  不要throw字面常量  throw new Error();  throw new Error("error");  const e = new Error("error"); throw e;  throw 'error';  throw 0;  throw undefined;  all   101  @typescript-eslint/no-unused-expressions  避免不可达的表达式  {}  {myLabel: someVar}  function namedFunctionDeclaration () {}  0  if(0) 0  {0}  f(0), {}  all   102  @typescript-eslint/no-unused-vars  避免声明后又不使用的变量  var x = 10; alert(x);  some_unused_var = 42;  var x;  all   103  @typescript-eslint/no-use-before-define  不要在变量定义前使用它们  var a; a = 10; alert(a);  function f() {} f(1);  alert(a); var a = 10;  f(); function f() {}  all   104  @typescript-eslint/no-useless-constructor  不要定义无用的构造方法  class A { }  class A { constructor () { doSomething(); } }  class B extends A { constructor() { super('foo'); } }  class A { constructor () { } }  class B extends A { constructor (...args) { super(...args); } }  all   105  @typescript-eslint/quotes  引号控制：字符串需使用双引号  var double = "double"; var unescaped = "a string containing 'single' quotes";  var single = 'single'; var backtick = `back${x}tick`;  all   106  @typescript-eslint/require-await  避免async修饰的方法中缺失await表达式  async function foo() { await doSomething(); }  bar(async () => { await doSomething(); });  async function foo() { doSomething(); }  bar(async () => { doSomething(); });  all   107  @typescript-eslint/return-await  避免使用非必须的return await  async function foo() { return bar(); }  async function foo() { await bar(); return; }  async function foo() { return await bar(); }  all   108  @typescript-eslint/semi  分号控制  var name = "ESLint";  class Foo { bar = 1; }  var name = "ESLint"  class Foo { bar = 1 }  all   109  @typescript-eslint/space-before-function-paren  方法/函数声明时名称和括号间空格控制  function foo() { // ... }  function foo () { // ... }  all   110  @typescript-eslint/space-infix-ops  运算符前后空格控制  a + b  a       + b  a ? b : c  a+b  a+ b  a +b  a?b:c  all      上一篇 附录 下一篇 通过DevEco Studio编译和上传软件包 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。编译构建 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    编译构建概述  配置编译构建信息  默认开启模块化编译模式  开启AOT编译模式  配置应用的依赖  HAP唯一性校验逻辑  构建闭源HAR  定制多目标构建产物  通过命令行方式构建应用或服务   上一篇 优秀案例 下一篇 编译构建概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用/服务开发 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     编辑器使用技巧  在模块中添加Ability  添加JS Component和Page  开发及引用共享包  定义HarmonyOS IDL接口  创建服务卡片  使用预览器查看应用/服务效果  代码Code Linter检查  代码Quick Fix快速修复  低代码开发  端云一体化开发   上一篇 添加/删除Module 下一篇 编辑器使用技巧 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。通过命令行方式构建应用或服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    命令行构建应用/服务概述  命令行构建应用/服务（API 8-9）  通过命令行方式构建应用或服务（API 4-7）   上一篇 定制多目标构建产物 下一篇 命令行构建应用/服务概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。准备HAP/APP构建环境安装JDK安装node.js下载HarmonyOS SDK配置环境变量检查工程中gradle版本构建应用或服务构建不带签名信息的APP将APP拆分为HAP使用调试证书对HAP进行签名在真机设备中安装HAP使用发布证书为APP签名发布APP参考信息构建不带签名信息的HAP构建携带签名的HAP或APP通过命令行方式构建应用或服务（API 4-7） 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
该功能适用于构建API Version 4至7的HarmonyOS应用/服务。 
 下表是命令行构建HarmonyOS应用或服务依赖的工具版本配套表信息。 工具  版本要求    JDK  JDK 17   Node.js  v14.19.1及以上，且低于v17.0.0   Gradle  7.3   sdkmgr  1.0.0.300及以上版本   编译构建插件  3.0.5.2及以上版本     准备HAP/APP构建环境 安装JDK下载JDK，只支持JDK 17版本。进入JDK软件包目录，执行如下命令，解压已经下载好的安装包，其中jdk-17.0.7_linux-x64_bin.tar.gz为软件包名称，请根据实际进行修改。已复制tar -xvf jdk-17.0.7_linux-x64_bin.tar.gz 配置JDK环境变量。执行如下命令，打开当前用户下的配置文件.bashrc。已复制vim ~/.bashrc 在配置文件中，添加JDK的环境变量信息，文件目录和软件包名称请根据实际情况进行修改。已复制#jdkexport JAVA_HOME=/opt/jdk-17.0.7_linux-x64_binexport PATH=$PATH:$JAVA_HOME/bin  执行source命令使配置文件立即生效。已复制source ~/.bashrc  执行如下命令，检查JDK安装结果。已复制java -version    安装node.js访问Node.js官方网站，下载Node.js，版本要求为v14.19.1及以上，且低于v17.0.0。进入Node.js软件包目录，执行如下命令，解压已经下载好的安装包，其中node-v14.19.1-linux-x64.tar.xz为软件包名称，请根据实际进行修改。已复制tar -xvf node-v14.19.1-linux-x64.tar.xz 配置Node.js环境变量。执行如下命令，打开当前用户下的配置文件.bashrc。已复制vim ~/.bashrc  在配置文件中，添加Node.js的环境变量信息，文件目录和软件包名称请根据实际情况进行修改。已复制#nodejsexport NODE_HOME=/opt/node-v14.19.1-linux-x64export PATH=$NODE_HOME/bin:$PATH  执行source命令使配置文件立即生效。已复制source ~/.bashrc   执行如下命令，检查Node.js安装结果。已复制node -v   下载HarmonyOS SDK通过sdkmgr命令行工具来统一下载和管理HarmonyOS SDK。 下载HarmonyOS SDK命令行工具：command-line-tools.zip执行如下命令，解压命令行工具，工具名称请根据实际情况进行修改。已复制unzip command-line-tools.zip 执行如下命令，打开SDK工具配置文件config.properties，并设置HarmonyOS SDK存储路径，请注意，指定HarmonyOS路径时请使用绝对路径。
说明
HarmonyOS SDK存储目录请提前创建好，并为当前用户赋予写权限。 
 已复制vim command-line-tools/sdkmanager/conf/config.properties  进入到command-line-tools/sdkmanager/bin下，安装HarmonyOS SDK。例如，同时安装Java和Js API 6的SDK、toolchains。关于sdkmgr的详细命令说明，请参考命令行工具使用说明。已复制./sdkmgr install java:6 js:6 toolchains --accept-license   配置环境变量配置HDC命令行工具和HarmonyOS SDK以及的环境变量信息。其中： HDC命令行工具用于HarmonyOS应用/服务调试所需的工具，该工具存放在SDK的toolchains目录中。为方便使用HDC命令行工具，请将其添加到环境变量中。HarmonyOS SDK中包含JS、Java、ArkTS及Native SDK（C/C++），如果工程中涉及C/C++，还需要单独设置Native SDK环境变量。 执行如下命令，打开当前用户下的配置文件.bashrc。已复制vim ~/.bashrc 在配置文件中，添加HDC工具、HarmonyOS SDK和Native SDK的环境变量信息，文件目录和软件包名称请根据实际情况进行修改。已复制#HDC工具环境变量export HDC_HOME=/opt/HarmonyOS/SDK/toolchainsexport PATH=$PATH:$HDC_HOME#如果工程中涉及C/C++，才需要设置，需要注意的是，设置Native环境变量的路径，需要设置到版本号层级。export OHOS_NATIVE_HOME=/opt/HarmonyOS/SDK/native/2.1.1.21#编译构建插件版本是3.0.3.2及后续版本，请配置如下环境变量export HOS_SDK_HOME=/opt/HarmonyOS/SDK#编译构建插件版本是2.4.5.5及以前版本，请配置如下环境变量export OHOS_SDK_HOME=/opt/HarmonyOS/SDK 执行source命令使配置文件立即生效。已复制source ~/.bashrc     检查工程中gradle版本当前配套的gradle版本为7.3版本，在进行构建HAP或APP前，应确认工程中对应的gradle版本是否正确。检查和修改方法如下： 打开命令行工具，请在工程根目录下执行如下命令，查看distributionUrl中指引的gradle版本号。 已复制vim gradle/wrapper/gradle-wrapper.properties 如果gradle版本不是7.3版本，请修改为7.3，gradle的Url可以设置为Web端下载路径、也可以设置为本地路径。 图1 下载路径方式 图2 本地路径方式  构建应用或服务通过命令行工具可以构建出HAP或APP包，用于应用或服务的测试、上架等。 如下图所示，一般通过CI流水线构建生成不带签名信息的APP，然后通过命令行工具将该APP包拆分为HAP并对HAP进行签名（调试签名），最后将签名后的HAP部署到设备上进行测试；HAP测试完成后，可使用签名工具对APP进行签名（发布签名），用于将HarmonyOS应用发布到AGC（AppGallery Connect）或者将元服务发布到HAG（HUAWEI Ability Gallery）。   构建不带签名信息的APP构建不带签名信息APP，请在工程根目录下执行如下命令：
说明
执行gradlew任务，需要具备执行权限，如果没有权限，可执行chmod u+x gradlew添加权限。 
 已复制./gradlew packageReleaseApp   将APP拆分为HAP将APP（带签名信息和不带签名信息APP均可）拆包为HAP，需要使用APP拆包工具hmos_app_unpacking_tool.jar进行拆包： 
说明
也可以直接使用命令行工具构建HAP，具体请参考构建不带签名信息的HAP。 
 已复制java -jar 'home/harmonyos/HarmonyOS/APP/hmos_app_unpacking_tool.jar' --mode app --app-path 'home/harmonyos/HarmonyOS/APP/harmonyos-demo.app' --out-path 'home/harmonyos/HarmonyOS/HAP' --force true --unpackapk false 关于该命令中需要修改的参数说明如下，其余参数不需要修改： jar：指定APP拆包工具。app-path：指定需要拆分的APP包。out-path：指定HAP存储路径，该路径不能与APP包存放路径相同。force：取值为true，表示强制删除输出文件夹中的所有文件。  使用调试证书对HAP进行签名通过APP拆包获得的HAP，无论APP是否签名，HAP都不会携带签名信息，因此要在真机设备上运行HAP，需要使用命令行工具对HAP进行签名。同时，需要提前申请签名所需文件，具体请参考申请调试证书。 下载HAP签名工具hapsigntoolv2.jar。使用如下命令对HAP进行签名。已复制java -jar 'home/harmonyos/HarmonyOS/APP/hapsigntoolv2.jar' sign -mode localjks -privatekey harmonyos-demo -inputFile 'home/harmonyos/HarmonyOS/APP/unsign-harmonyos-demo.hap' -outputFile 'home/harmonyos/HarmonyOS/APP/sign-harmonyos-demo.hap' -signAlg SHA256withECDSA -keystore harmonyos-demo-debug.p12 -keystorepasswd ab123456 -keyaliaspasswd ab123456 -profile harmonyos-demo-debug.p7b -certpath harmonyos-demo-debug.cer -profileSigned 1 关于该命令中需要修改的参数说明如下，其余参数不需要修改： privatekey：密钥的别名信息，与创建密钥库文件时“Alias”取值保持一致。inputFile：需要签名的HAP名称。outputFile：签名后的HAP名称。keystore：密钥库文件，格式为.p12。keystorepasswd：密钥库密码。keyaliaspasswd：密钥密码。profile：申请的调试Profile文件，格式为.p7b。certpath：申请的调试证书文件，格式为.cer。   在真机设备中安装HAP通过HDC工具将HAP推送到真机设备上进行安装，需要注意的是，推送的HAP必须是携带签名信息的，否则会导致HAP安装失败。 推送单个HAP的命令如下：已复制hdc app install signed_entry-release-rich.hap 推送多个HAP的命令如下：已复制hdc app install-multiple --hap xxx01.hap xxx02.hap xxx03.hap   使用发布证书为APP签名HAP测试完成后便可以启动上架，将HarmonyOS应用发布到AGC或者将元服务发布到HAG。在上架APP前，需要使用发布证书对APP进行签名，可以使用hapsigntoolv2.jar工具对未签名的APP包进行签名。 在使用命令行工具进行APP包签名前，需要提前申请签名所需文件，具体请参考申请发布证书。 使用如下命令对APP进行签名。已复制java -jar 'home/harmonyos/HarmonyOS/APP/hapsigntoolv2.jar' sign -mode localjks -privatekey harmonyos-demo -inputFile 'home/harmonyos/HarmonyOS/APP/unsign-harmonyos-demo.app' -outputFile 'home/harmonyos/HarmonyOS/APP/sign-harmonyos-demo.app' -signAlg SHA256withECDSA -keystore harmonyos-demo-release.p12 -keystorepasswd ab123456 -keyaliaspasswd ab123456 -profile harmonyos-demo-release.p7b -certpath harmonyos-demo-release.cer -profileSigned 1  关于该命令中需要修改的参数说明如下，其余参数不需要修改： privatekey：密钥的别名信息，与创建密钥库文件时“Alias”取值保持一致。inputFile：需要签名的HAP名称。outputFile：签名后的HAP名称。keystore：密钥库文件，格式为.p12。keystorepasswd：密钥库密码。keyaliaspasswd：密钥密码。profile：申请的调试Profile文件，格式为.p7b。certpath：申请的调试证书文件，格式为.cer。  发布APP使用发布证书签名后的APP可用于上架。 HarmonyOS应用：发布到AGC（AppGallery Connect），具体请参考发布HarmonyOS应用指导。元服务：发布到HAG（HUAWEI Ability Gallery），具体请参考发布元服务指导。  参考信息 构建不带签名信息的HAP使用命令行工具，也可以直接构建出HAP，可以通过如下命令构建debug类型和release类型的HAP。如果需要构建携带签名信息的HAP，请参考构建携带签名的HAP或APP。 构建debug类型的HAP，请在工程根目录下执行如下命令：已复制./gradlew assembleDebug 构建release类型的HAP，请在工程根目录下执行如下命令：已复制./gradlew assembleRelease   构建携带签名的HAP或APP要想直接构建出带签名信息的APP或HAP，您也可以提前将签名信息配置到工程中的build.gradle文件中，然后再调用构建命令生成APP或HAP。 使用在工程build.gradle中签名方案时，由于“storePassword”和“keyPassword”不支持明文密码，需要使用DevEco Studio签名后，将签名相关文件（包括p12、p7b、cer文件及material文件夹）拷贝至Ubuntu服务器中，再配置签名信息。  将签名文件拷贝到Ubuntu服务器后，打开工程级build.gradle文件，在ohos闭包中，添加如下代码块。已复制ohos {    signingConfigs {        debug {   //签名类型，调试HAP使用debug，APP使用Release            storeFile file('storefile-file.p12')            storePassword 'storepassword'            keyAlias = 'alias'            keyPassword  'keypassword'            signAlg = 'SHA256withECDSA'            profile file('profile-file.p7b')            certpath file('certpath-file.cer')        }    }    ...} 使用命令行工具构建HAP或APP。构建debug类型的HAP。已复制./gradlew assembleDebug 构建release类型的HAP。已复制./gradlew assembleRelease 构建APP。已复制./gradlew signReleaseApp      上一篇 命令行构建应用/服务（API 8-9） 下一篇 应用/服务运行 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。准备HAP/APP构建环境安装node.js配置NPM安装JDK下载命令行工具下载HarmonyOS SDK配置SDK环境变量安装ohpm构建应用或服务工程构建（API 9工程）工程构建（API 8工程）将APP拆分为HAP对HAP进行签名在真机设备中安装HAP使用发布证书为APP签名发布APP命令行构建应用/服务（API 8-9） 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
该功能适用于构建API Version 8-9及以上版本的应用/服务。API 9中使用了全新的hvigorw的方式，用于执行hvigor相关的命令行，与API 8中使用npm script的方式执行有区别。 
 下表是命令行构建应用或服务依赖的工具版本配套表信息。 工具  API 9 版本要求  API 8 版本要求    JDK  JDK 17  JDK 17   Node.js  v14.19.1及以上，且低于v17.0.0  v14.19.1及以上，且低于v17.0.0   Hvigor  2.0.0及以上  1.0.6及以上   编译构建插件  2.0.0及以上  1.0.6及以上   sdkmgr  1.0.0.100及以上  1.0.0.100及以上     准备HAP/APP构建环境 安装node.js访问Node.js官方网站，下载Node.js，版本要求为v14.19.1及以上，且低于v17.0.0。进入Node.js软件包目录，执行如下命令，解压已经下载好的安装包，其中node-v14.19.1-linux-x64.tar.xz为软件包名称，请根据实际进行修改。已复制tar -xvf node-v14.19.1-linux-x64.tar.xz 配置Node.js环境变量。执行如下命令，打开当前用户下的配置文件.bashrc。已复制vim ~/.bashrc  在配置文件中，添加Node.js的环境变量信息，文件目录和软件包名称请根据实际情况进行修改。已复制#nodejsexport NODE_HOME=/opt/node-v14.19.1-linux-x64export PATH=$NODE_HOME/bin:$PATH  执行source命令使配置文件立即生效。已复制source ~/.bashrc   执行如下命令，查询Node.js版本信息，确认安装成功。已复制node -v    配置NPMHvigor下载相关的依赖包需要从对应的npm仓库下载，遵循和使用npm的配置管理机制，因此在命令行构建的场景下也需要在.npmrc中配置相关仓库地址。 Hvigor构建依赖于网络环境，需要连接上网络才能确保工具的正常使用。 一般来说，如果使用的是个人或家庭网络，是不需要配置代理信息的，只有部分企业网络受限的情况下，才需要配置代理信息。 配置NPM仓库 npm仓库信息配置在当前用户目录下的.npmrc文件中。npm registry：配置npm仓的地址信息。ohos registry：HarmonyOS npm三方包共享仓。  打开一个命令行窗口。执行命令设置npm仓库信息，示例如下所示：已复制npm config set registry=https://repo.huaweicloud.com/repository/npm/npm config set @ohos:registry=https://repo.harmonyos.com/npm/ 仓库信息配置完成后，执行如下命令验证配置是否正常。已复制npm config get @ohos:registry 执行结果如下图所示，则说明仓库设置成功。   仓库设置完成后，如果网络访问受限，还需设置代理。 配置NPM代理 在Terminal里，执行命令设置npm代理信息，具体取值请以实际代理信息为准。示例如下所示：已复制npm config set proxy=http://user:password@proxy.server.com:portnpm config set https-proxy=http://user:password@proxy.server.com:port 
说明
如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下： !：%21@：%40#：%23$：%24&：%26*：%2A 
 代理配置完成后，打开命令行工具，执行如下命令验证网络是否正常。已复制npm info express 执行结果如下图所示，则说明代理设置成功。     安装JDK下载JDK，只支持JDK 17版本。进入JDK软件包目录，执行如下命令，解压已经下载好的安装包，其中jdk-17.0.6_linux-x64_bin.tar.gz为软件包名称，请根据实际进行修改。已复制tar -xvf jdk-17.0.6_linux-x64_bin.tar.gz 配置JDK环境变量。执行如下命令，打开当前用户下的配置文件.bashrc。已复制vim ~/.bashrc 在配置文件中，添加JDK的环境变量信息，文件目录和软件包名称请根据实际情况进行修改。已复制#jdkexport JAVA_HOME=/opt/jdk-17.0.6_linux-x64_binexport PATH=$PATH:$JAVA_HOME/bin  执行source命令使配置文件立即生效。已复制source ~/.bashrc  执行如下命令，检查JDK安装结果。已复制java -version    下载命令行工具下载命令行工具：command-line-tools.zip执行如下命令，解压命令行工具，工具名称请根据实际情况进行修改。已复制unzip command-line-tools.zip    下载HarmonyOS SDK通过sdkmgr命令行工具来统一下载和管理HarmonyOS SDK。 执行如下命令，打开SDK工具配置文件config.properties，并设置HarmonyOS SDK存储路径，请注意，指定路径时请使用绝对路径。
说明
HarmonyOS SDK存储目录请提前创建好，并为当前用户赋予写权限。 
 已复制vim command-line-tools/sdkmanager/conf/config.properties  进入到command-line-tools/sdkmanager/bin下，安装HarmonyOS SDK。例如，同时安装ArkTS和JS API 9的SDK、Toolchains。已复制./sdkmgr install OpenHarmony/ets:9 OpenHarmony/js:9 OpenHarmony/toolchains:9 toolchains:9 --accept-license    配置SDK环境变量配置hdc命令行工具和HarmonyOS SDK以及的环境变量信息。其中： hdc命令行工具用于HarmonyOS应用/服务调试所需的工具，该工具存放在SDK的toolchains目录中。为方便使用hdc命令行工具，请将其添加到环境变量中。HarmonyOS SDK中包含ArkTS、JS和Native SDK，以及toolchains工具链。 执行如下命令，打开当前用户下的配置文件.bashrc。已复制vim ~/.bashrc 在配置文件中，添加hdc工具、HarmonyOS SDK环境变量信息，文件目录和软件包名称请根据实际情况进行修改。已复制#HDC工具环境变量export HDC_HOME=/opt/HarmonyOS/SDK/toolchainsexport PATH=$PATH:$HDC_HOME#如果工程中涉及C/C++，才需要设置，需要注意的是，设置Native环境变量的路径，需要设置到版本号层级。export OHOS_NATIVE_HOME=/opt/HarmonyOS/SDK/native/2.1.1.21#编译构建插件版本是3.0.3.2及后续版本，请配置如下环境变量export HOS_SDK_HOME=/opt/HarmonyOS/SDK#编译构建插件版本是2.4.5.5及以前版本，请配置如下环境变量export OHOS_SDK_HOME=/opt/HarmonyOS/SDK 执行source命令使配置文件立即生效。已复制source ~/.bashrc     安装ohpm输入如下指令定义ohpm所在路径，其中TOOLS_INSTALL_DIR为上述命令行工具解压后所得目录路径。已复制OHPM_HOME=${TOOLS_INSTALL_DIR}/command-line-tools/ohpm 初始化ohpm，指令如下。已复制${OHPM_HOME}/bin/init 添加ohpm到环境变量，指令如下。已复制export PATH=${OHPM_HOME}/bin:${PATH} 执行如下命令，查询ohpm版本信息，确认安装成功。已复制ohpm -v 配置仓库地址（可指定多个地址，','号分割），指令如下。已复制ohpm config set registry https://ohpm.openharmony.cn/ohpm/     ohpm config set strict_ssl false   构建应用或服务通过命令行工具可以构建出HAP或APP包，用于应用或服务的测试、验证等。 如下图所示，一般通过CI流水线构建生成不带签名信息的APP，然后通过命令行工具将该APP包拆分为HAP并对HAP进行签名（调试签名），最后将签名后的HAP部署到设备上进行测试。  当然，您也可以直接构建HAP，然后再使用命令行工具对HAP进行签名后，将签名后的HAP部署到设备上进行测试。  命令行模式下，使用hvigor执行编译构建打包，命令行没有变化，执行方式与API 8工程有所区别，具体区别如下: 工程构建（API 9工程）API 9中使用命令行方式构建APP，与API 8有所区别，可以直接使用项目中自带的hvigorw的脚本来进行构建。 在工程的根目录节点下，执行如下命令运行hvigor的构建任务。
说明
从API 9开始，Hvigor 支持了daemon模式，并且会默认开启。 如果由于daemon导致了CI执行的不稳定, 您可以禁用它，以便在在每次构建时都使用一个全新的运行时环境。 
 打包APP的命令：已复制./hvigorw clean assembleApp --no-daemon 
说明
如果执行构建任务命令提示“Permission denied:./hvigorw”权限受限，则需要在当前工程目录下，执行chmod u+x ./hvigorw命令，为hvigorw工具赋权。 
  等待任务执行完毕后，可以在工程的build/outputs/default目录下获取构建的APP包。 打包HAP的命令： 已复制./hvigorw clean assembleHap --no-daemon 在各模块下的build/default/outputs/default目录下获取构建的HAP。   工程构建（API 8工程）API 8工程执行clean和打包app时，主要使用以下方式： 在工程的package.json的scripts中，定义构建任务脚本。其中任务名称buildOhosApp可以自定义，调用的构建任务clean assembleApp保持不变。已复制"scripts": {    "buildOhosApp": "hvigor clean assembleApp"}, 在工程的根目录节点下，执行npm install命令安装工程的依赖。已复制npm install 在工程的根目录节点下，执行如下命令运行上述步骤中定义的构建任务。已复制npm run buildOhosApp   将APP拆分为HAP将APP（带签名信息和不带签名信息APP均可）拆包为HAP，需要使用APP拆包工具hmos_app_unpacking_tool.jar进行拆包： 已复制java -jar 'home/harmonyos/HarmonyOS/APP/hmos_app_unpacking_tool.jar' --mode app --app-path 'home/harmonyos/HarmonyOS/APP/harmonyos-demo.app' --out-path 'home/harmonyos/HarmonyOS/HAP' --force true --unpackapk false 关于该命令中需要修改的参数说明如下，其余参数不需要修改： jar：指定APP拆包工具。app-path：指定需要拆分的APP包。out-path：指定HAP存储路径，该路径不能与APP包存放路径相同。force：取值为true，表示强制删除输出文件夹中的所有文件。  对HAP进行签名通过hvigor打包生成的HAP不会携带签名信息，如果要在真机设备上运行HAP，需要使用命令行工具对HAP进行签名。 准备好HAP签名工具hap_sign_tool.jar（在${HOS_SDK_HOME}/openharmony/9/toolchains/lib下）。准备好申请签名所需3个文件：密钥（.p12文件）、数字证书（.cer文件）、Profile（.p7b文件），具体请参考手动签名。使用如下命令对HAP进行签名。已复制java -jar hap-sign-tool.jar sign-app -keyAlias "key0" -signAlg "SHA256withECDSA" -mode "localSign" -appCertFile "test.cer" -profileFile "test.p7b" -inFile "hap-unsigned.hap" -keystoreFile "test.p12" -outFile "result\hap-signed.hap" -keyPwd "123456" -keystorePwd "123456" 关于该命令中需要修改的参数说明如下，其余参数不需要修改： keyAlias：密钥别名。appCertFile：申请的调试证书文件，格式为.cer。profileFile：申请的调试Profile文件，格式为.p7b。inFile：通过hvigor打包生成的未携带签名信息的HAP。keystoreFile：密钥库文件，格式为.p12。outFile：经过签名后生成的携带签名信息的HAP。keyPwd：密钥口令。keystorePwd：密钥库口令。   在真机设备中安装HAP通过HDC工具将HAP推送到真机设备上进行安装，需要注意的是，推送的HAP必须是携带签名信息的，否则会导致HAP安装失败。 推送HAP的命令如下：已复制hdc app install signed_entry-release-rich.hap   使用发布证书为APP签名HAP测试完成后便可以启动上架，将HarmonyOS应用发布到AGC或者将元服务发布到HAG。在上架APP前，需要使用发布证书对APP进行签名，可以使用hapsigntoolv2.jar工具对未签名的APP包进行签名。 在使用命令行工具进行APP包签名前，需要提前申请签名所需文件，具体请参考申请发布证书。 使用如下命令对APP进行签名。已复制java -jar 'home/harmonyos/HarmonyOS/APP/hapsigntoolv2.jar' sign -mode localjks -privatekey harmonyos-demo -inputFile 'home/harmonyos/HarmonyOS/APP/unsign-harmonyos-demo.app' -outputFile 'home/harmonyos/HarmonyOS/APP/sign-harmonyos-demo.app' -signAlg SHA256withECDSA -keystore harmonyos-demo-release.p12 -keystorepasswd ab123456 -keyaliaspasswd ab123456 -profile harmonyos-demo-release.p7b -certpath harmonyos-demo-release.cer -profileSigned 1  关于该命令中需要修改的参数说明如下，其余参数不需要修改： privatekey：密钥的别名信息，与创建密钥库文件时“Alias”取值保持一致。inputFile：需要签名的HAP名称。outputFile：签名后的HAP名称。keystore：密钥库文件，格式为.p12。keystorepasswd：密钥库密码。keyaliaspasswd：密钥密码。profile：申请的调试Profile文件，格式为.p7b。certpath：申请的调试证书文件，格式为.cer。  发布APP使用发布证书签名后的APP可用于上架。 HarmonyOS应用：发布到AGC（AppGallery Connect），具体请参考发布HarmonyOS应用指导。元服务：发布到HAG（HUAWEI Ability Gallery），具体请参考发布元服务指导。   上一篇 命令行构建应用/服务概述 下一篇 通过命令行方式构建应用或服务（API 4-7） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。命令行构建应用/服务概述 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 除了使用DevEco Studio一键式构建应用/服务外，还可以使用命令行工具来调用Hvigor任务进行构建。通过命令行的方式构建应用或服务，可用于构筑CI（Continuous Integration）持续集成流水线，按照计划时间自动化的构建HAP、APP、签名、安装部署等操作，降低开发者负担。 通过命令行方式构建应用或服务，可在Windows、Ubuntu和macOS下调用相应命令来执行，本文将以Ubuntu系统为例进行讲解，包括准备构建环境、构建HAP、构建APP、签名等操作。Windows和macOS系统，仅在搭建构建环境上存在差异，其余调用的命令行任务与Ubuntu系统没有区别。 通过命令行方式构建应用/服务在不同API版本工程有所区别，请根据工程的API版本号参考不同章节的指导。  上一篇 通过命令行方式构建应用或服务 下一篇 命令行构建应用/服务（API 8-9） 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。命令行工具 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     bytrace使用指导  SDK管理使用指导  codelinter使用指导  ohpm使用指导  hdc使用指导  hvigor命令行   上一篇 HarmonyOS应用/服务发布 下一篇 bytrace使用指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。公共事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 请参见Stage模型的"公共事件"。  上一篇 进程模型概述 下一篇 线程模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。公共事件简介 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  HarmonyOS通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力。 公共事件从系统角度可分为：系统公共事件和自定义公共事件。  系统公共事件：CES内部定义的公共事件，只有系统应用和系统服务才能发布，例如HAP安装，更新，卸载等公共事件。目前支持的系统公共事件详见系统公共事件定义。 自定义公共事件：应用自定义一些公共事件用来实现跨进程的事件通信能力。  公共事件按发送方式可分为：无序公共事件、有序公共事件和粘性公共事件。  无序公共事件：CES转发公共事件时，不考虑订阅者是否接收到，且订阅者接收到的顺序与其订阅顺序无关。 有序公共事件：CES转发公共事件时，根据订阅者设置的优先级等级，优先将公共事件发送给优先级较高的订阅者，等待其成功接收该公共事件之后再将事件发送给优先级较低的订阅者。如果有多个订阅者具有相同的优先级，则他们将随机接收到公共事件。 粘性公共事件：能够让订阅者收到在订阅前已经发送的公共事件就是粘性公共事件。普通的公共事件只能在订阅后发送才能收到，而粘性公共事件的特殊性就是可以先发送后订阅。发送粘性事件必须是系统应用或系统服务，且需要申请ohos.permission.COMMONEVENT_STICKY权限，配置方式请参阅访问控制授权申请指导。  每个应用都可以按需订阅公共事件，订阅成功，当公共事件发布时，系统会将其发送给对应的应用。这些公共事件可能来自系统、其他应用和应用自身。 图1 公共事件示意图   上一篇 公共事件 下一篇 公共事件订阅 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明发布不携带信息的公共事件发布携带信息的公共事件公共事件发布 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 当需要发布某个自定义公共事件时，可以通过publish()方法发布事件。发布的公共事件可以携带数据，供订阅者解析并进行下一步处理。 
注意
 已发出的粘性公共事件后来订阅者也可以接收到，其他公共事件都需要先订阅再接收，订阅参考公共事件订阅章节。 
   接口说明 详细接口见接口文档。     接口名 接口描述    publish(event: string, callback: AsyncCallback) 发布公共事件。   publish(event: string, options: CommonEventPublishData, callback: AsyncCallback) 指定发布信息并发布公共事件。      发布不携带信息的公共事件 不携带信息的公共事件，只能发布无序公共事件。  导入模块。 已复制import commonEventManager from '@ohos.commonEventManager'; 传入需要发布的事件名称和回调函数，发布事件。 已复制// 发布公共事件commonEventManager.publish("usual.event.SCREEN_OFF", (err) => {    if (err) {        console.error(`[CommonEvent] PublishCallBack err=${JSON.stringify(err)}`);    } else {        console.info(`[CommonEvent] Publish success`);    }})    发布携带信息的公共事件 携带信息的公共事件，可以发布为无序公共事件、有序公共事件和粘性事件，可以通过参数CommonEventPublishData的isOrdered、isSticky的字段进行设置。  导入模块。 已复制import commonEventManager from '@ohos.commonEventManager'; 传入需要发布的事件名称和回调函数，发布事件。 已复制// 公共事件相关信息let options = {    code: 1, // 公共事件的初始代码    data: "initial data", // 公共事件的初始数据} 传入需要发布的事件名称、需要发布的指定信息和回调函数，发布事件。 已复制// 发布公共事件commonEventManager.publish("custom_event", options, (err) => {    if (err) {        console.error('[CommonEvent] PublishCallBack err=' + JSON.stringify(err));    } else {        console.info('[CommonEvent] Publish success')    }})    上一篇 取消动态订阅公共事件 下一篇 线程模型 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤动态订阅公共事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 动态订阅是指当应用在运行状态时对某个公共事件进行订阅，在运行期间如果有订阅的事件发布那么订阅了这个事件的应用将会收到该事件及其传递的参数。例如，某应用希望在其运行期间收到电量过低的事件，并根据该事件降低其运行功耗，那么该应用便可动态订阅电量过低事件，收到该事件后关闭一些非必要的任务来降低功耗。订阅部分系统公共事件需要先申请权限，订阅这些事件所需要的权限请见公共事件权限列表。   接口说明 详细接口见接口文档。     接口名 接口描述    createSubscriber(subscribeInfo: CommonEventSubscribeInfo, callback: AsyncCallback<CommonEventData>): void 创建订阅者对象(callback)   createSubscriber(subscribeInfo: CommonEventSubscribeInfo): Promise<CommonEventSubscriber> 创建订阅者对象(promise)   subscribe(subscriber: CommonEventSubscriber, callback: AsyncCallback): void 订阅公共事件      开发步骤  导入模块。 已复制import commonEventManager from '@ohos.commonEventManager'; import Base from '@ohos.base';          创建订阅者信息，详细的订阅者信息数据类型及包含的参数请见CommonEventSubscribeInfo文档介绍。        已复制// 用于保存创建成功的订阅者对象，后续使用其完成订阅及退订的动作let subscriber: commonEventManager.CommonEventSubscriber | null = null;// 订阅者信息let subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {  events: ["usual.event.SCREEN_OFF"], // 订阅灭屏公共事件}  创建订阅者，保存返回的订阅者对象subscriber，用于执行后续的订阅、退订等操作。 已复制// 创建订阅者回调commonEventManager.createSubscriber(subscribeInfo, (err: Base.BusinessError, data: commonEventManager.CommonEventSubscriber) => {  if (err) {    console.error(`Failed to create subscriber. Code is ${err.code}, message is ${err.message}`);    return;  }  console.info('Succeeded in creating subscriber.');  subscriber = data;  // 订阅公共事件回调})
 创建订阅回调函数，订阅回调函数会在接收到事件时触发。订阅回调函数返回的data内包含了公共事件的名称、发布者携带的数据等信息，公共事件数据的详细参数和数据类型请见CommonEventData文档介绍。 已复制// 订阅公共事件回调if (subscriber !== null) {  commonEventManager.subscribe(subscriber, (err: Base.BusinessError, data: commonEventManager.CommonEventData) => {    if (err) {      console.error(`Failed to subscribe common event. Code is ${err.code}, message is ${err.message}`);      return;    }  })} else {  console.error(`Need create subscriber`);}    上一篇 公共事件订阅 下一篇 取消动态订阅公共事件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤取消动态订阅公共事件 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 动态订阅者完成业务需要时，需要主动取消订阅，订阅者通过调用unsubscribe()方法取消订阅事件。   接口说明     接口名 接口描述    unsubscribe(subscriber: CommonEventSubscriber, callback?: AsyncCallback) 取消订阅公共事件      开发步骤  导入模块。 已复制import commonEventManager from '@ohos.commonEventManager'; 根据动态订阅公共事件章节的步骤来订阅某个事件。 调用CommonEvent中的unsubscribe方法取消订阅某事件。 已复制// subscriber为订阅事件时创建的订阅者对象if (subscriber !== null) {    commonEventManager.unsubscribe(subscriber, (err) => {        if (err) {            console.error(`[CommonEvent] UnsubscribeCallBack err=${JSON.stringify(err)}`);        } else {            console.info(`[CommonEvent] Unsubscribe`);            subscriber = null        }    })}    上一篇 动态订阅公共事件 下一篇 公共事件发布 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。