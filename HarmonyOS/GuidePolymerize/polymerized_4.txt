您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。调试流程调试设置设置调试代码类型设置HAP安装方式启动调试断点管理使用真机进行调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 使用真机设备进行调试，真机设备分为本地物理真机和远程真机，其调试流程完全相同，都需要对应用/服务进行签名。本文以物理真机为例进行说明，关于如何运行远程真机请参考使用远程真机运行应用/服务。 调试流程DevEco Studio提供了丰富的HarmonyOS应用/服务调试能力，支持JS、ArkTS、C/C++单语言调试和ArkTS/JS+C/C++跨语言调试能力，同时还支持分布式应用/服务的跨设备调试，帮助开发者更方便、高效的调试应用/服务。 HarmonyOS应用/服务调试支持使用真机设备调试。使用真机设备进行调试前，需要对HAP进行签名。详细的调试流程如下图所示：   调试设置 设置调试代码类型工程调试类型默认为Detect Automatically，关于各调试类型的说明如下表所示： 表1 调试类型配置项调试类型  调试代码    Js Only  调试ArkTS代码，API Version 7~9支持调试JS代码，API Version 4~9支持   Native Only  仅调试C/C++代码，API Version 4~9支持   Dual(Js + Native)  调试C/C++工程的ArkTS/JS和C/C++代码，API Version 8~9支持   Detect Automatically  新建工程默认调试器选项，根据调试的工程类型，自动启动对应的调试器。API 4~9 Version 支持      修改调试类型的方法如下。 点击Run > Edit Configurations > Debugger，选择相应模块，设置Debug type即可。   设置HAP安装方式在调试阶段，HAP在设备上的安装方式有2种，可以根据实际需要进行设置。 安装方式一：先卸载应用/服务后，再重新安装，该方式会清除设备上的所有应用/服务缓存数据（默认安装方式）。安装方式二：采用覆盖安装方式，不卸载应用/服务，该方式会保留应用/服务的缓存数据。 设置方法如下： 单击Run > Edit Configurations，设置指定模块的HAP安装方式，勾选“Keep Application Data”，则表示采用覆盖安装方式，保留应用/服务缓存数据。  如果一个工程中同一个设备存在多个模块（如Phone设备，存在entry和feature模块），且存在模块间的调用时，在调试阶段需要同时安装多个模块的hap包到设备中。此时，需要在Deploy Multi Hap中选择多个模块，启动调试时，DevEco Studio会将所有的模块都安装到设备上。DevEco Studio V3.1 Release开始支持。  设置方法如下： 单击Run > Edit Configurations，在Deploy Multi Hap中，勾选Deploy Multi Hap Packages，选择多个模块。   启动调试在工具栏中，选择调试的设备，并单击Debug 或Attach Debugger to Process启动调试。
说明
Debug和Attach Debugger的区别在于，Attach Debugger to Process可以先运行应用/服务，然后再启动调试，或者直接启动设备上已安装的应用/服务进行调试；而Debug是直接运行应用/服务后立即启动调试。 
  如果需要设置断点调试，则需要选定要设置断点的有效代码行，在行号（比如：24行）的区域后，单击鼠标左键设置断点（如图示的红点）。如果无法添加断点，请查看FAQ调试过程中无法添加断点。 设置断点后，调试能够在正确的断点处中断，并高亮显示该行。 启动调试后，开发者可以通过调试器进行代码调试。调试器的功能说明如下表所示： 表2 调试器按钮按钮  名称  快捷键  功能      Resume Program  F9（macOS为Option+Command+R）  当程序执行到断点时停止执行，单击此按钮程序继续执行。     Step Over  F8（macOS为F8）  在单步调试时，直接前进到下一行（如果在函数中存在子函数时，不会进入子函数内单步执行，而是将整个子函数当作一步执行）。     Step Into  F7（macOS为F7）  在单步调试时，遇到子函数后，进入子函数并继续单步执行。     Force Step Into  Alt+Shift+F7（macOS为Option+Shift+F7）  在单步调试时，强制进入方法。     Step Out  Shift+F8（macOS为Shift+F8）  在单步调试执行到子函数内时，单击Step Out会执行完子函数剩余部分，并跳出返回到上一层函数。     Stop  Ctrl+F2（macOS为Command+F2）  停止调试任务。     Run To Cursor  Alt+F9（macOS为Option+F9）  断点执行到鼠标停留处。      对于元服务，由于元服务在设备中没有桌面图标，可以通过如下方式在设备中运行/调试元服务。 在服务中心展示的元服务：通过DevEco Studio的运行/调试按钮，将元服务推送到真机设备上安装，安装完成后便可以启动；同时在服务中心的最近使用中可以看到该元服务的卡片。通过hdc命令行工具，将元服务推送到真机设备上安装，安装完成后便可以启动；同时在服务中心的最近使用中可以看到该元服务的卡片。 在服务中心不展示的元服务：通过DevEco Studio的运行/调试按钮，将元服务推送到真机设备上安装，安装完成后便可以启动。通过hdc命令行工具，将元服务推送到真机设备上安装，安装完成后便可以启动。设备控制类的元服务，可通过碰一碰、扫一扫等方式运行。   断点管理在设置的程序断点红点处，单击鼠标右键，然后单击More或按快捷键Ctrl+Shift+F8（macOS为Shift+Command+F8），可以管理断点。  表3 不同代码类型的断点管理功能代码类型  断点管理    JS、ArkTS  普通行断点Exception（异常）断点   C/C++  普通行断点Exception（异常）断点Symbolic（符号）断点       上一篇 为应用/服务进行签名 下一篇 使用模拟器进行调试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。调试前的设置设置调试代码类型设置HAP安装方式启动调试使用模拟器进行调试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio提供了丰富的HarmonyOS应用/服务调试能力，使用远程模拟器支持JS、ArkTS单语言调试和JS+Java跨语言调试能力；使用本地模拟器支持JS和C++的调试；同时还支持分布式应用/服务的跨设备调试，帮助开发者更方便、高效的调试应用/服务。关于模拟器支持的API版本请参考使用模拟器运行应用/服务。 
说明
远程模拟器不支持C++单语言调试和Java+C++跨语言调试。 
 HarmonyOS应用/服务调试支持使用模拟器设备调试，可以支持运行已签名或未签名的应用/服务。使用模拟器调试应用/服务的流程如下图所示：  调试前的设置 设置调试代码类型工程调试类型默认为Detect Automatically，关于各调试类型的说明如下表所示： 表1 调试类型配置项调试类型  调试代码    Js Only  调试ArkTS代码，API Version 7~9支持调试JS代码，API Version 4~9支持   Native Only  仅调试C/C++代码，API Version 4~9支持   Dual(Js + Native)  调试C/C++工程的ArkTS/JS和C/C++代码，API Version 8~9支持   Detect Automatically  新建工程默认调试器选项，根据调试的工程类型，自动启动对应的调试器。API 4~9 Version 支持      修改调试类型的方法如下。 点击Run > Edit Configurations > Debugger，选择相应模块，设置Debug type即可。   设置HAP安装方式在调试阶段，HAP在设备上的安装方式有2种，可以根据实际需要进行设置。 安装方式一：先卸载应用/服务后，再重新安装，该方式会清除设备上的所有应用/服务缓存数据（默认安装方式）。安装方式二：采用覆盖安装方式，不卸载应用/服务，该方式会保留应用/服务的缓存数据。 设置方法如下： 单击Run > Edit Configurations，设置指定模块的HAP安装方式，勾选“Keep Application Data”，则表示采用覆盖安装方式，保留应用/服务缓存数据。  如果一个工程中同一个设备存在多个模块（如Phone设备，存在entry和feature模块），且存在模块间的调用时，在调试阶段需要同时安装多个模块的hap包到设备中。此时，需要在Deploy Multi Hap中选择多个模块，启动调试时，DevEco Studio会将所有的模块都安装到设备上。DevEco Studio V3.1 Release开始支持。  设置方法如下： 单击Run > Edit Configurations，在Deploy Multi Hap中，勾选Deploy Multi Hap Packages，选择多个模块。   启动调试在工具栏中，选择调试的设备，并单击Debug 或Attach Debugger to Process启动调试。
说明
Debug和Attach Debugger的区别在于，Attach Debugger to Process可以先运行应用/服务，然后再启动调试，或者直接启动设备上已安装的应用/服务进行调试；而Debug是直接运行应用/服务后立即启动调试。 
  如果需要设置断点调试，则需要选定要设置断点的有效代码行，在行号（比如：24行）的区域后，单击鼠标左键设置断点（如图示的红点）。 设置断点后，调试能够在正确的断点处中断，并高亮显示该行。 启动调试后，开发者可以通过调试器进行代码调试。调试器的功能说明如下表所示： 表2 调试器按钮按钮  名称  快捷键  功能      Resume Program  F9（macOS为Option+Command+R）  当程序执行到断点时停止执行，单击此按钮程序继续执行。     Step Over  F8（macOS为F8）  在单步调试时，直接前进到下一行（如果在函数中存在子函数时，不会进入子函数内单步执行，而是将整个子函数当作一步执行）。     Step Into  F7（macOS为F7）  在单步调试时，遇到子函数后，进入子函数并继续单步执行。     Force Step Into  Alt+Shift+F7（macOS为Option+Shift+F7）  在单步调试时，强制进入方法。     Step Out  Shift+F8（macOS为Shift+F8）  在单步调试执行到子函数内时，单击Step Out会执行完子函数剩余部分，并跳出返回到上一层函数。     Stop  Ctrl+F2（macOS为Command+F2）  停止调试任务。     Run To Cursor  Alt+F9（macOS为Option+F9）  断点执行到鼠标停留处。      对于元服务，由于元服务在设备中没有桌面图标，可以通过如下方式在设备中运行/调试。 在服务中心展示的元服务：通过DevEco Studio的运行/调试按钮，将元服务推送到真机设备上安装，安装完成后便可以启动；同时在服务中心的最近使用中可以看到该元服务的卡片。通过hdc命令行工具，将元服务推送到真机设备上安装，安装完成后便可以启动；同时在服务中心的最近使用中可以看到该元服务的卡片。 在服务中心不展示的元服务：通过DevEco Studio的运行/调试按钮，将元服务推送到真机设备上安装，安装完成后便可以启动元服务。通过hdc命令行工具，将元服务推送到真机设备上安装，安装完成后便可以启动。设备控制类的元服务，可通过碰一碰、扫一扫等方式运行。    上一篇 使用真机进行调试 下一篇 调试OpenHarmony应用/服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。业务介绍应用安全测试应用云测试丰富的真机设备资源专业详尽的测试报告业务介绍 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 业务介绍DevEco Service是HarmonyOS开发者云端服务中心，汇聚了丰富的资源和服务；支持在线体验多种开发场景，共建共享开发资源；并提供7×24小时远程实验室环境和多维度应用、设备测试服务。帮助您高效开发、高质量上线。 HUAWEI DevEco Service支持的能力包括远程实验室、应用安全测试、应用云测试服务。  应用安全测试HarmonyOS应用安全测试服务提供安全漏洞检测、隐私合规检测和恶意行为检测服务，提前检测和识别应用开发过程可能存在的安全性问题，满足HarmonyOS应用上架应用市场的要求。 当前已支持安全漏洞检测和隐私合规检测服务，恶意行为检测服务能力即将上线，敬请期待。   应用云测试HarmonyOS应用云测试提供兼容性测试、稳定性测试、性能测试、功耗测试、UX测试5大特色能力，检测应用从安装、启动、运行和卸载的全生命周期中可能存在的问题，如应用崩溃、启动响应耗时长、前后台内存/CPU占用高、启动/卸载异常等，全方位检测应用质量。    丰富的真机设备资源HarmonyOS应用云测试提供丰富的真机设备资源，覆盖华为1+8智能设备，包括手机、平板、智慧屏、智能手表、运动手表等设备，可以很好地帮助开发者解决设备资源短缺、测试成本高昂等问题。 当前已提供手机（Phone），平板（Tablet）、华为智慧屏（TV）和智能穿戴（Wearable）的设备资源，其它设备即将上线，敬请期待。  专业详尽的测试报告针对每一项测试任务，无需人工干预，全自动化完成测试，并且快速出具专业详尽的测试报告。 以应用云测试中的兼容性测试为例，下图展示的是HarmonyOS应用在智慧屏设备上的兼容性测试结果，点击详情便可以查询详尽的测试报告。    上一篇 DevEco Service使用指南 下一篇 DevEco低代码 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告性能测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
  性能测试主要验证HarmonyOS应用在华为真机设备上运行的性能问题，包括启动时长、界面显示、CPU占用和内存占用。具体性能测试项的详细说明请参考性能测试标准。 性能测试支持Phone和TV设备，包格式包括Hap/App。 前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。选择或者创建一个项目，如果新创建一个项目，注意选择HarmonyOS。 进入项目空间，在左侧导航栏中选择测试服务 > HarmonyOS云测试，进入HarmonyOS云测试页面，点击HarmonyOS云测试页面右侧的创建测试按钮，进入创建测试任务页面。 在创建测试任务页面选择性能测试，设置如下信息后，点击下一步。应用程序：选择待测试的HarmonyOS应用包，包括HAP和APP两种格式，如果未上传应用，请先从本地上传一个HarmonyOS应用包。应用分类：设置应用的一级分类、二级分类和三级分类。 
说明
每天只能进行100次性能测试任务，请合理安排测试任务。 
  选择测试设备，性能测试支持智慧屏（TV）和手机（Phone）。任务创建完成后，请等待测试任务完成，可以在HarmonyOS云测试任务列表中查看任务状态。   查看测试报告测试任务执行完成后，在任务列表中，可以点击查看测试报告按钮，查看测试结果详细信息。  在测试报告的概览页，可以查看测试任务的整体情况，如测试通过率、问题分布、在各个测试终端上的问题分布情况。  点击测试设备后的查看详情按钮，可以查看测试任务详情信息，测试截屏、异常信息和日志信息。   上一篇 稳定性测试 下一篇 功耗测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告隐私测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 通过动态检测和分析应用在设备上运行的隐私敏感行为，帮助开发者排查应用的恶意行为，构建纯净绿色的HarmonyOS应用。隐私测试支持17+项检测，包括获取地理位置信息检测、获取设备标识检测、获取通讯录信息检测、获取系统信息检测等。我们建议，HarmonyOS应用应遵循合理、正当、必要的原则收集用户个人信息，不应有未向用户明示且未经用户授权的情况下，擅自收集用户数据的行为。 隐私测试服务当前支持手机、TV设备，包格式包括Hap/APP。 前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。点击“创建项目”，创建一个项目空间，填写项目名称，选择HarmonyOS。 创建完成后，进入项目空间，在左侧导航栏中选择测试服务 > 安全测试。点击创建测试按钮，在动态隐私测试页面，上传或选择HarmonyOS应用包，包括HAP格式。然后点击确定按钮，创建测试任务。
说明
每天只能创建100次动态隐私测试任务，请合理安排测试任务。 
  任务创建完成后，等待任务执行完成。可在“任务列表”中查看测试任务的进度。   查看测试报告测试任务执行完成后，在任务列表中，可以点击查看报告按钮，查看测试结果详细信息。  在测试报告的概览页，可以查看测试任务的整体情况，包括风险率、敏感行为和动态隐私风险项。    上一篇 漏洞检测 下一篇 HarmonyOS应用云测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。录制CPU活动数据查看CPU跟踪数据使用 Call Chart 检查跟踪数据使用Flame Chart检查跟踪数据使用Top Down检查跟踪数据使用Bottom Up检查跟踪数据使用Trace Events查看系统事件分析HarmonyOS应用/服务的CPU活动性能 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 CPU Profiler 性能分析是用来分析CPU性能瓶颈的工具，可以实时查看应用/服务的CPU使用率和线程活动，也可以查看记录的方法跟踪数据、方法采样数据和系统跟踪数据的详情。基于CPU性能分析，您可以了解在一段时间内执行了哪些方法，以及每个方法在其执行期间消耗的CPU资源，可以有针对性的优化应用/服务的CPU使用率，提供更快、更顺畅的用户体验，以及延长设备电池续航时间。 录制CPU活动数据录制HarmonyOS应用或服务的CPU活动数据，需要将待分析的应用或服务运行起来，当前仅支持本地真机。 
说明
录制JS的CPU活动数据，应用/服务只能以Debug模式运行。 
 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击Profiler按钮，打开Profiler分析器。在Profiler分析器的SESSIONS窗口，单击+按钮，在弹出下拉列表中先选择设备，然后选择待分析的进程。 在实时变化视图，单击CPU区域，进入CPU详情页面。 在CPU详情页面选择CPU数据的录制模式，然后单击Record，开始录制CPU活动数据。开始录制后，会在SESSIONS窗口的当前会话下生成应用/服务的数据记录。CPU数据的录制模式分为以下几种：对Java 方法采样（Sample Java Methods）：在应用/服务的Java 代码执行期间，定期捕获应用/服务的调用堆栈。分析器会比较捕获的数据集，以推导与应用/服务的 Java 代码执行有关的时间和资源使用信息。跟踪Java 方法（Trace Java Methods）：在运行时检测应用/服务，在每个方法调用开始和结束时记录一个时间戳。系统会收集并比较这些时间戳，以生成方法跟踪数据，包括时间信息和CPU 使用率。跟踪JS 方法（Trace JS Methods）：在运行时检测应用/服务，在每个方法调用开始和结束时记录一个时间戳。系统会收集并比较这些时间戳，以生成方法跟踪数据，包括时间信息和CPU 使用率。跟踪系统调用（Trace System Calls）：捕获应用/服务运行的细节，以便您检查应用/服务与系统资源的交互情况。您可以检查线程状态的确切时间和持续时间、直观地查看所有内核的CPU 瓶颈在何处，并添加需分析的自定义跟踪事件。  除了使用以上几种数据录制模式外，还可以单击模式选择下拉列表中的Edit Configurations自定义数据录制模式。  单击CPU详情页面的上部或下部的Stop结束当前录制。CPU录制完成后，可以在SESSIONS窗口选中该数据记录，单击右键或导出按钮将数据记录导出，方便分享和以后的查看。   查看CPU跟踪数据CPU活动数据录制后，可以在SESSIONS窗口单击要查看的数据记录，或单击+按钮，在下拉列表中选择Load from file，导入数据记录文件。   单击数据记录，可查看数据详情。 CPU在录制时间内的使用情况。 IO资源占用情况。 Interaction：在应用/服务的生命周期内，用户与应用/服务互动的事件。 Threads：线程活动状态，可以查看线程是处于运行状态还是休眠状态，选择具体的线程，可以在右侧的Analysis窗口查看线程的详细信息。 Analysis窗口，选择All threads可以看到全部线程的信息。选择具体的某个线程，可以查看该线程或方法调用的详细数据。 Time reference菜单，选择以下选项之一，以确定如何测量每次调用的时间信息（仅跟踪 Java 方法中支持）：Wall clock time：该时间信息表示进程从开始运行到结束，时钟实际走过的时间。Thread time：该时间信息表示实际经过的时间减去线程没有占用CPU 资源的那部分时间。对于任何给定的调用，其线程时间始终小于或等于其Wall clock time。使用线程时间可以让您更好地了解线程的实际CPU 使用率中有多少是给定方法或函数占用的。  过滤器，按函数、方法、类或软件包名称过滤跟踪数据。在Flame chart 标签页中，会突出显示包含符合搜索查询条件的调用、软件包或类的调用堆栈。在Top down 和Bottom up标签页中，这些调用堆栈优先于其他跟踪结果。还可以通过勾选搜索字段旁边的相应方框来启用以下选项： Regex：搜索中包含正则表达式。 Match case：搜索区分大小写。 对于方法跟踪数据，可以直接在Threads时间轴中查看Call Chart，也可以从Analysis窗口查看Flame Chart、Top Down 和 Bottom Up标签页。对于系统调用跟踪数据，可以在Threads时间轴查看Trace Events，也可以从Analysis窗口查看 Flame Chart、Top Down 和 Bottom Up 标签页。  使用 Call Chart 检查跟踪数据Call Chart直接在Threads 时间轴中查看 ，将鼠标指针悬停在某个方法上，以图形方式来呈现方法跟踪数据或函数跟踪数据。对系统API 的调用显示为橙色，对应用/服务自有方法的调用显示为绿色，对第三方API（包括Java 语言API）的调用显示为蓝色。   使用Flame Chart检查跟踪数据Flame Chart标签页提供一个倒置的调用图表，用来汇总完全相同的调用堆栈。将鼠标指针悬停在某个方法上，可以查看哪些方法或函数消耗的时间最多。   使用Top Down检查跟踪数据Top Down标签显示一个调用列表，在该列表中展开方法或函数节点会显示它的被调用方。与Flame chart标签页类似，“Top Down”树也汇总了具有相同调用堆栈的完全相同的方法的跟踪信息。也就是说，Flame chart标签页提供了Top down标签页的图形表示方式。 Top Down 标签提供以下信息来帮助说明在每个调用上所花的CPU时间（时间也可表示为在选定范围内占线程总时间的百分比）： Self：方法或函数调用在执行自己的代码（而非被调用方的代码）上所花的时间。 Children：方法或函数调用在执行它的被调用方（而非自己的代码）上所花的时间。 Total：方法的Self 时间和Children 时间的总和。这表示应用/服务在执行调用时所用的总时间。   使用Bottom Up检查跟踪数据Bottom Up 标签页显示一个调用列表，在该列表中展开函数或方法的节点会显示它的调用方。Bottom Up 标签页用于按照占用的CPU时间由多到少（或由少到多）的顺序对方法或函数排序。您可以检查每个节点以确定哪些调用方在调用这些方法或函数上所花的CPU时间最多。与“Top Down”树相比，“Bottom Up”树中每个方法或函数的时间信息参照的是每个树顶部的方法（顶部节点）。CPU时间也可表示为在该记录期间占线程总时间的百分比。下表说明了如何解读顶部节点及其调用方（子节点）的时间信息。 Item  Self  Children  Total    “Bottom Up”树顶部的方法或函数（顶部节点）  表示方法或函数在执行自己的代码（而非被调用方的代码）上所花的总时间。与“Top Down”树相比，此时间信息表示在记录的持续时间内对此方法或函数的所有调用时间的总和。  表示方法或函数在执行它的被调用方（而非自己的代码）上所花的总时间。与“Top Down”树相比，此时间信息表示在记录的持续时间内对此方法或函数的被调用方的所有调用时间的总和。  Self 时间和 Children 时间的总和。   调用方（子节点）  表示被调用方在由调用方调用时的总 Self 时间。  表示被调用方在由调用方调用时的总 Children 时间。  Self 时间和 Children 时间的总和。       使用Trace Events查看系统事件检查系统跟踪数据时，您可以在Threads 时间轴中检查Trace Events，以查看每个线程上所发生事件的详细信息。将鼠标指针悬停在某个事件上，可查看该事件的名称以及在每种状态下所花费的时间。单击事件可在Analysis 窗格中查看详情。 CPU cores 窗格显示每个核心上安排的线程ability。将鼠标指针悬停在某个线程ability上，可查看该核心在该特定时间在哪个线程上运行。    上一篇 Profiler性能分析器介绍 下一篇 分析HarmonyOS应用/服务的内存使用 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看能耗概览检查系统事件分析HarmonyOS应用/服务能耗 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 能耗分析器会监控 CPU、网络无线装置和 GPS 传感器的使用情况，估算设备上每项资源的耗电量，并直观地显示其中每个组件消耗的电量。能耗分析器还会显示可能会影响耗电量的系统事件（唤醒锁定、闹钟、作业和位置信息请求）的发生次数。 查看能耗概览前提条件 待分析的应用已经运行在本地真机。 操作步骤 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击Profiler按钮，打开Profiler分析器。在Profiler分析器的SESSIONS窗口，单击+按钮，在弹出下拉列表中先选择设备，然后选择待分析的进程。 在实时变化视图，单击能耗区域，进入能耗概览视图。 ①事件：显示应用中的活动事件，包括用户与设备的交互、屏幕旋转事件等。 ②能耗：显示应用延时间轴的能耗估算结果。 ③系统：显示可能会影响耗电量的系统事件。    检查系统事件 在能耗概览视图的时间轴上，单击某一时刻或拖动选择某一时间段查看在该指定时刻或指定时间段的能耗详情。 ①在Energy时间轴中选择一个时间范围，会打开System Event窗口并显示系统事件的详细信息。 ②在System Event窗口单击指定系统事件，会打开右侧详情窗口显示详细信息，包括调用的堆栈。 ③在右侧详情窗口双击调用堆栈的调用方法条目，会在④源代码编辑器中对应位置突出显示。  能耗分析器会根据影响耗电量的系统事件，包括唤醒锁定、闹钟、位置信息请求、使用传感器等，在Energy时间轴下的System时间轴中显示彩色的条形，表示系统事件处于活动状态的时间范围。唤醒锁定用红色条形表示，闹钟用黄色条形表示，位置信息事件用紫色条形表示。  上一篇 分析HarmonyOS应用/服务网络活动 下一篇 HiTrace日志跟踪定位分析 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Profiler性能分析器介绍 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
说明
DevEco Studio 3.1 Release版本暂不支持对HarmonyOS设备中运行的应用进行性能分析，HarmonyOS工程如需使用该功能，请下载DevEco  Studio 3.0 Release版本。我们将在后续版本提供全新支持API 9的性能分析工具，敬请期待。 
 应用或服务的性能较差时，可能表现为响应速度慢、动画播放不流畅、卡顿、崩溃或极其耗电。为了避免出现这些性能问题，需要通过一系列性能分析工具来确定应用或服务对哪方面资源（例如CPU、内存、显卡、网络和设备电池）的使用率比较高。DevEco Studio集成Profiler性能分析器，通过Profiler性能分析器提供实时性能分析数据，并通过图表形式进行呈现，方便开发者及时了解应用/服务的CPU占用、内存的分配占用、网络资源占用和电池资源消耗的具体数据。 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击，打开Profiler性能分析器，如下图所示：  会话窗格，单击查看会话窗格的会话。或单击+按钮，在弹出的下拉菜单中，选择一个进程创建一个新的会话。或选择导入文件，查看历史记录，请注意，导入的历史记录只能导入HarmonyOS设备的跟踪记录。 缩放按钮用于对时间轴进行缩放，或使用Attach to live跳转到实时更新。 CPU、IO、内存、网络、能耗数据实时变化视图，其中单击CPU、内存、网络、能耗对应的区域，可进入详情视图，IO数据只能在手机具有root镜像权限时才会显示。  上一篇 Profiler性能分析 下一篇 分析HarmonyOS应用/服务的CPU活动性能 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。查看HarmonyOS应用/服务内存实时变化捕获及分析Java堆转储捕获及分析JS堆转储分析HarmonyOS应用/服务的内存使用 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 Profiler性能分析器支持内存使用分析。应用/服务运行时，Profiler的内存分析器实时显示内存使用情况，同时也支持捕获堆转储，跟踪内存分配，帮助开发者识别可能会导致应用卡顿、冻结的内存泄漏和内存抖动。 查看HarmonyOS应用/服务内存实时变化录制HarmonyOS应用或服务的内存使用数据，需要将待分析的应用或服务运行起来，当前仅支持本地真机。 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击Profiler按钮，打开Profiler分析器。在Profiler分析器的SESSIONS窗口，单击+按钮，在弹出下拉列表中先选择设备，然后选择待分析的进程。 Profiler将自动生成包括MEMORY在内的各项性能使用情况视图，包括如下信息： 实时显示总内存占用的变化。实时显示总内存占用的数值和悬浮框。在事件时间轴，显示活动状态、用户输入事件和屏幕旋转事件。  在实时变化视图，单击内存区域，进入内存详情页面。 内存详情页按内存类别实时显示内存变化视图，包括： Java：Java对象所占用的内存。JS：JS对象所占用的内存。Native：C或C++代码所占用的内存。Graphics：图形缓冲区队列向屏幕显示像素所使用的内存。这里是与CPU共享的内存，不是GPU专用内存。Stack：应用/服务中的原生堆栈和Java堆栈使用的内存。Code：应用/服务用于处理代码和资源的内存。Others：系统不确定如何分类的内存。Allocated：应用/服务分配的Java对象数。   捕获及分析Java堆转储支持捕获Java堆转储，参考查看HarmonyOS应用内存实时变化，进入内存详情页面，单击工具栏中的图标，选择 “Dump Java heap”。捕获的Java堆转储将在左侧的SESSIONS窗口对应显示，并在时间轴上对应时间段以灰色显示。  Java堆转储视图如下所示，单击①类视图下的任意一个类，会展开②实例视图，单击实例视图中的任意一个实例，会展开③引用视图。  ①类视图 类列表默认显示应用分配的对象类型以及它们使用的内存数值，包括： Class Name：堆中分配的类名。Allocations：堆中的分配数。Native Size：此对象类型使用的原生内存总量（以字节为单位）。Shallow Size：此对象类型使用的Java内存总量（以字节为单位）。Retained Size：为此类的所有实例而保留的内存总大小（以字节为单位）。 支持按堆类型和数据组织方式筛选和排列。 按堆类型筛选方式如下：default heap：当系统未指定堆时，使用该选项。app heap：应用分配内存的主堆。image heap：系统启动映像，包含启动期间预加载的类。 按数据组织方式：Arrange by class：根据类名称对所有分配进行分组。Arrange by package：根据软件包名称对所有分配进行分组。Arrange by callstack：将所有分配分组到其对应的调用堆栈。只有在记录分配期间捕获堆转储时，此选项才有效。  ②实例视图 在类视图中单击一个类名称，右侧将出现Instance View视图，显示该类的每个实例。每个实例包含以下信息： Depth：从任意GC根到选定实例的最短跳数。Native Size：原生内存中此实例的大小。Shallow Size：Java内存中此实例的大小。Retained Size：此实例所支配内存的大小。 ③引用视图 在实例视图中，单击一个实例，下方将出现References标签页，显示对该对象的每个引用。在Instance View 和Reference视图右键选择Go to Instance可查看实例详细信息。  捕获及分析JS堆转储支持捕获JS堆转储，参考查看HarmonyOS应用内存实时变化，进入内存详情页面，单击工具栏中的 图标，选择“Dump JS heap”。捕获的JS堆转储将在左侧的SESSIONS窗口对应显示，并在时间轴上对应时间段以灰色显示。 
说明
要捕获JS方法的堆转储，应用只能以Debug模式运行。 
  JS堆转储视图如下所示： 单击①对象构造函数视图下的任意一个实例，会展开②实例视图，单击实例视图中的任意一个实例，会展开③引用视图。  ①对象构造函数视图Constructor View JS heap dump首先将展示Constructor View，展示对象构造函数内存信息。Constructor View支持两种视图： Summary View：概览视图，按照构造函数展示内存数值。Comparison View：对照视图，支持对任意两个内存快照进行对比，可用于查看某操作前后内存变化情况，以检测可能存在的内存泄漏。 JS heap dump默认以Summary View视图展示。Summary View视图内容包括： Constructor：应用中对象的构造函数，以及由该构造函数生成的对象实例数。Distance：此对象例到达 GC 根的最短距离。Shallow Size：此对象自身所占用的内存大小（以字节为单位）和百分比。Retained Size：此对象自身及其引用对象所占用的内存大小（以字节为单位）和百分比。 单击视图下拉框可选择切换到 Comparison View。切换后，在右侧可下拉选择需要比较的另一内存快照。Comparison View视图内容包括： Constructor：应用中对象的构造函数，以及由该构造函数生成的对象实例数。New：此内存快照相较于被比较的内存快照新增的对象数。Deleted：此内存快照相较于被比较的内存快照减少的对象数。Delta：此内存快照相较于被比较的内存快照对象数的变化。Allocated Size：该对象在此内存快照相较于被比较的内存快照新增的内存大小（以字节为单位）。Freed Size：该对象在此内存快照相较于被比较的内存快照减少的内存大小（以字节为单位）。Size Delta：该对象在此内存快照相较于被比较的内存快照内存大小的变化（以字节为单位）。 
说明
在Constructor View中，单击按钮，然后在搜索框中搜索“detached”，可搜索为 DOM树中已经销毁、但仍被 JS 引用的对象，这些对象可能导致 DOM 内存泄漏。 
 ②实例视图Instance View 单击Constructor View中某一行，右侧将出现Instance View窗格，显示该对象的每个实例。Instance View各列信息含义与Constructor View一致。 ③引用视图Retainer View 显示该对象实例的每个引用（由哪个属性引用，以及该属性所在的对象）的内存信息。每个对象后方有“@”+ 数字，代表对象 ID。各引用的对象实例又可以继续展开。展开时默认展开一条引用链（即展开到 GC 根）。   上一篇 分析HarmonyOS应用/服务的CPU活动性能 下一篇 分析HarmonyOS应用/服务网络活动 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。分析HarmonyOS应用/服务网络活动 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 网络活动分析器会在时间轴上显示实时网络活动，包括发送和接收的数据以及当前的连接数。通过查看网络活动，可以检查应用/服务传输数据的方式和时间，并据此进行代码优化。 录制HarmonyOS应用或服务的网络活动数据，需要将待分析的应用或服务运行起来，当前仅支持本地真机。 在DevEco Studio菜单栏上单击View > Tool Windows > Profiler，或者在DevEco Studio底部工具栏单击Profiler按钮，打开Profiler分析器。在Profiler分析器的SESSIONS窗口，单击+按钮，在弹出下拉列表中先选择设备，然后选择待分析的进程。 在实时变化视图，单击网络区域，进入网络活动详情页面。 在时间轴上，单击某一时刻或拖动选择某一时间段查看在该指定时刻或指定时间段的网络活动详情。图1 查看指定时刻网络活动 图2 查看指定时间段的网络活动  ①在时间轴上，单击某一时刻或拖动选择某一时间段查看在该指定时刻或指定时间段的网络活动详情。 ②可以选择以下某个标签页，以详细了解时间轴上选定时段内的网络活动。 Connection View：列出了在时间轴上选定时段内从该应用的所有CPU线程发送或接收的文件。包括大小、类型、状态和传输时长。Thread View：显示该应用的每个CPU线程的网络活动。 ③Connection View或Thread View 单击请求名称，查看有关已发送或已接收数据的详细信息，单击各个页签可查看请求的标头和正文、响应的标头和正文或调用堆栈。   上一篇 分析HarmonyOS应用/服务的内存使用 下一篇 分析HarmonyOS应用/服务能耗 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。概述使用约束创建服务卡片预览服务卡片创建服务卡片 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 概述服务卡片支持不同的规格尺寸，开发者可以根据展示的不同内容和布局效果，选用不同的卡片尺寸，支持的尺寸包括：1*2、2*2、2*4和4*4宫格。 不同的SDK版本提供的卡片模板不同： API 9提供如下卡片模板： 模板名称  支持的设备  支持的开发语言  模板描述    Hello World  Phone、Tablet  ArkTS、JS  支持低代码开发的HelloWorld卡片。   Image With Information（图文卡片模板）  Phone、Tablet  ArkTS、JS  图文卡片模板主要在于展现图片和一定数量文本的搭配，在这种布局下，图片和文本属于同等重要的信息。在不同尺寸下，图片大小和文本数量会发生一定变化，用于凸显关键信息。   Immersive Information（沉浸图文卡片模板）  Phone、Tablet  ArkTS、JS  沉浸式卡片的装饰性较强，能够较好的提升卡片品质感并起到装饰桌面的作用，合理的去布局信息与背景图片之间的空间比例，可以提升用户的个性化使用体验。     API 8提供如下卡片模板： 模板名称  支持的设备  支持的开发语言  模板描述    Hello World  Phone  JS  支持低代码开发的HelloWorld卡片。   Image With Information（图文卡片模板）  Phone  JS  图文卡片模板主要在于展现图片和一定数量文本的搭配，在这种布局下，图片和文本属于同等重要的信息。在不同尺寸下，图片大小和文本数量会发生一定变化，用于凸显关键信息。   Immersive Information（沉浸图文卡片模板）  Phone  JS  沉浸式卡片的装饰性较强，能够较好的提升卡片品质感并起到装饰桌面的作用，合理的去布局信息与背景图片之间的空间比例，可以提升用户的个性化使用体验。     API 4~7提供如下卡片模板： 模板名称  支持的设备  支持的开发语言  模板描述    Image With Information（图文卡片模板）  Phone、Tablet  Java、JS  图文卡片模板主要在于展现图片和一定数量文本的搭配，在这种布局下，图片和文本属于同等重要的信息。在不同尺寸下，图片大小和文本数量会发生一定变化，用于凸显关键信息。       使用约束每个module最多可以配置16张服务卡片。卡片不支持调试。  创建服务卡片DevEco Studio提供服务卡片的一键创建功能，可以快速创建和生成服务卡片模板。 单击New Project > Atomic Service创建一个新的元服务时，会同步创建一个2*2的服务卡片模板，并创建入口卡片。关于工程配置项详细说明请参考创建一个新的工程。  卡片创建完成后，会在工程目录下生成EntryCard目录。  在该目录下，每个拥有EntryCard的模块，都会生成一个和模块名相同的文件夹，同时还会默认生成一张2x2的快照型EntryCard图片（png格式）。 开发者可以将其替换为提前设计好的2x2快照图：将新的快照图拷贝到上图目录下，删除默认图片，新图片命名遵循格式“卡片名称-2x2.png”。 在已有的Atomic Service工程中添加新模块时，会自动创建新服务卡片和EntryCard。在已有工程中，添加EntryCard，只能通过手工方式，按照上图中的EntryCard目录创建对应的文件夹和图片。在已有元服务工程或新建的Application应用工程中，新添加服务卡片，可以通过如下方法进行创建： 打开一个工程，创建服务卡片，创建方法包括如下两种方式：选择模块（如entry模块）下的任意文件，单击菜单栏File > New > Service Widget创建服务卡片。选择模块（如entry模块）下的任意文件，单击右键 > New > Service Widget创建服务卡片。 在Choose a Template for Your Service Widget界面中，选择卡片模板，单击Next。 在Configure Your Service Widget界面中，配置卡片的基本信息，包括：Service widget name：卡片的名称，在同一个应用/服务中，卡片名称不能重复，且只能包含大小写字母、数字和下划线。Description：卡片的描述信息。Enable Super Visual：是否选择低代码方式开发。Language：界面开发语言，可选择创建ArkTS/JS卡片。Support dimension：选择卡片的规格。部分卡片支持同时设置多种规格。Ability name：选择一个挂靠服务卡片的Form Ability，或者创建一个新的Form Ability。Module name：卡片所属的模块。  单击Finish完成卡片的创建。创建完成后，工具会自动创建出服务卡片的布局文件，并在form_config.json文件中写入服务卡片的属性字段，关于各字段的说明请参考应用配置文件说明。 卡片创建完成后，请根据开发指导，完成服务卡片的开发，详情请参考服务卡片开发指南。  预览服务卡片在开发服务卡片过程中，支持对卡片进行实时预览。服务卡片通过XML或JS文件进行布局设计，在开发过程中，可以对布局XML/JS文件进行实时预览，只要在XML/JS布局文件中保存了修改的源代码，在预览器中就可以实时查看布局效果。在Phone和Tablet服务卡片的预览效果中，每个尺寸的服务卡片提供3种场景的预览效果，分别为极窄（Minimum）、默认（Default）、极宽(Maximum)，开发者应确保三种尺寸的显示效果均正常，以便适应不同屏幕尺寸的设备。  关于预览器的使用详细说明请参考使用预览器查看应用/服务效果。   上一篇 定义HarmonyOS IDL接口 下一篇 使用预览器查看应用/服务效果 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告稳定性测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 稳定性测试主要验证HarmonyOS应用在华为真机设备上运行的稳定性问题，包括崩溃/应用冻屏、内存泄露和踩内存，稳定性测试项的详细说明请参考稳定性测试标准。 稳定性测试支持Phone和TV设备，包格式包括Hap/App。  前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。选择或者创建一个项目，如果新创建一个项目，注意选择HarmonyOS。 进入项目空间，在左侧导航栏中选择测试服务 > HarmonyOS云测试，进入HarmonyOS云测试页面，点击HarmonyOS云测试页面右侧的创建测试按钮，进入创建测试任务页面。 在创建测试任务页面选择稳定性测试，设置如下信息后，点击下一步。应用程序：选择待测试的HarmonyOS应用包，包括HAP和APP两种格式，如果未上传应用，请先从本地上传一个HarmonyOS应用包。测试时长设置：设置稳定性测试的测试时长。 
说明
每天只能进行总计1000分钟的稳定性测试任务，请合理安排测试任务。 
  选择测试设备，稳定性测试支持智慧屏（TV）和手机（Phone）。任务创建完成后，请等待测试任务完成，可以在HarmonyOS云测试任务列表中查看任务状态。   查看测试报告测试任务执行完成后，在任务列表中，可以点击查看测试报告按钮，查看测试结果详细信息。  在测试报告的概览页，可以查看测试任务的整体情况，如测试通过率、问题分布、在各个测试终端上的问题分布情况。  点击测试设备后的查看详情按钮，可以查看测试任务详情信息，如测试截屏、异常信息和日志信息。   上一篇 兼容性测试 下一篇 性能测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件创建测试任务查看测试报告漏洞检测 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 通过对HarmonyOS应用生命周期建模和应用攻击面建模，采用静态数据流分析技术，提高漏洞发现的准确率，同时覆盖20余种攻击面，65+漏洞测试项，帮助开发者提前发现和识别漏洞隐患。在检测报告中，会针对每一项漏洞风险项给出明确的修复建议，可以帮助开发者快速修复漏洞。  前提条件已注册华为开发者帐号，并完成实名认证，具体请参考帐号注册和实名认证。已通过DevEco Studio开发完应用，并编译构建生成Hap或App，具体请参考DevEco Studio使用指南。  创建测试任务访问HUAWEI DevEco Service页面，使用华为开发者帐号进行登录。点击界面上的“从这里开始”按钮，进入到控制台。点击“创建项目”，创建一个项目空间，填写项目名称，选择HarmonyOS。 创建完成后，进入项目空间，在左侧导航栏中选择测试服务 > 安全测试。点击“创建测试”按钮，在漏洞测试页面，选择或上传HarmonyOS应用包，包括HAP和APP两种格式。然后点击确定按钮，创建测试任务。
说明
每天只能创建100次漏洞测试任务，请合理安排测试任务。 
  任务创建完成后，等待任务执行完成。可在“任务列表”中查看测试任务的进度。   查看测试报告测试任务执行完成后，在任务列表中，可以点击查看报告按钮，查看测试结果详细信息。 在测试报告的概览页，可以查看测试任务的整体情况，包括漏洞的统计（致命、严重、一般和提示）和漏洞问题分布。  在安全漏洞的测试结果列表中，点击详情可以查阅详细的问题报告和修复解决方案。    上一篇 HarmonyOS应用安全测试 下一篇 隐私测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。HarmonyOS IDL简介创建.idl文件定义HarmonyOS IDL接口 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 HarmonyOS IDL简介HarmonyOS Interface Definition Language（简称HarmonyOS IDL）是HarmonyOS的接口描述语言。HarmonyOS IDL与其他接口语言类似，通过HarmonyOS IDL定义客户端与服务端均认可的编程接口，可以实现在二者间的跨进程通信（IPC，Inter-Process Communication）。跨进程通信意味着可以在一个进程访问另一个进程的数据，或调用另一个进程的方法。 通常把应用接口提供方（供调用）称为服务端，调用方称为客户端。客户端通过绑定服务端的Ability来与之进行交互，类似于绑定服务。关于HarmonyOS IDL接口语言的详细描述请参考HarmonyOS IDL接口使用规范。 
说明
只能使用Java或C++语言构建.idl文件，因此仅Java、Java+JS、C/C++工程支持IDL。 仅API 4-7的Gradle工程支持IDL。 
  创建.idl文件在已经创建/打开的HarmonyOS工程中，选择module目录或其子目录，单击鼠标右键，选择New > Idl File。 创建IDL File。可以直接输入IDL接口名称，也可以通过包名格式定义idl接口名称。两种方式的差异仅在于.idl文件的文件目录结构。按名称创建，创建IDL File时，输入接口名称，直接单击OK。  DevEco Studio在相应“module”的src>main路径下生成idl文件夹，并按照对应模块的包名生成同样的目录结构及IDL文件。  开发者可以使用Java或C++编程语言构建.idl文件，关于HarmonyOS IDL接口的实现请参考IDL开发指南。单击工程右边栏的Gradle，在Tasks > ohos:debug或ohos:release中选择compileDebugIdl或compileReleaseIdl，对模块下的IDL文件进行编译。 编译完成后，在build > generated > source > idl>debug/release> {Package Name}目录下，生成对应的接口类、桩类和代理类，如下图所示：    上一篇 开发及引用动态共享包 下一篇 创建服务卡片 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。图片 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    图片开发概述  图片解码  图片处理  图片编码  图片工具   上一篇 视频播放 下一篇 图片开发概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤开发示例-对资源文件中的图片进行解码图片解码 更新时间: 2024-03-20 16:30 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
  图片解码指将所支持格式的存档图片解码成统一的PixelMap，以便在应用或系统中进行图片显示或图片处理。当前支持的存档图片格式包括JPEG、PNG、GIF、RAW、WebP、BMP、SVG。  开发步骤 图片解码相关API的详细介绍请参见：图片解码接口说明。  全局导入Image模块。已复制import image from '@ohos.multimedia.image'; 获取图片。        方法一：获取沙箱路径。具体请参考获取应用文件路径。应用沙箱的介绍及如何向应用沙箱推送文件，请参考文件管理。已复制// Stage模型参考如下代码const context = getContext(this);const filePath = context.cacheDir + '/test.jpg'; 已复制// FA模型参考如下代码import featureAbility from '@ohos.ability.featureAbility';
const context = featureAbility.getContext();const filePath = context.getCacheDir() + "/test.jpg"; 方法二：通过沙箱路径获取图片的文件描述符。具体请参考file.fs API参考文档。该方法需要先导入@ohos.file.fs模块。 已复制import fs from '@ohos.file.fs'; 然后调用fs.openSync()获取文件描述符。 已复制// Stage模型参考如下代码const context = getContext(this);const filePath = context.cacheDir + '/test.jpg';const file = fs.openSync(filePath, fs.OpenMode.READ_WRITE);const fd = file?.fd; 已复制// FA模型参考如下代码import featureAbility from '@ohos.ability.featureAbility';
const context = featureAbility.getContext();const filePath = context.getCacheDir() + "/test.jpg";const file = fs.openSync(filePath, fs.OpenMode.READ_WRITE);const fd = file?.fd; 方法三：通过资源管理器获取资源文件的ArrayBuffer。具体请参考ResourceManager API参考文档。已复制// Stage模型const context = getContext(this);// 获取resourceManager资源管理器const resourceMgr = context.resourceManager; 已复制// FA模型// 导入resourceManager资源管理器import resourceManager from '@ohos.resourceManager';const resourceMgr = await resourceManager.getResourceManager(); 不同模型获取资源管理器的方式不同，获取资源管理器后，再调用resourceMgr.getRawFileContent()获取资源文件的ArrayBuffer。 已复制const fileData = await resourceMgr.getRawFileContent('test.jpg');// 获取图片的ArrayBufferconst buffer = fileData.buffer;  创建ImageSource实例。        方法一：通过沙箱路径创建ImageSource。沙箱路径可以通过步骤2的方法一获取。已复制// path为已获得的沙箱路径const imageSource = image.createImageSource(filePath); 方法二：通过文件描述符fd创建ImageSource。文件描述符可以通过步骤2的方法二获取。已复制// fd为已获得的文件描述符const imageSource = image.createImageSource(fd); 方法三：通过缓冲区数组创建ImageSource。缓冲区数组可以通过步骤2的方法三获取。已复制const imageSource = image.createImageSource(buffer);  设置解码参数DecodingOptions，解码获取PixelMap图片对象。已复制let decodingOptions = {    editable: true,    desiredPixelFormat: 3,}// 创建pixelMap并进行简单的旋转和缩放 const pixelMap = await imageSource.createPixelMap(decodingOptions); 解码完成，获取到PixelMap对象后，可以进行后续图片处理。    开发示例-对资源文件中的图片进行解码  获取resourceManager资源管理。已复制const context = getContext(this);// 获取resourceManager资源管理const resourceMgr = context.resourceManager; 获取rawfile文件夹下test.jpg的ArrayBuffer。已复制const fileData = await resourceMgr.getRawFileContent('test.jpg');// 获取图片的ArrayBufferconst buffer = fileData.buffer; 创建imageSource。已复制const imageSource = image.createImageSource(buffer); 创建PixelMap。已复制const pixelMap = await imageSource.createPixelMap();    上一篇 图片开发概述 下一篇 图片处理 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤图片编码 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  图片编码指将PixelMap编码成不同格式的存档图片（当前仅支持打包为JPEG和WebP格式），用于后续处理，如保存、传输等。  开发步骤 图片编码相关API的详细介绍请参见API参考。  创建图像编码ImagePacker对象。已复制// 导入相关模块包import image from '@ohos.multimedia.image';
const imagePackerApi = image.createImagePacker(); 设置编码输出流和编码参数。format为图像的编码格式；quality为图像质量，范围从0-100，100为最佳质量。 已复制let packOpts = { format:"image/jpeg", quality:98 }; 创建PixelMap对象或创建ImageSource对象。 进行图片编码，并保存编码后的图片。方法一：通过PixelMap进行编码。 已复制imagePackerApi.packing(pixelMap, packOpts).then( data => {  // data 为打包获取到的文件流，写入文件保存即可得到一张图片}).catch(error => {   console.error('Failed to pack the image. And the error is: ' + error); }) 方法二：通过imageSource进行编码。 已复制imagePackerApi.packing(imageSource, packOpts).then( data => {    // data 为打包获取到的文件流，写入文件保存即可得到一张图片}).catch(error => {   console.error('Failed to pack the image. And the error is: ' + error); })    上一篇 位图操作 下一篇 图片工具 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。图片开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 应用开发中的图片开发是对图片像素数据进行解析、处理、构造的过程，达到目标图片效果，主要涉及图片解码、图片处理、图片编码等。 在学习图片开发前，需要熟悉以下基本概念。 图片解码指将所支持格式的存档图片解码成统一的PixelMap，以便在应用或系统中进行图片显示或图片处理。当前支持的存档图片格式包括JPEG、PNG、GIF、RAW、WebP、BMP、SVG。  PixelMap指图片解码后无压缩的位图，用于图片显示或图片处理。 图片处理指对PixelMap进行相关的操作，如旋转、缩放、设置透明度、获取图片信息、读写像素数据等。  图片编码指将PixelMap编码成不同格式的存档图片（当前仅支持JPEG和WebP），用于后续处理，如保存、传输等。  图片开发的主要流程如下图所示。 图1 图片开发流程示意图 获取图片：通过应用沙箱等方式获取原始图片。创建ImageSource实例：ImageSource是图片解码出来的图片源类，用于获取或修改图片相关信息。图片解码：通过ImageSource解码生成PixelMap。图片处理：对PixelMap进行处理，更改图片属性实现图片的旋转、缩放、裁剪等效果。然后通过Image组件显示图片。图片编码：使用图片打包器类ImagePacker，将PixelMap或ImageSource进行压缩编码，生成一张新的图片。 除上述基本图片开发能力外，HarmonyOS还提供常用图片工具，供开发者选择使用。  上一篇 图片 下一篇 图片解码 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤位图操作 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  当需要对目标图片中的部分区域进行处理时，可以使用位图操作功能。此功能常用于图片美化等操作。 如下图所示，一张图片中，将指定的矩形区域像素数据读取出来，进行修改后，再写回原图片对应区域。  图1 位图操作示意图   开发步骤 位图操作相关API的详细介绍请参见API参考。  完成图片解码，获取PixelMap位图对象。 从PixelMap位图对象中获取信息。 已复制// 获取图像像素的总字节数let pixelBytesNumber = pixelMap.getPixelBytesNumber();// 获取图像像素每行字节数let rowCount = pixelMap.getBytesNumberPerRow();// 获取当前图像像素密度。像素密度是指每英寸图片所拥有的像素数量。像素密度越大，图片越精细。let getDensity = pixelMap.getDensity(); 读取并修改目标区域像素数据，写回原图。已复制// 场景一：将读取的整张图像像素数据结果写入ArrayBuffer中const readBuffer = new ArrayBuffer(pixelBytesNumber);pixelMap.readPixelsToBuffer(readBuffer).then(() => {  console.info('Succeeded in reading image pixel data.');}).catch(error => {  console.error('Failed to read image pixel data. And the error is: ' + error);})
// 场景二：读取指定区域内的图片数据，结果写入area.pixels中const area = {  pixels: new ArrayBuffer(8),  offset: 0,  stride: 8,  region: { size: { height: 1, width: 2 }, x: 0, y: 0 }}pixelMap.readPixels(area).then(() => {  console.info('Succeeded in reading the image data in the area.');}).catch(error => {  console.error('Failed to read the image data in the area. And the error is: ' + error);})
// 对于读取的图片数据，可以独立使用（创建新的pixelMap），也可以对area.pixels进行所需修改// 将图片数据area.pixels写入指定区域内pixelMap.writePixels(area).then(() => {  console.info('Succeeded to write pixelMap into the specified area.');})
// 将图片数据结果写入pixelMap中const writeColor = new ArrayBuffer(96);pixelMap.writeBufferToPixels(writeColor, () => {});    上一篇 图像变换 下一篇 图片编码 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。图片处理 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    图像变换  位图操作   上一篇 图片解码 下一篇 图像变换 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤图片工具 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  图片工具当前主要提供图片EXIF信息的读取与编辑能力。 EXIF（Exchangeable image file format）是专门为数码相机的照片设定的文件格式，可以记录数码照片的属性信息和拍摄数据。当前仅支持JPEG格式图片。 在图库等应用中，需要查看或修改数码照片的EXIF信息。由于摄像机的手动镜头的参数无法自动写入到EXIF信息中或者因为相机断电等原因经常会导致拍摄时间出错，这时候就需要手动修改错误的EXIF数据，即可使用本功能。 HarmonyOS目前仅支持对部分EXIF信息的查看和修改，具体支持的范围请参见：EIXF信息。  开发步骤 EXIF信息的读取与编辑相关API的详细介绍请参见API参考。  获取图片，创建图片源ImageSource。已复制// 导入相关模块包import image from '@ohos.multimedia.image';
// 获取沙箱路径创建ImageSourceconst fd = ...; // 获取需要被处理的图片的fdconst imageSource = image.createImageSource(fd); 读取、编辑EXIF信息。已复制// 读取EXIF信息，BitsPerSample为每个像素比特数imageSource.getImageProperty('BitsPerSample', (error, data) => {  if (error) {    console.error('Failed to get the value of the specified attribute key of the image.And the error is: ' + error);  } else {    console.info('Succeeded in getting the value of the specified attribute key of the image ' + data);  }})
// 编辑EXIF信息imageSource.modifyImageProperty('ImageWidth', '120').then(() => {  const width = imageSource.getImageProperty("ImageWidth");  console.info('The new imageWidth is ' + width);})    上一篇 图片编码 下一篇 安全 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤图像变换 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  图片处理指对PixelMap进行相关的操作，如获取图片信息、裁剪、缩放、偏移、旋转、翻转、设置透明度、读写像素数据等。图片处理主要包括图像变换、位图操作，本文介绍图像变换。  开发步骤 图像变换相关API的详细介绍请参见API参考。  完成图片解码，获取Pixelmap对象。 获取图片信息。已复制// 获取图片大小pixelMap.getImageInfo().then( info => {  console.info('info.width = ' + info.size.width);  console.info('info.height = ' + info.size.height);}).catch((err) => {  console.error("Failed to obtain the image pixel map information.And the error is: " + err);}); 进行图像变换操作。原图：    裁剪已复制// x: 裁剪起始点横坐标0// y: 裁剪起始点纵坐标0// height: 裁剪高度400，方向为从上往下（裁剪后的图片高度为400）// width: 裁剪宽度400，方向为从左到右（裁剪后的图片宽度为400）pixelMap.crop({ x: 0, y: 0, size: { height: 400, width: 400 } });  缩放已复制// 宽为原来的0.5// 高为原来的0.5pixelMap.scale(0.5, 0.5);  偏移已复制// 向下偏移100// 向右偏移100pixelMap.translate(100, 100);  旋转已复制// 顺时针旋转90°pixelMap.rotate(90);  翻转已复制// 垂直翻转pixelMap.flip(false, true);  已复制// 水平翻转 pixelMap.flip(true, false);  透明度已复制// 透明度0.5 pixelMap.opacity(0.5);       上一篇 图片处理 下一篇 位图操作 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发应用内HSP导出ts类和方法导出ArkUI组件导出native方法使用应用内HSP跨包页面路由跳转应用内HSP开发指导 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 应用内HSP指的是专门为某一应用开发的HSP，只能被该应用内部其他HAP/HSP使用，用于应用内部代码、资源的共享。 应用内HSP跟随其宿主应用的APP包一起发布，与该宿主应用具有相同的包名和生命周期。 开发应用内HSPHSP模块可以在DevEco Studio中由指定模板创建，我们以创建一个名为library的HSP模块为例。基本的工程目录结构大致如下： 已复制library├── src│   └── main│       ├── ets│       │   ├── pages│       │   └── index.ets│       ├── resources│       └── module.json5└── oh-package.json5 模块module.json5中的"type"标识模块类型，HSP的"type"是"shared"。 已复制{    "type": "shared"} HSP通过在入口文件中导出接口，对外提供能力。入口文件在模块oh-package.json5的"main"中配置。例如： 已复制{    "main": "./src/main/ets/index.ets"}  导出ts类和方法通过export导出ts类和方法，例如： 已复制// library/src/main/ets/utils/test.tsexport class Log {    static info(msg) {        console.info(msg);    }}
export function add(a: number, b: number) {  return a + b;}
export function minus(a: number, b: number) {  return a - b;} 对外暴露的接口，需要在入口文件index.ets中声明： 已复制// library/src/main/ets/index.etsexport { Log, add, minus } from './utils/test'  导出ArkUI组件ArkUI组件也可以通过export导出，例如： 已复制// library/src/main/ets/components/MyTitleBar.ets@Componentexport struct MyTitleBar {  build() {    Row() {      Text($r('app.string.library_title'))        .fontColor($r('app.color.white'))        .fontSize(25)        .margin({left:15})    }    .width('100%')    .height(50)    .padding({left:15})    .backgroundColor('#0D9FFB')  }} 对外暴露的接口，需要在入口文件index.ets中声明： 已复制// library/src/main/ets/index.etsexport { MyTitleBar } from './components/MyTitleBar'  HSP中资源使用说明 注意，在HSP中，通过$r/$rawfile可以使用本模块resources目录下的资源。 如果使用相对路径的方式，例如： 在HSP模块中使用Image("common/example.png")，实际上该Image组件访问的是HSP调用方（如entry）下的资源entry/src/main/ets/common/example.png。 导出native方法在HSP中也可以包含C++编写的so。对于so中的native方法，HSP通过间接的方式导出，以导出libnative.so的乘法接口multi为例： 已复制// ibrary/src/main/ets/utils/nativeTest.tsimport native from "libnative.so"
export function nativeMulti(a: number, b: number) {    return native.multi(a, b);} 对外暴露的接口，需要在入口文件index.ets中声明： 已复制// library/src/main/ets/index.etsexport { nativeMulti } from './utils/nativeTest'  使用应用内HSP要使用HSP中的接口，首先需要在使用方的oh-package.json5中配置对它的依赖。如果应用内HSP和使用方在同一工程下，可以直接本地引用，例如： 已复制// entry/oh-package.json5"dependencies": {    "library": "file:../library"} 然后就可以像使用HAR一样调用HSP的对外接口了。 例如，上面的library已经导出了下面这些接口： 已复制// library/src/main/ets/index.etsexport { Log, add, minus } from './utils/test'export { MyTitleBar } from './components/MyTitleBar'export { nativeMulti } from './utils/nativeTest' 在使用方的代码中，可以这样使用： 已复制// entry/src/main/ets/pages/index.etsimport { Log, add, MyTitleBar, nativeMulti } from "library"
@Entry@Componentstruct Index {  @State message: string = 'Hello World'  build() {    Row() {      Column() {        MyTitleBar()        Text(this.message)          .fontSize(30)          .fontWeight(FontWeight.Bold)        Button('add(1, 2)')          .onClick(()=>{            Log.info("add button click!");            this.message = "result: " + add(1, 2);          })        Button('nativeMulti(3, 4)')          .onClick(()=>{            Log.info("nativeMulti button click!");            this.message = "result: " + nativeMulti(3, 4);          })      }      .width('100%')    }    .height('100%')  }}  跨包页面路由跳转若开发者想在entry模块中，添加一个按钮跳转至library模块中的menu页面（路径为：library/src/main/ets/pages/menu.ets），那么可以在使用方的代码（entry模块下的Index.ets，路径为：entry/src/main/ets/MainAbility/Index.ets）里这样使用： 已复制import router from '@ohos.router';
@Entry@Componentstruct Index {    @State message: string = 'Hello World'
    build() {    Row() {        Column() {        Text(this.message)            .fontSize(50)            .fontWeight(FontWeight.Bold)        // 添加按钮，以响应用户点击        Button() {            Text('click to menu')            .fontSize(30)            .fontWeight(FontWeight.Bold)        }        .type(ButtonType.Capsule)        .margin({            top: 20        })        .backgroundColor('#0D9FFB')        .width('40%')        .height('5%')        // 绑定点击事件        .onClick(() => {            router.pushUrl({              url: '@bundle:com.example.hmservice/library/ets/pages/menu'            }).then(() => {              console.log("push page success");            }).catch(err => {              console.error(`pushUrl failed, code is ${err.code}, message is ${err.message}`);            })        })      .width('100%')    }    .height('100%')    }  }} 其中router.pushUrl方法的入参中url的内容为： 已复制'@bundle:com.example.hmservice/library/ets/pages/menu' url内容的模板为： 已复制'@bundle:包名（bundleName）/模块名（moduleName）/路径/页面所在的文件名(不加.ets后缀)'   上一篇 HSP 下一篇 应用程序包快速修复 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。Web 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
    Web组件概述  使用Web组件加载页面  设置基本属性和事件  在应用中使用前端页面JavaScript  管理页面跳转及浏览记录导航  管理Cookie及数据存储  自定义页面请求响应  使用Devtools工具调试前端页面   上一篇 自定义组件 下一篇 Web组件概述 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍导入模块接口说明虚拟键盘弹出检测开发步骤输入设备开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 输入设备管理提供设备热插拔监听、查询指定设备的键盘类型等能力。使用场景例如：当用户需要输入文本时，输入法会根据当前是否插入了物理键盘来决定是否弹出虚拟键盘，开发者可以通过监听设备热插拔判断是否有物理键盘插入。   导入模块 已复制import inputDevice from '@ohos.multimodalInput.inputDevice';   接口说明 输入设备管理常用接口如下表所示，接口详细介绍请参考ohos.multimodalInput.inputDevice文档。     实例名 接口名 说明    inputDevice function getDeviceList(): Promise<Array<number>>; 获取输入设备列表。   inputDevice function getKeyboardType(deviceId: number): Promise<KeyboardType>; 获取输入设备的键盘类型。   inputDevice function on(type: "change", listener: Callback<DeviceListener>): void; 监听输入设备的热插拔事件。   inputDevice function off(type: "change", listener?: Callback<DeviceListener>): void; 取消监听输入设备的热插拔事件。      虚拟键盘弹出检测 当用户需要输入文本时，输入法会根据当前是否插入了物理键盘来决定是否弹出虚拟键盘，开发者可以通过监听设备热插拔，判断是否有物理键盘插入。   开发步骤  调用getDeviceList方法查询所有连接的输入设备，调用getKeyboardType方法遍历所有连接的设备，判断是否有物理键盘，若有则标记已有物理键盘连接，该步骤确保监听设备热插拔之前，检测所有插入的输入设备。 调用on接口监听输入设备热插拔事件，若监听到有物理键盘插入，则标记已有物理键盘连接；若监听到有物理键盘拔掉，则标记没有物理键盘连接。  已复制import inputDevice from '@ohos.multimodalInput.inputDevice';
let isPhysicalKeyboardExist = true;try {  // 1.获取设备列表，判断是否有物理键盘连接  inputDevice.getDeviceList().then(data => {    for (let i = 0; i < data.length; ++i) {      inputDevice.getKeyboardType(data[i]).then(type => {        if (type === inputDevice.KeyboardType.ALPHABETIC_KEYBOARD) {          // 物理键盘已连接          isPhysicalKeyboardExist = true;        }      });    }  });  // 2.监听设备热插拔  inputDevice.on("change", (data) => {    console.log(`Device event info: ${JSON.stringify(data)}`);    inputDevice.getKeyboardType(data.deviceId).then((type) => {      console.log("The keyboard type is: " + type);      if (type === inputDevice.KeyboardType.ALPHABETIC_KEYBOARD && data.type == 'add') {        // 物理键盘已插入        isPhysicalKeyboardExist = true;      } else if (type == inputDevice.KeyboardType.ALPHABETIC_KEYBOARD && data.type == 'remove') {        // 物理键盘已拔掉        isPhysicalKeyboardExist = false;      }    });  });} catch (error) {  console.log(`Execute failed, error: ${JSON.stringify(error, [`code`, `message`])}`);}   上一篇 多模输入 下一篇 鼠标光标开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。搭建开发环境流程 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco Studio支持Windows系统和macOS系统，在开发应用/服务前，需要配置应用/服务的开发环境。环境配置流程如下所示：  如上图所示，搭建HarmonyOS应用/服务开发的环境包括软件安装、配置开发环境和运行Hello World三个环节，详细的指导请参考： 步骤  操作步骤  操作指导  说明    1  软件安装  Windows环境  安装DevEco Studio。   macOS环境   2  配置开发环境  （可选）配置Proxy  网络不能直接访问Internet，可通过设置代理服务器进行访问。 如果无需代理即可访问Internet，将跳过该步骤。   5  安装Node.js和ohpm  指定本地已安装的Node.js/ohpm，或在线下载。   6  下载HarmonyOS SDK  -   7  运行HelloWorld   创建一个新工程  使用模拟器运行Demo工程，验证环境是否已经配置完成。   8  运行Hello World      上一篇 快速开始 下一篇 下载与安装软件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念运作机制约束与限制国际化开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 当应用具有多个在语言、时区、区域特性等方面存在显著差异的目标用户和市场时，开发者往往需要提供应用的多个本地化版本，以保证不同地区用户的体验。 应用的国际化能力决定了应用本地化过程的难易程度。系统提供了一系列的国际化接口，基于这些国际化接口，开发者可以设计并实现具有良好国际化能力的应用，从而可以高效、低成本的实现应用的本地化。 基本概念Locale：Locale是对一个群体在语言、脚本、国家或区域，以及日历、排序、货币等区域特性方面的共性的抽象表示。 偏好语言：偏好语言是用户设置过的语言，表示该语言是用户可接受的语言。用户可以在 设置/系统和更新/语言和输入法/语言和地区/添加语言中添加偏好语言。   运作机制在调用国际化接口时，需要提供Locale信息，接口会依据该Locale的特性进行差异化的执行。Locale信息可以由开发人员通过硬编码的方式提供，但更通常的情况是使用用户设置的系统语言和区域。  约束与限制无   上一篇 国际化 下一篇 Intl开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。设置区域信息接口说明开发步骤格式化日期时间接口说明开发步骤数字格式化接口说明开发步骤字符串排序接口说明开发步骤判定单复数类别接口说明开发步骤相对时间格式化接口说明开发步骤Intl开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  本模块提供基础的应用国际化能力，包括时间日期格式化、数字格式化、排序等，相关接口在ECMA 402标准中定义。更多接口和使用方式请见Intl。 I18N模块提供其他非ECMA 402定义的国际化接口，与本模块共同使用可提供完整地国际化支持能力。  设置区域信息 调用Locale的相关接口实现最大化区域信息或最小化区域信息。   接口说明     类名 接口名称 描述    Locale constructor()8+ 实例化Locale对象。   Locale constructor(locale:string,options?:LocaleOptions) 基于locale参数及其选项实例化Locale对象。   Locale toString():string 将Locale信息转换为字符串。   Locale maximize():Locale 最大化区域信息。   Locale minimize():Locale 最小化区域信息。      开发步骤  导入Intl模块。 未正确导入包可能会产生不明确的接口行为。 已复制import Intl from '@ohos.intl'; 实例化Locale对象。 使用Locale的构造函数创建Locale对象，该方法接收一个表示Locale的字符串及可选的属性列表（intl为导入的模块名）。 表示Locale的字符串参数可以分为以下四部分：语言、脚本、地区、扩展参数。各个部分按照顺序使用中划线“-”进行连接。  语言：必选，使用2个或3个小写英文字母表示（可参考ISO-639标准），例如英文使用“en”表示，中文使用“zh”表示。 脚本：可选，使用4个英文字母表示，其中首字母需要大写，后面3个使用小写字母（可参考ISO-15924）。例如，中文繁体使用脚本“Hant”表示，中文简体使用脚本“Hans”表示。 国家或地区：可选，使用两个大写字母表示（可参考ISO-3166），例如中国使用“CN”表示，美国使用“US”表示； 扩展参数：可选，由key和value两部分组成，目前支持以下扩展参数（可参考BCP 47扩展）。各个扩展参数之间没有严格的顺序，使用“-key-value”的格式书写。扩展参数整体使用“-u”连接到语言、脚本、地区后面。例如“zh-u-nu-latn-ca-chinese”表示使用“latn”数字系统，“chinese”日历系统。扩展参数也可以通过第二个参数传入。              扩展参数ID 扩展参数说明    ca 表示日历系统   co 表示排序规则   hc 表示守时惯例   nu 表示数字系统   kn 表示字符串排序、比较时是否考虑数字的实际值   kf 表示字符串排序、比较时是否考虑大小写     已复制let locale = "zh-CN";let options = {caseFirst: "false", calendar: "chinese", collation: "pinyin"};let localeObj = new Intl.Locale(locale, options); 获取Locale的字符串表示。 调用toString方法来获取Locale对象的字符串表示，其中包括了语言、区域及其他选项信息。 已复制let localeStr = localeObj.toString(); // localeStr = "zh-CN-u-ca-chinese-co-pinyin-kf-false 最大化区域信息。 调用maximize方法来最大化区域信息，即当缺少脚本与地区信息时，对其进行补全。 已复制let maximizedLocale = localeObj.maximize();let maximizedLocaleStr = maximizedLocale.toString(); // localeStr = "zh-Hans-CN-u-ca-chinese-co-pinyin-kf-false 最小化区域信息。 调用minimize方法来最小化区域信息，即当存在脚本与地区信息时，对其进行删除。 已复制let minimizedLocale = localeObj.minimize();let minimizedLocaleStr = minimizedLocale.toString(); // zh-u-ca-chinese-co-pinyin-kf-false    格式化日期时间 调用日期时间格式化DateTimeFormat的接口，实现针对特定Locale的日期格式化以及时间段格式化功能。   接口说明     类名 接口名称 描述    DateTimeFormat constructor()8+ 创建日期时间格式化对象。   DateTimeFormat constructor(locale:string|Array<string>,options?:DateTimeOptions) 创建日期时间格式化对象，并设置提供的Locale和格式化相关属性。   DateTimeFormat format(date:Date):string 依据DateTimeFormat对象的Locale及其他格式化属性，计算日期时间的格式化表示。   DateTimeFormat formatRange(startDate:Date,endDate:Date):string 依据DateTimeFormat对象的Locale及其他格式化属性，计算时间段的格式化表示。   DateTimeFormat resolvedOptions():DateTimeOptions 获取DateTimeFormat对象的相关属性。      开发步骤  导入Intl模块。 未正确导入包可能会产生不明确的接口行为。 已复制import Intl from '@ohos.intl'; 实例化日期时间格式化对象。 一种方法是使用DateTimeFormat提供的默认构造函数，通过访问系统语言和地区设置，获取系统默认Locale，并将其作为DateTimeFormat对象内部的Locale。 已复制let dateTimeFormat = new Intl.DateTimeFormat(); 另一种方法是使用开发者提供的Locale和格式化参数来创建日期时间格式化对象。其中，格式化参数是可选的，完整的格式化参数列表见DateTimeOptions。 已复制let options = {dateStyle: "full", timeStyle: "full"};let dateTimeFormat = new Intl.DateTimeFormat("zh-CN", options); 格式化日期时间。 使用DateTimeFormat的format方法对一个Date对象进行格式化，该方法会返回一个字符串作为格式化的结果。 已复制let options = {dateStyle: "full", timeStyle: "full"};let dateTimeFormat = new Intl.DateTimeFormat("zh-CN", options);let date = new Date(2022, 12, 12, 12, 12, 12);let formatResult = dateTimeFormat.format(date); // formatResult = "2023年1月12日星期四 中国标准时间 下午12:12:12" 格式化时间段。 使用DateTimeFormat的formatRange方法对一个时间段进行格式化。该方法需要传入两个Date对象，分别表示时间段的起止日期，返回一个字符串作为格式化的结果。 已复制let startDate = new Date(2021, 11, 17, 3, 24, 0);let endDate = new Date(2021, 11, 18, 3, 24, 0);let datefmt = new Intl.DateTimeFormat("en-GB");let formatRangeResult = datefmt.formatRange(startDate, endDate); // formatRangeResult = "17/12/2021-18/12/2021" 访问日期时间格式化对象的相关属性。 DateTimeFormat的resolvedOptions方法会返回一个对象，该对象包含了DateTimeFormat对象的所有相关属性及其值。 已复制let options = {dateStyle: "full", timeStyle: "full"};let dateTimeFormat = new Intl.DateTimeFormat("zh-CN", options);let resolvedOptions = dateTimeFormat.resolvedOptions(); // resolvedOptions = {"locale": "zh-CN", "calendar": "gregorian", "dateStyle":"full", "timeStyle":"full", "timeZone": "CST"}    数字格式化 调用数字格式化NumberFormat的接口，实现针对特定Locale的数字格式化功能。   接口说明     类名 接口名称 描述    NumberFormat constructor()8+ 创建数字格式化对象。   NumberFormat constructor(locale:string|Array<string>,options?:NumberOptions) 创建数字格式化对象，并设置提供的locale和格式化相关属性。   NumberFormat format(number:number):string 依据NumberFormat对象的Locale及其他格式化属性，计算数字的格式化表示。   NumberFormat resolvedOptions():NumberOptions 获取NumberFormat对象的相关属性。      开发步骤  导入Intl模块。 未正确导入包可能会产生不明确的接口行为。 已复制import Intl from '@ohos.intl'; 实例化数字格式化对象。 一种方法是使用NumberFormat提供的默认构造函数，通过访问系统的语言和地区以获取系统默认Locale并进行设置（intl为导入的模块名）。 已复制let numberFormat = new Intl.NumberFormat(); 另一种方法是使用开发者提供的Locale和格式化参数来创建数字格式化对象。其中，格式化参数是可选的，完整的格式化参数列表参见NumberOptions。 已复制let options = {compactDisplay: "short", notation: "compact"};let numberFormat = new Intl.NumberFormat("zh-CN", options); 数字格式化。 使用NumberFormat的format方法对传入的数字进行格式化。该方法返回一个字符串作为格式化的结果。 已复制let options = {compactDisplay: "short", notation: "compact"};let numberFormat = new Intl.NumberFormat("zh-CN", options);let number = 1234.5678;let formatResult = numberFormat.format(number); // formatResult = "1235" 访问数字格式化对象的相关属性。 NumberFormat的resolvedOptions方法会返回一个对象，该对象包含了NumberFormat对象的所有相关属性及其值。 已复制let options = {compactDisplay: "short", notation: "compact"};let numberFormat = new Intl.NumberFormat("zh-CN", options);let resolvedOptions = numberFormat.resolvedOptions();  // resolvedOptions = {"locale": "zh-CN", "compactDisplay": "short", "notation": "compact", "numberingSystem": "Latn"}    字符串排序 不同区域的用户对于字符串排序具有不同的需求。调用字符串排序Collator的接口，实现针对特定Locale的字符串排序功能。   接口说明     类名 接口名称 描述    Collator constructor()8+ 创建排序对象。   Collator constructor(locale:string|Array<string>,options?:CollatorOptions)8+ 创建排序对象，并设置提供的locale和其他相关属性。   Collator compare(first:string,second:string):number8+ 依据排序对象的Locale及其属性，计算两个字符串的比较结果。   Collator resolvedOptions():CollatorOptions8+ 获取排序对象的相关属性。      开发步骤  导入Intl模块。 未正确导入包可能会产生不明确的接口行为。 已复制import Intl from '@ohos.intl'; 实例化排序对象。 一种方法是使用Collator提供的默认构造函数，通过访问系统的语言和地区以获取系统默认Locale并进行设置（intl为导入的模块名）。 已复制let collator = new Intl.Collator(); 另一种方法是使用开发者提供的Locale和其他相关参数来创建Collator对象，完整的参数列表参见CollatorOptions。 其中，sensitivity参数用于控制哪些级别的差异会被用于比较两个字符串。取值"base"表示，仅比较字符本身，不考虑重音符号、大小写差异。例如，'a' != 'b'，'a' == 'á'，'a' == 'A'。取值"accent"表示考虑重音符号，不考虑大小写的差异。例如，'a' != 'b'，'a' != 'á'，'a' == 'A'。取值"case"表示考虑大小写的差异，不考虑重音符号的差异。例如，'a' != 'b'，'a' == 'á'，'a' != 'A'。取值"variant"表示考虑重音符号、大小写等方面差异。例如'a' != 'b'，'a' != 'á'，'a' != 'A'。 已复制let collator= new Intl.Collator("zh-CN", {localeMatcher: "best fit", usage: "sort", sensitivity: "case"}); 比较字符串。 使用Collator的compare方法对传入的两个字符串进行比较。该方法返回一个数值作为比较的结果，返回-1表示第一个字符串小于第二个字符串，返回1表示第一个字符大于第二个字符串，返回0表示两个字符串相同。基于两个字符串的比较结果，开发者可以字符串集合进行排序。 已复制let collator= new Intl.Collator("zh-CN", {localeMatcher: "best fit", usage: "sort", sensitivity: "case"});let str1 = "first string";let str2 = "second string";let compareResult = collator.compare(str1, str2); // compareResult = -1str1 = "first";str2 = "First";compareResult = collator.compare(str1, str2); // compareResult = -1 访问排序对象的相关属性。 Collator的resolvedOptions方法会返回一个对象，该对象包含了Collator对象的所有相关属性及其值。 已复制let collator= new Intl.Collator("zh-CN", {localeMatcher: "best fit", usage: "sort"});let options = collator.resolvedOptions(); // options = {"localeMatcher": "best fit", "locale": "zh-CN", "usage": "sort", "sensitivity": "variant", "ignorePunctuation": "false", "numeric": false, "caseFirst": "false", "collation": "default"}    判定单复数类别 在一些语言的语法中，当数字后面存在名词时，名词需要根据数字的值采用不同的形式。调用单复数PluralRules的接口，可以实现针对特定Locale计算数字单复数类别的功能，从而选择合适的名词单复数表示。   接口说明     类名 接口名称 描述    PluralRules constructor()8+ 创建单复数对象。   PluralRules constructor(locale:string|Array<string>,options?:PluralRulesOptions)8+ 创建单复数对象，并设置提供的locale和其他相关属性。   PluralRules select(n:number):string8+ 依据单复数对象的Locale及其他格式化属性，计算数字的单复数类别。      开发步骤  导入Intl模块。 未正确导入包可能会产生不明确的接口行为。 已复制import Intl from '@ohos.intl'; 实例化单复数对象。 一种方法是使用PluralRules提供的默认构造函数，通过访问系统的语言和地区以获取系统默认Locale并进行设置（intl为导入的模块名）。 已复制let pluralRules = new Intl.PluralRules(); 另一种方法是使用开发者提供的Locale和其他相关参数来创建单复数对象。完整的参数列表参见PluralRulesOptions。 已复制let pluralRules = new Intl.PluralRules("zh-CN", {localeMatcher: "best fit", type: "cardinal"}); 计算数字单复数类别。 使用PluralRules的select方法计算传入数字的单复数类别。该方法返回一个字符串作为传入数字的类别，包括："zero", "one", "two", "few", "many", "other"六个类别。 已复制let pluralRules = new Intl.PluralRules("zh-CN", {localeMatcher: "best fit", type: "cardinal"});let number = 1234.5678;let categoryResult = pluralRules.select(number); // categoryResult = "other"    相对时间格式化 调用相对时间格式化RelativeTimeFormat的接口，实现针对特定Locale的相对时间格式化功能。   接口说明     类名 接口名称 描述    RelativeTimeFormat constructor()8+ 创建相对时间格式化对象。   RelativeTimeFormat constructor(locale:string|Array<string>,options?:RelativeTimeFormatInputOptions)8+ 创建相对时间格式化对象，并设置提供的locale和格式化相关属性。   RelativeTimeFormat format(value:number,unit:string):string8+ 依据相对时间格式化对象的Locale及其他格式化属性，计算相对时间的格式化表示。   RelativeTimeFormat formatToParts(value:number,unit:string):Array<object>8+ 依据相对时间格式化对象的Locale及其他格式化属性，返回相对时间格式化表示的各个部分。   RelativeTimeFormat resolvedOptions():RelativeTimeFormatResolvedOptions8+ 获取相对时间格式化对象的相关属性。      开发步骤  导入Intl模块。 未正确导入包可能会产生不明确的接口行为。 已复制import Intl from '@ohos.intl'; 实例化相对时间格式化对象。 一种方法是使用RelativeTimeFormat提供的默认构造函数，通过访问系统的语言和地区以获取系统默认Locale并进行设置（intl为导入的模块名）。 已复制let relativeTimeFormat = new Intl.RelativeTimeFormat(); 另一种方法是使用开发者提供的Locale和格式化参数来创建相对时间格式化对象。其中，格式化参数是可选的，完整的参数列表参见 RelativeTimeFormatInputOptions。 已复制let relativeTimeFormat = new Intl.RelativeTimeFormat("zh-CN", {numeric: "always", style: "long"}); 相对时间格式化。 使用RelativeTimeFormat的format方法对相对时间进行格式化。方法接收一个表示相对时间长度的数值和表示单位的字符串，其中单位包括："year", "quarter", "month", "week", "day", "hour", "minute", "second"。方法返回一个字符串作为格式化的结果。 已复制let relativeTimeFormat = new Intl.RelativeTimeFormat("zh-CN", {numeric: "always", style: "long"});let number = 2;let unit = "year";let formatResult = relativeTimeFormat.format(number, unit); // 2年后 获取相对时间格式化结果的各个部分。 获取相对时间格式化结果的各个部分，从而自定义格式化结果。 已复制let relativeTimeFormat = new Intl.RelativeTimeFormat("zh-CN", {numeric: "always", style: "long"});let number = 2;let unit = "year";let formatPartsResult = relativeTimeFormat.formatToParts(number, unit); // formatPartsResult = [{"type": "integer", "value": "2", "unit": "year"}, {"type":"literal", "value": "年后"}] 访问相对时间格式化对象的相关属性。 RelativeTimeFormat的resolvedOptions方法会返回一个对象，该对象包含了RelativeTimeFormat对象的所有相关属性及其值，完整的属性列表参见 RelativeTimeFormatResolvedOptions。 已复制let relativeTimeFormat = new Intl.RelativeTimeFormat("zh-CN", {numeric: "always", style: "long"});let options = relativeTimeFormat.resolvedOptions(); // options = {"locale": "zh-CN", "style": "long", "numeric": "always", "numberingSystem": "latn"}    上一篇 国际化开发概述 下一篇 I18n开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。I/O密集型任务开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  使用异步并发可以解决单次I/O任务阻塞的问题，但是如果遇到I/O密集型任务，同样会阻塞线程中其它任务的执行，这时需要使用多线程并发能力来进行解决。 I/O密集型任务的性能重点通常不在于CPU的处理能力，而在于I/O操作的速度和效率。这种任务通常需要频繁地进行磁盘读写、网络通信等操作。此处以频繁读写系统文件来模拟I/O密集型并发任务的处理。  定义并发函数，内部密集调用I/O能力。已复制import fs from '@ohos.file.fs';
// 定义并发函数，内部密集调用I/O能力@Concurrentasync function concurrentTest(fileList: string[]) {  // 写入文件的实现  async function write(data, filePath) {    let file = await fs.open(filePath, fs.OpenMode.READ_WRITE);    await fs.write(file.fd, data);    fs.close(file);  }  // 循环写文件操作  for (let i = 0; i < fileList.length; i++) {    write('Hello World!', fileList[i]).then(() => {      console.info(`Succeeded in writing the file. FileList: ${fileList[i]}`);    }).catch((err) => {      console.error(`Failed to write the file. Code is ${err.code}, message is ${err.message}`)      return false;    })  }  return true;}  使用TaskPool执行包含密集I/O的并发函数：通过调用execute()方法执行任务，并在回调中进行调度结果处理。示例中的filePath1和filePath2的获取方式请参见获取应用文件路径。已复制import taskpool from '@ohos.taskpool';
let filePath1 = ...; // 应用文件路径let filePath2 = ...;
// 使用TaskPool执行包含密集I/O的并发函数// 数组较大时，I/O密集型任务任务分发也会抢占主线程，需要使用多线程能力taskpool.execute(concurrentTest, [filePath1, filePath2]).then((ret) => {  // 调度结果处理  console.info(`The result: ${ret}`);})    上一篇 CPU密集型任务开发指导 下一篇 同步任务开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。场景介绍接口说明开发步骤Native侧开发步骤JS侧开发步骤IPC与RPC通信开发指导 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   场景介绍 IPC/RPC的主要工作是让运行在不同进程的Proxy和Stub互相通信，包括Proxy和Stub运行在不同设备的情况。   接口说明 表1 Native侧IPC接口     类/接口 方法 功能说明    IRemoteBroker sptr<IRemoteObject> AsObject() 返回通信对象。Stub端返回RemoteObject对象本身，Proxy端返回代理对象。   IRemoteStub virtual int OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option) 请求处理方法，派生类需要重写该方法用来处理Proxy的请求并返回结果。   IRemoteProxy Remote()->SendRequest(code, data, reply, option) 消息发送方法，业务的Proxy类需要从IRemoteProxy类派生，该方法用来向对端发送消息。      开发步骤   Native侧开发步骤  添加依赖 SDK依赖： 已复制#ipc场景external_deps = [  "ipc:ipc_single",]
#rpc场景external_deps = [  "ipc:ipc_core",] 此外， IPC/RPC依赖的refbase实现在公共基础库下，请增加对utils的依赖： 已复制external_deps = [  "c_utils:utils",] 定义IPC接口ITestAbility SA接口继承IPC基类接口IRemoteBroker，接口里定义描述符、业务函数和消息码，其中业务函数在Proxy端和Stub端都需要实现。 已复制#include "iremote_broker.h"
//定义消息码const int TRANS_ID_PING_ABILITY = 5
const std::string DESCRIPTOR = "test.ITestAbility";
class ITestAbility : public IRemoteBroker {public:    // DECLARE_INTERFACE_DESCRIPTOR是必需的，入参需使用std::u16string；    DECLARE_INTERFACE_DESCRIPTOR(to_utf16(DESCRIPTOR));    virtual int TestPingAbility(const std::u16string &dummy) = 0; // 定义业务函数}; 定义和实现服务端TestAbilityStub 该类是和IPC框架相关的实现，需要继承 IRemoteStub<ITestAbility>。Stub端作为接收请求的一端，需重写OnRemoteRequest方法用于接收客户端调用。 已复制#include "iability_test.h"#include "iremote_stub.h"
class TestAbilityStub : public IRemoteStub<ITestAbility> {public:    virtual int OnRemoteRequest(uint32_t code, MessageParcel &data, MessageParcel &reply, MessageOption &option) override;    int TestPingAbility(const std::u16string &dummy) override; };
int TestAbilityStub::OnRemoteRequest(uint32_t code,    MessageParcel &data, MessageParcel &reply, MessageOption &option){    switch (code) {        case TRANS_ID_PING_ABILITY: {            std::u16string dummy = data.ReadString16();            int result = TestPingAbility(dummy);            reply.WriteInt32(result);            return 0;        }        default:            return IPCObjectStub::OnRemoteRequest(code, data, reply, option);    }} 定义服务端业务函数具体实现类TestAbility 已复制#include "iability_server_test.h"
class TestAbility : public TestAbilityStub {public:    int TestPingAbility(const std::u16string &dummy);}
int TestAbility::TestPingAbility(const std::u16string &dummy) {    return 0;} 定义和实现客户端 TestAbilityProxy 该类是Proxy端实现，继承IRemoteProxy<ITestAbility>，调用SendRequest接口向Stub端发送请求，对外暴露服务端提供的能力。 已复制#include "iability_test.h"#include "iremote_proxy.h"#include "iremote_object.h"
class TestAbilityProxy : public IRemoteProxy<ITestAbility> {public:    explicit TestAbilityProxy(const sptr<IRemoteObject> &impl);    int TestPingAbility(const std::u16string &dummy) override;private:    static inline BrokerDelegator<TestAbilityProxy> delegator_; // 方便后续使用iface_cast宏}
TestAbilityProxy::TestAbilityProxy(const sptr<IRemoteObject> &impl)    : IRemoteProxy<ITestAbility>(impl){}
int TestAbilityProxy::TestPingAbility(const std::u16string &dummy){    MessageOption option;    MessageParcel dataParcel, replyParcel;    dataParcel.WriteString16(dummy);    int error = Remote()->SendRequest(TRANS_ID_PING_ABILITY, dataParcel, replyParcel, option);    int result = (error == ERR_NONE) ? replyParcel.ReadInt32() : -1;    return result;} SA注册与启动 SA需要将自己的TestAbilityStub实例通过AddSystemAbility接口注册到SystemAbilityManager，设备内与分布式的注册参数不同。 已复制// 注册到本设备内auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();samgr->AddSystemAbility(saId, new TestAbility());
// 在组网场景下，会被同步到其他设备上auto samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();ISystemAbilityManager::SAExtraProp saExtra;saExtra.isDistributed = true; // 设置为分布式SAint result = samgr->AddSystemAbility(saId, new TestAbility(), saExtra); SA获取与调用 通过SystemAbilityManager的GetSystemAbility方法可获取到对应SA的代理IRemoteObject，然后构造TestAbilityProxy即可。 已复制// 获取本设备内注册的SA的proxysptr<ISystemAbilityManager> samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();sptr<IRemoteObject> remoteObject = samgr->GetSystemAbility(saId);sptr<ITestAbility> testAbility = iface_cast<ITestAbility>(remoteObject); // 使用iface_cast宏转换成具体类型
// 获取其他设备注册的SA的proxysptr<ISystemAbilityManager> samgr = SystemAbilityManagerClient::GetInstance().GetSystemAbilityManager();
// networkId是组网场景下对应设备的标识符，可以通过GetLocalNodeDeviceInfo获取sptr<IRemoteObject> remoteObject = samgr->GetSystemAbility(saId, networkId);sptr<TestAbilityProxy> proxy(new TestAbilityProxy(remoteObject)); // 直接构造具体Proxy    JS侧开发步骤  添加依赖 已复制import rpc from "@ohos.rpc"import featureAbility from "@ohos.ability.featureAbility" 绑定Ability 首先，构造变量want，指定要绑定的Ability所在应用的包名、组件名，如果是跨设备的场景，还需要绑定目标设备NetworkId（组网场景下对应设备的标识符，可以使用deviceManager获取目标设备的NetworkId）；然后，构造变量connect，指定绑定成功、绑定失败、断开连接时的回调函数；最后，使用featureAbility提供的接口绑定Ability。 已复制import rpc from "@ohos.rpc"import featureAbility from "@ohos.ability.featureAbility"
let proxy = nulllet connectId = null
// 单个设备绑定Abilitylet want = {    // 包名和组件名写实际的值    "bundleName": "ohos.rpc.test.server",    "abilityName": "ohos.rpc.test.server.ServiceAbility",}let connect = {    onConnect:function(elementName, remote) {        proxy = remote    },    onDisconnect:function(elementName) {    },    onFailed:function() {        proxy = null    }}connectId = featureAbility.connectAbility(want, connect)
// 如果是跨设备绑定，可以使用deviceManager获取目标设备NetworkIdimport deviceManager from '@ohos.distributedHardware.deviceManager'function deviceManagerCallback(deviceManager) {    let deviceList = deviceManager.getTrustedDeviceListSync()    let networkId = deviceList[0].networkId    let want = {        "bundleName": "ohos.rpc.test.server",        "abilityName": "ohos.rpc.test.service.ServiceAbility",        "networkId": networkId,        "flags": 256    }    connectId = featureAbility.connectAbility(want, connect)}// 第一个参数是本应用的包名，第二个参数是接收deviceManager的回调函数deviceManager.createDeviceManager("ohos.rpc.test", deviceManagerCallback) 服务端处理客户端请求 服务端被绑定的Ability在onConnect方法里返回继承自rpc.RemoteObject的对象，该对象需要实现onRemoteMessageRequest方法，处理客户端的请求。 已复制onConnect(want: Want) {    var robj:rpc.RemoteObject = new Stub("rpcTestAbility")    return robj}class Stub extends rpc.RemoteObject {    constructor(descriptor) {        super(descriptor)    }    onRemoteMessageRequest(code, data, reply, option) {        // 根据code处理客户端的请求        return true    }} 客户端处理服务端响应 客户端在onConnect回调里接收到代理对象，调用sendRequestAsync方法发起请求，在期约（JavaScript期约：用于表示一个异步操作的最终完成或失败及其结果值）或者回调函数里接收结果。 已复制// 使用期约let option = new rpc.MessageOption()let data = rpc.MessageParcel.create()let reply = rpc.MessageParcel.create()// 往data里写入参数proxy.sendRequestAsync(1, data, reply, option)    .then(function(result) {        if (result.errCode != 0) {            console.error("send request failed, errCode: " + result.errCode)            return        }        // 从result.reply里读取结果    })    .catch(function(e) {        console.error("send request got exception: " + e)    }    .finally(() => {        data.reclaim()        reply.reclaim()    })
// 使用回调函数function sendRequestCallback(result) {    try {        if (result.errCode != 0) {            console.error("send request failed, errCode: " + result.errCode)            return        }        // 从result.reply里读取结果    } finally {        result.data.reclaim()        result.reply.reclaim()    }}let option = new rpc.MessageOption()let data = rpc.MessageParcel.create()let reply = rpc.MessageParcel.create()// 往data里写入参数proxy.sendRequest(1, data, reply, option, sendRequestCallback) 断开连接 IPC通信结束后，使用featureAbility的接口断开连接。 已复制import rpc from "@ohos.rpc"import featureAbility from "@ohos.ability.featureAbility"function disconnectCallback() {    console.info("disconnect ability done")}featureAbility.disconnectAbility(connectId, disconnectCallback)    上一篇 IPC与RPC通信概述 下一篇 远端状态订阅开发实例 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基本概念约束与限制使用建议IPC与RPC通信概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 基本概念IPC（Inter-Process Communication）与RPC（Remote Procedure Call）用于实现跨进程通信，不同的是前者使用Binder驱动，用于设备内的跨进程通信，后者使用软总线驱动，用于跨设备跨进程通信。需要跨进程通信的原因是因为每个进程都有自己独立的资源和内存空间，其他进程不能随意访问不同进程的内存和资源，IPC/RPC便是为了突破这一点。IPC和RPC通常采用客户端-服务器（Client-Server）模型，在使用时，请求服务的（Client）一端进程可获取提供服务（Server）一端所在进程的代理（Proxy），并通过此代理读写数据来实现进程间的数据通信，更具体的讲，首先请求服务的（Client）一端会建立一个服务提供端（Server）的代理对象，这个代理对象具备和服务提供端（Server）一样的功能，若想访问服务提供端（Server）中的某一个方法，只需访问代理对象中对应的方法即可，代理对象会将请求发送给服务提供端（Server）；然后服务提供端（Server）处理接受到的请求，处理完之后通过驱动返回处理结果给代理对象；最后代理对象将请求结果进一步返回给请求服务端（Client）。通常，Server会先注册系统能力（System Ability）到系统能力管理者（System Ability Manager，缩写SAMgr）中，SAMgr负责管理这些SA并向Client提供相关的接口。Client要和某个具体的SA通信，必须先从SAMgr中获取该SA的代理，然后使用代理和SA通信。下文直接使用Proxy表示服务请求方，Stub表示服务提供方。   约束与限制单个设备上跨进程通信时，传输的数据量最大约为1MB，过大的数据量请使用匿名共享内存。 不支持在RPC中订阅匿名Stub对象（没有向SAMgr注册Stub对象）的死亡通知。 不支持把跨设备的Proxy对象传递回该Proxy对象所指向的Stub对象所在的设备，即指向远端设备Stub的Proxy对象不能在本设备内进行二次跨进程传递。   使用建议首先，需要编写接口类，接口类中必须定义消息码，供通信双方标识操作，可以有未实现的的方法，因为通信双方均需继承该接口类且双方不能是抽象类，所以此时定义的未实现的方法必须在双方继承时给出实现，这保证了继承双方不是抽象类。然后，需要编写Stub端相关类及其接口，并且实现AsObject方法及OnRemoteRequest方法。同时，也需要编写Proxy端，实现接口类中的方法和AsObject方法，也可以封装一些额外的方法用于调用SendRequest向对端发送数据。以上三者都具备后，便可以向SAMgr注册SA了，此时的注册应该在Stub所在进程完成。最后，在需要的地方从SAMgr中获取Proxy，便可通过Proxy实现与Stub的跨进程通信了。 相关步骤： 实现接口类：需继承IRemoteBroker，需定义消息码，可声明不在此类实现的方法。 实现服务提供端（Stub）：需继承IRemoteStub或者RemoteObject，需重写AsObject方法及OnRemoteRequest方法。 实现服务请求端（Proxy）：需继承IRemoteProxy或RemoteProxy，需重写AsObject方法，封装所需方法调用SendRequest。 注册SA：申请SA的唯一ID，向SAMgr注册SA。 获取SA：通过SA的ID和设备ID获取Proxy，使用Proxy与远端通信    上一篇 IPC与RPC通信 下一篇 IPC与RPC通信开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。线程间通信 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 请参见Stage模型的"线程间通信"。  上一篇 线程模型概述 下一篇 UI开发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用Emitter进行线程间通信 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Emitter主要提供线程间发送和处理事件的能力，包括对持续订阅事件或单次订阅事件的处理、取消订阅事件、发送事件到事件队列等。 Emitter的开发步骤如下：  订阅事件 已复制import emitter from "@ohos.events.emitter";
// 定义一个eventId为1的事件let event = {    eventId: 1};
// 收到eventId为1的事件后执行该回调let callback = (eventData) => {    console.info('event callback');};
// 订阅eventId为1的事件emitter.on(event, callback); 发送事件 已复制import emitter from "@ohos.events.emitter";
// 定义一个eventId为1的事件，事件优先级为Lowlet event = {    eventId: 1,    priority: emitter.EventPriority.LOW};
let eventData = {    data: {        "content": "c",        "id": 1,        "isEmpty": false,    }};
// 发送eventId为1的事件，事件内容为eventDataemitter.emit(event, eventData);   上一篇 线程模型概述 下一篇 使用Worker进行线程间通信 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用Worker进行线程间通信 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  Worker是与主线程并行的独立线程。创建Worker的线程被称为宿主线程，Worker工作的线程被称为Worker线程。创建Worker时传入的脚本文件在Worker线程中执行，通常在Worker线程中处理耗时的操作，需要注意的是，Worker中不能直接更新Page。 Worker的开发步骤如下：  在工程的模块级build-profile.json5文件的buildOption属性中添加配置信息。 已复制  "buildOption": {    "sourceOption": {      "workers": [        "./src/main/ets/workers/worker.ts"      ]    }  } 根据build-profile.json5中的配置创建对应的worker.ts文件。 已复制import worker from '@ohos.worker';
let parent = worker.workerPort;
// 处理来自主线程的消息parent.onmessage = function(message) {    console.info("onmessage: " + message)    // 发送消息到主线程    parent.postMessage("message from worker thread.")} 主线程中使用如下方式初始化和使用worker。  Stage模型： 已复制import worker from '@ohos.worker';
let wk = new worker.ThreadWorker("entry/ets/workers/worker.ts");
// 发送消息到worker线程wk.postMessage("message from main thread.")
// 处理来自worker线程的消息wk.onmessage = function(message) {    console.info("message from worker: " + message)
    // 根据业务按需停止worker线程    wk.terminate()} FA模型： 已复制import worker from '@ohos.worker';
let wk = new worker.ThreadWorker("../workers/worker.ts");
// 发送消息到worker线程wk.postMessage("message from main thread.")
// 处理来自worker线程的消息wk.onmessage = function(message) {    console.info("message from worker: " + message)
    // 根据业务按需停止worker线程    wk.terminate()}   说明：  build-profile.json5中配置的worker.ts的相对路径都为./src/main/ets/workers/worker.ts时，在Stage模型下创建worker需要传入路径entry/ets/workers/worker.ts；在FA模型下创建worker需要传入路径../workers/worker.ts。 主线程与Worker线程间支持的数据类型参考序列化支持类型。   上一篇 使用Emitter进行线程间通信 下一篇 FA模型开发指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。目录结构文件访问规则媒体文件格式文件组织 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  目录结构JS FA应用的JS模块(entry/src/main/js/module)的典型开发目录结构如下： 图1 目录结构  图2 多实例资源共享目录结构  目录结构中文件分类如下： .hml结尾的HML模板文件，描述当前页面的文件布局结构。 .css结尾的CSS样式文件，描述页面样式。 .js结尾的JS文件，处理页面间的交互。  各个文件夹的作用： app.js文件用于全局JavaScript逻辑和应用生命周期管理，详见app.js。 pages目录用于存放所有组件页面。 common目录用于存放公共资源文件，比如：媒体资源，自定义组件和JS文件。 resources目录用于存放资源配置文件，比如：多分辨率加载等配置文件，详见资源限定与访问章节。 share目录用于配置多个实例共享的资源内容，比如：share中的图片和JSON文件可被default1和default2实例共享。  
说明
 i18n和resources文件夹不可重命名。 如果share目录中的资源和实例(default)中的资源文件同名且目录一致时，实例中资源的优先级高于share中资源的优先级。 share目录当前不支持i18n。 在使用DevEco Studio进行应用开发时，目录结构中的可选文件夹需要开发者根据实际情况自行创建。  
  文件访问规则应用资源可通过绝对路径或相对路径的方式进行访问，绝对路径以"/"开头，相对路径以"./"或"../"。具体访问规则如下： 引用代码文件，推荐使用相对路径，比如：../common/utils.js。 引用资源文件，推荐使用绝对路径。比如：/common/xxx.png。 公共代码文件和资源文件推荐放在common下，通过以上两条规则进行访问。 CSS样式文件中通过url()函数创建<url>数据类型，如：url(/common/xxx.png)。  
说明
 当代码文件A需要引用代码文件B时： 如果代码文件A和文件B位于同一目录，则代码文件B引用资源文件时可使用相对路径，也可使用绝对路径。 如果代码文件A和文件B位于不同目录，则代码文件B引用资源文件时必须使用绝对路径。因为Webpack打包时，代码文件B的目录会发生变化。 在js文件中通过数据绑定的方式指定资源文件路径时，必须使用绝对路径。  
  媒体文件格式表1 支持的图片格式 格式 支持的文件类型   BMP .bmp  GIF .gif  JPEG .jpg  PNG .png  WebP .webp    表2 支持的视频格式 格式 支持的文件类型   H.264 AVC Baseline Profile (BP)  .3gp .mp4       上一篇 框架说明 下一篇 js标签配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用生命周期应用对象6+app.js 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用生命周期每个应用可以在app.js自定义应用级生命周期的实现逻辑，以下示例仅在生命周期函数中打印对应日志： 已复制// app.jsexport default {    onCreate() {        console.info('Application onCreate');    },
    onDestroy() {        console.info('Application onDestroy');    },}  应用对象6+ 属性 类型 描述   getApp Function 提供getApp()全局方法，可以在自定义js文件中获取app.js中暴露的对象。    示例如下： 已复制// app.jsexport default {    data: {        test: "by getAPP"    },    onCreate() {        console.info('AceApplication onCreate');    },    onDestroy() {        console.info('AceApplication onDestroy');    },}; 已复制// test.js 自定义逻辑代码export var appData = getApp().data;   上一篇 js标签配置 下一篇 语法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。pageswindow示例js标签配置 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 js标签中包含了实例名称、页面路由和窗口样式信息。 标签 类型 默认值 必填 描述   name string default 是 标识JS实例的名字。  pages Array - 是 路由信息，详见“**pages**”。  window Object - 否 窗口信息，详见“**window**”。    
说明
 name、pages和window等标签配置需在配置文件（config.json）中的“js”标签中完成设置。 
 pages定义每个页面的路由信息，每个页面由页面路径和页面名组成，页面的文件名就是页面名。比如： 已复制{    ...    "pages": [        "pages/index/index",        "pages/detail/detail"    ]    ...} 
说明
 pages列表中第一个页面是应用的首页，即entry入口。 页面文件名不能使用组件名称，比如：text.hml、button.hml等。  
  windowwindow用于定义与显示窗口相关的配置。对于屏幕适配问题，有2种配置方法： 指定designWidth（屏幕逻辑宽度），所有与大小相关的样式（例如width、font-size）均以designWidth和实际屏幕宽度的比例进行缩放，例如在designWidth为720时，如果设置width为100px时，在实际宽度为1440物理像素的屏幕上，width实际渲染像素为200物理像素。 设置autoDesignWidth为true，此时designWidth字段将会被忽略，渲染组件和布局时按屏幕密度进行缩放。屏幕逻辑宽度由设备宽度和屏幕密度自动计算得出，在不同设备上可能不同，请使用相对布局来适配多种设备。例如：在466*466分辨率，320dpi的设备上，屏幕密度为2（以160dpi为基准），1px等于渲染出的2物理像素。 
说明
 组件样式中<length>类型的默认值，按屏幕密度进行计算和绘制，如：在屏幕密度为2（以160dpi为基准）的设备上，默认<length>为1px时，设备上实际渲染出2物理像素。 autoDesignWidth、designWidth的设置不影响默认值计算方式和绘制结果。  
  属性 类型 必填 缺省值 描述   designWidth number 否 720  页面显示设计时的参考值，实际显示效果基于设备宽度与参考值之间的比例进行缩放。  autoDesignWidth boolean 否 false 页面设计基准宽度是否自动计算，当设为true时，designWidth将会被忽略，设计基准宽度由设备宽度与屏幕密度计算得出。    示例如下： 已复制{    ...    "window": {        "designWidth": 720,        "autoDesignWidth": false    }    ...}  示例已复制{  "app": {    "bundleName": "com.example.player",    "version": {        "code": 1,        "name": "1.0"    },    "vendor": "example"  }  "module": {      ...      "js": [      {          "name": "default",          "pages": [              "pages/index/index",              "pages/detail/detail"          ],          "window": {              "designWidth": 720,              "autoDesignWidth": false          }      }      ],      "abilities": [      {          ...      }    ]  }}   上一篇 文件组织 下一篇 app.js 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用生命周期页面生命周期生命周期 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  应用生命周期在app.js中可以定义如下应用生命周期函数： 属性 类型 描述 触发时机   onCreate () => void 应用创建 当应用创建时调用。  onShow6+ () => void 应用处于前台 当应用处于前台时触发。  onHide6+ () => void 应用处于后台 当应用处于后台时触发。  onDestroy () => void 应用销毁 当应用退出时触发。     页面生命周期在页面JS文件中可以定义如下页面生命周期函数： 属性 类型 描述 触发时机   onInit () => void 页面初始化 页面数据初始化完成时触发，只触发一次。  onReady () => void 页面创建完成 页面创建完成时触发，只触发一次。  onShow () => void 页面显示 页面显示时触发。  onHide () => void 页面消失 页面消失时触发。  onDestroy () => void 页面销毁 页面销毁时触发。  onBackPress () => boolean 返回按钮动作 当用户点击返回按钮时触发。 - 返回true表示页面自己处理返回逻辑。 - 返回false表示使用默认的返回逻辑。 - 不返回值会作为false处理。   onActive()5+ () => void 页面激活 页面激活时触发。  onInactive()5+ () => void 页面暂停 页面暂停时触发。  onNewRequest()5+ () => void FA重新请求 FA已经启动时收到新的请求后触发。    页面A的生命周期接口的调用顺序 打开页面A：onInit() -> onReady() -> onShow() 在页面A打开页面B：onHide() 从页面B返回页面A：onShow() 退出页面A：onBackPress() -> onHide() -> onDestroy() 页面隐藏到后台运行：onInactive() -> onHide() 页面从后台运行恢复到前台：onShow() -> onActive()     上一篇 JS语法参考 下一篇 资源限定与访问 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。定义资源文件引用资源获取语言多语言支持 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  基于开发框架的应用会覆盖多个国家和地区，开发框架支持多语言能力后，可以让应用开发者无需开发多个不同语言的版本，就可以同时支持多种语言的切换，为项目维护带来便利。 开发者仅需要通过定义资源文件和引用资源两个步骤，就可以使用开发框架的多语言能力；如果需要在应用中获取当前系统语言，请参考获取语言。  定义资源文件 资源文件用于存放应用在多种语言场景下的资源内容，开发框架使用JSON文件保存资源定义。在文件组织中指定的i18n文件夹内放置语言资源文件，其中语言资源文件的命名是由语言、文字、国家或地区的限定词通过中划线连接组成，其中文字和国家或地区可以省略，如zh-Hant-HK（中国香港地区使用的繁体中文）、zh-CN（中国使用的简体中文）、zh（中文）。命名规则如下： 已复制language[-script-region].json 限定词的取值需符合下表要求。 表1 限定词取值要求     限定词类型 含义与取值说明    语言 表示设备使用的语言类型，由2~3个小写字母组成。例如：zh表示中文，en表示英语，mai表示迈蒂利语。 详细取值范围，请查阅ISO 639（ISO制定的语言编码标准）。   文字 表示设备使用的文字类型，由1个大写字母（首字母）和3个小写字母组成。例如：Hans表示简体中文，Hant表示繁体中文。 详细取值范围，请查阅ISO 15924（ISO制定的文字编码标准）。   国家或地区 表示用户所在的国家或地区，由2~3个大写字母或者3个数字组成。例如：CN表示中国，GB表示英国。 详细取值范围，请查阅ISO 3166-1（ISO制定的国家和地区编码标准）。    当开发框架无法在应用中找到系统语言的资源文件时，默认使用en-US.json中的资源内容。 资源文件内容格式如下： en-US.json 已复制{    "strings": {        "hello": "Hello world!",        "object": "Object parameter substitution-{name}",        "array": "Array type parameter substitution-{0}",        "symbol": "@#$%^&*()_+-={}[]\\|:;\"'<>,./?"    },
    "files": {        "image": "image/en_picture.PNG"    }} 由于不同语言针对单复数有不同的匹配规则，在资源文件中使用“zero”“one”“two”“few”“many”“other”定义不同单复数场景下的词条内容。例如中文不区分单复数，仅存在“other”场景；英文存在“one”、“other”场景；阿拉伯语存在上述6种场景。 以en-US.json和ar-AE.json为例，资源文件内容格式如下： en-US.json 已复制{    "strings": {        "people": {            "one": "one person",            "other": "{count} people"        }    }} ar-AE.json 已复制{    "strings": {        "people": {            "zero": "لا أحد",            "one": "وحده",            "two": "اثنان",            "few": "ستة اشخاص",            "many": "خمسون شخص",            "other": "مائة شخص"        }    }}   引用资源 在应用开发的页面中使用多语言的语法，包含简单格式化和单复数格式化两种，都可以在hml或js中使用。  简单格式化方法 在应用中使用$t方法引用资源，$t既可以在hml中使用，也可以在js中使用。系统将根据当前语言环境和指定的资源路径（通过$t的path参数设置），显示对应语言的资源文件中的内容。 表2 简单格式化     属性 类型 参数 必填 描述    $t Function 请见表 $t参数说明 是 根据系统语言完成简单的替换：this.$t('strings.hello')    表3 $t参数说明     参数 类型 必填 描述    path string 是 资源路径   params Array|Object 否 运行时用来替换占位符的实际内容，占位符分为两种： - 具名占位符，例如{name}。实际内容必须用Object类型指定，例如：$t('strings.object', {name:'Hello world'})。 - 数字占位符，例如{0}。实际内容必须用Array类型指定，例如：$t('strings.array', [Hello world']    简单格式化示例代码 已复制<!-- xxx.hml --><div>  <!-- 不使用占位符，text中显示“Hello world!” -->  <text>{{ $t('strings.hello') }}</text>  <!-- 具名占位符格式，运行时将占位符{name}替换为“Hello world” -->  <text>{{ $t('strings.object', { name: 'Hello world' }) }}</text>  <!-- 数字占位符格式，运行时将占位符{0}替换为“Hello world” -->  <text>{{ $t('strings.array', ['Hello world']) }}</text>  <!-- 先在js中获取资源内容，再在text中显示“Hello world” -->  <text>{{ hello }}</text>  <!-- 先在js中获取资源内容，并将占位符{name}替换为“Hello world”，再在text中显示“Object parameter substitution-Hello world” -->  <text>{{ replaceObject }}</text>  <!-- 先在js中获取资源内容，并将占位符{0}替换为“Hello world”，再在text中显示“Array type parameter substitution-Hello world” -->  <text>{{ replaceArray }}</text>
  <!-- 获取图片路径 -->  <image src="{{ $t('files.image') }}" class="image"></image>  <!-- 先在js中获取图片路径，再在image中显示图片 -->  <image src="{{ replaceSrc }}" class="image"></image></div> 已复制// xxx.js// 下面为在js文件中的使用方法。export default {  data: {    hello: '',    replaceObject: '',    replaceArray: '',    replaceSrc: '',  },  onInit() {    this.hello = this.$t('strings.hello');    this.replaceObject = this.$t('strings.object', { name: 'Hello world' });    this.replaceArray = this.$t('strings.array', ['Hello world']);    this.replaceSrc = this.$t('files.image');  },   } 单复数格式化方法 表4 单复数格式化     属性 类型 参数 必填 描述    $tc Function 请见表 $tc参数说明 是 根据系统语言完成单复数替换：this.$tc('strings.people') >  说明： > 定义资源的内容通过json格式的key为“zero”、“one”、“two”、“few”、“many”和“other”区分。    表5 $tc参数说明     参数 类型 必填 描述    path string 是 资源路径   count number 是 要表达的值    单复数格式化示例代码 已复制<!--xxx.hml--><div>  <!-- 传递数值为0时： "0 people" 阿拉伯语中此处匹配key为zero的词条-->  <text>{{ $tc('strings.people', 0) }}</text>  <!-- 传递数值为1时： "one person" 阿拉伯语中此处匹配key为one的词条-->  <text>{{ $tc('strings.people', 1) }}</text>  <!-- 传递数值为2时： "2 people" 阿拉伯语中此处匹配key为two的词条-->  <text>{{ $tc('strings.people', 2) }}</text>  <!-- 传递数值为6时： "6 people" 阿拉伯语中此处匹配key为few的词条-->  <text>{{ $tc('strings.people', 6) }}</text>  <!-- 传递数值为50时： "50 people" 阿拉伯语中此处匹配key为many的词条-->  <text>{{ $tc('strings.people', 50) }}</text>  <!-- 传递数值为100时： "100 people" 阿拉伯语中此处匹配key为other的词条-->  <text>{{ $tc('strings.people', 100) }}</text></div>    获取语言 获取语言功能请参考应用配置。   上一篇 资源限定与访问 下一篇 构建用户界面 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。资源限定词资源限定词的命名要求限定词与设备状态的匹配规则引用JS模块内resources资源示例资源限定与访问 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  资源限定词资源限定词可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括屏幕密度等维度，限定词之间通过中划线（-）连接。开发者在resources目录下创建限定词文件时，需要掌握限定词文件的命名要求以及与限定词文件与设备状态的匹配规则。  资源限定词的命名要求限定词的组合顺序：屏幕密度。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称，顺序不可颠倒。 限定词的连接方式：限定词之间均采用中划线（-）连接。例如：res-dark-ldpi.json 。 限定词的取值范围：每类限定词的取值必须符合下表的条件，否则，将无法匹配目录中的资源文件，限定词大小写敏感。 限定词前缀：resources资源文件的资源限定词有前缀res，例如res-ldpi.json。 默认资源限定文件：resources资源文件的默认资源限定文件为res-defaults.json。 资源限定文件中不支持使用枚举格式的颜色来设置资源。  表1 资源限定词 类型 含义与取值说明   屏幕密度 表示设备的屏幕密度（单位为dpi），取值如下： - ldpi：表示低密度屏幕（~120dpi）（0.75基准密度） - mdpi：表示中密度屏幕（~160dpi）（基准密度） - hdpi：表示高密度屏幕（~240dpi）（1.5基准密度） - xhdpi：表示加高密度屏幕（~320dpi）（2.0基准密度） - xxhdpi：表示超超高密度屏幕（~480dpi）（3.0基准密度） - xxxhdpi：表示超超超高密度屏幕（~640dpi）（4.0基准密度）      限定词与设备状态的匹配规则在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：MCC和MNC> 横竖屏 > 深色模式 > 设备类型 > 屏幕密度。在资源限定词目录均未匹配的情况下，则匹配默认资源限定文件。 如果限定词目录中包含资源限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如：资源限定文件res-hdpi.json与当前设备密度xhdpi无法匹配。   引用JS模块内resources资源在应用开发的hml和js文件中使用$r的语法，可以对JS模块内的resources目录下的json资源进行格式化，获取相应的资源内容。 属性 类型 描述   $r (key: string) => string 获取资源限定下具体的资源内容。例如：this.$r('strings.hello')。 参数说明： - key：定义在资源限定文件中的键值，如strings.hello。     res-defaults.json示例： 已复制{    "strings": {                "hello": "hello world"      }}  示例resources/res-dark.json: 已复制{    "image": {        "clockFace": "common/dark_face.png"    },    "colors": {    "background": "#000000"    }} resources/res-defaults.json: 已复制{    "image": {        "clockFace": "common/face.png"    },    "colors": {    "background": "#ffffff"    }} 已复制<!-- xxx.hml --><div style="background-color: {{ $r('colors.background') }}">    <image src="{{ $r('image.clockFace') }}"></image></div> 
说明
 资源限定文件中不支持颜色枚举格式。 
   上一篇 生命周期 下一篇 多语言支持 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。尺寸单位样式导入声明样式选择器选择器优先级伪类样式预编译CSS样式继承6+CSS语法参考 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  CSS是描述HML页面结构的样式语言。所有组件均存在系统默认样式，也可在页面CSS样式文件中对组件、页面自定义不同的样式。请参考通用样式了解兼容JS的类Web开发范式支持的组件样式。  尺寸单位  逻辑像素px（文档中以<length>表示）：  默认屏幕具有的逻辑宽度为720px（配置见配置文件中的window小节），实际显示时会将页面布局缩放至屏幕实际宽度，如100px在实际宽度为1440物理像素的屏幕上，实际渲染为200物理像素（从720px向1440物理像素，所有尺寸放大2倍）。 额外配置autoDesignWidth为true时（配置见配置文件中的window小节），逻辑像素px将按照屏幕密度进行缩放，如100px在屏幕密度为3的设备上，实际渲染为300物理像素。应用需要适配多种设备时，建议采用此方法。  百分比（文档中以<percentage>表示）：表示该组件占父组件尺寸的百分比，如组件的width设置为50%，代表其宽度为父组件的50%。    样式导入 为了模块化管理和代码复用，CSS样式文件支持 @import 语句，导入css文件。   声明样式 每个页面目录下存在一个与布局hml文件同名的css文件，用来描述该hml页面中组件的样式，决定组件应该如何显示。  内部样式，支持使用style、class属性来控制组件的样式。例如： 已复制<!-- index.hml --><div class="container">  <text style="color: red">Hello World</text></div> 已复制/* index.css */.container {  justify-content: center;} 文件导入，合并外部样式文件。例如，在common目录中定义样式文件style.css，并在index.css文件首行中进行导入： 已复制/* style.css */.title {  font-size: 50px;} 已复制/* index.css */@import '../../common/style.css';.container {  justify-content: center;}    选择器 css选择器用于选择需要添加样式的元素，支持的选择器如下表所示：     选择器 样例 样例描述    .class .container 用于选择class="container"的组件。   #id #titleId 用于选择id="titleId"的组件。   tag text 用于选择text组件。   , .title, .content 用于选择class="title"和class="content"的组件。   #id .class tag #containerId .content text 非严格父子关系的后代选择器，选择具有id="containerId"作为祖先元素，class="content"作为次级祖先元素的所有text组件。如需使用严格的父子关系，可以使用“>”代替空格，如：#containerId>.content。    示例： 已复制<!-- 页面布局xxx.hml --><div id="containerId" class="container">  <text id="titleId" class="title">标题</text>  <div class="content">    <text id="contentId">内容</text>  </div></div> 已复制/* 页面样式xxx.css *//* 对所有div组件设置样式 */div {  flex-direction: column;}/* 对class="title"的组件设置样式 */.title {  font-size: 30px;}/* 对id="contentId"的组件设置样式 */#contentId {  font-size: 20px;}/* 对所有class="title"以及class="content"的组件都设置padding为5px */.title, .content {  padding: 5px;}/* 对class="container"的组件下的所有text设置样式 */.container text {  color: #007dff;}/* 对class="container"的组件下的直接后代text设置样式 */.container > text {  color: #fa2a2d;} 以上样式运行效果如下：  其中“.container text”将“标题”和“内容”设置为蓝色，而“.container > text”直接后代选择器将“标题”设置为红色。2者优先级相同，但直接后代选择器声明顺序靠后，将前者样式覆盖（优先级计算见选择器优先级）。   选择器优先级 选择器的优先级计算规则与w3c规则保持一致（只支持：内联样式，id，class，tag，后代和直接后代），其中内联样式为在元素style属性中声明的样式。 当多条选择器声明匹配到同一元素时，各类选择器优先级由高到低顺序为：内联样式 > id > class > tag。   伪类 css伪类是选择器中的关键字，用于指定要选择元素的特殊状态。例如，:disabled状态可以用来设置元素的disabled属性变为true时的样式。 除了单个伪类之外，还支持伪类的组合，例如，:focus:checked状态可以用来设置元素的focus属性和checked属性同时为true时的样式。支持的单个伪类如下表所示，按照优先级降序排列：     名称 支持组件 描述    :disabled 支持disabled属性的组件 表示disabled属性变为true时的元素（不支持动画样式的设置）。   :active 支持click事件的组件 表示被用户激活的元素，如：被用户按下的按钮、被激活的tab-bar页签（不支持动画样式的设置）。   :waiting button 表示waiting属性为true的元素（不支持动画样式的设置）。   :checked input[type="checkbox"、type="radio"]、 switch 表示checked属性为true的元素（不支持动画样式的设置）。    伪类示例如下，设置按钮的:active伪类可以控制被用户按下时的样式： 已复制<!-- index.hml --><div class="container">  <input type="button" class="button" value="Button"></input></div> 已复制/* index.css */.button:active {  background-color: #888888;/*按钮被激活时，背景颜色变为#888888 */} 
说明
 针对弹窗类组件及其子元素不支持伪类效果，包括popup、dialog、menu、option、picker 
   样式预编译 预编译提供了利用特有语法生成css的程序，可以提供变量、运算等功能，令开发者更便捷地定义组件样式，目前支持less、sass和scss的预编译。使用样式预编译时，需要将原css文件后缀改为less、sass或scss，如index.css改为index.less、index.sass或index.scss。  当前文件使用样式预编译，例如将原index.css改为index.less： 已复制/* index.less *//* 定义变量 */@colorBackground: #000000;.container {  background-color: @colorBackground; /* 使用当前less文件中定义的变量 */} 引用预编译文件，例如common中存在style.scss文件，将原index.css改为index.scss，并引入style.scss： 已复制/* style.scss *//* 定义变量 */$colorBackground: #000000; 在index.scss中引用： 已复制/* index.scss *//* 引入外部scss文件 */@import '../../common/style.scss';.container {  background-color: $colorBackground; /* 使用style.scss中定义的变量 */} 
说明
 引用的预编译文件建议放在common目录进行管理。 
    CSS样式继承6+ css样式继承提供了子节点继承父节点样式的能力，继承下来的样式在多选择器样式匹配的场景下，优先级排最低，当前支持以下样式的继承：  font-family font-weight font-size font-style text-align line-height letter-spacing color visibility    上一篇 HML语法参考 下一篇 JS语法参考 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。页面结构数据绑定普通事件绑定冒泡事件绑定5+捕获事件绑定5+列表渲染条件渲染逻辑控制块模板引用HML语法参考 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  HML（HarmonyOS Markup Language）是一套类HTML的标记语言，通过组件，事件构建出页面的内容。页面具备数据绑定、事件绑定、列表渲染、条件渲染和逻辑控制等高级能力。  页面结构 已复制<!-- xxx.hml --><div class="item-container">  <text class="item-title">Image Show</text>  <div class="item-content">    <image src="/common/xxx.png" class="image"></image>  </div></div>   数据绑定 已复制<!-- xxx.hml --><div onclick="changeText">  <text> {{content[1]}} </text></div> 已复制/*xxx.css*/.container{    margin: 200px;} 已复制// xxx.jsexport default {  data: {    content: ['Hello World!', 'Welcome to my world!']  },  changeText: function() {    this.content.splice(1, 1, this.content[0]);  }} 
说明
  针对数组内的数据修改，请使用splice方法生效数据绑定变更。 hml文件中的js表达式不支持ES6语法。  
    普通事件绑定 事件通过'on'或者'@'绑定在组件上，当组件触发事件时会执行JS文件中对应的事件处理函数。 事件支持的写法有：  "funcName"：funcName为事件回调函数名（在JS文件中定义相应的函数实现）。 "funcName(a,b)"：函数参数例如a，b可以是常量，或者是在JS文件中的data中定义的变量（前面不用写this.）。 示例 已复制<!-- xxx.hml --><div class="container">    <text class="title">{{count}}</text>    <div class="box">        <input type="button" class="btn" value="increase" onclick="increase" />        <input type="button" class="btn" value="decrease" @click="decrease" />        <!-- 传递额外参数 -->        <input type="button" class="btn" value="double" @click="multiply(2)" />        <input type="button" class="btn" value="decuple" @click="multiply(10)" />        <input type="button" class="btn" value="square" @click="multiply(count)" />    </div></div> 已复制// xxx.jsexport default {  data: {    count: 0  },  increase() {    this.count++;  },  decrease() {    this.count--;  },  multiply(multiplier) {    this.count = multiplier * this.count;  }}; 已复制/* xxx.css */.container {    display: flex;    flex-direction: column;    justify-content: center;    align-items: center;    left: 0px;    top: 0px;    width: 454px;    height: 454px;}.title {    font-size: 30px;    text-align: center;    width: 200px;    height: 100px;}.box {    width: 454px;    height: 200px;    justify-content: center;    align-items: center;    flex-wrap: wrap;}.btn {    width: 200px;    border-radius: 0;    margin-top: 10px;    margin-left: 10px;}     冒泡事件绑定5+ 冒泡事件绑定包括：  绑定冒泡事件：on:{event}.bubble。on:{event}等价于on:{event}.bubble。 绑定并阻止冒泡事件向上冒泡：grab:{event}.bubble。grab:{event}等价于grab:{event}.bubble。 
说明
 冒泡事件是指多个组件嵌套时，组件之间会有层次关系，当这些组件注册了相同的事件时，这个事件会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，一直向上到其他祖先上的处理程序。如果当一个组件触发了这个事件，它会首先触发该组件的回调函数，然后触发其父元素上的回调函数，然后触发其他祖先上的处理程序。 详细冒泡事件说明参见通用事件章节。 
 示例 已复制<!-- xxx.hml --><div>   <!-- 使用事件冒泡模式绑定事件回调函数。5+ -->;    <div on:touchstart.bubble="touchstartfunc"></div>    <div on:touchstart="touchstartfunc"></div>    <!-- 绑定事件回调函数，但阻止事件向上传递。5+ -->    <div grab:touchstart.bubble="touchstartfunc"></div>    <div grab:touchstart="touchstartfunc"></div>    <!-- 使用事件冒泡模式绑定事件回调函数。6+ -->    <div on:click.bubble="clickfunc"></div>    <div on:click="clickfunc"></div>    <!-- 绑定事件回调函数，但阻止事件向上传递。6+ -->    <div grab:click.bubble="clickfunc"></div>    <div grab:click="clickfunc"></div></div> 已复制// xxx.jsexport default {    clickfunc: function(e) {        console.log(e);    },    touchstartfuc: function(e) {        console.log(e);    },}  
说明
 采用旧写法(onclick)的事件绑定在最小API版本6以下时采用不冒泡处理，在最小API版本为6及6以上时采用冒泡处理。 
   捕获事件绑定5+ Touch触摸类事件支持捕获，捕获阶段位于冒泡阶段之前，捕获事件先到达父组件然后达到子组件。 捕获事件绑定包括：  绑定捕获事件：on:{event}.capture。 绑定并阻止事件向下传递：grab:{event}.capture。 示例 已复制<!-- xxx.hml --><div>    <!-- 使用事件捕获模式绑定事件回调函数。5+ -->        <div on:touchstart.capture="touchstartfunc"></div>    <!-- 绑定事件回调函数，但阻止事件向下传递。5+ -->    <div grab:touchstart.capture="touchstartfunc"></div></div> 已复制// xxx.jsexport default {    touchstartfuc: function(e) {        console.log(e);    },}    列表渲染 已复制<!-- xxx.hml --><div class="array-container" style="flex-direction: column;margin: 200px;">  <!-- div列表渲染 -->  <!-- 默认$item代表数组中的元素, $idx代表数组中的元素索引 -->  <div for="{{array}}" tid="id" onclick="changeText">    <text>{{$idx}}.{{$item.name}}</text>  </div>  <!-- 自定义元素变量名称 -->  <div for="{{value in array}}" tid="id" onclick="changeText">        <text>{{$idx}}.{{value.name}}</text>  </div>  <!-- 自定义元素变量、索引名称 -->  <div for="{{(index, value) in array}}" tid="id" onclick="changeText">        <text>{{index}}.{{value.name}}</text>  </div></div> 已复制// xxx.jsexport default {  data: {    array: [      {id: 1, name: 'jack', age: 18},       {id: 2, name: 'tony', age: 18},    ],  },  changeText: function() {    if (this.array[1].name === "tony"){      this.array.splice(1, 1, {id:2, name: 'Isabella', age: 18});    } else {      this.array.splice(2, 1, {id:3, name: 'Bary', age: 18});    }  },} tid属性主要用来加速for循环的重渲染，旨在列表中的数据有变更时，提高重新渲染的效率。tid属性是用来指定数组中每个元素的唯一标识，如果未指定，数组中每个元素的索引为该元素的唯一id。例如上述tid="id"表示数组中的每个元素的id属性为该元素的唯一标识。for循环支持的写法如下：  for="array"：其中array为数组对象，array的元素变量默认为$item。 for="v in array"：其中v为自定义的元素变量，元素索引默认为$idx。 for="(i, v) in array"：其中元素索引为i，元素变量为v，遍历数组对象array。  
说明
  数组中的每个元素必须存在tid指定的数据属性，否则运行时可能会导致异常。 数组中被tid指定的属性要保证唯一性，如果不是则会造成性能损耗。比如，示例中只有id和name可以作为tid字段，因为它们属于唯一字段。 tid不支持表达式。  
    条件渲染 条件渲染分为2种：if/elif/else和show。两种写法的区别在于：第一种写法里if为false时，组件不会在vdom中构建，也不会渲染，而第二种写法里show为false时虽然也不渲染，但会在vdom中构建；另外，当使用if/elif/else写法时，节点必须是兄弟节点，否则编译无法通过。实例如下： 已复制<!-- xxx.hml --><div class="container">  <button class="btn" type="capsule" value="toggleShow" onclick="toggleShow"></button>  <button class="btn" type="capsule" value="toggleDisplay" onclick="toggleDisplay"></button>  <text if="{{visible}}"> Hello-world1 </text>  <text elif="{{display}}"> Hello-world2 </text>  <text else> Hello-World </text></div> 已复制/* xxx.css */.container{  flex-direction: column;  align-items: center;}.btn{  width: 280px;  font-size: 26px;  margin: 10px 0;} 已复制// xxx.jsexport default {  data: {    visible: false,    display: true,  },  toggleShow: function() {    this.visible = !this.visible;  },  toggleDisplay: function() {    this.display = !this.display;  }}  优化渲染优化：show方法。当show为true时，节点正常渲染；当为false时，仅仅设置display样式为none。 已复制<!-- xxx.hml --><div class="container">  <button class="btn" type="capsule" value="toggle" onclick="toggle"></button>  <text show="{{visible}}" > Hello World </text></div> 已复制/* xxx.css */.container{  flex-direction: column;  align-items: center;}.btn{  width: 280px;  font-size: 26px;  margin: 10px 0;} 已复制// xxx.jsexport default {  data: {    visible: false,  },  toggle: function() {    this.visible = !this.visible;  },} 
说明
 禁止在同一个元素上同时设置for和if属性。 
    逻辑控制块 <block>控制块使得循环渲染和条件渲染变得更加灵活；block在构建时不会被当作真实的节点编译。注意block标签只支持for和if属性。 已复制<!-- xxx.hml --><list>  <block for="glasses">    <list-item type="glasses">      <text>{{$item.name}}</text>    </list-item>    <block for="$item.kinds">      <list-item type="kind">        <text>{{$item.color}}</text>      </list-item>    </block>  </block></list> 已复制// xxx.jsexport default {  data: {    glasses: [      {name:'sunglasses', kinds:[{name:'XXX',color:'XXX'},{name:'XXX',color:'XXX'}]},      {name:'nearsightedness mirror', kinds:[{name:'XXX',color:'XXX'}]},    ],  },}    模板引用 HML可以通过element引用模板文件，详细介绍可参考自定义组件章节。 已复制<!-- template.hml --><div class="item">   <text>Name: {{name}}</text>  <text>Age: {{age}}</text></div> 已复制<!-- index.hml --><element name='comp' src='../../common/template.hml'></element><div>  <comp name="Tony" age="18"></comp></div>   上一篇 语法 下一篇 CSS语法参考 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。语法对象方法获取DOM元素获取ViewModelJS语法参考 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  JS文件用来定义HML页面的业务逻辑，支持ECMA规范的JavaScript语言。基于JavaScript语言的动态化能力，可以使应用更加富有表现力，具备更加灵活的设计能力。下面讲述JS文件的编译和运行的支持情况。  语法 支持ES6语法。  模块声明 使用import方法引入功能模块： 已复制import router from '@ohos.router'; 代码引用 使用import方法导入js代码： 已复制import utils from '../../common/utils.js';    对象  应用对象     属性 类型 描述    $def Object 使用this.$app.$def获取在app.js中暴露的对象。 >  说明： > 应用对象不支持数据绑定，需主动触发UI更新。    示例代码 已复制// app.jsexport default {  onCreate() {    console.info('Application onCreate');  },  onDestroy() {    console.info('Application onDestroy');  },  globalData: {    appData: 'appData',    appVersion: '2.0',  },  globalMethod() {    console.info('This is a global method!');    this.globalData.appVersion = '3.0';  }}; 已复制// index.js页面逻辑代码export default {  data: {    appData: 'localData',    appVersion:'1.0',  },  onInit() {    this.appData = this.$app.$def.globalData.appData;    this.appVersion = this.$app.$def.globalData.appVersion;  },  invokeGlobalMethod() {    this.$app.$def.globalMethod();  },  getAppVersion() {    this.appVersion = this.$app.$def.globalData.appVersion;  }} 页面对象     属性 类型 描述    data Object/Function 页面的数据模型，类型是对象或者函数，如果类型是函数，返回值必须是对象。属性名不能以$或_开头，不要使用保留字for, if, show, tid。 data与private和public不能重合使用。   $refs Object 持有注册过ref 属性的DOM元素或子组件实例的对象。示例见获取DOM元素。   private Object 页面的数据模型，private下的数据属性只能由当前页面修改。   public Object 页面的数据模型，public下的数据属性的行为与data保持一致。   props Array/Object props用于组件之间的通信，可以通过<tag xxxx='value'>方式传递给组件；props名称必须用小写，不能以$或_开头，不要使用保留字for, if, show, tid。目前props的数据类型不支持Function。示例见自定义组件。   computed Object 用于在读取或设置进行预先处理，计算属性的结果会被缓存。计算属性名不能以$或_开头，不要使用保留字。示例见自定义组件。       方法  数据方法     方法 参数 描述    $set key: string, value: any 添加新的数据属性或者修改已有数据属性。 用法： this.$set('key',value)：添加数据属性。   $delete key: string 删除数据属性。 用法： this.$delete('key')：删除数据属性。    示例代码 已复制// index.jsexport default {  data: {    keyMap: {      OS: 'HarmonyOS',      Version: '2.0',    },  },  getAppVersion() {    this.$set('keyMap.Version', '3.0');    console.info("keyMap.Version = " + this.keyMap.Version); // keyMap.Version = 3.0
    this.$delete('keyMap');    console.info("keyMap.Version = " + this.keyMap); // log print: keyMap.Version = undefined  }} 公共方法     方法 参数 描述    $element id: string 获得指定id的组件对象，如果无指定id，则返回根组件对象。示例见获取DOM元素。 用法： <div id='xxx'></div> - this.$element('xxx')：获得id为xxx的组件对象。 - this.$element()：获得根组件对象。   $rootElement 无 获取根组件对象。 用法：this.$rootElement().scrollTo({ duration: 500, position: 300 }), 页面在500ms内滚动300px。   $root 无 获得顶级ViewModel实例。获取ViewModel示例。   $parent 无 获得父级ViewModel实例。获取ViewModel示例。   $child id: string 获得指定id的子级自定义组件的ViewModel实例。获取ViewModel示例。 用法： this.$child('xxx') ：获取id为xxx的子级自定义组件的ViewModel实例。    事件方法     方法 参数 描述    $watch data: string, callback: string | Function 观察data中的属性变化，如果属性值改变，触发绑定的事件。示例见自定义组件。 用法： this.$watch('key', callback)    页面方法     方法 参数 描述    scrollTo6+ scrollPageParam: ScrollPageParam 将页面滚动到目标位置，可以通过ID选择器指定或者滚动距离指定。    表1 ScrollPageParam6+     名称 类型 默认值 描述    position number - 指定滚动位置。   id string - 指定需要滚动到的元素id。   duration number 300 指定滚动时长，单位为毫秒。   timingFunction string ease 指定滚动动画曲线，可选值参考 动画样式animation-timing-function。   complete () => void - 指定滚动完成后需要执行的回调函数。    示例： 已复制this.$rootElement().scrollTo({position: 0})this.$rootElement().scrollTo({id: 'id', duration: 200, timingFunction: 'ease-in', complete: ()=>void})    获取DOM元素  通过$refs获取DOM元素 已复制<!-- index.hml --><div class="container">  <image-animator class="image-player" ref="animator" images="{{images}}" duration="1s" onclick="handleClick"></image-animator></div> 已复制// index.jsexport default {  data: {    images: [      { src: '/common/frame1.png' },      { src: '/common/frame2.png' },      { src: '/common/frame3.png' }    ]  },  handleClick() {    const animator = this.$refs.animator; // 获取ref属性为animator的DOM元素    const state = animator.getState();    if (state === 'paused') {      animator.resume();    } else if (state === 'stopped') {      animator.start();    } else {      animator.pause();    }  },}; 通过$element获取DOM元素 已复制<!-- index.hml --><div class="container" style="width:500px;height: 700px; margin: 100px;">  <image-animator class="image-player" id="animator" images="{{images}}" duration="1s" onclick="handleClick"></image-animator></div> 已复制// index.jsexport default {  data: {    images: [      { src: '/common/frame1.png' },      { src: '/common/frame2.png' },      { src: '/common/frame3.png' }    ]  },  handleClick() {    const animator = this.$element('animator'); // 获取id属性为animator的DOM元素    const state = animator.getState();    if (state === 'paused') {      animator.resume();    } else if (state === 'stopped') {      animator.start();    } else {      animator.pause();    }  },};     获取ViewModel 根节点所在页面： 已复制<!-- root.hml --><element name='parentComp' src='../../common/component/parent/parent.hml'></element><div class="container">  <div class="container">    <text>{{text}}</text>    <parentComp></parentComp>  </div></div> 已复制// root.jsexport default {  data: {    text: 'I am root!',  },}  自定义parent组件： 已复制<!-- parent.hml --><element name='childComp' src='../child/child.hml'></element><div class="item" onclick="textClicked">  <text class="text-style" onclick="parentClicked">parent component click</text>  <text class="text-style" if="{{showValue}}">hello parent component!</text>  <childComp id = "selfDefineChild"></childComp></div> 已复制// parent.jsexport default {  data: {    showValue: false,    text: 'I am parent component!',  },  parentClicked () {    this.showValue = !this.showValue;    console.info('parent component get parent text');    console.info(`${this.$parent().text}`);    console.info("parent component get child function");    console.info(`${this.$child('selfDefineChild').childClicked()}`);  },} 自定义child组件： 已复制<!-- child.hml --><div class="item" onclick="textClicked">  <text class="text-style" onclick="childClicked">child component clicked</text>  <text class="text-style" if="{{isShow}}">hello child component</text></div> 已复制// child.jsexport default {  data: {    isShow: false,    text: 'I am child component!',  },  childClicked () {    this.isShow = !this.isShow;    console.info('child component get parent text');    console.info('${this.$parent().text}');    console.info('child component get root text');    console.info('${this.$root().text}');  },}    上一篇 CSS语法参考 下一篇 生命周期 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。运作机制接口说明开发步骤创建卡片FormExtensionAbility配置卡片配置文件卡片信息的持久化卡片数据交互开发卡片页面开发卡片事件开发基于JS UI的卡片 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  以下内容介绍基于类Web范式的JS UI卡片开发指南。  运作机制 卡片框架的运作机制如图1所示。 图1 卡片框架运作机制（Stage模型）  卡片使用方包含以下模块：  卡片使用：包含卡片的创建、删除、请求更新等操作。 通信适配层：由OpenHarmony SDK提供，负责与卡片管理服务通信，用于将卡片的相关操作到卡片管理服务。  卡片管理服务包含以下模块：  周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。 卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。 卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。 卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。 通信适配层：负责与卡片使用方和提供方进行RPC通信。  卡片提供方包含以下模块：  卡片服务：由卡片提供方开发者实现，开发者实现生命周期处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。 卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。 通信适配层：由OpenHarmony SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务。  
说明
 实际开发时只需要作为卡片提供方进行卡片内容的开发，卡片使用方和卡片管理服务由系统自动处理。 
   接口说明 FormExtensionAbility类拥有如下API接口，具体的API介绍详见接口文档。     接口名 描述    onAddForm(want: Want): formBindingData.FormBindingData 卡片提供方接收创建卡片的通知接口。   onCastToNormalForm(formId: string): void 卡片提供方接收临时卡片转常态卡片的通知接口。   onUpdateForm(formId: string): void 卡片提供方接收更新卡片的通知接口。   onChangeFormVisibility(newStatus: { [key: string]: number }): void 卡片提供方接收修改可见性的通知接口。   onFormEvent(formId: string, message: string): void 卡片提供方接收处理卡片事件的通知接口。   onRemoveForm(formId: string): void 卡片提供方接收销毁卡片的通知接口。   onConfigurationUpdate(config: Configuration): void 当系统配置更新时调用。   onShareForm?(formId: string): { [key: string]: any } 卡片提供方接收卡片分享的通知接口。    formProvider类有如下API接口，具体的API介绍详见接口文档。     接口名 描述    setFormNextRefreshTime(formId: string, minute: number, callback: AsyncCallback<void>): void; 设置指定卡片的下一次更新时间。   setFormNextRefreshTime(formId: string, minute: number): Promise<void>; 设置指定卡片的下一次更新时间，以promise方式返回。   updateForm(formId: string, formBindingData: FormBindingData, callback: AsyncCallback<void>): void; 更新指定的卡片。   updateForm(formId: string, formBindingData: FormBindingData): Promise<void>; 更新指定的卡片，以promise方式返回。    formBindingData类有如下API接口，具体的API介绍详见接口文档。     接口名 描述    createFormBindingData(obj?: Object | string): FormBindingData 创建一个FormBindingData对象。      开发步骤 Stage卡片开发，即基于Stage模型的卡片提供方开发，主要涉及如下关键步骤：  创建卡片FormExtensionAbility：卡片生命周期回调函数FormExtensionAbility开发。 配置卡片配置文件：配置应用配置文件module.json5和profile配置文件。 卡片信息的持久化：对卡片信息进行持久化管理。 卡片数据交互：通过updateForm更新卡片显示的信息。 开发卡片页面：使用HML+CSS+JSON开发JS卡片页面。 开发卡片事件：为卡片添加router事件和message事件。    创建卡片FormExtensionAbility 创建Stage模型的卡片，需实现FormExtensionAbility生命周期接口。先参考DevEco Studio服务卡片开发指南生成服务卡片模板。  在EntryFormAbility.ts中，导入相关模块。 已复制import FormExtensionAbility from '@ohos.app.form.FormExtensionAbility';import formBindingData from '@ohos.app.form.formBindingData';import formInfo from '@ohos.app.form.formInfo';import formProvider from '@ohos.app.form.formProvider';import dataStorage from '@ohos.data.storage'; 在EntryFormAbility.ts中，实现FormExtension生命周期接口。 已复制export default class EntryFormAbility extends FormExtensionAbility {    onAddForm(want) {        console.info('[EntryFormAbility] onAddForm');        // 使用方创建卡片时触发，提供方需要返回卡片数据绑定类        let obj = {            "title": "titleOnCreate",            "detail": "detailOnCreate"        };        let formData = formBindingData.createFormBindingData(obj);        return formData;    }    onCastToNormalForm(formId) {        // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理        console.info('[EntryFormAbility] onCastToNormalForm');    }    onUpdateForm(formId) {        // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新        console.info('[EntryFormAbility] onUpdateForm');        let obj = {            "title": "titleOnUpdate",            "detail": "detailOnUpdate"        };        let formData = formBindingData.createFormBindingData(obj);        formProvider.updateForm(formId, formData).catch((error) => {            console.info('[EntryFormAbility] updateForm, error:' + JSON.stringify(error));        });    }    onChangeFormVisibility(newStatus) {        // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，仅系统应用生效        console.info('[EntryFormAbility] onChangeFormVisibility');    }    onFormEvent(formId, message) {        // 若卡片支持触发事件，则需要重写该方法并实现对事件的触发        console.info('[EntryFormAbility] onFormEvent');    }    onRemoveForm(formId) {        // 删除卡片实例数据        console.info('[EntryFormAbility] onRemoveForm');    }    onConfigurationUpdate(config) {        console.info('[EntryFormAbility] nConfigurationUpdate, config:' + JSON.stringify(config));    }    onAcquireFormState(want) {        return formInfo.FormState.READY;    }}  
说明
 FormExtensionAbility不能常驻后台，即在卡片生命周期回调函数中无法处理长时间的任务。 
   配置卡片配置文件  卡片需要在module.json5配置文件中的extensionAbilities标签下，配置ExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串"ohos.extension.form"，资源为卡片的具体配置信息的索引。 配置示例如下： 已复制{  "module": {    ...    "extensionAbilities": [      {        "name": "EntryFormAbility",        "srcEntrance": "./ets/entryformability/EntryFormAbility.ts",        "label": "$string:EntryFormAbility_label",        "description": "$string:EntryFormAbility_desc",        "type": "form",        "metadata": [          {            "name": "ohos.extension.form",            "resource": "$profile:form_config"          }        ]      }    ]  }} 卡片的具体配置信息。在上述FormExtensionAbility的元信息（"metadata"配置项）中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。内部字段结构说明如下表所示。 表1 卡片profile配置文件     属性名称 含义 数据类型 是否可缺省    name 表示卡片的类名，字符串最大长度为127字节。 字符串 否   description 表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。 字符串 可缺省，缺省为空。   src 表示卡片对应的UI代码的完整路径。 字符串 否   window 用于定义与显示窗口相关的配置。 对象 可缺省   isDefault 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。 - true：默认卡片。 - false：非默认卡片。 布尔值 否   colorMode 表示卡片的主题样式，取值范围如下： - auto：自适应。 - dark：深色主题。 - light：浅色主题。 字符串 可缺省，缺省值为“auto”。   supportDimensions 表示卡片支持的外观规格，取值范围： - 1 * 2：表示1行2列的二宫格。 - 2 * 2：表示2行2列的四宫格。 - 2 * 4：表示2行4列的八宫格。 - 4 * 4：表示4行4列的十六宫格。 字符串数组 否   defaultDimension 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 字符串 否   updateEnabled 表示卡片是否支持周期性刷新，取值范围： - true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。 - false：表示不支持周期性刷新。 布尔类型 否   scheduledUpdateTime 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。 updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 字符串 可缺省，缺省值为“0:0”。   updateDuration 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。 当取值为0时，表示该参数不生效。 当取值为正整数N时，表示刷新周期为30*N分钟。 updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 数值 可缺省，缺省值为“0”。   formConfigAbility 表示卡片的配置跳转链接，采用URI格式。 字符串 可缺省，缺省值为空。   formVisibleNotify 标识是否允许卡片使用卡片可见性通知。 字符串 可缺省，缺省值为空。   metaData 表示卡片的自定义信息，包含customizeData数组标签。 对象 可缺省，缺省值为空。    配置示例如下： 已复制{  "forms": [    {      "name": "widget",      "description": "This is a service widget.",      "src": "./js/widget/pages/index/index",      "window": {        "designWidth": 720,        "autoDesignWidth": true      },      "colorMode": "auto",      "isDefault": true,      "updateEnabled": true,      "scheduledUpdateTime": "10:30",      "updateDuration": 1,      "defaultDimension": "2*2",      "supportDimensions": [        "2*2"      ]    }  ]}    卡片信息的持久化 因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息，且卡片管理服务支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。 已复制const DATA_STORAGE_PATH = "/data/storage/el2/base/haps/form_store";async function storeFormInfo(formId: string, formName: string, tempFlag: boolean) {    // 此处仅对卡片ID：formId，卡片名：formName和是否为临时卡片：tempFlag进行了持久化    let formInfo = {        "formName": formName,        "tempFlag": tempFlag,        "updateCount": 0    };    try {        const storage = await dataStorage.getStorage(DATA_STORAGE_PATH);        // put form info        await storage.put(formId, JSON.stringify(formInfo));        console.info(`[EntryFormAbility] storeFormInfo, put form info successfully, formId: ${formId}`);        await storage.flush();    } catch (err) {        console.error(`[EntryFormAbility] failed to storeFormInfo, err: ${JSON.stringify(err)}`);    }}
export default class EntryFormAbility extends FormExtension {    ...    onAddForm(want) {        console.info('[EntryFormAbility] onAddForm');
        let formId = want.parameters["ohos.extra.param.key.form_identity"];        let formName = want.parameters["ohos.extra.param.key.form_name"];        let tempFlag = want.parameters["ohos.extra.param.key.form_temporary"];        // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用        // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例        storeFormInfo(formId, formName, tempFlag);
        let obj = {            "title": "titleOnCreate",            "detail": "detailOnCreate"        };        let formData = formBindingData.createFormBindingData(obj);        return formData;    }} 且需要适配onRemoveForm卡片删除通知接口，在其中实现卡片实例数据的删除。 已复制const DATA_STORAGE_PATH = "/data/storage/el2/base/haps/form_store";async function deleteFormInfo(formId: string) {    try {        const storage = await dataStorage.getStorage(DATA_STORAGE_PATH);        // del form info        await storage.delete(formId);        console.info(`[EntryFormAbility] deleteFormInfo, del form info successfully, formId: ${formId}`);        await storage.flush();    } catch (err) {        console.error(`[EntryFormAbility] failed to deleteFormInfo, err: ${JSON.stringify(err)}`);    }}
...
export default class EntryFormAbility extends FormExtension {    ...    onRemoveForm(formId) {        console.info('[EntryFormAbility] onRemoveForm');        // 删除之前持久化的卡片实例数据        // 此接口请根据实际情况实现，具体请参考：FormExtAbility Stage模型卡片实例        deleteFormInfo(formId);    }} 具体的持久化方法可以参考应用数据持久化概述。 需要注意的是，卡片使用方在请求卡片时传递给提供方应用的Want数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片：  常态卡片：卡片使用方会持久化的卡片； 临时卡片：卡片使用方不会持久化的卡片；  由于临时卡片的数据具有非持久化的特殊性，某些场景例如卡片服务框架死亡重启，此时临时卡片数据在卡片管理服务中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。   卡片数据交互 当卡片应用需要更新数据时（如触发了定时更新或定点更新），卡片应用获取最新数据，并调用updateForm()接口主动触发卡片的更新。 已复制onUpdateForm(formId) {    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新    console.info('[EntryFormAbility] onUpdateForm');    let obj = {        "title": "titleOnUpdate",        "detail": "detailOnUpdate"    };    let formData = formBindingData.createFormBindingData(obj);    // 调用updateForm接口去更新对应的卡片，仅更新入参中携带的数据信息，其他信息保持不变    formProvider.updateForm(formId, formData).catch((error) => {        console.info('[EntryFormAbility] updateForm, error:' + JSON.stringify(error));    });}   开发卡片页面 开发者可以使用类Web范式（HML+CSS+JSON）开发JS卡片页面。生成如下卡片页面，可以这样配置卡片页面文件：  
说明
 当前仅支持JS扩展的类Web开发范式来实现卡片的UI。 
  HML：使用类Web范式的组件描述卡片的页面信息。 已复制<div class="container">  <stack>    <div class="container-img">      <image src="/common/widget.png" class="bg-img"></image>    </div>    <div class="container-inner">      <text class="title">{{title}}</text>      <text class="detail_text" onclick="routerEvent">{{detail}}</text>    </div>  </stack></div> CSS：HML中类Web范式组件的样式信息。 已复制.container {  flex-direction: column;  justify-content: center;  align-items: center;}
.bg-img {  flex-shrink: 0;  height: 100%;}
.container-inner {  flex-direction: column;  justify-content: flex-end;  align-items: flex-start;  height: 100%;  width: 100%;  padding: 12px;}
.title {  font-size: 19px;  font-weight: bold;  color: white;  text-overflow: ellipsis;  max-lines: 1;}
.detail_text {  font-size: 16px;  color: white;  opacity: 0.66;  text-overflow: ellipsis;  max-lines: 1;  margin-top: 6px;} JSON：卡片页面中的数据和事件交互。 已复制{  "data": {    "title": "TitleDefault",    "detail": "TextDefault"  },  "actions": {    "routerEvent": {      "action": "router",      "abilityName": "EntryAbility",      "params": {        "message": "add detail"      }    }  }}    开发卡片事件 卡片支持为组件设置交互事件（action），包括router事件和message事件，其中router事件用于UIAbility跳转，message事件用于卡片开发人员自定义点击事件。 关键步骤说明如下：  在HML中为组件设置onclick属性，其值对应到JSON文件的actions字段中。 设置router事件：  action属性值为"router"。 abilityName为跳转目标的UIAbility名（支持跳转FA模型的PageAbility组件和Stage模型的UIAbility组件），如目前DevEco Studio创建的Stage模型的UIAbility默认名为EntryAbility。 params为传递给跳转目标UIAbility的自定义参数，可以按需填写。其值可以在目标UIAbility启动时的want中的parameters里获取。如Stage模型MainAbility的onCreate生命周期里的入参want的parameters字段下获取到配置的参数。  设置message事件：  action属性值为"message"。 params为message事件的用户自定义参数，可以按需填写。其值可以在卡片生命周期函数onFormEvent()中的message里获取。   示例如下。  HML文件 已复制<div class="container">  <stack>    <div class="container-img">      <image src="/common/widget.png" class="bg-img"></image>    </div>    <div class="container-inner">      <text class="title" onclick="routerEvent">{{title}}</text>      <text class="detail_text" onclick="messageEvent">{{detail}}</text>    </div>  </stack></div> CSS文件 已复制.container {  flex-direction: column;  justify-content: center;  align-items: center;}
.bg-img {  flex-shrink: 0;  height: 100%;}
.container-inner {  flex-direction: column;  justify-content: flex-end;  align-items: flex-start;  height: 100%;  width: 100%;  padding: 12px;}
.title {  font-size: 19px;  font-weight: bold;  color: white;  text-overflow: ellipsis;  max-lines: 1;}
.detail_text {  font-size: 16px;  color: white;  opacity: 0.66;  text-overflow: ellipsis;  max-lines: 1;  margin-top: 6px;} JSON文件 已复制{  "data": {    "title": "TitleDefault",    "detail": "TextDefault"  },  "actions": {    "routerEvent": {      "action": "router",      "abilityName": "EntryAbility",      "params": {        "info": "router info",        "message": "router message"      }    },    "messageEvent": {      "action": "message",      "params": {        "detail": "message detail"      }    }  }} 在UIAbility中接收router事件并获取参数 已复制import UIAbility from '@ohos.app.ability.UIAbility'
export default class EntryAbility extends UIAbility {    onCreate(want, launchParam) {        let params = JSON.parse(want.parameters.params);        // 获取router事件中传递的info参数        if (params.info === "router info") {            // do something            // console.info("router info:" + params.info)        }        // 获取router事件中传递的message参数        if (params.message === "router message") {            // do something            // console.info("router message:" + params.message)        }    }    ...}; 在FormExtensionAbility中接收message事件并获取参数 已复制import FormExtension from '@ohos.app.form.FormExtensionAbility';
export default class FormAbility extends FormExtension {    ...    onFormEvent(formId, message) {        // 获取message事件中传递的detail参数        let msg = JSON.parse(message)        if (msg.detail === "message detail") {            // do something            // console.info("message info:" + msg.detail)        }    }    ...};    上一篇 根据卡片状态刷新不同内容 下一篇 AbilityStage组件容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。接口说明开发步骤跳转拨号界面 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 当应用需要跳转到拨号界面，并显示拨号的号码时，使用本业务。当开发者调用makeCall接口时，设备会自动跳转到拨号界面。和正常拨打电话一样，用户可以选择音频或视频呼叫，卡1或卡2拨出。 接口说明call模块为开发者提供呼叫管理功能。observer模块为开发者提供订阅和取消订阅通话业务状态的功能。具体接口说明如下表。 功能分类 接口名 描述 所需权限   能力获取 call.hasVoiceCapability() 是否具有语音功能 无  跳转拨号界面 call.makeCall() 跳转到拨号界面，并显示拨号的号码 无  订阅通话业务状态变化 observer.on('callStateChange') 订阅通话业务状态变化 ohos.permission.READ_CALL_LOG （获取通话号码需要该权限）  取消订阅通话业务状态变化 observer.off('callStateChange') 取消订阅通话业务状态变化 无     开发步骤import需要的模块。 调用hasVoiceCapability()接口获取当前设备呼叫能力，如果支持继续下一步；如果不支持则无法发起呼叫。 跳转到拨号界面，并显示拨号的号码。 （可选）订阅通话业务状态变化。 已复制// import需要的模块import call from '@ohos.telephony.call';import observer from '@ohos.telephony.observer';
// 调用查询能力接口let isSupport = call.hasVoiceCapability();if (!isSupport) {    console.log("not support voice capability, return.");    return;}// 如果设备支持呼叫能力，则继续跳转到拨号界面，并显示拨号的号码call.makeCall("13xxxx", (err)=> {    if (!err) {        console.log("make call success.");    } else {        console.log("make call fail, err is:" + JSON.stringify(err));    }});// 订阅通话业务状态变化（可选）observer.on("callStateChange", (data) => {    console.log("call state change, data is:" + JSON.stringify(data));});    上一篇 电话服务开发概述 下一篇 获取当前蜂窝网络信号信息 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。ArrayListVectorListLinkedListDequeQueueStack线性容器的使用线性容器 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue、Stack七种。 线性容器，充分考虑了数据访问的速度，运行时（Runtime）通过一条字节码指令就可以完成增、删、改、查等操作。  ArrayList ArrayList即动态数组，可用来构造全局的数组对象。 当需要频繁读取集合中的元素时，推荐使用ArrayList。 ArrayList依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容大小为原始容量的1.5倍。 ArrayList进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(element: T)函数每次在数组尾部增加一个元素。   通过insert(element: T, index: number)在指定位置插入一个元素。   访问元素 通过arr[index]获取指定index对应的value值，通过指令获取保证访问速度。   通过forEach(callbackFn: (value: T, index?: number, arrlist?: ArrayList<T>) => void, thisArg?: Object): void访问整个ArrayList容器的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过arr[index] = xxx修改指定index位置对应的value值。   删除元素 通过remove(element: T)删除第一个匹配到的元素。   通过removeByRange(fromIndex: number, toIndex:number)删除指定范围内的元素。      Vector 
说明
 API version 9开始，该接口不再维护，推荐使用ArrayList。 
 Vector是指连续存储结构，可用来构造全局的数组对象。Vector依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容大小为原始容量的2倍。 Vector和ArrayList相似，都是基于数组实现，但Vector提供了更多操作数组的接口。Vector在支持操作符访问的基础上，还增加了get/set接口，提供更为完善的校验及容错机制，满足用户不同场景下的需求。 Vector进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(element: T)函数每次在数组尾部增加一个元素。   通过insert(element: T, index: number)在指定位置插入一个元素。   访问元素 通过vec[index]获取指定index对应的value值，通过指令获取保证访问速度。   通过get(index: number)获取指定index位置对应的元素。   通过getLastElement()获取最后一个元素。   通过getIndexOf(element:T)获取第一个匹配到元素的位置。   通过getLastIndexOf(element:T)获取最后一个匹配到元素的位置。   通过forEach(callbackFn: (value: T, index?: number, Vector?: Vector<T>) => void, thisArg?: Object)访问整个Vector的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过vec[index]=xxx修改指定index位置对应的value值。   通过set(index:number,element:T)修改指定index位置的元素值为element。   通过setLength(newSize:number)设置Vector的长度大小。   删除元素 通过removeByIndex(index:number)删除index位置对应的value值。   通过remove(element:T)删除第一个匹配到的元素。   通过removeByRange(fromIndex:number,toIndex:number)删除指定范围内的元素。      List List可用来构造一个单向链表对象，即只能通过头节点开始访问到尾节点。List依据泛型定义，在内存中的存储位置可以是不连续的。 List和LinkedList相比，LinkedList是双向链表，可以快速地在头尾进行增删，而List是单向链表，无法双向操作。 当需要频繁的插入删除时，推荐使用List高效操作。 可以通过get/set等接口对存储的元素进行修改，List进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(element: T)函数每次在数组尾部增加一个元素。   通过insert(element: T, index: number)在指定位置插入一个元素。   访问元素 通过list[index]获取指定index对应的value值，通过指令获取保证访问速度。   通过get(index: number)获取指定index位置对应的元素。   通过getFirst()获取第一个元素。   通过getLast()获取最后一个元素。   通过getIndexOf(element: T)获取第一个匹配到元素的位置。   通过getLastIndexOf(element: T)获取最后一个匹配到元素的位置。   通过forEach(callbackfn: (value:T, index?: number, list?: List<T>)=> void,thisArg?: Object)访问整个List的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过list[index] = xxx修改指定index位置对应的value值。   通过set(index:number, element: T)修改指定index位置的元素值为element。   通过replaceAllElements(callbackFn:(value: T,index?: number,list?: List<T>)=>T,thisArg?: Object)对List内元素进行替换操作。   删除元素 通过removeByIndex(index:number)删除index位置对应的value值。   通过remove(element:T)删除第一个匹配到的元素。      LinkedList LinkedList可用来构造一个双向链表对象，可以在某一节点向前或者向后遍历List。LinkedList依据泛型定义，在内存中的存储位置可以是不连续的。 LinkedList和List相比，LinkedList是双向链表，可以快速地在头尾进行增删，而List是单向链表，无法双向操作。 LinkedList和ArrayList相比，插入数据效率LinkedList优于ArrayList，而查询效率ArrayList优于LinkedList。 当需要频繁的插入删除时，推荐使用LinkedList高效操作。 可以通过get/set等接口对存储的元素进行修改，LinkedList进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(element: T)函数每次在数组尾部增加一个元素。   通过insert(index: number, element: T)在指定位置插入一个元素。   访问元素 通过list[index]获取指定index对应的value值，通过指令获取保证访问速度。   通过get(index: number)获取指定index位置对应的元素。   通过getFirst()获取第一个元素。   通过getLast()获取最后一个元素。   通过getIndexOf(element: T)获取第一个匹配到元素的位置。   通过getLastIndexOf(element: T)获取最后一个匹配到元素的位置。   通过forEach(callbackFn: (value: T, index?: number, list?: LinkedList<T>) => void, thisArg?: Object)访问整个LinkedList的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过list[index]=xxx修改指定index位置对应的value值。   通过set(index: number,element: T)修改指定index位置的元素值为element。   删除元素 通过removeByIndex(index: number)删除index位置对应的value值。   通过remove(element: T)删除第一个匹配到的元素。      Deque Deque可用来构造双端队列对象，存储元素遵循先进先出以及先进后出的规则，双端队列可以分别从队头或者队尾进行访问。 Deque依据泛型定义，要求存储位置是一片连续的内存空间，其初始容量大小为8，并支持动态扩容，每次扩容大小为原始容量的2倍。Deque底层采用循环队列实现，入队及出队操作效率都比较高。 Deque和Queue相比，Queue的特点是先进先出，只能在头部删除元素，尾部增加元素。 Deque和Vector相比，它们都支持在两端增删元素，但Deque不能进行中间插入的操作。对头部元素的插入删除效率高于Vector，而Vector访问元素的效率高于Deque。 需要频繁在集合两端进行增删元素的操作时，推荐使用Deque。 Deque进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过insertFront(element: T)函数每次在队头增加一个元素。   增加元素 通过insertEnd(element: T)函数每次在队尾增加一个元素。   访问元素 通过getFirst()获取队首元素的value值，但是不进行出队操作。   通过getLast()获取队尾元素的value值，但是不进行出队操作。   通过popFirst()获取队首元素的value值，并进行出队操作。   通过popLast()获取队尾元素的value值，并进行出队操作。   通过forEach(callbackFn:(value: T, index?: number, deque?: Deque<T>) => void, thisArg?: Object)访问整个Deque的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过forEach(callbackFn:(value: T, index?: number, deque?: Deque<T>)=> void, thisArg?: Object)对队列进行修改操作。   删除元素 通过popFirst()对队首元素进行出队操作并删除。   通过popLast()对队尾元素进行出队操作并删除。      Queue Queue可用来构造队列对象，存储元素遵循先进先出的规则。 Queue依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容大小为原始容量的2倍。 Queue底层采用循环队列实现，入队及出队操作效率都比较高。 Queue和Deque相比，Queue只能在一端删除一端增加，Deque可以两端增删。 一般符合先进先出的场景可以使用Queue。 Queue进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过add(element: T)函数每次在队尾增加一个元素。   访问元素 通过getFirst()获取队首元素的value值，但是不进行出队操作。   通过pop()获取队首元素的value值，并进行出队操作。   通过forEach(callbackFn: (value: T, index?: number, queue?: Queue<T>) => void,thisArg?: Object)访问整个Queue的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   修改元素 通过forEach(callbackFn:(value: T, index?: number, queue?: Queue<T>) => void,thisArg?: Object)对队列进行修改操作。   删除元素 通过pop()对队首进行出队操作并删除。      Stack Stack可用来构造栈对象，存储元素遵循先进后出的规则。 Stack依据泛型定义，要求存储位置是一片连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容大小为原始容量的1.5倍。Stack底层基于数组实现，入栈出栈均从数组的一端操作。 Stack和Queue相比，Queue基于循环队列实现，只能在一端删除，另一端插入，而Stack都在一端操作。 一般符合先进后出的场景可以使用Stack。 Stack进行增、删、改、查操作的常用API如下：     操作 描述    增加元素 通过push(item: T)函数每次在栈顶增加一个元素。   访问元素 通过peek()获取栈顶元素的value值，但是不进行出栈操作。   通过pop()获取栈顶的value值，并进行出栈操作。   通过forEach(callbackFn: (value: T, index?: number, stack?: Stack<T>) => void, thisArg?: Object)访问整个Stack的元素。   通过[Symbol.iterator]():IterableIterator<T>迭代器进行数据访问。   通过locate(element: T)获取元素对应的位置。   修改元素 通过forEach(callbackFn:(value: T, index?: number, stack?: Stack<T>) => void, thisArg?: Object)对栈内元素进行修改操作。   删除元素 通过pop()对栈顶进行出栈操作并删除。      线性容器的使用 此处列举常用的线性容器ArrayList、Vector、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示： 已复制// ArrayListimport ArrayList from '@ohos.util.ArrayList'; // 导入ArrayList模块
let arrayList = new ArrayList();arrayList.add('a');arrayList.add(1); // 增加元素console.info(`result: ${arrayList[0]}`); // 访问元素arrayList[0] = 'one'; // 修改元素console.info(`result: ${arrayList[0]}`);
// Vectorimport Vector from '@ohos.util.Vector'; // 导入Vector模块
let vector = new Vector();vector.add('a');let b1 = [1, 2, 3];vector.add(b1);vector.add(false); // 增加元素console.info(`result: ${vector[0]}`); // 访问元素console.info(`result: ${vector.getFirstElement()}`); // 访问元素
// Dequeimport Deque from '@ohos.util.Deque'; // 导入Deque模块
let deque = new Deque();deque.insertFront('a');deque.insertFront(1); // 增加元素console.info(`result: ${deque[0]}`); // 访问元素deque[0] = 'one'; // 修改元素console.info(`result: ${deque[0]}`);
// Stackimport Stack from '@ohos.util.Stack'; // 导入Stack模块 
let stack = new Stack();stack.push('a');stack.push(1); // 增加元素console.info(`result: ${stack[0]}`); // 访问元素stack.pop(); // 删除栈顶元素并返回该删除元素console.info(`result: ${stack.length}`);
// Listimport List from '@ohos.util.List'; // 导入List模块
let list = new List();list.add('a');list.add(1);let b2 = [1, 2, 3];list.add(b2); // 增加元素console.info(`result: ${list[0]}`); // 访问元素console.info(`result: ${list.get(0)}`); // 访问元素   上一篇 容器类库概述 下一篇 非线性容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。位置服务开发概述位置服务简介运作机制约束与限制申请位置权限开发指导场景概述开发步骤获取设备的位置信息开发指导场景概述接口说明开发步骤（逆）地理编码转化开发指导场景概述接口说明开发步骤地理围栏开发指导场景概述接口说明开发步骤位置服务开发指南 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
   位置服务开发概述 移动终端设备已经深入人们日常生活的方方面面，如查看所在城市的天气、新闻轶事、出行打车、旅行导航、运动记录。这些习以为常的活动，都离不开定位用户终端设备的位置。 当用户处于这些丰富的使用场景中时，系统的位置能力可以提供实时准确的位置数据。对于开发者，设计基于位置体验的服务，也可以使应用的使用体验更贴近每个用户。 当应用在实现基于设备位置的功能时，如：驾车导航，记录运动轨迹等，可以调用该模块的API接口，完成位置信息的获取。   位置服务简介 位置子系统使用多种定位技术提供服务，如GNSS定位、基站定位、WLAN/蓝牙定位（基站定位、WLAN/蓝牙定位后续统称“网络定位技术”）；通过这些定位技术，无论用户设备在室内或是户外，都可以准确地确定设备位置。 位置服务除了提供基础的定位服务之外，还提供了地理围栏、地理编码、逆地理编码、国家码等功能和接口。  坐标 系统以1984年世界大地坐标系统为参考，使用经度、纬度数据描述地球上的一个位置。 GNSS定位 基于全球导航卫星系统，包含：GPS、GLONASS、北斗、Galileo等，通过导航卫星、设备芯片提供的定位算法，来确定设备准确位置。定位过程具体使用哪些定位系统，取决于用户设备的硬件能力。 基站定位 根据设备当前驻网基站和相邻基站的位置，估算设备当前位置。此定位方式的定位结果精度相对较低，并且需要设备可以访问蜂窝网络。 WLAN、蓝牙定位 根据设备可搜索到的周围WLAN、蓝牙设备位置，估算设备当前位置。此定位方式的定位结果精度依赖设备周围可见的固定WLAN、蓝牙设备的分布，密度较高时，精度也相较于基站定位方式更高，同时也需要设备可以访问网络。    运作机制 位置能力作为系统为应用提供的一种基础服务，需要应用在所使用的业务场景，向系统主动发起请求，并在业务场景结束时，主动结束此请求，在此过程中系统会将实时的定位结果上报给应用。   约束与限制 使用设备的位置能力，需要用户进行确认并主动开启位置开关。如果位置开关没有开启，系统不会向任何应用提供位置服务。 设备位置信息属于用户敏感数据，所以即使用户已经开启位置开关，应用在获取设备位置前仍需向用户申请位置访问权限。在用户确认允许后，系统才会向应用提供位置服务。   申请位置权限开发指导   场景概述 应用在使用位置服务系统能力前，需要检查是否已经获取用户授权访问设备位置信息。如未获得授权，可以向用户申请需要的位置权限。 系统提供的定位权限有：  ohos.permission.LOCATION：用于获取精准位置，精准度在米级别。 ohos.permission.APPROXIMATELY_LOCATION：用于获取模糊位置，精确度为5公里。 ohos.permission.LOCATION_IN_BACKGROUND：用于应用切换到后台仍然需要获取定位信息的场景。  访问设备的位置信息，必须申请权限，并且获得用户授权。 表1 位置权限申请方式介绍     target API level 申请位置权限 申请结果 位置的精确度    小于9 ohos.permission.LOCATION 成功 获取到精准位置，精准度在米级别。   大于等于9 ohos.permission.LOCATION 失败 无法获取位置。   大于等于9 ohos.permission.APPROXIMATELY_LOCATION 成功 获取到模糊位置，精确度为5公里。   大于等于9 同时申请ohos.permission.APPROXIMATELY_LOCATION和ohos.permission.LOCATION 成功 获取到精准位置，精准度在米级别。    如果应用在后台运行时也需要访问设备位置，除需要将应用声明为允许后台运行外，还必须申请ohos.permission.LOCATION_IN_BACKGROUND权限，这样应用在切入后台之后，系统可以继续上报位置信息。 开发者可以在应用配置文件中声明所需要的权限，具体可参考授权申请指导。 位置服务每个接口需要申请哪些权限可以参见如下文档：位置服务。   开发步骤 具体可参考授权申请指导。   获取设备的位置信息开发指导   场景概述 开发者可以调用HarmonyOS位置相关接口，获取设备实时位置，或者最近的历史位置。 对于位置敏感的应用业务，建议获取设备实时位置信息。如果不需要设备实时位置信息，并且希望尽可能的节省耗电，开发者可以考虑获取最近的历史位置。   接口说明 获取设备的位置信息所使用的接口如下，详细说明参见：位置服务。 表2 获取设备的位置信息接口介绍     接口名 功能描述    on(type: 'locationChange', request: LocationRequest, callback: Callback<Location>): void 开启位置变化订阅，并发起定位请求。   off(type: 'locationChange', callback?: Callback<Location>): void 关闭位置变化订阅，并删除对应的定位请求。   getCurrentLocation(request: CurrentLocationRequest, callback: AsyncCallback<Location>): void 获取当前位置，使用callback回调异步返回结果。   getCurrentLocation(request?: CurrentLocationRequest): Promise<Location> 获取当前位置，使用Promise方式异步返回结果。   getLastLocation(): Location 获取最近一次定位结果。      开发步骤  获取设备的位置信息，需要有位置权限，位置权限申请的方法和步骤见申请位置权限开发指导。 导入geoLocationManager模块，所有与基础定位能力相关的功能API，都是通过该模块提供的。 已复制import geoLocationManager from '@ohos.geoLocationManager'; 实例化LocationRequest对象，用于告知系统该向应用提供何种类型的位置服务，以及位置结果上报的频率。 方式一： 为了面向开发者提供贴近其使用场景的API使用方式，系统定义了几种常见的位置能力使用场景，并针对使用场景做了适当的优化处理，应用可以直接匹配使用，简化开发复杂度。系统当前支持场景如下表所示。 定位场景类型说明  导航场景：NAVIGATION 适用于在户外定位设备实时位置的场景，如车载、步行导航。 在此场景下，为保证系统提供位置结果精度最优，主要使用GNSS定位技术提供定位服务，结合场景特点，在导航启动之初，用户很可能在室内、车库等遮蔽环境，GNSS技术很难提供位置服务。 为解决此问题，我们会在GNSS提供稳定位置结果之前，使用系统网络定位技术，向应用提供位置服务，以在导航初始阶段提升用户体验。 此场景默认以最小1秒间隔上报定位结果，使用此场景的应用必须申请ohos.permission.LOCATION权限，同时获得用户授权。 轨迹跟踪场景：TRAJECTORY_TRACKING 适用于记录用户位置轨迹的场景，如运动类应用记录轨迹功能。主要使用GNSS定位技术提供定位服务。 此场景默认以最小1秒间隔上报定位结果，并且应用必须申请ohos.permission.LOCATION权限，同时获得用户授权。 出行约车场景：CAR_HAILING 适用于用户出行打车时定位当前位置的场景，如网约车类应用。 此场景默认以最小1秒间隔上报定位结果，并且应用必须申请ohos.permission.LOCATION权限，同时获得用户授权。 生活服务场景：DAILY_LIFE_SERVICE 生活服务场景，适用于不需要定位用户精确位置的使用场景，如新闻资讯、网购、点餐类应用，做推荐、推送时定位用户大致位置即可。 此场景默认以最小1秒间隔上报定位结果，并且应用至少申请ohos.permission.LOCATION权限，同时获得用户授权。 无功耗场景：NO_POWER 无功耗场景，适用于不需要主动启动定位业务。系统在响应其他应用启动定位业务并上报位置结果时，会同时向请求此场景的应用程序上报定位结果，当前的应用程序不产生定位功耗。 此场景默认以最小1秒间隔上报定位结果，并且应用需要申请ohos.permission.LOCATION权限，同时获得用户授权。  已复制    export enum LocationRequestScenario {         UNSET = 0x300,         NAVIGATION,         TRAJECTORY_TRACKING,         CAR_HAILING,         DAILY_LIFE_SERVICE,         NO_POWER,     } 以导航场景为例，实例化方式如下： 已复制let requestInfo = {'scenario': geoLocationManager.LocationRequestScenario.NAVIGATION, 'timeInterval': 0, 'distanceInterval': 0, 'maxAccuracy': 0}; 方式二： 如果定义的现有场景类型不能满足所需的开发场景，系统提供了基本的定位优先级策略类型。 定位优先级策略类型说明  定位精度优先策略：ACCURACY 定位精度优先策略主要以GNSS定位技术为主，在开阔场景下可以提供米级的定位精度，具体性能指标依赖用户设备的定位硬件能力，但在室内等强遮蔽定位场景下，无法提供准确的位置服务。 快速定位优先策略：FIRST_FIX 快速定位优先策略会同时使用GNSS定位、基站定位和WLAN、蓝牙定位技术，以便室内和户外场景下，通过此策略都可以获得位置结果，当各种定位技术都有提供位置结果时，系统会选择其中精度较好的结果返回给应用。因为对各种定位技术同时使用，对设备的硬件资源消耗较大，功耗也较大。 低功耗定位优先策略：LOW_POWER 低功耗定位优先策略主要使用基站定位和WLAN、蓝牙定位技术，也可以同时提供室内和户外场景下的位置服务，因为其依赖周边基站、可见WLAN、蓝牙设备的分布情况，定位结果的精度波动范围较大，如果对定位结果精度要求不高，或者使用场景多在有基站、可见WLAN、蓝牙设备高密度分布的情况下，推荐使用，可以有效节省设备功耗。  已复制    export enum LocationRequestPriority {         UNSET = 0x200,         ACCURACY,         LOW_POWER,         FIRST_FIX,     } 以定位精度优先策略为例，实例化方式如下： 已复制let requestInfo = {'priority': geoLocationManager.LocationRequestPriority.ACCURACY, 'timeInterval': 0, 'distanceInterval': 0, 'maxAccuracy': 0}; 实例化Callback对象，用于向系统提供位置上报的途径。 应用需要自行实现系统定义好的回调接口，并将其实例化。系统在定位成功确定设备的实时位置结果时，会通过该接口上报给应用。应用程序可以在接口的实现中完成自己的业务逻辑。 已复制let locationChange = (location) => {    console.log('locationChanger: data: ' + JSON.stringify(location));}; 启动定位。 已复制geoLocationManager.on('locationChange', requestInfo, locationChange); （可选）结束定位。 如果不主动结束定位可能导致设备功耗高，耗电快；建议在不需要获取定位信息时及时结束定位。 已复制geoLocationManager.off('locationChange', locationChange); 如果应用使用场景不需要实时的设备位置，可以获取系统缓存的最近一次历史定位结果。 已复制import geoLocationManager from '@ohos.geoLocationManager';try {    let location = geoLocationManager.getLastLocation();} catch (err) {    console.error("errCode:" + err.code + ",errMessage:" + err.message);}    （逆）地理编码转化开发指导   场景概述 使用坐标描述一个位置，非常准确，但是并不直观，面向用户表达并不友好。系统向开发者提供了以下两种转化能力。  地理编码转化：将地理描述转化为具体坐标。 逆地理编码转化能力：将坐标转化为地理描述。  其中地理编码包含多个属性来描述位置，包括国家、行政区划、街道、门牌号、地址描述等等，这样的信息更便于用户理解。   接口说明 进行坐标和地理编码信息的相互转化，所使用的接口说明如下，详细信息参见：位置服务。 表3 （逆）地理编码转化接口介绍     接口名 功能描述    isGeocoderAvailable(): boolean; 判断（逆）地理编码服务状态。   getAddressesFromLocation(request: ReverseGeoCodeRequest, callback: AsyncCallback<Array<GeoAddress>>): void 调用逆地理编码服务，将坐标转换为地理描述，使用callback回调异步返回结果。   getAddressesFromLocation(request: ReverseGeoCodeRequest): Promise<Array<GeoAddress>> 调用逆地理编码服务，将坐标转换为地理描述，使用Promise方式异步返回结果。   getAddressesFromLocationName(request: GeoCodeRequest, callback: AsyncCallback<Array<GeoAddress>>): void 调用地理编码服务，将地理描述转换为具体坐标，使用callback回调异步返回结果。   getAddressesFromLocationName(request: GeoCodeRequest): Promise<Array<GeoAddress>> 调用地理编码服务，将地理描述转换为具体坐标，使用Promise方式异步返回结果。      开发步骤 
说明
 GeoConvert需要访问后端服务，请确保设备联网，以进行信息获取。 
  导入geoLocationManager模块，所有与（逆）地理编码转化能力相关的功能API，都是通过该模块提供的。 已复制import geoLocationManager from '@ohos.geoLocationManager'; 查询geoCoder服务是否可用。  调用isGeoServiceAvailable查询geoCoder服务是否可用，如果服务可用再继续进行步骤3。 已复制import geoLocationManager from '@ohos.geoLocationManager';try {    let isAvailable = geoLocationManager.isGeocoderAvailable();} catch (err) {    console.error("errCode:" + err.code + ",errMessage:" + err.message);}  获取转化结果。  调用getAddressesFromLocation，坐标转化地理位置信息。 已复制let reverseGeocodeRequest = {"latitude": 31.12, "longitude": 121.11, "maxItems": 1};try {    geoLocationManager.getAddressesFromLocation(reverseGeocodeRequest, (err, data) => {        if (err) {            console.log('getAddressesFromLocation err: ' + JSON.stringify(err));        } else {            console.log('getAddressesFromLocation data: ' + JSON.stringify(data));        }    });} catch (err) {    console.error("errCode:" + err.code + ",errMessage:" + err.message);} 参考接口API说明位置服务，应用可以获得与此坐标匹配的GeoAddress列表，应用可以根据实际使用需求，读取相应的参数数据。 调用getAddressesFromLocationName位置描述转化坐标。 已复制let geocodeRequest = {"description": "上海市浦东新区xx路xx号", "maxItems": 1};try {    geoLocationManager.getAddressesFromLocationName(geocodeRequest, (err, data) => {        if (err) {            console.log('getAddressesFromLocationName err: ' + JSON.stringify(err));        } else {            console.log('getAddressesFromLocationName data: ' + JSON.stringify(data));        }    });} catch (err) {    console.error("errCode:" + err.code + ",errMessage:" + err.message);} 参考接口API说明位置服务，应用可以获得与位置描述相匹配的GeoAddress列表，其中包含对应的坐标数据，请参考API使用。 如果需要查询的位置描述可能出现多地重名的请求，可以设置GeoCodeRequest，通过设置一个经纬度范围，以高效地获取期望的准确结果。     地理围栏开发指导   场景概述 地理围栏就是虚拟地理边界，当设备进入、离开某个特定地理区域时，可以接收自动通知和警告。 目前仅支持圆形围栏，并且依赖GNSS芯片的地理围栏功能。 应用场景举例：开发者可以使用地理围栏，在企业周围创建一个区域进行广告定位，在不同的地点，在移动设备上进行有针对性的促销优惠。   接口说明 地理围栏所使用的接口如下，详细说明参见：位置服务。 表4 地理围栏接口介绍     接口名 功能描述    on(type: 'gnssFenceStatusChange', request: GeofenceRequest, want: WantAgent): void; 添加一个围栏，并订阅地理围栏事件。   off(type: 'gnssFenceStatusChange', request: GeofenceRequest, want: WantAgent): void; 删除一个围栏，并取消订阅该围栏事件。      开发步骤  使用地理围栏功能，需要有权限ohos.permission.APPROXIMATELY_LOCATION，位置权限申请的方法和步骤见申请位置权限开发指导。 导入geoLocationManager模块和wantAgent模块。 已复制import geoLocationManager from '@ohos.geoLocationManager';import wantAgent from '@ohos.app.ability.wantAgent'; 创建WantAgentInfo信息。 场景一：创建拉起Ability的WantAgentInfo信息。 已复制let wantAgentObj = null; // 用于保存创建成功的wantAgent对象，后续使用其完成触发的动作。
// 通过WantAgentInfo的operationType设置动作类型let wantAgentInfo = {    wants: [        {            deviceId: '',            bundleName: 'com.example.myapplication',            abilityName: 'EntryAbility',            action: '',            entities: [],            uri: '',            parameters: {}        }    ],    operationType: wantAgent.OperationType.START_ABILITY,    requestCode: 0,    wantAgentFlags:[wantAgent.WantAgentFlags.CONSTANT_FLAG]}; 场景二：创建发布公共事件的WantAgentInfo信息。 已复制let wantAgentObj = null; // 用于保存创建成功的WantAgent对象，后续使用其完成触发的动作。
// 通过WantAgentInfo的operationType设置动作类型let wantAgentInfo = {    wants: [        {            action: 'event_name', // 设置事件名            parameters: {},        }    ],    operationType: wantAgent.OperationType.SEND_COMMON_EVENT,    requestCode: 0,    wantAgentFlags: [wantAgent.WantAgentFlags.CONSTANT_FLAG],} 调用getWantAgent()方法进行创建WantAgent。  并且在获取到WantAgent对象之后调用地理围栏接口添加围栏。 已复制// 创建WantAgentwantAgent.getWantAgent(wantAgentInfo, (err, data) => {    if (err) {      console.error('getWantAgent err=' + JSON.stringify(err));      return;    }    console.info('getWantAgent success');    wantAgentObj = data;    let requestInfo = {'priority': 0x201, 'scenario': 0x301, "geofence": {"latitude": 121, "longitude": 26, "radius": 100, "expiration": 10000}};    try {        geoLocationManager.on('gnssFenceStatusChange', requestInfo, wantAgentObj);    } catch (err) {        console.error("errCode:" + err.code + ",errMessage:" + err.message);    }});  当设备进入或者退出该围栏时，系统会自动触发WantAgent的动作。    上一篇 位置服务 下一篇 传感器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。DevEco低代码 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    简介  版本更新说明  开发准备  开发元服务  应用配置  自测试  应用发布  平台操作指导  常见问题   上一篇 业务介绍 下一篇 简介 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例音频组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 配合播放音频的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到音频组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将音频组件拖入到编辑区，即完成使用。选中编辑区音频组件，在右侧的页签对其属性和事件进行设置。  特有属性>播放类型设置为“常规模式”展示效果如下图。  特有属性>播放类型设置为“极简模式”展示效果如下图。  在编辑区选中音频组件后，可以在右侧的事件页签中对其进行定义。  特有属性 属性设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    播放器类型  string  否  常规模式  播放器的样式，目前支持常规模式和极简模式2种类型。   自动循环  boolean  否  否  设置是否自动循环播放。   播放链接  string  是  无  音频的播放地址，支持的音频格式(m4a、mp3、ogg、wav、acc、flac)，API6不支持http链接。   播放图标  string  否  无  音频播放时显示的图标http链接。   暂停图标  string  否  无  音频暂停时显示的图标http链接。   关闭图标  string  否  无  音频关闭时的图标http链接。   已播放时长  string  否  00:00  音频开始播放位置，格式为00:00。   总时长  string  否  00:00  音频文件的总时长，格式为00:00。   音频标题  string  是  音频标题内容  音频播放时显示的标题。   音频标题字体大小  number  否  16  设置音频标题字体大小，单位fp。   音频标题字体颜色  string | number | Color  否  #000000  设置音频标题字体颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   音频标题字体粗细  string | number  否  400  设置音频标题字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。   音频标题字体  string  否  HarmonyOS_Sans  设置音频标题字体。当前支持'HarmonyOS_Sans'字体和注册自定义字体。   时间字体大小  number  否  14  设置时间字体大小，单位fp。   时间字体颜色  string | number | Color  否  #000000  设置时间字体颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   时间字体粗细  string | number  否  400  设置时间字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。   时间字体  string  否  HarmonyOS_Sans  设置时间字体。当前支持'HarmonyOS_Sans'字体和注册自定义字体。   时间字体样式  FontStyle  否  正常  设置时间字体样式，包含默认、正常、斜体。   进度条颜色  string | number | Color  否  #007DFF  设置进度条颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。     事件 在编辑区选中音频组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件只支持以下特有事件： 事件类型  是否必选  描述    闲置状态  否  监听播放器的闲置状态（API6不支持）。   资源初始化  否  监听播放器的资源初始化（API6不支持）。   准备状态  否  监听播放器的已准备状态（API6不支持）。   正在播放状态  否  监听播放器的正在播放状态。   暂停状态  否  监听播放器的暂停状态。   播放至结尾状态  否  监听播放器播放至结尾状态。   停止状态  否  监听播放器的停止状态。   销毁状态  否  监听播放器的销毁状态（API6不支持）。   错误状态  否  监听播放器的错误状态，当播放引擎发生不可逆的错误，则会转换至当前状态（API6不支持）。   监听错误  否  监听播放器的错误信息。   资源时长更新  否  用于进度条，监听进度条长度，刷新资源时长（API6不支持）。   当前时间更新  否  用于进度条，监听进度条当前位置，刷新当前时间。   跳转完成  否  跳转到指定播放位置后，如果跳转操作成功，将上报该事件（API6不支持）。   倍速设置  否  设置播放倍速后，如果设置操作成功，将上报该事件（API6不支持）。   音量改变  否  调节播放音量后，如果音量操作成功，将上报该事件。   缓冲更新  否  用于网络播放，监听网络播放缓冲信息，用于上报缓冲百分比以及缓存播放进度（API6不支持）。   播放中断  否  监听音频焦点切换信息，如果当前设备存在多个音频正在播放，音频焦点被切换（即播放其他媒体如通话等）时将上报该事件（API6不支持）。   关闭按钮点击  否  界面右上角关闭按钮被点击，将上报该事件。     运行示例 导入真机的效果图：    上一篇 日历组件 下一篇 自定义组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。基础组件 更新时间: 2024-03-30 10:25 DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte
分享
     评分条组件  单选框组件  菜单组件  富文本组件  文本域组件  堆叠容器组件  弹性容器组件  列表组件  滚动容器  页签组件  横向容器  垂直容器  导航组件  文本组件  网页容器   上一篇 ForEach：循环渲染 下一篇 评分条组件 以上内容对您是否有帮助？DOC.startaDOC.startbDOC.startcDOC.startdDOC.starte意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。区块 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 区块为复数组件在一个容器下的集合体，可基于一定的业务规则组合组件来生成，属于页面内容的子集。区块可在应用中快速复用，达到快速搭建业务页面的效果。 生成区块模板选择应用，点击编辑应用，进入应用开发页面，点击编辑区右上角页面锁，解锁，获取编辑权限，在左侧组件中选择区块需要的官方组件或自定义组件。区块最外层是一个容器，可以选择横向，垂直，弹性容器等，然后在容器里面放置其它组件，根据右侧组件属性调整组件位置大小等。 区块设置完成后，鼠标右键点击最外层容器，选择创建区块，按要求输入区块名称，选择本地图片作为区块封面，点击确定，模板创建成功。 在组件 > 区块模板 > 自定义区块可以看到创建的区块模板。  使用区块选中创建的区块模板，将其拖入编辑区，调整位置即可。  当引入的区块模板所依赖的资源在当前项目中已存在，可以选择使用原有资源或者覆盖原有资源（设置变量请参考开发元服务 > 变量管理章节）。    上一篇 自定义组件 下一篇 事件方法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例日历组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 用于展示日历的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到日历组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将日历组件拖入到编辑区，即完成使用。选中编辑区日历组件，在右侧的页签对其属性和事件进行设置。  创建变量允许日期（设置好允许日期后，在允许日期范围外的日期，即为无效日期），案例如下：  创建变量日期详情，案例如下：  特有属性 属性设置需要用到变量，变量的使用方式可以参考变量管理章节。 字段标题  类型  是否必选  默认值  描述    唯一标识  string  否  无  关联用户点击的事件，可通过唯一标识找到对应的日历组件。   允许日期  array  否  无  绑定的类型为数组，数组中对象需要包含两个字段：startDate（string）和period（int），，表示用户在包括开始时间（startDate）的时间段（period）内，可选择的日期，period单位是天。样例格式： [{ "startDate": "2023-8-2", "period": 21 }]   选择日期  object  是  无  表示日历默认选中高亮的日期，样例格式： { "date": "2023-8-5" }   日期详情  array  否  无  绑定三个字段，startDate（string），period（int）和content（string），表示用户在包括开始时间（startDate）的时间段（period）内，可选择的日期及内容的详情信息。样例格式： [{ "startDate": "2023-8-1", "period": 6, "content": "你好" }]   日期格式  string  否  年-月-日  日期的展示格式，包含默认、年-月-日、月-日。   总字体大小  number  是  16  设置所有字体大小，单位fp。   总字体样式  FontStyle  是  正常  设置总字体样式，包含默认、正常、斜体。   总字体  string  是  HarmonyOS_Sans  设置总字体，当前支持'HarmonyOS_Sans'字体和注册自定义字体。   总字体颜色  string | number | Color  否  black  设置总字体的颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   总字体粗细  string | number  是  正常  设置总字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。   行高  number  否  22  设置日期行高，单位fp。   间距  number  否  0  设置日期间距，单位vp。   选择日期  string  否  当天  设置选择的日期。   选择日期背景色  string | number | Color  是  #0A59F7  设置选择日期背景的颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   选择日期字体大小  number  是  16  设置选择日期字体大小，单位fp。   选择日期字体样式  FontStyle  是  正常  设置选择日期字体样式，包含默认、正常、斜体。   选择日期字体颜色  string  是  write  设置选择日期字体的颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   选择日期字体粗细  string | number  是  正常  设置选择日期字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。   选择日期字体  string  是  HarmonyOS_Sans  设置日期字体，当前支持'HarmonyOS_Sans'字体和注册自定义字体。   无效日期字体大小  number  是  16  设置无效日期字体大小，单位fp。   无效日期字体样式  FontStyle  是  正常  设置无效日期字体样式，包含默认、正常、斜体。   无效日期字体颜色  string | number | Color  是  #888888  设置无效日期字体的颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   无效日期字体粗细  string | number  是  正常  设置无效日期字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。   无效日期字体  string  是  HarmonyOS_Sans  设置无效日期字体。当前支持'HarmonyOS_Sans'字体和注册自定义字体。     特有属性按照样例设置后展示效果如下图，另外在编辑区选中日历组件后，可以在右侧的事件页签中对其进行定义。  事件 在编辑区选中日历组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件只支持以下特有事件： 事件类型  是否必选  描述    变更  否  用于配置用户点击日历不同日期触发的事件。   上一月  否  用于配置用户点击日历的”<”的事件（默认组件已有将日历翻至上一页效果，无需额外配置）。   下一月  否  用于配置用户点击日历的”>”的事件（默认组件已有将日历翻至下一页效果，无需额外配置）。   左滑(不支持API6)  否  用于配置用户向左滑动日历的的事件   右滑(不支持API6)  否  用于配置用户向右滑动日历的的事件     创建变量允许日期（设置好允许日期后，在允许日期范围外的日期，即为无效日期），案例如下：  创建变量日期详情，案例如下：  运行示例 画布设置效果如下：  导入真机的效果图：   上一篇 登录组件 下一篇 音频组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例垂直容器 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 将组件进行沿垂直排列的容器。 使用说明用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到垂直容器组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将垂直容器组件拖入到编辑区，即完成使用。选中编辑区垂直容器，在右侧的页签对其属性和事件进行设置。   特有属性 字段标题  类型  是否必选  默认值  描述    间隔（不支持API6）  number | string  否  0  纵向布局元素垂直方向间距。 从API version 9开始，间隔为负数或者主轴对齐方式设置为两端对齐、平分、均分时不生效。 说明：可选值为大于等于0的数字，或者可以转换为数字的字符串。   主轴对齐方式  FlexAlign  是  起点对齐  设置子组件在垂直方向上的对齐格式。   交叉轴对齐方式  HorizontalAlign  是  居中对齐  设置子组件在水平方向上的对齐格式。      事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。事件方法设置可以参考事件方法章节。  运行示例 画布设置效果如下：  导入真机的效果图：   上一篇 横向容器 下一篇 导航组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     组件通用信息  基础组件  业务组件  自定义组件   上一篇 变量管理 下一篇 组件通用信息 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。组件通用信息 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     组件通用属性   上一篇 组件 下一篇 组件通用属性 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。组件通用属性 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     尺寸设置  布局约束  ForEach：循环渲染   上一篇 组件通用信息 下一篇 尺寸设置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。属性说明属性描述场景示例ForEach：循环渲染 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 用于循环展示一个或多个组件，可将一个数组类型的数据循环展示在页面中。如循环展示一个商品列表。 属性说明 参数名  类型  是否必选  默认值  说明    循环渲染(ForEach)  array  否  无  循环展示的源数据，须选择数组类型的变量。   键值生成器(keyGenerator)  (item: any, index?: number) => string  否  无  用于给数组中的每一个数据项生成唯一且固定的键值，需选择一个自定义方法，方法默认接收item和index参数。   item参数  string  否  item1  循环渲染数组中的item设置的参数名，item表示正在处理的当前对象。   index参数  string  否  idx1  循环渲染数组中的index设置的参数名，index表示正在处理的当前对象的索引。      属性描述循环渲染的功能位于属性面板下的渲染模块下。绑定该变量后如图变化所示，可设置循环的键值生成器、item参数、index参数。  同时在绑定了循环渲染节点的子节点选择变量时，会增加一个数据字段选项，可以选择到当前item和index。   场景示例以下示例将实现一个简易的商品列表，商品数据配置在数据模型中以模拟接口数据返回。 添加变量 goodsList 绑定数据模型。添加变量可参考新建变量。在画布搭建好列表的UI结构，设置好第一个列表项的样式布局。选中列表项元素，属性面板滑到下侧选择循环渲染，关联第一步配置的变量。此时对列表项的元素绑定变量时可从数据字段面板中选取循环item。在自定义代码中添加事件 buyGoods。选中购买按钮，切换到事件面板，添加点击事件并传入item值。查看真机效果，安装过程可参考自测试。     上一篇 布局约束 下一篇 基础组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。属性说明运行示例布局约束 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 布局约束是通过位置设置、宽高比设置和显示优先级约束组件显示效果，包含定位方式、横轴坐标、纵轴坐标、固定比例、显示优先级和对齐方式六种属性设置。 属性说明 参数名  类型  是否必选  默认值  描述    定位方式  文本  否  相对定位  定位方式有相对定位和绝对定位两种方式。相对定位表示组件相对组件生成时的偏移位置，绝对定位表示组件左上角相对父容器左上角顶点的偏移位置，定位方向均为横轴向右为正，纵轴向下为正。   横轴坐标  数字  否  无  横轴坐标表示组件在选定定位方式下具体横轴定位参数，有vp与%两种选择单位，支持直接输入、微调与绑定变量。   纵轴坐标  数字  否  无  纵轴坐标表示组件在选定定位方式下具体纵轴定位参数，有vp与%两种选择单位，支持直接输入、微调与绑定变量。   固定比例  数字  否  无  固定比例表示固定组件宽度对高度的比值，即设置组件宽高比，支持直接输入、微调与绑定变量。   显示优先级  数字  否  无  显示优先级表示组件在父容器下的显示优先顺序，当父容器空间不足时，低优先级的组件会被隐藏。支持直接输入、微调和绑定变量。   对齐方式(不支持API6)  文本  否  横向和纵向居中  对齐方式表示组件内容相对组件的呈现方式，包括默认、顶部起始端、顶部横向居中、顶部尾端、起始端纵向居中、横向和纵向居中、尾端纵向居中、底部起始端、底部横向居中、底部尾端十种方式，尚不支持API6。     图示在灰色背景垂直容器为父容器下，文本组件的绝对定位与相对定位设置的演示。  图示对文本文件进行横轴坐标与纵轴坐标调试演示。  图示对文本组件进行固定比例设置的演示。  图示在横向容器下，对子组件显示优先级设置的演示，图中从左到右依次是评分组件、文本域组件、单选框组件、评分条组件，因容器显示空间不足，只能显示3个组件，因此容器根据子组件的显示优先级进行显示调整。  图示对按钮组件进行对齐方式设置的演示。  横轴坐标、纵轴坐标、固定比例和显示优先级四种属性设置均可与变量绑定进行属性控制，通过绑定链接>选择变量>自定义变量/页面参数>选择变量名步骤顺序完成变量绑定。添加变量可参考新建变量，图示变量绑定过程。  运行示例 以下示例实现对文本组件的简单布局约束设置。  以下为真机效果，安装过程可参考自测试。   上一篇 尺寸设置 下一篇 ForEach：循环渲染 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。属性说明运行示例尺寸设置 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 用于设置组件的宽高及宽高限制。 属性说明 属性单位可选择vp或%，选择%时，该组件大小根据其父组件进行计算。属性值支持微调。组件的最小宽度、最大宽度、最小高度、最大高度设置可限制组件实际尺寸，避免组件显示异常。参数设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 参数名  类型  是否必选  默认值  描述    宽  数字  否  组件自身内容需要的宽度  设置组件的宽度。 单位设置为“vp”时，若子组件的宽大于父组件的宽，则会画出父组件的范围。 单位设置为“%”时，最大值为“100%”，不会画出父组件范围。   高  数字  否  组件自身内容需要的高度  设置组件的高度。 单位设置为“vp”时，若子组件的高大于父组件的高，则会画出父组件的范围。 单位设置为“%”时，最大值为“100%”，不会画出父组件范围。   最小宽度  数字  否  0  设置组件的最小宽度，优先级高于宽和最大宽度。   最大宽度  数字  否  无限  设置组件的最大宽度，优先级高于宽。   最小高度  数字  否  0  设置组件的最小高度，优先级高于高和最大高度。   最大高度  数字  否  无限  设置组件的最大高度，优先级高于高。     运行示例 以下示例将垂直容器宽设置为固定150vp，高设置为父组件的50%且最小高度为200vp。  以下为真机效果   上一篇 组件通用属性 下一篇 布局约束 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。调试证书生成密钥和证书请求文件证书私钥指纹申请调试证书注册调试设备申请调试Profile文件配置签名信息发布证书生成密钥和证书请求文件申请发布证书申请Profile文件配置签名信息证书配置 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 为了确保元服务的完整性，HarmonyOS通过数字证书和Profile文件对元服务进行管控，只有签名后的元服务才能安装到真机上运行。 签名过程中涉及到如下基本概念： 密钥：包含非对称加密中使用的公钥和私钥，存储在密钥库文件中，格式为.p12，公钥和私钥对用于数字签名和验证。证书请求文件：格式为.csr，全称为Certificate Signing Request，包含密钥对中的公钥和公共名称、组织名称、组织单位等信息，用于向AppGallery Connect申请数字证书。数字证书：格式为.cer，由AppGallery Connect颁发。Profile文件：格式为.p7b，包含元服务的包名、数字证书信息、描述元服务允许申请的证书权限列表，以及允许元服务调试的设备列表（如果元服务类型为Release类型，则设备列表为空）等内容，每个元服务包中均必须包含一个Profile文件。 调试证书 生成密钥和证书请求文件选择应用点击编辑应用进入应用开发页面，通过侧边导航栏选择设置 > 配置私钥。 点击新增，在弹出的新增私钥界面填写密钥信息，填写后选择确定提交。 参数  说明    name  姓名，支持字母和空格，长度不超过64个字符。   keyName  私钥名称，支持字母和下划线，长度不超过64个字符。   organizationalUnit  组织单位，支持字母，长度不超过64个字符。   organization  组织，支持字母，长度不超过64个字符。   cityOrLocality  城市，支持字母，长度不超过64个字符。   stateOrProvince  省份，支持字母，长度不超过64个字符。   countryCode  国家码，支持数字及字母，长度不超过64个字符。      私钥生成完成后，可点击下载文件列获取对应私钥对应的证书请求文件（.csr），可用于后续步骤申请证书使用。   证书私钥指纹在调试阶段，使用AppGallery Connect的服务能力需要配置签名证书指纹，其中需要的指纹值可以在配置私钥页面的私钥列表中，点击对应私钥的指纹按钮，从展示的弹框面板中获取。   申请调试证书登录AppGallery Connect，选择用户与访问。左侧导航栏选择证书管理，进入证书管理页面，点击新增证书。  在弹出新增证书界面填写相关信息后，点击提交。 参数  说明    证书名称  不超过100个字符。   证书类型  选择“调试证书”。   上传证书请求文件（CSR）  上传生成密钥和证书请求文件时获取的.csr文件。      证书申请成功后，证书管理页面展示生成的证书内容。点击下载将生成的证书保存至本地。每个帐号最多申请2个调试证书，如果证书已过期或者不再使用，点击废除即可删除证书。    注册调试设备登录AppGallery Connect，选择用户与访问。左侧导航栏选择设备管理，进入设备管理页面。点击添加设备，参考下表填写设备信息，单个添加设备。点击批量添加设备，下载模板，参考下表填写多条设备信息，上传文件，批量添加设备。 参数  说明    名称  不超过100个字符。   类型  选择需要调试设备的类型。   UDID  设备唯一标识符，是由字母和数字组成的64位字符串。您可在对应的调试设备上获取UDID。     
说明
手机获取UDID方式： 打开设置 > 关于手机，多次点击版本号，打开开发者模式。打开设置 > 系统和更新，在最下方找到开发人员选项，打开USB调试开关。使用PC连接手机后，打开命令行工具，进入HDC目录（一般为：HarmonyOS SDK安装目录/hmscore/{版本号}/toolchains，建议配到环境变量中），输入hdc shell bm get --udid命令，获取设备的UDID。  
 设备注册成功，即可在设备管理页面查看到设备信息。   申请调试Profile文件登录AppGallery Connect，选择我的项目。找到对应项目，点击项目卡片中需要调试的元服务。导航选择HarmonyOS应用 > HAP Provision Profile管理，进入管理HAP Provision Profile页面，点击“添加”。 在HarmonyAppProvision信息界面填写相关信息，点击提交。 参数  说明    名称  不超过100个字符。   类型  选择“调试”。   选择证书  选择申请的调试证书。   选择设备  选择注册的调试设备。   申请受限权限  若软件包因特殊场景要求使用受限权限，如读取、 添加、移除或更改联系人数据等，务必在此处进行申请，否则元服务将无法在调试设备上安装调试。     申请成功，即可在管理HAP Provision Profile页面查看Profile信息。点击下载，将文件下载到本地。   配置签名信息选择应用点击编辑应用进入低代码应用开发页面，通过侧边导航栏选择设置>应用签名，进入签名配置页面。在debug页签中通过下拉框可选择前面步骤所生成的私钥、证书、Profile，通过保存按钮完成配置。配置完成后，在执行调试版应用包的编译生成时，将会使用配置的证书为应用包完成签名。   发布证书 生成密钥和证书请求文件选择应用点击编辑应用进入应用开发页面，通过侧边导航栏选择设置 > 配置私钥。点击新增，在弹出的新增私钥界面填写密钥信息，填写后选择确定提交。 参数  说明    name  姓名，支持字母和空格，长度不超过64个字符。   keyName  私钥名称，支持字母和下划线，长度不超过64个字符。   organizationalUnit  组织单位，支持字母，长度不超过64个字符。   organization  组织，支持字母，长度不超过64个字符。   cityOrLocality  城市，支持字母，长度不超过64个字符。   stateOrProvince  省份，支持字母，长度不超过64个字符。   countryCode  国家码，支持数字及字母，长度不超过64个字符。     私钥生成完成后，可点击下载文件列获取对应私钥对应的证书请求文件（.csr），用于后续步骤申请证书使用。   申请发布证书登录AppGallery Connect，选择用户与访问。左侧导航栏选择证书管理，进入证书管理页面，点击新增证书。 在弹出新增证书界面填写相关信息后，点击提交。 参数  说明    证书名称  不超过100个字符。   证书类型  选择“发布证书”。   上传证书请求文件（CSR）  上传生成密钥和证书请求文件时获取的.csr文件。      证书申请成功后，证书管理页面展示生成的证书内容。点击下载可将生成的证书下载至本地保存。如果证书已过期或者无需使用，点击废除即可删除证书。    申请Profile文件登录AppGallery Connect，选择我的项目。找到对应项目，点击项目卡片中需要发布的元服务。导航选择HarmonyOS应用 > HAP Provision Profile管理，进入管理HAP Provision Profile页面，点击添加。 在HarmonyAppProvision信息界面填写相关信息，点击提交。 参数  说明    名称  不超过100个字符。   类型  选择“发布”。   选择证书  选择发布证书。   申请受限权限  若软件包因特殊场景要求使用受限权限，如读取、 添加、移除或更改联系人数据等，务必在此处进行申请，否则元服务将无法上架应用市场。     申请成功，即可在管理HAP Provision Profile页面查看Profile信息。点击下载，可将文件下载到本地保存。   配置签名信息选择应用点击编辑应用进入应用开发页面，通过侧边导航栏选择设置 > 应用签名。在release页签中通过下拉框可选择前面步骤所生成的私钥、证书、Profile，通过保存按钮完成配置。配置完成后，在执行发布/上架时，将会使用配置的证书为应用包完成签名。     上一篇 应用配置 下一篇 图标配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用配置 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    证书配置  图标配置  访问控制   上一篇 服务卡片开发 下一篇 证书配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。图标配置 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 图标配置对图标的要求如下： 快照：图标需为正方形，尺寸要求600*600px，格式为.png，大小在1M以内。图标：图标需为正方形，尺寸要求512*512px，格式为.png，大小在1M以内。 选择应用点击编辑应用进入低代码应用开发页面，通过侧边导航栏选择设置 > 图标配置。点击对应图标，选择本地图标进行上传，点击“确定”按钮即可完成图标配置。 
说明
图标和快照作为元服务的基础信息应能准确反映服务提供方的特征及服务的核心体验，相关设计原则可详阅元服务设计。 
   上一篇 证书配置 下一篇 访问控制 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。访问控制 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 为了提升应用模板的使用体验，应用支持按登录状态过滤数据。 访问控制登录状态如下： 应用内数据无需登录访问：用户默认访问权限：应用关联的角色。 应用内数据需要登录访问：登录前用户访问权限：应用关联的角色。登录后用户访问权限：应用关联的角色。  前提：角色需要关联应用才可以在应用内访问控制绑定。  角色关联应用 1.登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。 2.找到对应的项目，进入低代码平台页面。 3.选择低代码平台 > 用户权限 > 角色与权限，进入“角色与权限”页面。 4.在列表中选择您要关联的角色，点击编辑，进入到角色编辑页面。 5.在“已关联应用”一栏中增加/删除应用，点击保存即可。  应用绑定角色 1.选择应用点击编辑应用进入低代码应用开发页面，通过侧边导航栏选择设置 > 访问控制。 2.点击您要选择的登录状态，选择关联的角色，点击保存即可完成访问控制配置（角色维护请参考角色与权限章节）。 设置用户默认访问权限后，该角色无需登录即可访问应用内数据。  应用内数据需登录才能访问设置登录前用户访问权限后，用户登录前将使用该角色来进行数据权限控制。 设置登录后用户访问权限后，用户登录后将使用该角色来进行数据权限控制。    上一篇 图标配置 下一篇 自测试 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发自定义组件使用自定义组件维护自定义组件自定义组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 为了增加组件的丰富性和拓展性，DevEco低代码支持用户针对所需，可进行组件的个性化定制，并在开发页面中进行使用，大大提高平台的灵活行与可用性。 开发自定义组件选择应用，通过点击“编辑应用“进入DevEco低代码应用开发页面，选择页面树 > 自定义组件，点击新建组件库或新建组件。 新建后的组件库和自定义组件在其对应下方展示，可以对其进行编辑，删除的操作，组件库的编辑中可修改名称和描述，组件的编辑中可修改名称、描述和图标。 选中对应的组件后，可以将组件库区域栏中的组件拖拽到编辑区，并在页面右侧的区域，对其中的组件进行属性的定义。图示中新增一个操作列表项的自定义组件，加入了三个官方组件构成了一个自定义组件，当编辑完自定义组件，切换到页面树的页面即可在当前页面使用刚创建的自定义组件。在创建自定义组件中创建的变量将作用自定义组件的属性值，同样创建的自定义方法将作用自定义组件的事件   使用自定义组件在DevEco低代码页面中，选择页面树>页面区域中，选中需要操作的页面后，可以在组件库>自定义组件区域中展示创建好的自定义组件，通过拖拽的方式可以将其应用到相应的页面。  对于自定义组件事件的使用，首先需要在创建自定义组件时，创建自定义方法，并勾选自定义事件。 然后要在自定义组件中使用创建的自定义方法，如下图通过绑定点击事件触发自定义方法。 最后就可以使用组件的自定义方法了。如图所示此自定义组件的自定义方法“event”将在组件中“<”受到点击时触发。  维护自定义组件创建的自定义组件将统一维护到组件库中，您可以导出组件供其他项目使用，也可以复制一个已有组件，在此基础上进行定制，生成新的自定义组件。 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择组件库，进入组件库页面。点击待导出组件所在行的导出，或者勾选需要导出的组件，点击导出。导出的文件可在其他项目中导入，也可以再次导出，用于定制开发新组件。 点击导入。 选择组件文件，点击确定。 新创建一个与导入组件同名的组件。 导航选择应用管理，点击待开发应用的编辑应用，进入应用开发界面。在页面树下自定义组件页签下，可以看到新加的组件。 对组件进行改名和二次定制开发后，在应用开发时使用。   上一篇 音频组件 下一篇 区块 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。代码编辑器界面介绍新建/修改/删除自定义方法使用自定义方法自定义方法 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在使用可视化编辑器进行拖拽式开发后，开发者可以根据业务需求使用代码编辑器自定义代码，从而完善元服务的逻辑丰富度和复杂度。DevEco低代码支持开发者通过自定义函数扩展业务逻辑，通过编码或复用部分现有代码，支持相对复杂的元服务开发。 代码编辑器界面介绍在设计页面时打开代码编辑器，可以自定义页面方法；在设计自定义组件时打开代码编辑器，可以自定义组件方法。在设计服务卡片（API9）时打开代码编辑器，可以自定义卡片方法。代码编辑器界面如下图所示：   编辑区，编辑代码的区域，可以通过顶部标签切换编辑不同方法，点击保存按钮保存方法。根据所选用API版本（API6、API9）和页面形态（页面、卡片）的不同，应用打包时会使用不同编辑区的代码。API6编辑区，基于JavaScript语言，开发者选用API6版本时，应用会使用API6编辑区中的代码。API9编辑区，基于ArkTs语言，开发者选用API9版本时，应用会使用API9编辑区的代码。当设计服务卡片（API9）时打开代码编辑器，只支持编辑API9代码。页面代码模块，可进行全局方法和页面方法的选择、新增、删除、重命名。其中全局目录是全局自定义方法管理，下方是每个页面的资源管理，全局、每个页面都包含一个生命周期lifecycle，可在handler下可创建一个或多个自定义方法。全局lifecycle： 表1 全局lifecycle的API6方法方法  说明    onCreate  当应用创建时调用。   onDestroy  当应用退出时触发。     表2 全局lifecycle的API9方法方法  说明    onCreate  在应用加载过程中，ability实例创建完成时触发。   onDestroy  在ability实例销毁时触发。   onWindowStageDestroy  在ability实例销毁之前，window stage被销毁后的回调函数。   onForeground  ability状态变成前台时的回调函数。   onBackground  ability状态变成后台时的回调函数。     页面lifecycle： 表3 页面lifecycle的API6方法API6方法  说明    onInit  页面数据初始化完成时触发，只触发一次。   onReady  页面创建完成时触发，只触发一次。   onShow  页面显示时触发。   onHide  页面消失时触发。   onDestroy  页面销毁时触发。     表4 页面lifecycle的API9方法API9方法  说明    onPageShow  页面每次显示时触发一次，包括路由过程、应用进入前后台等场景，仅@Entry修饰的自定义组件生效。   onPageHide  页面每次隐藏时触发一次，包括路由过程、应用进入前后台等场景，仅@Entry修饰的自定义组件生效。   onBackPress  当用户点击返回按钮时触发，仅@Entry修饰的自定义组件生效。   aboutToAppear  aboutToAppear函数在创建自定义组件的新实例后，在执行其build函数之前执行。   aboutToDisappear  aboutToDisappear函数在自定义组件析构销毁之前执行。      组件代码模块，可进行组件方法的选择、新增、删除、重命名，每个自定义组件都包含一个生命周期lifecycle，可创建多个handler。组件lifecycle方法同上表页面lifecycle方法。卡片代码模块，可进行卡片方法的选择、新增、删除、重命名，一个应用只有一个卡片生命周期lifecycle，每个卡片都可创建多个handler。卡片lifecycle包含以下方法： 表5 卡片lifecycle方法方法  说明    onAddForm  使用方创建卡片时触发，提供方需要返回卡片数据绑定类。   onCastToNormalForm  使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理。   onUpdateForm  若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要重写该方法以支持数据更新。   onChangeFormVisibility  需要配置formVisibleNotify为true，且为系统应用才会回调。   onFormEvent  若卡片支持触发事件，则需要重写该方法并实现对事件的触发。   onRemoveForm  当对应的卡片删除时触发的回调，入参是被删除的卡片ID。   onAcquireFormState  卡片提供方接收查询卡片状态通知接口，默认返回卡片初始状态。      新建/修改/删除自定义方法DevEco低代码自定义方法包含生命周期lifecycle方法和普通handler方法。 
说明
一个元服务有一个全局的生命周期方法，元服务下每个页面有一个生命周期方法，元服务的生命周期方法在创建元服务时默认生成，页面的生命周期方法在创建页面时默认生成，生命周期方法可以编辑，但是不能删除和修改方法名。 
 选择应用点击编辑应用进入应用开发页面，点击代码编辑器。 在弹出的代码编辑器面板中点击页面或全局下的handler右侧的+按钮，在弹出的新建代码中填入方法名和方法描述，点击保存，新建完成。 参数  是否必填  说明    方法名  是  字母、数字和下划线，不能以数字开头，长度不超过20个字符，方法名不能重复。   方法描述  否  方法描述。      新建的方法会生成方法对应API 6/API 9的默认代码，点击对应方法可以显示对应API 6/API 9方法编辑器，如图所示。 用户可以在编辑器修改自定义方法内容，点击保存即可。 在自定义方法内可以引用页面变量 用户可以通过自定义方法后面的按钮修改方法名称和描述，点击保存即可。 用户可以通过点击自定义方法右侧的删除按钮，删除自定义方法，点击确认即可删除。   使用自定义方法在使用可视化编辑器进行拖拽式开发后，可以根据业务需要绑定自定义方法，从而实现更为复杂的业务逻辑。 以button按钮为例，介绍使用自定义方法的操作步骤。 选中要绑定自定义方法的按钮，右侧切换到事件栏，根据事件类型点击对应事件右侧的编辑。 在弹出的执行动作面板中，选择自定义代码。 在使用方法面板中，执行动作的下拉选项中选择要使用的自定义方法，选中之后会出现此自定义方法的入参和出参，入参可以绑定常量值，也可以绑定变量，出参只能绑定变量。 点击保存，绑定完成，后续元服务运行时点击按钮就会执行此自定义方法。   上一篇 变量赋值 下一篇 方法链式调用 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发元服务 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    开发界面介绍  变量管理  组件  区块  事件方法  图片素材库  服务卡片开发   上一篇 开发准备 下一篇 开发界面介绍 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。填写应用信息填写版本信息应用信息填写 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 填写应用信息登录 AppGallery Connect，点击我的应用。选择HarmonyOS应用页签，在应用列表中可以通过一些条件快速筛选待操作的应用，点击待发布的元服务。 在应用信息页签的基本信息区域，您可以配置元服务支持的设备信息，元服务默认发布到手机。 在可本地化基础信息区域，配置元服务发布后向用户呈现的信息。 根据元服务提供的功能和内容，在应用分类区域选择元服务服务归属的类别。填写完成点击保存后，点击下一步，开始配置版本信息。  填写版本信息进入版本信息界面，是否开放式测试版本根据当前需要发布的版本是否是开放性测试版本来选择。在内容分级区域，点击设置，按实际情况填写调查问卷，填写完成将获取当前元服务的年龄分级结果。在隐私声明区域提供隐私声明链接。隐私政策网址：该网站将供用户访问，从而了解服务是如何处理敏感的用户数据和设备数据。隐私权利：提供用户实施其权利的相关网站，例如：删除、修改、导出个人数据的入口。 在版权信息区域上传发布元服务所需的资质材料。点击承诺函链接，仔细阅读承诺书后，勾选我已阅读并同意《承诺函》。电子版权证书：可选。应用版权证书或者代理证书：可选。  （可选）如果元服务类别为游戏，则要求在版号区域上传游戏版本信息。具体要求参见游戏版权、版号要求。版号信息：提供向相关单位申请的游戏版号。版号证明：上传版号批文和版号授权书。  配置上架时间。审核通过立即上架：版本审核通过后，即全网用户都可以使用此版本。指定时间：版本审核通过后，到达您指定的时间，全网用户才可以使用此版本。    上一篇 应用发布 下一篇 应用推送发布 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。事件方法 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     页面交互方法  变量赋值  自定义方法  方法链式调用   上一篇 区块 下一篇 页面交互方法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例弹性容器组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 根据容器大小调整子组件排列情况的弹性方式布局子组件的容器组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中看到弹性容器组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将弹性容器组件拖入到编辑区，即完成使用。选中编辑区弹性容器，在右侧的页签对其属性进行设置。  弹性容器基础布局展示如下： 
说明
弹性容器属性里面的内容对齐方式只能在多行(换行)的情况下才有使用效果。 
 1.为了清晰演示特有属性的设置，进行元素换行和不换行两种设置下的演示，首先是不换行设置如下：  2.换行设置如下：  特有属性 字段标题  类型  是否必选  默认值  描述    主轴方向  FlexDirection  否  横向排列  设置子组件在容器内的排列方向。   元素换行  FlexWrap  否  不换行  Flex容器是单行/列还是多行/列排列。 说明：在多行布局时，通过交叉轴方向，确认新行堆叠方向。   内容对齐方式  FlexAlign  否  起点对齐  交叉轴中有额外的空间时，子组件多行内容的对齐方式。仅在元素换行为换行或反向换行下生效。   主轴对齐方式  FlexAlign  否  起点点对齐  所有子组件在容器主轴上的对齐格式。   交叉轴对齐方式  ItemAlign  否  起点对齐  所有子组件在Flex容器交叉轴上的对齐格式。     弹性容器组件使用特殊场景： 1.弹性容器组件内部嵌套多个容器组件，可如下图进行设置。  2.当弹性容器里面嵌套弹性容器的情况下，导致容器与容器重叠，此时要选中想要的弹性容器，可以点击左下角组件树的结构，点击结构右边对应的小眼睛隐藏不想选中的组件，然后再进行操作。  事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。事件方法设置可以参考事件方法章节。  运行示例  导入真机的效果图：    上一篇 堆叠容器组件 下一篇 列表组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。低代码工程创建低代码开发界面介绍开发界面介绍 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 低代码工程创建用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码进行应用创建，低码工程的初始化会随应用创建完成。  低代码开发界面介绍低代码开发界面如下图所示：    导航栏，可导航跳转至编辑器、应用管理、数据模型、连接器、素材、设置等页面。编辑器：对应图标，用于编辑页面、卡片内容。应用管理：对应图标，用于搜索您要发布的应用名称，点击卡片上的“编辑应用”（或点击应用名称），进入应用详情页。数据模型：对应图标、用于自定义数据模型，实现自定义数据逻辑或联通外部数据。连接器：对应图标，用于链接外部数据源与外部应用能力。素材：对应图标、在素材库中进行素材的上传和管理，并在应用开发页面中引用素材作为静态资源。设置：对应图标，用于配置私钥、应用签名、图标配置相关操作。 页面树，可进行页面的选择、新增、删除、重命名，也可新增文件夹用于对页面的管理。变量管理及代码编辑器面板入口，分别用于应用的变量创建以及自定义代码的编辑。功能面板，包括常用的撤销、恢复、显示/隐藏组件虚拟边框、横竖屏切换、媒体查询以及代码转换查看等。画布，开发者可在此区域对组件进行拖拽、拉伸等可视化操作，构建UI界面布局效果。编译发布功能，可将开发的元服务进行调试版编译或发布及发布前的检查。属性事件栏，选中画布中的相应组件后，在右侧属性栏可以对该组件的属性样式进行配置，切换事件栏则可以对该组件的事件进行绑定。包括：尺寸：用于设置组件宽、高及相应最大、最小值相关样式。边距：用于设置组件的内、外边距相关样式。背景：用于设置组件的背景颜色、背景图片路径、重复方式、尺寸、位置等常规样式。边框：用于设置组件的边框宽度、样式、颜色、角半径等常规样式。布局：用于设置组件的定位方式、纵横轴坐标、固定比例、显示优先级、对齐方式等相关样式。效果：用于设置组件的不透明度、显隐、是否可交互等相关样式。渲染：用于设置组件的循环渲染、条件渲染相关样式。 UI控件栏，可以将相应的组件选中并拖动到画布中，实现控件的添加。组件树，在低代码开发界面中，开发者可以直观地看到组件的层级结构、摘要信息以及错误提示。开发者可以通过选中组件树中的组件（画布中对应的组件被同步选中），实现画布内组件的快速定位；单击组件后的或图标，可以隐藏/显示相应的组件。页面锁，在初次进入页面开发时，开发者无法对页面进行编辑操作，需要先点击此按钮进行解锁以获取页面编辑权限，而当页面已被其他用户解锁编辑时则会提示正在被其他用户使用，无法解锁。另外，在解锁时会比对当前页面内容是否为最新数据，若不是则会提示进行页面刷新操作以避免修改覆盖问题。   上一篇 开发元服务 下一篇 变量管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件列表项组件使用说明列表项特有属性列表项组件事件运行示例列表组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 列表组件包含一系列相同宽度的列表项，适合连续、多行呈现同类数据，例如图片和文本。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件库>官方组件中可看到列表组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将列表组件拖入到编辑区，即完成使用。选中编辑区列表组件，在右侧的页签对其属性和事件进行设置。  
说明
1.列表组件只能包含列表项组件，并不能独立使用。 2.该组件回弹的前提是要有滚动。内容小于一屏时，没有回弹效果。 3.子组件的索引值计算规则是按子组件的顺序依次递增。 4.子组件的显隐属性设置为隐藏依然会计算索引值。 
 特有属性 字段标题  类型  是否必选  默认值  描述    起始索引值  number  否  0  设置列表组件初次加载时视口起始位置显示的item的索引值。 说明： 设置为除-1外其他负数或超过了当前组件最后一个item的索引值时视为无效取值，无效取值按默认值显示。   间隔(不支持API6)  number | string  否  0  子组件主轴方向的间隔。 说明： 设置为除-1外其他负数或百分比时，按默认值显示。 间隔参数值小于列表分割线宽度时，子组件主轴方向的间隔取分割线宽度。   排列方向(不支持API6)  Axis  否  垂直排列  设置列表组件排列方向。 从API version 9开始，该接口支持在ArkTS卡片中使用。   颜色(不支持API6)  number | string | Color  否  black  分割线的颜色。   进度条宽度(不支持API6)  number | string  否  无分割线  分割线的线宽。   起始边距(不支持API6)  number | string  否  无分割线  分割线与列表侧边起始端的距离。   结束边距(不支持API6)  number | string  否  无分割线  分割线与列表侧边结束端的距离。   是否可编辑(不支持API6)  boolean  否  否  声明当前列表组件是否处于可编辑模式。从API version9开始废弃。   滑动效果(不支持API6)  EdgeEffect  否  弹性  设置组件的滑动效果。 从API version 9开始支持在ArkTS卡片中使用。   是否启用链式联动(不支持API6)  boolean  否  否  设置当前列表是否启用链式联动动效，开启后列表滑动以及顶部和底部拖拽时会有链式联动的效果。 链式联动效果：列表内的list-item间隔一定距离，在基本的滑动交互行为下，主动对象驱动从动对象进行联动，驱动效果遵循弹簧物理动效。 - 否：不启用链式联动。 - 是：启用链式联动。 从API version 9开始支持在ArkTS卡片中使用。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件方法设置可以参考事件方法章节。组件支持以下特有事件。 事件类型  是否必选  描述    子项删除  否  当列表组件在编辑模式时，点击列表项组件右边出现的删除按钮时触发。   索引滑动  否  列表滑动时触发。 触发该事件的条件：列表初始化时会触发一次，列表组件显示区域内第一个子组件的索引值或后一个子组件的索引值有变化时会触发。 列表的边缘效果为弹簧效果时，在列表划动到边缘继续划动和松手回弹过程不会触发索引滑动事件。 从API version 9开始，该接口支持在ArkTS卡片中使用。   子项拖拽进入  否  拖拽进入列表元素范围内时触发。   子项拖拽移动  否  拖拽在列表元素范围内移动时触发。   子项拖拽离开  否  拖拽离开列表元素时触发。   子项开始拖拽  否  开始拖拽列表元素时触发。   子项停止拖拽  否  绑定该事件的列表元素可作为拖拽释放目标，当在列表元素内停止拖拽时触发。     列表项组件使用说明 在组件库>官方组件中可看到列表项组件，将其拖入到列表组件中使用。在编辑区选中列表项组件后，在右侧的页签对其属性和事件进行设置。 
说明
列表项用来展示列表具体内容，父组件必须是列表组件，可以包含单个子组件。 
  列表项特有属性 属性设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    吸顶效果(不支持API6)  Sticky  是  无  设置列表项吸顶效果。   是否可编辑(不支持API6)  boolean |  是  否  当前列表项元素是否可编辑，进入编辑模式后可删除或移动列表项。 从API version9开始废弃。     列表项组件事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  运行示例画布设置效果如下：  导入真机的效果图：    上一篇 弹性容器组件 下一篇 滚动容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例登录组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 帮助业务实现登录功能的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到登录组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将登录组件拖入到编辑区，即完成使用。选中编辑区登录组件，在右侧的页签对其属性和事件进行设置。  在编辑区选中登录组件后，在右侧的事件根据场景对所需触发的时机进行事件绑定，通过点击对应事件栏的+进行绑定，并选择登录认证（登录认证可以被任意组件使用）。 
说明
在项目开通认证服务后，才可使用登录组件的功能。 在调试阶段的登录能力使用，需要用户在项目中配置证书指纹，可参见证书私钥指纹章节。 
   登录认证支持获取用户信息与登出两种执行动作。  参数  是否必填  说明    执行动作  是  支持2种执行动作：”获取用户信息”，”登出”。   保存为  否  方法调用的相应参数，变量使用方式可以参考”变量管理”章节。   成功回调方法  否  方法成功调用触发的回调，具体方法定义参考”自定义方法”章节。   失败回调方法  否  方法成功调用触发的回调，具体方法定义参考”自定义方法”章节。   请求超时时间  否  请求超时时间。     特有属性 属性设置需要用到变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    样式  number  是  胶囊型按钮  按钮的形状，目前支持三种形状： 普通按钮胶囊型按钮圆形按钮   按压态  boolean  是  是  是否开启点击效果。   文本  string  是  登录  按钮的文本值。   华为帐号登录  boolean  是  是  是否使用华为帐号登录。   手机验证码登录  boolean  是  是  是否使用手机验证码登录。   登录页Logo  string  否  无  登录页的图案。   启动用户协议  boolean  是  是  是否启用用户协议。   登录协议内容  string  否  无  协议内容。     事件在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件除支持以下特有事件：  参数  是否必填  说明    成功回调方法  否  方法成功调用触发的回调，具体方法定义参考”自定义方法”章节。   失败回调方法  否  方法成功调用触发的回调，具体方法定义参考”自定义方法”章节。     运行示例 画布设置效果如下：  真机模拟如下：    上一篇 支付组件 下一篇 日历组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件菜单项组件使用说明菜单项特有属性菜单项组件事件运行示例菜单组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 以垂直列表形式显示的菜单的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到菜单组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将菜单组件拖入到编辑区，即完成使用。选中编辑区菜单，在右侧的页签对其属性进行设置。 
说明
菜单组件子组件只能是菜单项组件。 
  特有属性 属性设置需要用到变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    字体大小  number  否  无  统一设置菜单组件中所有文本的尺寸，使用fp单位。     事件 菜单组件不具有事件。 菜单项组件使用说明 在组件库>官方组件中可看到菜单项组件，将其拖入到菜单组件中使用。在编辑区选中菜单项组件后，在右侧的页签对其属性和事件进行设置。  拖入其他组件，在属性栏-绑定菜单选中对应弹出的菜单组件即绑定成功。 
说明
菜单组件需要和其他组件的绑定菜单属性设置配合使用，不支持作为普通组件单独使用。 
  页面拖入多个菜单组件。 
说明
1.菜单组件并不是独立存在的组件，在画布上的效果为悬浮显示，页面拖入多个菜单组件时，会悬浮重叠显示。可以在左侧组件树选择显示/隐藏的菜单组件。 2.菜单项组件支持在菜单组件中上下拖动。 
  菜单项特有属性 属性设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    文本内容  string  是  MenuItem  item的内容信息。   结束标签（不支持API6）  string  否  无  定义结束标签信息，如快捷方式Ctrl+C等。   左侧图标  string  否  无  item中显示在左侧的图标信息路径。   右侧图标（不支持API6）  string  否  无  item中显示在右侧的图标信息路径。   是否选中  boolean  否  无  设置菜单项是否选中。   选中图标（不支持API6）  boolean  否  无  当菜单项被选中时，是否显示被选中的图标。     菜单项组件事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可参考自定义方法章节，组件仅支持以下特有事件： 事件类型  是否必选  描述    状态改变  否  当选中状态发生变化时，触发该回调。     运行示例画布设置效果如下：   导入真机的效果图：   上一篇 单选框组件 下一篇 富文本组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。方法链式调用 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 在绑定事件方法的时候，接受方法成功、失败回调，同时该成功和失败的回调也支持继续绑定成功、失败回调，实现链式调用。 1.添加事件  2.选择其他方法  3.变更绑定的方法  3.方法之间的关系   上一篇 自定义方法 下一篇 图片素材库 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例导航组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 一般作为Page页面的根容器，通过属性设置来展示页面的标题栏、工具栏、导航栏等。 使用说明用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件库>官方组件中可看到导航组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将导航组件拖入到编辑区，即完成使用。选中编辑区导航组件，在右侧的页签对其属性和事件进行设置。   特有属性属性设置可填写常量值或绑定变量，变量的使用方式请参考变量管理。  字段标题  类型  是否必选  默认值  描述    标题  string  否  无  页面标题。   子标题  string  否  无  页面副标题。   菜单  object  否  无  页面右上角菜单。竖屏最多支持显示3个图标，横屏最多支持显示5个图标，多余的图标会被放入自动生成的更多图标。   标题模式  object  是  小标题  页面标题栏显示模式。   工具栏  object  是  无  设置工具栏内容。 items: 工具栏所有项。 说明：items均分底部工具栏，在每个均分内容区布局文本和图标，文本超长时，逐级缩小，缩小之后换行，最后...截断。   隐藏工具栏  boolean  是  否  隐藏工具栏。 true: 隐藏工具栏。 false: 显示工具栏。   隐藏标题栏  boolean  是  否  隐藏标题栏。 true: 隐藏标题栏。 false: 显示标题栏。   隐藏后退按钮  boolean  是  否  隐藏返回键。不支持隐藏NavDestination组件标题栏中的返回图标。 true: 隐藏返回键。 false: 显示返回键。 说明： 返回键仅针对标题模式为小标题时才生效。     事件在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件方法设置可以参考事件方法章节。组件支持以下特有事件： 事件类型  是否必选  描述    标题模式变化  否  当标题模式为自适应时，随着可滚动组件的滑动标题栏模式发生变化时触发此回调。      运行示例 画布设置效果如下：  导入真机的效果图：    上一篇 垂直容器 下一篇 文本组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。简介 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 DevEco低代码是一个基于Serverless和ArkUI的端云一体化低代码开发平台，可通过拖拽式开发，可视化配置构建元服务。打通HarmonyOS云侧与端侧能力，轻松实现HMS Core和AGC Serverless能力的调用。通过与元服务生态、HMS Core、AGC Serverless平台、DevEco Studio、开发者联盟生态市场等产品的深度打通，助力元服务快速开发与降本增效。  上一篇 DevEco低代码 下一篇 版本更新说明 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件操作步骤预检查应用推送发布 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 前提条件 您已申请发布证书。您已申请发布Profile。您已配置私钥和应用签名。您已测试应用。 操作步骤 选择低代码平台 > 应用管理，进入应用管理页面。在应用列表中搜索您要发布的应用名称，点击卡片上的编辑应用（或点击应用名称，进入应用详情页，点击右上角的编辑应用）。 在执行发布前建议先执行预检查功能，以确认必填信息是否完成配置。系统跳转到低代码开发页面，点击页面右上角的发布。 配置项  配置项说明    发布版本  支持两种发布版本： API6API9   发布方式  支持两种发布方式： 发布版，适用于正式上架您的应用到华为应用市场。开放性测试，适用于您的应用在正式上架华为应用市场前，提前发布一个测试版本给您信任的测试用户。测试版本仅对您指定的测试用户可见，这样您就可以提前收到用户反馈，并在应用正式上架前改进您的应用。   版本号  必填，格式为[0-99].[0-99].[0-99].[0-99]。如，1.1.1.0。     发布按钮下将会展示发布进度。在发布过程中，如果出现错误，请联系平台支持人员。 完成发布包的编译推送后在弹窗页面中可点击“下载”获取本次生成的应用包。点击“去发布”可以跳转到应用的“分发 > 版本信息”页面。  在发布完成后，软件包可以在分发 > 版本信息中进行管理。 在应用发布成功后，应用在应用管理页面中的“”将会变更为绿色。 在应用详情中会增加对应的发布记录。  预检查在发布前建议先点击右上角的预检查按钮进行预检查。  预检查将检验以下信息：  上架信息是否填写提示信息未完善：可点击前往配置，信息填写可参照填写应用信息章节。 是否配置签名提示环境签名校验未通过：可点击前往配置，参考发布证书配置，对签名进行配置。   使用到的数据模型与连接器是否发布提示有未发布的数据模型：可点击前往配置，快速发布数据模型或连接器。  应用图片和快照是否配置提示 未配置应用图片和快照：可点击前往配置，进行应用图片和快照的配置。     上一篇 应用信息填写 下一篇 平台操作指导 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。页面交互方法 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 以文本为例，介绍使用页面交互方法的操作步骤。 选中要绑定方法的组件，右侧切换到事件栏，根据事件类型点击对应事件右侧的+。 在弹出的执行面板中，选择“页面交互”其中一个。 点击打开页面，选择需要跳转的页面，再选择一种路由方式，点击保存按钮，完成打开页面的方法绑定。  如果选中的页面配置了跳转参数，此处会列出选中页面的跳转参数列表。  点击返回页面，选择一种返回类型，若是返回指定页面，需要选择页面，点击保存，完成返回页面的事件绑定。 点击销毁其他页面，直接点击保存，则完成销毁其他页面的事件绑定。  路由跳转传参示例 场景假设有一个订单列表页面orderList和订单详情页面orderDetail，以下示例实现从列表页跳转到详情页，并通过页面跳转参数传递订单名称和订单id的过程。 1. 简易搭建一个订单列表页面，每条订单含有订单名称、订单id和一个查看按钮，点击查看按钮可以跳转到详情页。 2. 简易搭建一个订单详情页面，创建2个变量 orderName 和 orderId，并将其 是否为跳转参数 设置为 是。 3. 回到列表页面，给查看按钮绑定点击事件。选择跳转到 orderDetail 页面，此时可读取到详情页面设置的 orderName 和 orderId 参数，点击绑定变量选择订单号和订单id。（注：页面跳转参数为非必填，可根据实际需要进行传递） 4. 查看运行效果，安装过程可参考自测试。      上一篇 事件方法 下一篇 变量赋值 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明支付组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 使用支付组件可快速在您的元服务中实现支付功能，当前支持华为支付和微信支付，其中华为支付支持使用国内主流银行卡，以及华为支付余额进行支付。  使用说明用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件库>官方组件中可看到支付组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将支付组件拖入到编辑区，即完成使用。选中编辑区支付组件，在右侧的页签对其属性和事件进行设置。   支付组件的属性设置 属性设置可能用到变量，变量使用可参考变量管理章节。  支付组件连接器创建 拖入支付组件时，会查询当前项目是否存在支付连接器，没有会自动为项目创建一个支付连接器。 若需要手动创建支付连接器请参照新建支付连接器章节。  支付连接器配置 
说明
当选中未完成商户信息配置的支付连接器，会有红点提示。 
 打开支付连接器配置。 进入支付连接器配置弹框。 表1 连接器配置参数参数名称  参数类型  是否必填  描述    商户ID  String  是  请参考商户证书准备的商户号。   商户认证ID  String  是  请参考商户证书准备的认证ID。   回调地址  String  是  支付或退款成功后接收回调信息的URL地址。 用于接收支付成功和退款成功的回调信息。创建连接器时，系统自动生成了回调地址，如果您有自己的服务器，可以更新为接收回调的URL地址。   密钥  String  否  请参考商户证书准备的证书密钥。该配置项在此编辑页面中仅支持设置不支持回显。   公钥  String  否  请参考商户证书准备的证书公钥。该配置项在此编辑页面中仅支持设置不支持回显。     
说明
支付连接器可绑定订单模型以及退款订单模型（随支付连接器创建），用户可基于平台提供的数据模型能力来进行订单的处理，以下的使用说明基于使用订单模型展开。相关配置项可进一步参照配置支付连接器章节。 
    支付组件的使用 支付组件的相关属性在页面右侧，均在属性和事件中进行定义。在属性>支付区域，支付连接器必须定义，若属性>支付>支付连接器的配置中没有列出可选的支付连接器，可通过左侧的连接器按钮（标红位置）跳转到连接器编辑页面进行配置。 直接支付创建订单：在使用组件的事件中选择调用数据源方法，数据来源选择数据模型，数据源名称选择随支付连接器创建的订单数据模型，初始换方法选择create，配置参数并保存。直接支付：拖入支付组件，右侧属性栏中共选择支付类型为直接支付，选择支付连接器，绑定预下单参数。 表2 直接支付的预下单参数参数名称  参数类型  是否必填  描述    mercOrderNo  String  是  商户订单号，由商户自己生成，商户需保证订单信息唯一性，最大长度40个字符。   tradeSummary  String  是  交易的摘要，最大长度46个字符，格式建议：“商户应用名称-商品描述”。   totalAmount  String  是  订单最大金额，必须是大于0的值，单位为分。   bizType  String  是  业务类型： “100001”：虚拟商品购买 “100002”：实物商品购买 “100003”：预付类账号充值 “100004”：航旅交通服务 “100005”：活动票务订购 “100006”：商业服务消费 “100007”：生活服务消费 “100008”：租金缴纳 “100009”：会员费缴纳 “100011”：其他商家消费 “100037”：公共便民服务   currency  String  否  货币单位（如不传则默认为CNY）,最大长度为3。   expireTime  String  否  交易要求过期时间，最大180天，不传默认为2小时，格式要求："yyyy-MM-dd'T'HH:mm:ss.SSSZ" 。（注意：要使用必须传准确的UTC时间）   quantity  String  是  商品数量。   unitPrice  String  是  商品单价，单位为分。   goodsName  String  是  商品名称。     
说明
使用直接支付，创建的订单如果支付失败则订单废弃，无法继续使用。 
   使用示例： 前置条件：构建商品页面，初始化商品变量goods。 在商品页面新建一个String类变量orderId，在商品页面进入时对其初始化随机数用于创建订单。   在订单页面新建一个String类变量id，设为跳转参数。  跳转要用到事件方法。点击绑定事件，选择执行动作中的页面交互的打开页面动作，在选择页面中选择跳转到的页面，将orderId作为跳转参数传递，在路由方式中选择跳转方法。  在订单页面新建变量orderDetail，数据来源选择选择随支付连接器创建的订单数据模型。  再创建一个变量payParam，字段为直接支付的传参，在代码编辑器中创建一个初始化的自定义方法initPayParam。在orderDetail变量初始化成功回调此方法。    拖入支付组件，配置样式，支付类型选择直接支付，选择支付连接器和预下单参数payParam。  预下单-继续支付创建订单：在使用组件的事件中选择调用数据源方法，数据来源选择数据模型，数据源名称选择随支付连接器创建的订单数据模型，初始换方法选择create，配置参数并保存。预下单：在使用组件的事件中选择调用数据源方法，数据来源选择连接器，数据源名称选择对应的支付连接器，初始化方法选择preOrder预下单方法，配置参数并保存。 表3 入参参数名称  参数类型  是否必填  描述    mercOrderNo  String  是  商户订单号，由商户自己生成，商户需保证订单信息唯一性。最大长度40个字符。   tradeSummary  String  是  交易的摘要。格式建议：“商户应用名称-商品描述”。最大长度46个字符。   totalAmount  Long  是  订单最大金额，必须为大于0的值，单位为分。   bizType  String  是  业务类型： “100001”：虚拟商品购买； “100002”：实物商品购买； “100003”：预付类账号充值； “100004”：航旅交通服务； “100005”：活动票务订购； “100006”：商业服务消费； “100007”：生活服务消费； “100008”：租金缴纳； “100009”：会员费缴纳， “100011”：其他商家消费； “100037”：公共便民服务   currency  String  否  货币单位（如不传则默认为CNY）,最大长度为3。   expireTime  String  否  交易要求过期时间，最大180天，不传默认为2小时。 交易过期时间。格式要求："yyyy-MM-dd'T'HH:mm:ss.SSSZ" 注意：要使用必须传准确的UTC时间。   quantity  Integer  是  商品数量。   unitPrice  Long  是  商品单价，单位为分。   goodsName  String  是  商品名称。     表4 出参参数名称  参数类型  描述  示例    resultCode  String  返回码。  “000000”成功，其他失败。   resultDesc  String  返回描述。  Success成功，其他失败。   subCode  String  业务错误码。  -   subDesc  String  业务错误描述信息。  -   sign  String  签名值，商户可以对此API做验签处理。  -   timestamp  String  时间戳。  时间戳，标准北京时间，时区为东八区，自1970年1月1日 0点0分0秒以来的毫秒数，13位。示例值：1666230721315   prepayId  String  预下单ID。  1230328134226089052035172127   mercOrderNo  String  商户订单号。  xxx   noncestr  String  随机字符串。  be5a84ea08e91103cff6ce839fa1708b   authId  String  商户鉴权ID。  1111018051000XX   mercNo  String  商户号。  1018051000XX     继续支付：拖入支付组件，选择支付类型为继续支付，选择支付连接器，绑定预下单参数。 表5 继续支付的预下单参数参数名称  参数类型  描述    prepayid  String  预下单产生的prepayid。     
说明
使用预下单-继续支付，创建的订单如果支付失败，订单状态为待支付，可以继续支付。 
   退款创建退款订单：在任意组件的事件中选择调用数据源方法，数据来源选择数据模型，数据源名称选择随支付连接器创建的退款订单数据模型，初始换方法选择create，配置参数并保存。订单退款：在任意组件的事件中选择调用数据源方法，数据来源选择连接器，数据源名称选择对应的支付连接器，初始化方法选择refundOrder退款方法，配置参数并保存。 表6 入参参数名称  参数类型  是否必填  描述    mercOrderNo  String  是  商户订单号，由商户自己生成，商户确保订单的唯一性。   mercRefundOrderNo  String  是  商户退款订单号，商户需要保证上商户系统内部唯一。   refundAmount  Long  否  退款金额。 需要退款的金额，该金额不能大于订单金额，单位为分。 注：如果正向交易使用了营销，该退款金额包含营销金额，华为支付会按业务规则分配营销和买家自有资金分别退多少，默认按比例退款。如不填则默认全额退款。   reason  String  否  退款原因，账单详情中显示。     表7 出参参数名称  参数类型  描述  示例    resultCode  String  返回码。  “000000”成功，其他失败。   resultDesc  String  返回描述。  Success成功，其他失败。   subCode  String  业务错误码。  -   subDesc  String  业务错误描述信息。  -   sign  String  签名值，商户可以对此API做验签处理。  -   mercOrderNo  String  商户订单号。  -   mercRefundOrderNo  String  商户退款订单号。  -   refundAmount  Long  退款金额。  100   payerRefundAmount  Long  用户退款金额。  100         上一篇 业务组件 下一篇 登录组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。图片素材管理图片素材使用图片素材库 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 为减小生成的元服务包大小，DevEco低代码提供了图片素材库功能，用户可在素材库中进行素材的上传和管理，并在应用开发页面中引用素材作为静态资源。素材将会以url的方式替代将静态资源图片打包到工程内的方式，从而降低生成的元服务应用包大小。 图片素材管理选择应用点击编辑应用进入DevEco低代码应用开发页面，通过侧边导航栏选择“素材”进入素材管理页面。在素材管理页面中可进行图片素材的上传管理，图片素材将会存储到项目的云存储空间中。上传图片支持png、jpg类型，大小不超过5M。 用户点击新建文件夹按钮创建素材库文件夹，用于素材的分类管理。 用户上传素材后可以在素材库中查看图片的预览图，以及图片的详细信息。并且可以将图片下载到本地或删除。    图片素材使用在图片素材库进行上传后，可以在应用编辑的时候引用图片作为静态资源使用。 选择应用点击编辑应用进入DevEco低代码应用开发页面，从组件库中将图片组件拖入到画布中。 在弹出的选择图片面板中可选择已上传至素材库的图片，选择后点击确定按钮完成绑定。 绑定完成后，即可在画布中看到图片效果。 也可在组件的属性栏背景 > 背景图片路径中使用素材库的图片，并可通过背景 > 背景图片重复方式来进行效果设置。     上一篇 方法链式调用 下一篇 服务卡片开发 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。注册帐号申请加入白名单（可选）商户入网创建项目开通DevEco低代码创建元服务开发准备 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 注册帐号您需要拥有华为开发者帐号并且开通付费服务，才能实现低代码开发元服务。 序号  步骤  企业  个人    1  注册华为开发者联盟帐号  注册帐号   2  实名认证  企业开发者实名认证  个人开发者实名认证   3  开通付费服务  开通付费服务      申请加入白名单目前DevEco低代码还处于Beta阶段，需要您向agconnect@huawei.com发送申请邮件，申请开通后方可使用。 邮件标题及内容要求如下： 邮件标题：DevEco低代码申请开通 邮件内容：需包含开发者名称和开发者ID 
说明
开发者ID即开发者的Developer ID，查询方法参见查看用户信息。在收到您的申请后，华为运营人员会在1-3个工作日内给您答复。 
  （可选）商户入网
说明
如果需要使用华为支付能力，您需提前完成商户入网，否则跳过此步骤。 
 服务商接入华为支付，需要先完成如下准备工作： 在华为支付商户平台完成商户入网。准备证书，并上传华为支付商户平台。  创建项目登录AppGallery Connect，点击我的项目”。在项目页面中点击添加项目。在创建项目页面中输入项目名称后 ，点击创建并继续。 项目创建后会进入开通分析服务页面，关闭为此项目启动分析服务，点击完成即可完成项目的创建。   开通DevEco低代码
说明
只有分配了“帐号持有者”角色的帐号才可开通DevEco低代码，“管理员”、“开发”和“运营”角色的帐号仅有使用权限，关于帐号的角色与权限说明，请参见角色与权限列表。 
 登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表选择要操作的项目，进入到低代码平台页面。 点击立即开通。  在弹出的提示框中点击确定，进入数据处理位置页面。 数据处理位置选择中国，点击下一步。
说明
目前DevEco低代码平台数据处理位置只支持中国。设置默认数据处理位置需要开发服务管理权限，请联系您所在团队的帐号持有者或者管理员设置。 
  在弹出的提示框中点击下一步。 设置云缓存的密码，密码设置完成后，点击下一步。密码设置规则如下：字母开头。8-32位。密码必须包含至少1位数字（0-9），一个大写字母，一个小写字母及一个特殊字符（-~!@#%^*_=+?$&()|<>{}[]）。  在弹出的提示框中，点击确认开通，服务开通成功。   创建元服务参考新建服务，创建您的服务。   上一篇 版本更新说明 下一篇 开发元服务 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。应用发布 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
    应用信息填写  应用推送发布   上一篇 自测试 下一篇 应用信息填写 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例单选框组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 提供选项的打开或关闭的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到单选框组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将单选框组件拖入到编辑区，即完成使用。选中编辑区单选框，在右侧的页签对其属性和事件进行设置。  特有属性 属性设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    是否选中  boolean  否  false  设置单选框的选中状态。   值  string  否  value  当前单选框的值。   群组名称  string  否  groupName  当前单选框的所属群组名。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件支持以下特有事件： 事件类型  是否必选  描述    选中状态改变  否  单选框选中状态改变时触发回调。     运行示例 画布设置效果如下：  导入真机的效果图：   上一篇 评分条组件 下一篇 菜单组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例评分条组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 提供在给定范围内选择评分的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到评分条组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将评分条组件拖入到编辑区，即完成使用。选中编辑区评分条，在右侧的页签对其属性和事件进行设置。 
说明
1.画布呈现的评星数只能是评星步长的整数倍，若选择的星级数不为评星步长的整数倍时，按评星数对评星步长进行四舍五入，取整数倍计算星数，具体可以参考运行示例。 2.目前支持的评星步长最小粒度为1，若小于1时按1计算。 
  特有属性 属性设置可填写常量值或绑定变量，变量的使用方式请参考变量管理。 字段标题  类型  是否必选  默认值  描述    星级总数  number  否  5  评分条的星级总数。   当前评星数  number  否  0  评分条当前评星数。   评星步长  number  否  0.5  评分条的评星步长。   指示器  boolean  否  否  评分条是否作为一个指示器，此时用户不可操作。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件支持以下特有事件： 事件类型  是否必选  描述    变更  否  评分条的评星发生改变时触发该回调。     运行示例 画布设置效果如下：  导入真机的效果图：   上一篇 基础组件 下一篇 单选框组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例富文本组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 解析并显示HTML格式文本的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到富文本组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将富文本组件拖入到编辑区，即完成使用。选中编辑区富文本，在右侧的页签对其属性和事件进行设置。  在属性中可看到富文本内容一栏，内容为字符串或字符类型变量。变量使用方式参考变量管理。  特有属性 属性设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    文本内容  string  否  无  组件显示的内容。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件支持以下特有事件： 事件类型  是否必选  描述    加载开始  否  加载网页时触发。   加载结束  否  网页加载结束时触发。     运行示例 画布设置效果如下：  导入真机的效果图：   上一篇 菜单组件 下一篇 文本域组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例横向容器 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 将组件进行沿水平横向排列的容器。 使用说明用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到横向容器组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将横向容器组件拖入到编辑区，即完成使用。选中编辑区横向容器，在右侧的页签对其属性和事件进行设置。   特有属性 字段标题  类型  是否必选  默认值  描述    间隔（不支持API6）  number | string  否  0  横向布局元素间距。 从API version 9开始，间隔为负数或者主轴对齐方式设置为两端对齐、平分、均分时不生效。 说明：可选值为大于等于0的数字，或者可以转换为数字的字符串。   主轴对齐方式  FlexAlign  是  起点对齐  设置子组件在水平方向上的对齐格式。   对齐方式  VerticalAlign  是  居中对齐  设置子组件在垂直方向上的对齐格式。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。事件方法设置可以参考事件方法章节。  运行示例 画布设置效果如下：  导入真机的效果图：   上一篇 页签组件 下一篇 垂直容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例滚动容器 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 可滚动的容器组件，当子组件的布局尺寸超过父组件的尺寸时，内容可以滚动。 
说明
该组件滚动的前提是设置的滚动方向大小小于内容大小。 
 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到滚动容器组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将滚动容器组件拖入到编辑区，即完成使用。选中编辑区滚动容器组件，在右侧的页签对其属性和事件进行设置。  特有属性属性设置可填写常量值或绑定变量，变量的使用方式请参考变量管理。 字段标题  类型  是否必选  默认值  描述    滚动方向  ScrollDirection  是  垂直方向滚动  设置滚动方向，包含默认、水平方向滚动、垂直方向滚动、不可滚动选项。   滚动条状态（不支持API6）  BarState  是  自动  设置滚动条状态，包含默认、关闭、开启、自动。   滚动条的颜色（不支持API6）  string | number | Color  否  black  设置滚动条的颜色。    滚动条的宽度（不支持API6）  string | number  否  4vp  设置滚动条的宽度，不支持百分比设置。 说明：如果滚动条的宽度超过其高度，则滚动条的宽度会变为默认值。   滑动效果（不支持API6）  EdgeEffect  是  无效果  设置滑动效果，包含默认、弹性、渐隐、无效果。     在滚动容器组件中修改滚动方向、滚动条状态、滚动条的颜色、滚动条的宽度等属性效果如下：   事件在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件支持以下特有事件： 事件类型  是否必选  描述    滚动（不支持API6）  否  滚动事件回调,。 触发该事件的条件: 1、滚动组件滚动到边缘时触发，支持键鼠操作等其他触发滚动的输入设置。 2、通过滚动控制器API接口调用。 3、越界回弹。   滚动至边缘（不支持API6）  否  滚动到边缘事件回调。 触发该事件的条件 ： 1、滚动组件触发滚动时触发，支持键鼠操作等其他触发滚动的输入设置。 2、通过滚动控制器API接口调用。 3、越界回弹。   滚动停止（不支持API6）  否  滚动停止事件回调。 触发该事件的条件 ： 1、滚动组件触发滚动后停止，支持键鼠操作等其他触发滚动的输入设置。 2、通过滚动控制器API接口调用后停止，带过渡动效。   滚动开始（不支持API6）  否  滚动开始时触发。手指拖动Scroll或拖动Scroll的滚动条触发的滚动开始时，会触发该事件。     滚动容器组件使用特殊场景： 1.当垂直容器组件需要包一个滚动容器组件时，若拖拽的滚动容器组件放不进去，可以先将父级容器组件宽高变大之后再拖拽子容器。 2.当垂直容器组件需要包一个滚动容器组件，导致容器与容器重叠，此时要选中想要的容器，可以点击左下角组件树的结构，点击结构右边对应的小眼睛隐藏不想选中的组件，然后再进行操作，具体操作如下。   运行示例画布设置效果如下：  导入真机的效果图：    上一篇 列表组件 下一篇 页签组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。前提条件操作步骤自测试 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 前提条件您已申请调试证书。您已申请调试Profile。您已配置私钥和应用签名。  操作步骤登录AppGallery Connect，点击“全部服务 > 开发构建 > Serverless > DevEco低代码”。在项目列表中选择要操作的项目，进入低代码平台页面。选择低代码平台 > 应用管理，进入“应用管理”页面。在应用列表中搜索您要发布的应用名称，点击卡片上的编辑应用（或点击应用名称，进入应用详情页，点击右上角的编辑应用）。 系统跳转到DevEco低代码开发页面，点击页面右上角的打包调试。 点击调试版后，按照所需要的规格，选择对应的规格，系统将会执行调试应用包的打包编译任务。任务可通过取消调试任务按钮来进行取消。 编译任务完成后，可通过面板中的下载将编译后的应用包下载到本地。  用户可参照hdc工具使用指导，通过命令行工具将应用hap包安装至本地测试设备中进行调测。示例：通过hdc app install 【packagePath】将应用hap报安装至本地设备     上一篇 访问控制 下一篇 应用发布 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。API 6服务卡片开发API 9服务卡片开发服务卡片开发 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 选择应用点击编辑应用进入应用开发页面，通过左上角切换成API 6/API 9服务卡片开发。  API 6服务卡片开发API 6服务卡片开发界面如下图：  UI控件栏，可以将相应的组件选中并拖动到画布中，实现控件的添加。组件树，在低代码开发界面中，开发者可以直观地看到组件的层级结构、摘要信息以及错误提示。开发者可以通过选中组件树中的组件（画布中对应的组件被同步选中），实现画布内组件的快速定位；单击组件后的或图标，可以隐藏/显示相应的组件。画布，开发者可在此区域对组件进行拖拽、拉伸等可视化操作，构建UI界面布局效果。属性样式栏，选中画布中的相应组件后，在右侧属性样式栏可以对该组件的属性样式进行配置。包括：属性：对应图标，用于设置组件基本标识和外观显示特征的属性，如组件的ID、If等属性。 样式：对应图标，用于设置宽、高、背景、定位、显隐等常规样式。特性：对应图标，用于设置组件的特有样式，如描述文本组件的文字大小及字体样式等。弹性布局：对应图标，用于设置弹性布局（Flex）相关样式。事件：对应图标，为组件绑定相关事件，并设置绑定事件的回调函数。边框边距：对应图标，用于设置内外边距、边框等与盒式模型相关的样式。 网格布局：对应图标，用于设置网格布局相关样式，该图标只有“基础容器组件”的“样式>显示类型”被设置为“网格布局”时才会出现。原子属性：对应图标，用于设置原子布局相关样式。 功能面板，包括常用的画布缩小放大、撤销、显示/隐藏组件虚拟边框、媒体查询、Json面板、以及代码转换查看等。    JSON面板： 配置变量及事件API6服务卡片的变量及事件是在Json面板中管理的，示例中创建了新的字符串变量、跳转事件及消息事件。  绑定变量及事件将上一步创建的变量以及跳转事件绑定到文本组件上。 
说明
当前仅支持API 6单张服务卡片开发，卡片尺寸为2x2。 
   API 9服务卡片开发API 9服务卡片开发如下图：   页面树，可进行卡片的新建、导入、配置、导出、删除。画布，开发者可在此区域对组件进行拖拽、拉伸等可视化操作，构建UI界面布局效果。属性栏，选中画布中的相应组件后，在右侧属性栏可以对该组件的属性样式进行配置。功能面板，包括常用的尺寸选择、画布缩小放大、撤销、显示/隐藏组件虚拟边框、以及代码转换查看等。UI控件栏，可以将相应的组件选中并拖动到画布中，实现控件的添加。事件栏，选中画布中的相应组件后，在右侧事件栏可以对该组件的事件进行绑定。  卡片新建、删除点击图标，选择新建卡片，在弹出的新建卡片界面填写卡片信息，点击确定按钮完成新建。   点击选择删除，完成卡片删除。默认卡片不能被删除。   卡片配置点击图标，选择卡片配置，在弹出的卡片配置界面填写相关内容，点击确定按钮完成卡片配置。   参数  说明    卡片名称  长度不超过64个字符。   卡片描述  长度不超过256个字符。   卡片支持规格  必须是1*2，2*2，2*4，4*4其中存在的，默认卡片必须包含2*2。   是否为默认卡片  开启则当前卡片设置未默认卡片，默认卡片不能被取消。   默认规格  必须是'卡片支持规格'其中一个，默认卡片必须是2*2。   是否支持周期刷新  不开启则不会进行周期刷新。   刷新时刻  定时刷新时间，遵循24小时制。   刷新周期  刷新周期为取值N*30分钟, N只支持0~50之间的整数，为0时不生效。      卡片导出导入卡片编辑完毕后，点击选择导出卡片，即完成卡片导出。  点击图标，选择导入卡片，在弹出的导入卡片界面填写卡片信息，上传导出的卡片包，点击确定按钮完成卡片导入。    卡片绑定打开应用事件在服务卡片中选择需要绑定事件的组件，并选择对应事件。    上一篇 图片素材库 下一篇 应用配置 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。业务组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
     支付组件  登录组件  日历组件  音频组件   上一篇 网页容器 下一篇 支付组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件子组件位置调整层级调整运行示例堆叠容器组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 子组件按照顺序依次入栈，后一个子组件覆盖前一个子组件。 使用说明用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中看到堆叠容器组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将堆叠容器组件拖入到编辑区，即完成使用。选中编辑区堆叠容器，在右侧的页签对其属性进行设置。   特有属性 字段标题  类型  是否必选  默认值  描述    内容对齐方式  Alignment  否  横向和纵向居中  设置子组件在容器内的对齐方式。可选择对齐方式有： 顶部起始端 顶部横向居中 顶部尾端 起始端纵向居中 横向和纵向居中 尾端纵向居中 底部起始端     对齐方式效果如下：  事件 堆叠容器不具有事件。 子组件位置调整 1.在堆叠容器中，子组件的位置由容器对齐方式与子组件的布局约束共同决定，如图所示。  2.子组件可以在堆叠容器内自由拖动，可以拖动到任何位置，但无法拖出堆叠容器，如图所示。  3.堆叠容器在子组件在拖动时，可以根据子组件的位置提供对齐约束，方便用户操作，如图所示。  层级调整 因为堆叠容器是按子组件入栈顺序进行层级顺序设置，如果想调整子组件顺序，需要重新将子组件复制出容器，再重新拖入堆叠容器，方法如下。 1.选取需要将调整层级的组件，右击选择复制，如因堆叠原因无法选择到组件，可在左下组件树中，将阻碍进行选取操作的其他组件设为隐藏。  2.在堆叠容器外复制出组件(如看不见复制出的组件，可在组件树中选取组件，将其布局中定位方式设置为绝对定位)，并删除原选择组件，将阻碍选取的隐藏组件取消隐藏状态。  3.拖动复制的组件到堆叠容器中，通过拖动到容器内其余子组件的右边设置层级在其下方，相应拖到到左边设置层级在其上方，如图所示。   运行示例 在堆叠容器组件中设置内容对齐方式为顶部尾端，然后拖入2个文本组件，设置文本内容和样式如下：  导入真机的效果图：   上一篇 文本域组件 下一篇 弹性容器组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。页签容器使用说明特有属性事件页签内容子组件使用说明特有属性事件运行示例画布设置效果如下：页签组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 提供可进行内容视图切换的组件。 
说明
页签组件由页签容器和页签内容组合使用。 
页签容器
 通过页签进行内容视图切换的容器组件，每个页签对应一个内容视图。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到页签容器组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将页签容器组件拖入到编辑区，即完成使用。选中编辑区页签容器，在右侧的页签对其属性和事件进行设置。 
说明
页签容器仅可包含子组件页签内容。 
  特有属性 字段标题  类型  是否必选  默认值  描述    纵向  boolean  是  否  设置为“否”是为横向页签，设置为“是”是为纵向页签。   索引  number  是  0  设置初始页签索引。 说明： 设置为小于0的值时按默认值显示。 可选值为[0, 页签内容子节点数量-1]。 设置不同值时，默认生效切换动效，可以设置滑动动画时长为0关闭动画。   是否可滑动切换页面  boolean  是  是  设置为“是”时可以通过滑动页面进行页面切换，为“否”时不可滑动切换页面。   页签位置（不支持API6)  BarPosition  是  开始  设置页签位置，包含默认、开始、结束选项。   页签的布局模式  BarMode  是  固定  页签的布局模式，包含默认、滚动、固定选项。   页签的宽度值  number  否  100%  设置页签的宽度值。 说明：设置为小于0或大于页签宽度值时，按默认值显示。   页签的高度值  number  否  200vp  设置页签的高度值。 说明：设置为小于0或大于Tabs高度值时，按默认值显示。   滑动动画时长（不支持API6）  number  是  200  页签内容滑动动画时长。不设置时，点击切换页签无动画，滑动切换有动画；设置时，点击切换和滑动切换都有动画。 说明：设置为小于0或百分比时，按默认值显示。     事件在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件支持以下特有事件： 事件类型  是否必选  描述    变更  否  页签切换后触发的事件。 触发该事件的条件： 1、可滑动切换页面设置为“是”时，页签内容滑动时触发。 2、点击页签处触发。      
页签内容
 仅在页签容器中使用，对应一个切换页签的内容视图。 
说明
可内置系统组件和自定义组件。 
 子组件 支持单个子组件。 使用说明 可以在组件库>官方组件中看到页签内容组件，将页签内容组件拖入到页签容器中使用。在编辑区选中页签内容组件后，可以在右侧的属性页签中对特有属性和通用属性进行定义。  特有属性 字段标题  类型  是否必选  默认值  描述    图片内容  string  否  无  页签内的图片内容。   文字内容  string  否  无  页签内的文字内容。     事件 页签内容组件不具有事件。 运行示例 画布设置效果如下： 导入真机的效果图：    上一篇 滚动容器 下一篇 横向容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例文本组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 显示一段文本的组件。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件库>官方组件中可看到文本组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将文本组件拖入到编辑区，即完成使用。选中编辑区文本组件，在右侧的页签对其属性和事件进行设置。  特有属性 属性设置可填写常量值或绑定变量，变量的使用方式请参考变量管理。 字段标题  类型  是否必选  默认值  描述    文本内容  string  否  无  设置文本展示的内容。   字体大小  number  是  16  设置字体大小，使用fp单位。   字体样式  FontStyle  是  正常  设置字体样式，包含正常和斜体两种选项。   字体颜色  number | string | Color  是  black  设置字体的颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   字体粗细  FontWeight | number | string  是  正常  设置文本的字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如"400"，以及"bold"、"bolder"、 "lighter"、"regular"、"medium"。   文本对齐方式  TextAlign  是  居中对齐  设置文本段落在水平方向的对齐方式，包含对齐首部、居中对齐、对齐尾部选项。   行高  string | number  否  自适应字体大小  设置文本的文本行高，设置值不大于0时不限制文本行高，单位为fp。   超长显示  TextOverflow  是  裁剪  设置文本超长时的显示方式，包含裁剪、省略号、不裁剪（不支持api6）选项。 说明：文本截断是按字截断。例如，英文以单词为最小单位进行截断，若需要以字母为单位进行截断，可在字母间添加零宽空格：\u200B。 需配合最大行数使用，单独设置不生效。   基线偏移量  number | string  否  0  设置文本基线的偏移量，单位为fp。   装饰线样式  TextDecorationType  是  不使用  设置文本装饰线样式，包含下划线、中划线、上划线（不支持api6）、不适用选项。   装饰线颜色  number | string | Color  否  black  设置装饰线颜色的颜色，支持HEX格式颜色，支持rgb或者rgba格式颜色，支持颜色枚举值。   大小写  TextCase  是  保持原有大小写  设置文本大小写（不支持api6），包含保持原有大小写、全小写、全大写选项。   字体  string  是  sans-serif  设置字体列表。当前支持'sans-serif'字体和注册自定义字体。   最大行数  number  否  无限  设置文本的最大行数。 说明：默认情况下，文本是自动折行的，如果指定此参数，则文本最多不会超过指定的行。如果有多余的文本，可以通过超长显示来指定截断方式。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。事件方法设置可以参考事件方法章节。  运行示例 画布设置效果如下：  导入真机的效果图：    上一篇 导航组件 下一篇 网页容器 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例文本域组件 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 文本域组件，多行文本输入的文本框，当输入的文本内容超过组件宽度时会自动换行显示。 使用说明 用户登录AppGallery Connect， 点击全部服务 > 开发构建 > Serverless > DevEco低代码，选择应用进入项目页面，选择元服务应用，点击编辑应用进入元服务开发页面，在组件>官方组件中可看到文本域组件。点击中心编辑区右上角页面锁，解锁获取编辑权限，将文本域组件拖入到编辑区，即完成使用。选中编辑区富文本，在右侧的页签对其属性和事件进行设置。  特有属性 属性设置可填写常量值或绑定变量，变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    提示文本  string  否  无  文本内容为空时，默认显示的文本内容。   文本内容  string  否  无  文本域组件默认显示的内容。   提示文本颜色  number | string | Color  否  #8c8c8c  设置提示文本颜色   提示文本字体大小（不支持API6）  number  否  16vp  设置提示文本字体大小   提示文本字体粗细（不支持API6）  FontWeight | number | string  否  粗细正常  设置提示文本字体粗细，包含正常、更细、常规、中等、加粗、更粗、100、200、300、400、500、600、700、800、900选项。number类型取值[100, 900]，取值间隔为100，默认为400，取值越大，字体越粗。string类型仅支持number类型取值的字符串形式，例如"400"，以及"bold"、"bolder"、"lighter"、"regular"、"medium"。   提示文本字体列表（不支持API6）  string  否  sans-serif  设置提示文本字体。   提示文本字体样式（不支持API6）  FontStyle  否  标准  设置提示文本字体样式，包含默认、标准、斜体选项。   输入框光标颜色  number | string | Color  否  #000000  设置输入框光标颜色。      特有属性设置后展示效果如下图。  在右侧文本内容中输入内容后，提示文本消失，删除文本内容后，提示文本出现。  事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件方法设置可以参考事件方法章节。组件支持以下特有事件： 事件类型  是否必选  描述    变更  否  输入内容发生变化时，触发该事件。   复制  否  长按输入框内部区域弹出剪贴板后，点击剪切板复制按钮，触发该事件。   剪切  否  长按输入框内部区域弹出剪贴板后，点击剪切板剪切按钮，触发该事件。   粘贴  否  长按输入框内部区域弹出剪贴板后，点击剪切板粘贴按钮，触发该事件。      运行示例 导入真机的效果图：   上一篇 富文本组件 下一篇 堆叠容器组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。变量赋值 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 变量赋值方法可为当前页面变量进行赋值操作，本章节以字符串变量的赋值为例简要介绍变量赋值方法的操作。 1.前置条件：在变量管理面板中添加变量 示例中创建了showStr以及sourceStr两个字符串变量，并将showStr绑定到文本组件上。  2.在事件中配置变量赋值方法 在文本组件的点击事件配置面板中选择“变量赋值”方法  3.配置赋值参数  参数名称  是否必选  描述    选择变量  是  要进行赋值的目标变量，支持下拉选择当前页面变量。   变量值  是  可输入要赋予所选变量的值，也可以通过“绑定变量”按钮来选择相同类型的变量进行赋值。     
说明
面板会对选择变量以及变量值的类型进行校验，仅支持进行相同类型的变量赋值操作。对于对象或数组类型的变量仅支持通过绑定变量的方式设置“变量值”参数 
 4.运行效果：点击文本组件后，显示的文本值被赋值为sourceStr的变量值。   上一篇 页面交互方法 下一篇 自定义方法 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。新建变量变量的作用域变量装饰器使用规则绑定变量在代码编辑器中使用页面变量变量管理 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 用户可以在变量管理中新建普通变量（字符串、数字、布尔值）、对象变量和数组变量，不同的变量类型创建所填写的信息有所不同。变量可以在事件配置中使用也可以在属性绑定变量以及代码编辑器中使用。本章节从如何新建变量，变量的作用域，属性绑定变量，变量装饰器使用规则以及如何在代码编辑器中使用变量这几个方面具体介绍如何使用变量。 新建变量选择应用点击编辑应用进入低代码应用开发页面，点击变量管理。 在弹出的变量管理面板中可点击新建变量。 在弹出的新建变量面板中填写变量信息。其中变量类型可分为普通变量（字符串、数字、布尔值）、对象变量和数组变量，不同的变量类型创建所填写的信息有所不同。普通变量：  参数  是否必填  说明    变量名  是  字母、数字和下划线，需以字母开头，长度不超过100个字符，同一个页面内的变量名称不能重复，应用内可重复。   变量类型  是  包含以下枚举类型：STRING、NUMBER、BOOLEAN、ARRAY、OBJECT。   作用域  是  变量为当前页面变量。   装饰器类型  否  具体请查看zh-cn_topic_0000001822830853.html#section252343920343。   是否为跳转参数  否  标识该变量是否为页面跳转时的参数，配置后可在页面交互方法中使用。卡片变量和组件变量不可填写。   变量默认值  否  变量的初始化默认值，当没有填写默认值时会给非装饰器变量根据变量类型自动填充默认值。STRING为空字符串，NUMBER为0，BOOLEAN为false。   变量备注  否  长度不超过255个字符。     数组变量的数据来源： 数组变量-自定义：    参数  是否必填  说明    变量名  是  字母、数字和下划线，需以字母开头，长度不超过100个字符，同一个页面内的变量名称不能重复，应用内可重复。   变量类型  是  包含以下枚举类型：STRING、NUMBER、BOOLEAN、ARRAY、OBJECT。   作用域  是  变量为当前页面变量。   装饰器类型  否  具体请查看变量装饰器使用规则。   是否为跳转参数  否  标识该变量是否为页面跳转时的参数，配置后可在页面交互方法中使用。全局变量和组件变量不可填写。   对象字段  是  当变量类型为ARRAY<OBJECT>时，可填添加字段。   变量默认值  是  变量的初始化默认值，需用户根据自定义的字段对变量默认值进行初始化。   变量备注  否  长度不超过255个字符。     参数  是否必填  说明    字段名称  是  字母、数字和下划线，需以字母开头，长度不超过20个字符。同层级字段名称不可重复。   字段描述  否  长度不超过255个字符。   数据类型  是  枚举类型，包含：STRING、NUMBER、BOOLEAN、ARRAY、OBJECT。 ARRAY、OBJECT类型可添加子字段最大嵌套层数为5。     
说明
数组默认值配置说明(以ARRAY<STRING>为例)： 1.设置变量类型为ARRAY<STRING>  2.配置数组变量默认值，将数组写成json格式字符串，最外层使用[]。 已复制[    "abc",    "def"] 
 对象变量： 对象变量的数据来源可选择为数据模型、连接器、自定义，其对应需要填写的信息有所不同。 对象变量-数据模型：    参数  是否必填  说明    变量名  是  字母、数字和下划线，需以字母开头，长度不超过100个字符，同一个页面内的变量名称不能重复，应用内可重复。   变量类型  是  包含以下枚举类型：STRING、NUMBER、BOOLEAN、ARRAY、OBJECT。   作用域  是  变量为当前页面变量。   装饰器类型  否  具体请查看变量装饰器使用规则。   是否为跳转参数  否  标识该变量是否为页面跳转时的参数，配置后可在页面交互方法中使用。全局变量和组件变量不可填写。   数据来源  是  页面上的对象变量可选数据来源为数据模型、连接器、自定义。而组件变量及API9卡片上的对象类型只支持自定义。   数据源名称  是  数据来源选择了数据模型或连接器，则显示当前项目下的数据模型或连接器名称列表。   初始化方法  是  数据来源选择了数据模型或连接器必填。数据源为数据模型时，初始化方法可选GET或LIST方法，对应获取对象为单一对象或列表，初始化方法不同时对应可选初始化参数不同。数据源为连接器时，初始化方法则显示出连接器中定义的方法名称列表。   主键值  否  初始化方法为GET可选填。将要查询的数据在数据模型中的主键值。   页码  否  初始化方法为LIST可选填。将要查询的数据在数据模型表中的页码。   页面大小  否  初始化方法为LIST可选填。查询数据时分页大小。   排序字段  否  初始化方法为LIST可选填。查询数据模型数据的排序字段名称。   排序方式  否  初始化方法为LIST可选填。查询数据模型数据的排序字段方式，枚举类型选择：包含：ASC(升序)、DESC(降序)。   查询条件  否  可设置模型字段作为数据初始化的筛选条件，可选择字段、运算符和值来作为筛选条件。   成功回调方法  否  初始化成功后触发的回调方法，可选择对应作用域的自定义方法、数据模型或连接器变量的构造器方法，和事件处绑定数据源的数据源方法。   失败回调方法  否  初始化失败时触发的回调方法，可选择对应作用域的自定义方法、数据模型或连接器变量的构造器方法，和事件处绑定数据源的数据源方法。   对象字段  否  数据来源选择了自定义时必填。   请求超时时间  是  初始化请求响应的超时时间，大于0的整数，单位为秒，默认值为70秒。   变量备注  否  长度不超过255个字符。     对象变量-连接器：   参数  是否必填  说明    变量名  是  字母、数字和下划线，需以字母开头，长度不超过100个字符，同一个页面内的变量名称不能重复，应用内可重复。   变量类型  是  枚举类型选择，包含：STRING、NUMBER、BOOLEAN、ARRAY、OBJECT。   作用域  是  变量为当前页面变量。   装饰器类型  否  具体请查看变量装饰器使用规则变量装饰器使用规则。   是否为跳转参数  否  标识该变量是否为页面跳转时的参数，配置后可在页面交互方法中使用。全局变量不可填写。   数据来源  是  页面上的对象变量可选数据来源为数据模型、连接器、自定义。而组件变量及API9卡片上的对象类型只支持自定义。   数据源名称  是  数据来源选择了数据模型或连接器，则显示当前项目下的数据模型或连接器名称列表，根据需要进行选择。   初始化方法  是  数据来源选择了数据模型或连接器必填。数据源为数据模型时，初始化方法可选GET或LIST方法，对应获取对象为单一对象或列表，初始化方法不同时对应可选初始化参数不同。数据源为连接器时，初始化方法则显示出连接器中定义的方法名称列表。   初始化方法入参  否  初始化方法为连接器方法时选填。列出连接器方法中所有入参，根据入参定义确定是否必填。   成功回调方法  否  初始化成功后触发的回调方法，可选择对应作用域的自定义方法、数据模型或连接器变量的构造器方法，和事件处绑定数据源的数据源方法。   失败回调方法  否  初始化失败时触发的回调方法，可选择对应作用域的自定义方法、数据模型或连接器变量的构造器方法，和事件处绑定数据源的数据源方法。   请求超时时间  是  初始化请求响应的超时时间，大于0的整数，单位为秒，默认值为70秒。   变量备注  否  长度不超过255个字符。     对象变量-自定义：  参数  是否必填  说明    变量名  是  字母、数字和下划线，需以字母开头，长度不超过100个字符，同一个页面内的变量名称不能重复，应用内可重复。   变量类型  是  枚举类型选择，包含：STRING、NUMBER、BOOLEAN、ARRAY、OBJECT。   作用域  是  变量为当前页面变量。   装饰器类型  否  具体请查看变量装饰器使用规则。   是否为跳转参数  否  标识该变量是否为页面跳转时的参数，配置后可在页面交互方法中使用。全局变量不可填写。   数据来源  是  页面上的对象变量可选数据来源为数据模型、连接器、自定义。而组件变量及API9卡片上的对象类型只支持自定义。   对象字段  是  当数据来源选择为自定义时，可填添加字段。   变量默认值  是  变量的初始化默认值，需用户根据自定义的字段对变量默认值进行初始化。   变量备注  否  长度不超过255个字符。     
说明
对象变量默认值配置说明： 1.配置对象字段。  2.配置变量默认值，采用json格式字符串写出对象变量默认值。最外层用{}，必须包含所有对象字段的默认值。 已复制{"name":"xiaoming","age":12} 
   变量的作用域变量可在页面、API 9服务卡片和自定义组件中使用，根据作用域限制使用范围。 在页面开发界面进入变量管理可对页面变量进行编辑。在API 9服务卡片开发界面进入变量管理可对卡片变量进行编辑。在自定义组件开发界面进入变量管理可对组件变量进行编辑。  变量装饰器使用规则 装饰器  同步类型  允许装饰的变量类型  使用范围    @State  不与父组件中任何类型的变量同步。  Object、string、number、boolean、以及这些类型的数组。  页面--支持 组件--支持 卡片--支持   @Prop  单向同步：对父组件状态变量值的修改，将同步给子组件@Prop装饰的变量，子组件@Prop变量的修改不会同步到父组件的状态变量上。  string、number、boolean类型。  页面--不支持 组件--支持 卡片--不支持   @Link  双向同步：对父组件状态变量值的修改，将同步给子组件@Link装饰的变量，子组件@Link变量的修改会同步到父组件的状态变量上。  Object、string、number、boolean类型，以及这些类型的数组。  页面--不支持 组件--支持 卡片--不支持   @LocalStorageProp  单向同步：从LocalStorage的对应属性到组件的状态变量。  Object、class、string、number、boolean、enum类型，以及这些类型的数组。  页面--支持 组件--支持 卡片--支持   @LocalStorageLink  双向同步：@LocalStorageLink装饰的变量和在@Component中创建与LocalStorage中给定属性建立双向同步关系。  Object、class、string、number、boolean、enum类型，以及这些类型的数组。  页面--支持 组件--支持 卡片--不支持   @StorageProp  单向同步：从AppStorage的对应属性到组件的状态变量。  Object、class、string、number、boolean、enum类型，以及这些类型的数组。  页面--支持 组件--不支持 卡片--不支持   @StorageLink  双向同步：@StorageLink是和AppStorage中key对应的属性建立双向数据同步：  Object、class、string、number、boolean、enum类型，以及这些类型的数组。  页面--支持 组件--不支持 卡片--不支持      绑定变量选择应用点击编辑应用进入低代码应用开发页面，点击选中画布中的组件（也可点击选中组件树中的组件）。在属性栏中，对于需要绑定变量的属性，点击对应属性栏旁的按钮。 在弹出的变量面板中选择需要绑定的变量，并点击保存按钮完成绑定。 完成绑定后，对应属性在运行时将会显示对应的变量值。   
说明
装饰器详情可参见ArkTS语言状态管理概述：状态管理概述-管理组件拥有的状态-状态管理-学习ArkTS语言-入门-HarmonyOS应用开发。 
  在代码编辑器中使用页面变量在代码编辑器里可以使用普通变量（字符串、数字、布尔值），数组变量和对象变量。 在代码编辑器里调用普通变量（字符串、数字、布尔值），以数字为例。 在变量管理里创建一个数字类型的变量。  在代码编辑器里用this.变量名来调用在变量管理里创建的普通变量。   2. 在代码编辑器里调用数组类型变量。 在变量管理里创建数组类型变量(以ARRAY<OBJECT>类型为例)。 在代码编辑器里用this.数组名来调用在变量管理里创建的数组变量。  3.在代码编辑器里使用对象类型变量。 在变量管理里创建一个对象类型的变量。 在代码编辑器里用this.对象名来调用在变量管理里创建的对象变量。    上一篇 开发界面介绍 下一篇 组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。4.1.0.110（2023-12-26）历史版本4.0.0.410（2023-10-15）4.0.0.300（2023-08-15）4.0.0.200（2023-06-20）版本更新说明 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 4.1.0.110（2023-12-26）新增特性 增加访问控制配置，用于设置应用内数据访问权限。 修改特性 数组变量子元素支持选择常规类型（字符串、数字、布尔值）。创建变量面板增加“默认值映射”按钮，用于根据变量数据结构自动生成默认值模板，覆盖至默认值输入框中。页面变量增加支持装饰器@StorageProp与@StorageLink。     历史版本 4.0.0.410（2023-10-15）新增特性 新增组件：音频组件、评分组件、单选框组件、菜单组件、文本域组件、富文本组件。新增页面模板功能，可基于模板新建页面。新增区块功能，区块基于一个容器范围的组件生成，用户可根据业务规则自行组合，并在应用中复用。新增变量赋值方法。 修改特性 自定义组件的共享维度由应用级扩展到团队级，同一团队账号下可见的自定义组件范围相同。自定义组件也可在AppGallery Connect的组件库中进行管理。 若项目未创建过支付连接器，初次使用支付组件时将会自动在后台创建1个支付连接器及2个数据模型（订单和退款订单）。支付组件选择支付连接器处，可配置支付连接器属性。自定义组件切换为团队帐号维度，同一团队帐号下可见。方法绑定增加方法嵌套能力，可配置在方法调用成功或失败时执行的下一个方法。     4.0.0.300（2023-08-15）新增特性 DevEco低代码支持API 9开发。新增自定义组件功能。新增支持页面跳转配置。自定义方法新增支持API 9的ETS代码编辑。新增创建API 9服务卡片，API 9服务卡片在同一应用中支持多张卡片，多尺寸配置，并支持导入导出。变量属性增加装饰器、URL参数和自定义数据源，作用范围增加API 9服务卡片和自定义组件。新增组件：日历组件、支付组件。 修改特性 属性栏分类优化，可更加直观地选择配置属性。     4.0.0.200（2023-06-20）推出了全新的DevEco低代码，欢迎开发者接入。      上一篇 简介 下一篇 开发准备 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。使用说明特有属性事件运行示例网页容器 更新时间: 2024-03-30 10:25 毫无帮助帮助不大一般很好非常好
分享
 具有网页显示能力的Web组件,嵌套于容器内显示网页。 使用说明 登录账号后，选择所需要的应用，进入到DevEco低代码平台，可以在组件库>官方组件中看到网页容器组件，点击中心编辑区右上角的页面锁，进行解锁，获取编辑权限。然后将网页容器组件拖入到中心的编辑区使用。选中网页容器组件，可以在右侧的属性页中输入网页地址(不支持子组件)。  特有属性 网页链接可以是网页地址或者绑定变量，绑定变量的使用方式可以参考变量管理。 字段标题  类型  是否必选  默认值  描述    网页链接  string  是  无  网页资源地址(以http或https开头)。     事件 在编辑区选中组件后，可以在右侧的事件页签中对其进行定义。  事件设置需要用到自定义方法，自定义方法的使用方式可以参考自定义方法章节，组件无通用事件，以下为特有事件。 事件类型  是否必选  描述    开始加载  否  网页开始加载时触发该回调。   加载成功  否  网页加载完成时触发该回调。   加载失败  否  网页加载失败触时发该回调。     运行示例 画布设置效果如下：  导入真机的效果图： 
说明
API6与API9视图效果展示会有差别。API6的网页容器因为不受外部容器大小影响，所以会占满页面。 
    上一篇 文本组件 下一篇 业务组件 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。媒体系统架构媒体应用开发概述 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
 媒体系统架构媒体系统提供用户视觉、听觉信息的处理能力，如音视频信息的采集、压缩存储、解压播放等。在操作系统实现中，通常基于不同的媒体信息处理内容，将媒体划分为不同的模块，包括：音频、视频（也称播放录制）、图片等。 如下图所示，媒体系统面向应用开发提供音视频应用、图库应用的编程框架接口；面向设备开发提供对接不同硬件芯片适配加速功能；中间以服务形态提供媒体核心功能和管理机制。 图1 媒体系统整体框架 音频（audio）：提供音量管理、音频路由管理、混音管理接口与服务。视频（media）：提供音视频解压播放、压缩录制接口与服务。图片（image）：提供图片编解码、图片处理接口与服务。   上一篇 媒体 下一篇 音视频 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。开发步骤及注意事项完整示例管理麦克风 更新时间: 2024-03-20 16:30 毫无帮助帮助不大一般很好非常好
分享
  因为在录制过程中需要使用麦克风录制相关音频数据，所以建议开发者在调用录制接口前查询麦克风状态，并在录制过程中监听麦克风的状态变化，避免影响录制效果。 在音频录制过程中，用户可以将麦克风静音，此时录音过程正常进行，录制生成的数据文件的大小随录制时长递增，但写入文件的数据均为0，即无声数据（空白数据）。  开发步骤及注意事项 在AudioVolumeGroupManager中提供了管理麦克风状态的方法，接口的详细说明请参考API文档。  创建audioVolumeGroupManager对象。已复制import audio from '@ohos.multimedia.audio';
let audioVolumeGroupManager;async function loadVolumeGroupManager() { //创建audioVolumeGroupManager对象  const groupid = audio.DEFAULT_VOLUME_GROUP_ID;  audioVolumeGroupManager = await audio.getAudioManager().getVolumeManager().getVolumeGroupManager(groupid);  console.info('audioVolumeGroupManager create success.');} 调用on('micStateChange')监听麦克风状态变化，当麦克风静音状态发生变化时将通知应用。目前此订阅接口在单进程多AudioManager实例的使用场景下，仅最后一个实例的订阅生效，其他实例的订阅会被覆盖（即使最后一个实例没有进行订阅），因此推荐使用单一AudioManager实例进行开发。 已复制async function on() {   //监听麦克风状态变化  audioVolumeGroupManager.on('micStateChange', (micStateChange) => {    console.info(`Current microphone status is: ${micStateChange.mute} `);  });} 调用isMicrophoneMute查询麦克风当前静音状态，返回true为静音，false为非静音。已复制async function isMicrophoneMute() { //查询麦克风是否静音  await audioVolumeGroupManager.isMicrophoneMute().then((value) => {    console.info(`isMicrophoneMute is: ${value}.`);  });} 根据查询结果的实际情况，调用setMicrophoneMute设置麦克风静音状态，入参输入true为静音，false为非静音。已复制async function setMicrophoneMuteTrue() { //设置麦克风静音，入参为true  await audioVolumeGroupManager.setMicrophoneMute(true).then(() => {    console.info('setMicrophoneMute to mute.');  });}async function setMicrophoneMuteFalse() { //取消麦克风静音，入参为false  await audioVolumeGroupManager.setMicrophoneMute(false).then(() => {    console.info('setMicrophoneMute to not mute.');  });}    完整示例 参考以下示例，完成从设置麦克风静音到取消麦克风静音的过程。 已复制import audio from '@ohos.multimedia.audio';
@Entry@Componentstruct AudioVolumeGroup { private audioVolumeGroupManager: audio.AudioVolumeGroupManager;
  async loadVolumeGroupManager() {    const groupid = audio.DEFAULT_VOLUME_GROUP_ID;    this.audioVolumeGroupManager = await audio.getAudioManager().getVolumeManager().getVolumeGroupManager(groupid);    console.info('audioVolumeGroupManager------create-------success.');  }
  async on() {   //监听麦克风状态变化    await this.loadVolumeGroupManager();    this.audioVolumeGroupManager.on('micStateChange', (micStateChange) => {      console.info(`Current microphone status is: ${micStateChange.mute} `);    });  }  async isMicrophoneMute() { //查询麦克风是否静音    await this.audioVolumeGroupManager.isMicrophoneMute().then((value) => {      console.info(`isMicrophoneMute is: ${value}.`);    });  }  async setMicrophoneMuteTrue() { //设置麦克风静音    await this.loadVolumeGroupManager();    await this.audioVolumeGroupManager.setMicrophoneMute(true).then(() => {      console.info('setMicrophoneMute to mute.');    });  }  async setMicrophoneMuteFalse() { //取消麦克风静音    await this.loadVolumeGroupManager();    await this.audioVolumeGroupManager.setMicrophoneMute(false).then(() => {      console.info('setMicrophoneMute to not mute.');    });  }  async test(){    await this.on();    await this.isMicrophoneMute();    await this.setMicrophoneMuteTrue();    await this.isMicrophoneMute();    await this.setMicrophoneMuteFalse();    await this.isMicrophoneMute();    await this.setMicrophoneMuteTrue();    await this.isMicrophoneMute();  }}   上一篇 使用OpenSL ES开发音频录制功能 下一篇 音频录制流管理 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。