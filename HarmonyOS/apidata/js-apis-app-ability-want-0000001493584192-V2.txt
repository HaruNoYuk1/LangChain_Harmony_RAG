您正在浏览HarmonyOS开发者3.1/4.0版本配套的开发者文档，对应API能力级别为API 9 Release，详细版本配套关系请参考版本说明。导入模块属性@ohos.app.ability.Want (Want) 更新时间: 2024-03-18 17:33 毫无帮助帮助不大一般很好非常好
分享
 Want是对象间信息传递的载体, 可以用于应用组件间的信息传递。 Want的使用场景之一是作为startAbility的参数, 其包含了指定的启动目标, 以及启动时需携带的相关数据, 如bundleName和abilityName字段分别指明目标Ability所在应用的包名以及对应包内的Ability名称。当Ability A需要启动Ability B并传入一些数据时, 可使用Want作为载体将这些数据传递给Ability B。 
说明
本模块首批接口从API version 9 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。 
 导入模块已复制import Want from '@ohos.app.ability.Want';  属性系统能力：以下各项对应的系统能力均为SystemCapability.Ability.AbilityBase 名称  类型  必填  说明    deviceId  string  否  表示运行指定Ability的设备ID。   bundleName  string  否  表示包描述。如果在Want中同时指定了BundleName和AbilityName，则Want可以直接匹配到指定的Ability。   abilityName  string  否  表示待启动的Ability名称。如果在Want中该字段同时指定了BundleName和AbilityName，则Want可以直接匹配到指定的Ability。AbilityName需要在一个应用的范围内保证唯一。   uri  string  否  表示Uri描述。如果在Want中指定了Uri，则Want将匹配指定的Uri信息，包括scheme, schemeSpecificPart, authority和path信息。   type  string  否  表示MIME type类型描述，打开文件的类型，主要用于文管打开文件。比如：'text/xml' 、 'image/*'等，MIME定义参考：https://www.iana.org/assignments/media-types/media-types.xhtml?utm_source=ld246.com。   flags  number  否  表示处理Want的方式。默认传数字，具体参考：flags说明。   action  string  否  表示要执行的通用操作（如：查看、分享、应用详情）。在隐式Want中，您可以定义该字段，配合uri或parameters来表示对数据要执行的操作。   parameters  {[key: string]: any}  否  表示WantParams描述，由开发者自行决定传入的键值对。默认会携带以下key值： - ohos.aafwk.callerPid：表示拉起方的pid。 - ohos.aafwk.param.callerToken：表示拉起方的token。 - ohos.aafwk.param.callerUid：表示BundleInfo中的uid，应用包里应用程序的uid。 - component.startup.newRules：表示是否启用新的管控规则。 - moduleName：表示拉起方的模块名，该字段的值即使定义成其他字符串，在传递到另一端时会被修改为正确的值。 - ohos.dlp.params.sandbox：表示dlp文件才会有。   entities  Array<string>  否  表示目标Ability额外的类别信息（如：浏览器、视频播放器），在隐式Want中是对action字段的补充。在隐式Want中，您可以定义该字段，来过滤匹配Ability类型。   moduleName  string  否  表示待启动的Ability所属的模块（module）。     示例： 基础用法 已复制  let want = {      'deviceId': '', // deviceId为空表示本设备      'bundleName': 'com.extreme.test',      'abilityName': 'MainAbility',      'moduleName': 'entry' // moduleName非必选  };  this.context.startAbility(want, (error) => {      // 显式拉起Ability，通过bundleName、abilityName和moduleName可以唯一确定一个Ability      console.log('error.code = ' + error.code);  }) 通过自定字段传递数据，以下为当前支持类型。 字符串（String）已复制let want = {    bundleName: 'com.example.demo',    abilityName: 'com.example.demo.MainAbility',    parameters: {        keyForString: 'str',    },}; 数字（Number）已复制let want = {    bundleName: 'com.example.demo',    abilityName: 'com.example.demo.MainAbility',    parameters: {        keyForInt: 100,        keyForDouble: 99.99,    },}; 布尔（Boolean）已复制let want = {    bundleName: 'com.example.demo',    abilityName: 'com.example.demo.MainAbility',    parameters: {        keyForBool: true,    },}; 对象（Object）已复制let want = {    bundleName: 'com.example.demo',    abilityName: 'com.example.demo.MainAbility',    parameters: {        keyForObject: {            keyForObjectString: 'str',            keyForObjectInt: -200,            keyForObjectDouble: 35.5,            keyForObjectBool: false,        },    },}; 数组（Array）已复制let want = {    bundleName: 'com.example.demo',    abilityName: 'com.example.demo.MainAbility',    parameters: {        keyForArrayString: ['str1', 'str2', 'str3'],        keyForArrayInt: [100, 200, 300, 400],        keyForArrayDouble: [0.1, 0.2],        keyForArrayObject: [{obj1: 'aaa'}, {obj2: 100}],    },}; 文件描述符（FD）已复制    import fileio from '@ohos.fileio';    let fd;    try {        fd = fileio.openSync('/data/storage/el2/base/haps/pic.png');    } catch(e) {        console.log('openSync fail:' + JSON.stringify(e));    }    let want = {        'deviceId': '', // deviceId为空表示本设备        'bundleName': 'com.extreme.test',        'abilityName': 'MainAbility',        'moduleName': 'entry', // moduleName非必选        'parameters': {            'keyFd':{'type':'FD', 'value':fd} // {'type':'FD', 'value':fd}是固定用法，用于表示该数据是FD        }    };    this.context.startAbility(want, (error) => {        // 显式拉起Ability，通过bundleName、abilityName和moduleName可以唯一确定一个Ability        console.log('error.code = ' + error.code);    }); parameter参数用法：以ability.params.backToOtherMissionStack为例，ServiceExtension在拉起UIAbility的时候，可以支持跨任务链返回。已复制    // (1) UIAbility1启动一个ServiceExtension    let context = getContext(this) as common.UIAbilityContext; // UIAbilityContext    let want = {      bundleName: 'com.example.myapplication1',      abilityName: 'ServiceExtensionAbility',    };
    context.startAbility(want, (err) => {      console.error(`Failed to startAbility. Code: ${err.code}, message: ${err.message}`);    });
    // (2) 该ServiceExtension去启动另一个UIAbility2，并在启动的时候携带参数ability.params.backToOtherMissionStack为true    let context = ...; // ServiceExtensionContext    let want = {      bundleName: 'com.example.myapplication2',      abilityName: 'MainAbility',      parameters: {        "ability.params.backToOtherMissionStack": true,      },    };
    context.startAbility(want, (err) => {      console.error(`Failed to startAbility. Code: ${err.code}, message: ${err.message}`);    });
 在上述例子中： 如果ServiceExtension启动UIAbility2时，不携带ability.params.backToOtherMissionStack参数，或者携带的ability.params.backToOtherMissionStack参数为false，则UIAbility1和UIAbility2不在同一个任务栈里面，在UIAbility2的界面点back键，不会回到UIAbility1的界面。如果携带的ability.params.backToOtherMissionStack参数为true，则表示支持跨任务链返回，此时在UIAbility2的界面点back键，会回到UIAbility1的界面。     上一篇 @ohos.app.ability.errorManager (ErrorManager) 下一篇 @ohos.app.ability.wantAgent (WantAgent模块) 以上内容对您是否有帮助？毫无帮助帮助不大一般很好非常好意见反馈
更多帮助请到“社区论坛”，如需要其他帮助，请通过“智能客服”提问。